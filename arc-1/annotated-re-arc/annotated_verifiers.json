{
  "007bbfb7": {
    "original": "def verify_007bbfb7(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = other(x0, ZERO)\n    x2 = shape(I)\n    x3 = multiply(x2, x2)\n    x4 = canvas(ZERO, x3)\n    x5 = ofcolor(I, x1)\n    x6 = lbind(shift, x5)\n    x7 = shape(I)\n    x8 = rbind(multiply, x7)\n    x9 = apply(x8, x5)\n    x10 = mapply(x6, x9)\n    x11 = fill(x4, x1, x10)\n    return x11\n\n",
    "annotated": "def verify_007bbfb7(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Find the non-zero color (foreground color) in the input grid\n    x1 = other(x0, ZERO)\n    \n    # Get the dimensions (height, width) of the input grid\n    x2 = shape(I)\n    \n    # Calculate the dimensions of the output grid by squaring input dimensions\n    # This effectively creates a \"zoomed in\" version of the input\n    x3 = multiply(x2, x2)\n    \n    # Create an empty output grid with the calculated dimensions, filled with zeros\n    x4 = canvas(ZERO, x3)\n    \n    # Get the set of coordinates of all non-zero (colored) cells in the input grid\n    x5 = ofcolor(I, x1)\n    \n    # Create a partially applied function that will shift coordinates\n    x6 = lbind(shift, x5)\n    \n    # Get the dimensions of the input grid again (for use in scaling)\n    x7 = shape(I)\n    \n    # Create a partially applied function that will multiply coordinates by input dimensions\n    x8 = rbind(multiply, x7)\n    \n    # Apply the multiplication to each coordinate in x5\n    # This scales up the coordinates to match the output grid size\n    x9 = apply(x8, x5)\n    \n    # Apply the shift function to the scaled coordinates\n    # This creates the set of all coordinates to be colored in the output grid\n    x10 = mapply(x6, x9)\n    \n    # Fill the output grid with the non-zero color at the calculated coordinates\n    # This creates the final \"zoomed in\" version of the input\n    x11 = fill(x4, x1, x10)\n    \n    # Return the final output grid\n    return x11\n"
  },
  "00d62c1b": {
    "original": "def verify_00d62c1b(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = mostcolor(I)\n    x2 = colorfilter(x0, x1)\n    x3 = rbind(bordering, I)\n    x4 = compose(flip, x3)\n    x5 = mfilter(x2, x4)\n    x6 = fill(I, FOUR, x5)\n    return x6\n\n",
    "annotated": "def verify_00d62c1b(I: Grid) -> Grid:\n    # Identify all objects on the input grid, including diagonally connected cells\n    x0 = objects(I, T, F, F)\n    \n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Filter objects to get only those of the background color\n    x2 = colorfilter(x0, x1)\n    \n    # Create a function that checks if an object is bordering the grid edge\n    x3 = rbind(bordering, I)\n    \n    # Create a function that returns True if an object is NOT bordering the grid edge\n    x4 = compose(flip, x3)\n    \n    # Filter and merge background objects that are not bordering the grid edge\n    # This identifies \"holes\" or enclosed areas in the grid\n    x5 = mfilter(x2, x4)\n    \n    # Fill the identified \"holes\" with color 4 (cyan)\n    # This is the main transformation of the puzzle: filling enclosed areas\n    x6 = fill(I, FOUR, x5)\n    \n    # Return the transformed grid\n    return x6\n"
  },
  "017c7c7b": {
    "original": "def verify_017c7c7b(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = other(x0, ZERO)\n    x2 = ofcolor(I, x1)\n    x3 = asobject(I)\n    x4 = vperiod(x3)\n    x5 = height(I)\n    x6 = halve(x5)\n    x7 = add(x5, x6)\n    x8 = width(I)\n    x9 = astuple(x7, x8)\n    x10 = canvas(ZERO, x9)\n    x11 = increment(x7)\n    x12 = interval(ZERO, x11, x4)\n    x13 = lbind(shift, x2)\n    x14 = apply(toivec, x12)\n    x15 = mapply(x13, x14)\n    x16 = fill(x10, TWO, x15)\n    return x16\n\n",
    "annotated": "def verify_017c7c7b(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Find the non-zero color in the input grid (assumes there are only two colors: 0 and another)\n    x1 = other(x0, ZERO)\n    \n    # Get the indices of all cells with the non-zero color\n    x2 = ofcolor(I, x1)\n    \n    # Convert the entire input grid to an object representation\n    x3 = asobject(I)\n    \n    # Calculate the vertical periodicity of the input grid object\n    # This determines the height of the repeating pattern\n    x4 = vperiod(x3)\n    \n    # Get the height of the input grid\n    x5 = height(I)\n    \n    # Calculate half of the input grid's height\n    x6 = halve(x5)\n    \n    # Calculate the height of the output grid (1.5 times the input height)\n    x7 = add(x5, x6)\n    \n    # Get the width of the input grid\n    x8 = width(I)\n    \n    # Create a tuple representing the dimensions of the output grid\n    x9 = astuple(x7, x8)\n    \n    # Create an empty canvas for the output grid with dimensions from x9\n    x10 = canvas(ZERO, x9)\n    \n    # Calculate the number of times the pattern should be repeated vertically\n    # by incrementing the output height (to ensure coverage)\n    x11 = increment(x7)\n    \n    # Create a sequence of integers from 0 to x11, stepping by the pattern height (x4)\n    # This represents the vertical positions where the pattern should be placed\n    x12 = interval(ZERO, x11, x4)\n    \n    # Partially apply the shift function, fixing the second argument to x2 (the pattern indices)\n    x13 = lbind(shift, x2)\n    \n    # Convert each number in x12 to a vertical offset tuple (i, 0)\n    x14 = apply(toivec, x12)\n    \n    # Apply the shift function to each vertical offset, effectively creating copies of the pattern\n    x15 = mapply(x13, x14)\n    \n    # Fill the output canvas with color 2 at all the calculated positions\n    # This creates the final output with the repeated pattern\n    x16 = fill(x10, TWO, x15)\n    \n    # Return the completed output grid\n    return x16\n"
  },
  "025d127b": {
    "original": "def verify_025d127b(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, T, T)\n    x2 = rbind(objects, F)\n    x3 = rbind(x2, F)\n    x4 = rbind(x3, T)\n    x5 = lbind(canvas, x0)\n    x6 = compose(x5, shape)\n    x7 = fork(paint, x6, normalize)\n    x8 = compose(x4, x7)\n    x9 = fork(colorfilter, x8, color)\n    x10 = rbind(shift, RIGHT)\n    x11 = rbind(argmax, rightmost)\n    x12 = compose(x11, x9)\n    x13 = fork(remove, x12, x9)\n    x14 = chain(x10, merge, x13)\n    x15 = rbind(argmax, rightmost)\n    x16 = compose(x15, x9)\n    x17 = fork(combine, x16, x14)\n    x18 = fork(shift, x17, ulcorner)\n    x19 = merge(x1)\n    x20 = fill(I, x0, x19)\n    x21 = mapply(x18, x1)\n    x22 = paint(x20, x21)\n    return x22\n\n",
    "annotated": "def verify_025d127b(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Extract all objects from the input grid, including diagonally connected and background objects\n    x1 = objects(I, T, T, T)\n    # Create a partially applied function that extracts objects without considering diagonal connections\n    x2 = rbind(objects, F)\n    # Further modify the function to not consider background objects\n    x3 = rbind(x2, F)\n    # Finalize the object extraction function to consider only directly connected, non-background objects\n    x4 = rbind(x3, T)\n    # Create a function that generates a canvas with the background color\n    x5 = lbind(canvas, x0)\n    # Compose functions to create a canvas of the same shape as the input\n    x6 = compose(x5, shape)\n    # Create a function that paints normalized objects onto a background canvas\n    x7 = fork(paint, x6, normalize)\n    # Compose the object extraction and painting functions\n    x8 = compose(x4, x7)\n    # Create a function that filters objects by their color\n    x9 = fork(colorfilter, x8, color)\n    # Create a function that shifts objects one step to the right\n    x10 = rbind(shift, RIGHT)\n    # Create a function that finds the rightmost object\n    x11 = rbind(argmax, rightmost)\n    # Compose functions to find the rightmost object of a specific color\n    x12 = compose(x11, x9)\n    # Create a function that removes the rightmost object from a set of objects\n    x13 = fork(remove, x12, x9)\n    # Chain functions to shift the merged set of non-rightmost objects to the right\n    x14 = chain(x10, merge, x13)\n    # Create another function to find the rightmost object (used for combining)\n    x15 = rbind(argmax, rightmost)\n    # Compose functions to find the rightmost object of a specific color (for combining)\n    x16 = compose(x15, x9)\n    # Create a function that combines the rightmost object with the shifted set\n    x17 = fork(combine, x16, x14)\n    # Create a function that shifts the combined object set to its original position\n    x18 = fork(shift, x17, ulcorner)\n    # Merge all objects from the input grid\n    x19 = merge(x1)\n    # Create a new grid by filling the merged object area with the background color\n    x20 = fill(I, x0, x19)\n    # Apply the transformation (shift and combine) to all objects\n    x21 = mapply(x18, x1)\n    # Paint the transformed objects onto the background grid to create the output\n    x22 = paint(x20, x21)\n    # Return the final transformed grid\n    return x22\n"
  },
  "045e512c": {
    "original": "def verify_045e512c(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = argmax(x0, size)\n    x2 = height(x1)\n    x3 = width(x1)\n    x4 = neighbors(ORIGIN)\n    x5 = toindices(x1)\n    x6 = lbind(shift, x5)\n    x7 = height(I)\n    x8 = divide(x7, x2)\n    x9 = width(I)\n    x10 = divide(x9, x3)\n    x11 = astuple(x8, x10)\n    x12 = maximum(x11)\n    x13 = increment(x12)\n    x14 = interval(ONE, x13, ONE)\n    x15 = astuple(x2, x3)\n    x16 = lbind(multiply, x15)\n    x17 = compose(crement, x16)\n    x18 = lbind(mapply, x6)\n    x19 = rbind(apply, x14)\n    x20 = lbind(rbind, multiply)\n    x21 = compose(x20, x17)\n    x22 = chain(x18, x19, x21)\n    x23 = rbind(toobject, I)\n    x24 = compose(x6, x17)\n    x25 = chain(palette, x23, x24)\n    x26 = mostcolor(I)\n    x27 = rbind(equality, x26)\n    x28 = rbind(argmin, x27)\n    x29 = compose(x28, x25)\n    x30 = fork(recolor, x29, x22)\n    x31 = mapply(x30, x4)\n    x32 = paint(I, x31)\n    return x32\n\n",
    "annotated": "def verify_045e512c(I: Grid) -> Grid:\n    # Get all objects in the input grid, including background\n    x0 = objects(I, T, T, T)\n    # Find the largest object (main object)\n    x1 = argmax(x0, size)\n    # Get the height of the main object\n    x2 = height(x1)\n    # Get the width of the main object\n    x3 = width(x1)\n    # Get the 8 neighboring directions from the origin\n    x4 = neighbors(ORIGIN)\n    # Get the indices of the main object\n    x5 = toindices(x1)\n    # Create a function to shift the main object\n    x6 = lbind(shift, x5)\n    # Get the height of the input grid\n    x7 = height(I)\n    # Calculate how many times the object can fit vertically\n    x8 = divide(x7, x2)\n    # Get the width of the input grid\n    x9 = width(I)\n    # Calculate how many times the object can fit horizontally\n    x10 = divide(x9, x3)\n    # Create a tuple of vertical and horizontal fit counts\n    x11 = astuple(x8, x10)\n    # Find the maximum number of times the object can fit in either direction\n    x12 = maximum(x11)\n    # Increment the max fit count (to ensure coverage)\n    x13 = increment(x12)\n    # Create a range from 1 to the incremented max fit count\n    x14 = interval(ONE, x13, ONE)\n    # Create a tuple of the object's dimensions\n    x15 = astuple(x2, x3)\n    # Create a function to multiply by the object's dimensions\n    x16 = lbind(multiply, x15)\n    # Create a function to adjust the multiplication result\n    x17 = compose(crement, x16)\n    # Create a function to apply the shift to multiple positions\n    x18 = lbind(mapply, x6)\n    # Create a function to apply a function to the range of fit counts\n    x19 = rbind(apply, x14)\n    # Create a function to bind multiplication as the right argument\n    x20 = lbind(rbind, multiply)\n    # Compose the multiplication binding with the adjustment function\n    x21 = compose(x20, x17)\n    # Chain functions to create shifted objects in all directions and distances\n    x22 = chain(x18, x19, x21)\n    # Create a function to convert grid cells to objects\n    x23 = rbind(toobject, I)\n    # Create a function to get the shifted position of the main object\n    x24 = compose(x6, x17)\n    # Chain functions to get the color palette of shifted objects\n    x25 = chain(palette, x23, x24)\n    # Get the most common color in the input grid (background color)\n    x26 = mostcolor(I)\n    # Create a function to check if a color is not the background color\n    x27 = rbind(equality, x26)\n    # Create a function to find the color that's not the background\n    x28 = rbind(argmin, x27)\n    # Compose functions to get the non-background color of shifted objects\n    x29 = compose(x28, x25)\n    # Create a function to recolor shifted objects with their corresponding colors\n    x30 = fork(recolor, x29, x22)\n    # Apply the recoloring function to all neighboring directions\n    x31 = mapply(x30, x4)\n    # Paint the recolored objects onto the input grid to create the output\n    x32 = paint(I, x31)\n    # Return the final output grid with replicated and recolored objects\n    return x32\n"
  },
  "0520fde7": {
    "original": "def verify_0520fde7(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = halve(x0)\n    x2 = tojvec(x1)\n    x3 = height(I)\n    x4 = decrement(x3)\n    x5 = astuple(x4, x1)\n    x6 = connect(x2, x5)\n    x7 = toobject(x6, I)\n    x8 = numcolors(x7)\n    x9 = equality(x8, ONE)\n    x10 = branch(x9, lefthalf, tophalf)\n    x11 = branch(x9, righthalf, bottomhalf)\n    x12 = x10(I)\n    x13 = x11(I)\n    x14 = palette(x12)\n    x15 = other(x14, ZERO)\n    x16 = palette(x13)\n    x17 = other(x16, ZERO)\n    x18 = shape(x12)\n    x19 = canvas(ZERO, x18)\n    x20 = ofcolor(x12, x15)\n    x21 = ofcolor(x13, x17)\n    x22 = intersection(x20, x21)\n    x23 = fill(x19, TWO, x22)\n    return x23\n\n",
    "annotated": "def verify_0520fde7(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    # Calculate half of the width (this will be used to split the grid)\n    x1 = halve(x0)\n    # Create a vector pointing to the middle column\n    x2 = tojvec(x1)\n    # Get the height of the input grid\n    x3 = height(I)\n    # Subtract 1 from the height (to get the bottom row index)\n    x4 = decrement(x3)\n    # Create a tuple representing the bottom-middle point of the grid\n    x5 = astuple(x4, x1)\n    # Create a line from the top-middle to the bottom-middle of the grid\n    x6 = connect(x2, x5)\n    # Convert the line to an object on the grid (this represents the vertical bar)\n    x7 = toobject(x6, I)\n    # Count the number of colors in the vertical bar\n    x8 = numcolors(x7)\n    # Check if the vertical bar has only one color\n    x9 = equality(x8, ONE)\n    # If the bar has one color, use lefthalf function, otherwise use tophalf\n    x10 = branch(x9, lefthalf, tophalf)\n    # If the bar has one color, use righthalf function, otherwise use bottomhalf\n    x11 = branch(x9, righthalf, bottomhalf)\n    # Apply the chosen function (left/top half) to the input grid\n    x12 = x10(I)\n    # Apply the chosen function (right/bottom half) to the input grid\n    x13 = x11(I)\n    # Get the palette of colors from the first half\n    x14 = palette(x12)\n    # Find the non-zero color in the first half (this is the color of the first set of points)\n    x15 = other(x14, ZERO)\n    # Get the palette of colors from the second half\n    x16 = palette(x13)\n    # Find the non-zero color in the second half (this is the color of the second set of points)\n    x17 = other(x16, ZERO)\n    # Get the shape (dimensions) of the first half\n    x18 = shape(x12)\n    # Create a new canvas filled with zeros, with the same shape as the first half\n    x19 = canvas(ZERO, x18)\n    # Find all cells in the first half that have the color of the first set\n    x20 = ofcolor(x12, x15)\n    # Find all cells in the second half that have the color of the second set\n    x21 = ofcolor(x13, x17)\n    # Find the intersection of the two sets of cells (common points)\n    x22 = intersection(x20, x21)\n    # Fill the new canvas with color 2 at the positions of the common points\n    x23 = fill(x19, TWO, x22)\n    # Return the resulting grid, which shows the intersection of the two point sets\n    return x23\n"
  },
  "05269061": {
    "original": "def verify_05269061(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = maximum(x0)\n    x2 = interval(ZERO, x1, ONE)\n    x3 = interval(ONE, x1, ONE)\n    x4 = rbind(toobject, I)\n    x5 = rbind(shoot, RIGHT)\n    x6 = chain(x4, x5, toivec)\n    x7 = rbind(shoot, DOWN)\n    x8 = chain(x4, x7, tojvec)\n    x9 = apply(x6, x2)\n    x10 = apply(x8, x2)\n    x11 = rbind(shoot, UP_RIGHT)\n    x12 = chain(x4, x11, toivec)\n    x13 = rbind(shoot, UP_RIGHT)\n    x14 = decrement(x1)\n    x15 = lbind(astuple, x14)\n    x16 = chain(x4, x13, x15)\n    x17 = apply(x12, x2)\n    x18 = apply(x16, x3)\n    x19 = combine(x17, x18)\n    x20 = rbind(shoot, NEG_UNITY)\n    x21 = decrement(x1)\n    x22 = lbind(astuple, x21)\n    x23 = chain(x4, x20, x22)\n    x24 = rbind(shoot, NEG_UNITY)\n    x25 = decrement(x1)\n    x26 = rbind(astuple, x25)\n    x27 = lbind(subtract, x25)\n    x28 = compose(x26, x27)\n    x29 = chain(x4, x24, x28)\n    x30 = apply(x23, x2)\n    x31 = apply(x29, x3)\n    x32 = combine(x30, x31)\n    x33 = rbind(valmax, numcolors)\n    x34 = matcher(x33, ONE)\n    x35 = x34(x9)\n    x36 = x34(x10)\n    x37 = x34(x19)\n    x38 = branch(x37, x19, x32)\n    x39 = branch(x36, x10, x38)\n    x40 = branch(x35, x9, x39)\n    x41 = apply(mostcolor, x40)\n    x42 = matcher(identity, ZERO)\n    x43 = compose(flip, x42)\n    x44 = sfilter(x41, x43)\n    x45 = size(x44)\n    x46 = double(x1)\n    x47 = divide(x46, x45)\n    x48 = increment(x47)\n    x49 = interval(ZERO, x48, ONE)\n    x50 = matcher(first, ZERO)\n    x51 = compose(flip, x50)\n    x52 = fork(recolor, first, last)\n    x53 = size(x40)\n    x54 = interval(ZERO, x53, ONE)\n    x55 = rbind(compose, first)\n    x56 = lbind(rbind, greater)\n    x57 = chain(x55, x56, decrement)\n    x58 = lbind(apply, last)\n    x59 = lbind(chain, x58)\n    x60 = rbind(x59, x57)\n    x61 = lbind(lbind, sfilter)\n    x62 = lbind(pair, x54)\n    x63 = chain(x60, x61, x62)\n    x64 = x63(x40)\n    x65 = x63(x41)\n    x66 = rbind(multiply, x45)\n    x67 = compose(x64, x66)\n    x68 = rbind(multiply, x45)\n    x69 = compose(x65, x68)\n    x70 = lbind(mapply, x52)\n    x71 = rbind(sfilter, x51)\n    x72 = lbind(pair, x41)\n    x73 = compose(x72, x67)\n    x74 = chain(x70, x71, x73)\n    x75 = lbind(mapply, x52)\n    x76 = rbind(sfilter, x51)\n    x77 = rbind(pair, x40)\n    x78 = compose(x77, x69)\n    x79 = chain(x75, x76, x78)\n    x80 = fork(combine, x74, x79)\n    x81 = mapply(x80, x49)\n    x82 = paint(I, x81)\n    return x82\n\n",
    "annotated": "def verify_05269061(I: Grid) -> Grid:\n    x0 = shape(I)  # Get the dimensions of the input grid\n    x1 = maximum(x0)  # Get the maximum dimension (height or width)\n    x2 = interval(ZERO, x1, ONE)  # Create a range from 0 to max dimension\n    x3 = interval(ONE, x1, ONE)  # Create a range from 1 to max dimension\n    x4 = rbind(toobject, I)  # Partially apply toobject function with input grid\n    x5 = rbind(shoot, RIGHT)  # Partially apply shoot function with RIGHT direction\n    x6 = chain(x4, x5, toivec)  # Chain functions to shoot right from each row\n    x7 = rbind(shoot, DOWN)  # Partially apply shoot function with DOWN direction\n    x8 = chain(x4, x7, tojvec)  # Chain functions to shoot down from each column\n    x9 = apply(x6, x2)  # Apply horizontal shooting to all rows\n    x10 = apply(x8, x2)  # Apply vertical shooting to all columns\n    x11 = rbind(shoot, UP_RIGHT)  # Partially apply shoot function with UP_RIGHT direction\n    x12 = chain(x4, x11, toivec)  # Chain functions to shoot up-right from each row\n    x13 = rbind(shoot, UP_RIGHT)  # Partially apply shoot function with UP_RIGHT direction (again)\n    x14 = decrement(x1)  # Decrement the maximum dimension\n    x15 = lbind(astuple, x14)  # Partially apply astuple function with decremented max dimension\n    x16 = chain(x4, x13, x15)  # Chain functions to shoot up-right from bottom-left corner\n    x17 = apply(x12, x2)  # Apply up-right shooting from each row\n    x18 = apply(x16, x3)  # Apply up-right shooting from bottom-left corner\n    x19 = combine(x17, x18)  # Combine the two up-right shootings\n    x20 = rbind(shoot, NEG_UNITY)  # Partially apply shoot function with NEG_UNITY direction\n    x21 = decrement(x1)  # Decrement the maximum dimension (again)\n    x22 = lbind(astuple, x21)  # Partially apply astuple function with decremented max dimension\n    x23 = chain(x4, x20, x22)  # Chain functions to shoot down-left from top-right corner\n    x24 = rbind(shoot, NEG_UNITY)  # Partially apply shoot function with NEG_UNITY direction (again)\n    x25 = decrement(x1)  # Decrement the maximum dimension (third time)\n    x26 = rbind(astuple, x25)  # Partially apply astuple function with decremented max dimension\n    x27 = lbind(subtract, x25)  # Partially apply subtract function with decremented max dimension\n    x28 = compose(x26, x27)  # Compose functions to create coordinates for down-left shooting\n    x29 = chain(x4, x24, x28)  # Chain functions to shoot down-left from top-right area\n    x30 = apply(x23, x2)  # Apply down-left shooting from top-right corner\n    x31 = apply(x29, x3)  # Apply down-left shooting from top-right area\n    x32 = combine(x30, x31)  # Combine the two down-left shootings\n    x33 = rbind(valmax, numcolors)  # Partially apply valmax function with numcolors\n    x34 = matcher(x33, ONE)  # Create a matcher function for single-color lines\n    x35 = x34(x9)  # Check if horizontal lines are single-color\n    x36 = x34(x10)  # Check if vertical lines are single-color\n    x37 = x34(x19)  # Check if up-right diagonals are single-color\n    x38 = branch(x37, x19, x32)  # Choose between up-right and down-left diagonals\n    x39 = branch(x36, x10, x38)  # Choose between vertical and diagonal lines\n    x40 = branch(x35, x9, x39)  # Choose between horizontal and other lines\n    x41 = apply(mostcolor, x40)  # Get the most common color for each line\n    x42 = matcher(identity, ZERO)  # Create a matcher function for zero\n    x43 = compose(flip, x42)  # Compose flip and zero-matcher functions\n    x44 = sfilter(x41, x43)  # Filter out zero colors\n    x45 = size(x44)  # Get the number of non-zero colors\n    x46 = double(x1)  # Double the maximum dimension\n    x47 = divide(x46, x45)  # Calculate the period of the color pattern\n    x48 = increment(x47)  # Increment the period\n    x49 = interval(ZERO, x48, ONE)  # Create a range from 0 to the period\n    x50 = matcher(first, ZERO)  # Create a matcher function for first element being zero\n    x51 = compose(flip, x50)  # Compose flip and first-zero-matcher functions\n    x52 = fork(recolor, first, last)  # Create a function to recolor based on first and last elements\n    x53 = size(x40)  # Get the number of lines\n    x54 = interval(ZERO, x53, ONE)  # Create a range from 0 to number of lines\n    x55 = rbind(compose, first)  # Partially apply compose with first function\n    x56 = lbind(rbind, greater)  # Partially apply rbind with greater function\n    x57 = chain(x55, x56, decrement)  # Chain functions to create a \"greater than previous\" function\n    x58 = lbind(apply, last)  # Partially apply apply with last function\n    x59 = lbind(chain, x58)  # Partially apply chain with apply-last function\n    x60 = rbind(x59, x57)  # Combine chained functions\n    x61 = lbind(lbind, sfilter)  # Partially apply lbind with sfilter function\n    x62 = lbind(pair, x54)  # Partially apply pair with range of line numbers\n    x63 = chain(x60, x61, x62)  # Chain functions to create a complex filtering function\n    x64 = x63(x40)  # Apply complex filtering to chosen lines\n    x65 = x63(x41)  # Apply complex filtering to most common colors\n    x66 = rbind(multiply, x45)  # Partially apply multiply with number of non-zero colors\n    x67 = compose(x64, x66)  # Compose filtering and multiplication for lines\n    x68 = rbind(multiply, x45)  # Partially apply multiply with number of non-zero colors (again)\n    x69 = compose(x65, x68)  # Compose filtering and multiplication for colors\n    x70 = lbind(mapply, x52)  # Partially apply mapply with recoloring function\n    x71 = rbind(sfilter, x51)  # Partially apply sfilter with non-zero filter\n    x72 = lbind(pair, x41)  # Partially apply pair with most common colors\n    x73 = compose(x72, x67)  # Compose pairing and filtering for lines\n    x74 = chain(x70, x71, x73)  # Chain functions to create a recoloring function for lines\n    x75 = lbind(mapply, x52)  # Partially apply mapply with recoloring function (again)\n    x76 = rbind(sfilter, x51)  # Partially apply sfilter with non-zero filter (again)\n    x77 = rbind(pair, x40)  # Partially apply pair with chosen lines\n    x78 = compose(x77, x69)  # Compose pairing and filtering for colors\n    x79 = chain(x75, x76, x78)  # Chain functions to create a recoloring function for colors\n    x80 = fork(combine, x74, x79)  # Create a function to combine line and color recoloring\n    x81 = mapply(x80, x49)  # Apply the combined recoloring function to the color pattern\n    x82 = paint(I, x81)  # Paint the recolored pattern onto the input grid\n    return x82  # Return the final painted grid\n\n"
  },
  "05f2a901": {
    "original": "def verify_05f2a901(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = extract(x0, x2)\n    x4 = other(x0, x3)\n    x5 = gravitate(x4, x3)\n    x6 = move(I, x4, x5)\n    return x6\n\n",
    "annotated": "def verify_05f2a901(I: Grid) -> Grid:\n    # Find all objects in the input grid, including background and considering diagonal connections\n    x0 = objects(I, T, T, T)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its height * width (i.e., if it's rectangular)\n    x2 = fork(equality, size, x1)\n    \n    # Extract the rectangular object from x0 (this should be the destination square)\n    x3 = extract(x0, x2)\n    \n    # Get the other object from x0 (this should be the irregular shape that needs to be moved)\n    x4 = other(x0, x3)\n    \n    # Calculate the direction and distance to move x4 until it's adjacent to x3\n    # This simulates the \"gravity\" effect, moving the shape down towards the square\n    x5 = gravitate(x4, x3)\n    \n    # Move the irregular shape (x4) on the input grid according to the calculated gravitation (x5)\n    # This creates the output grid with the shape moved down to just above the square\n    x6 = move(I, x4, x5)\n    \n    # Return the modified grid as the output\n    return x6\n"
  },
  "06df4c85": {
    "original": "def verify_06df4c85(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = frontiers(I)\n    x2 = merge(x1)\n    x3 = difference(x0, x2)\n    x4 = mostcolor(x3)\n    x5 = objects(I, T, F, F)\n    x6 = color(x2)\n    x7 = matcher(color, x6)\n    x8 = matcher(color, x4)\n    x9 = fork(either, x7, x8)\n    x10 = compose(flip, x9)\n    x11 = sfilter(x5, x10)\n    x12 = merge(x11)\n    x13 = palette(x12)\n    x14 = lbind(mfilter, x11)\n    x15 = lbind(matcher, color)\n    x16 = compose(x14, x15)\n    x17 = apply(x16, x13)\n    x18 = fork(either, vline, hline)\n    x19 = lbind(prapply, connect)\n    x20 = fork(x19, identity, identity)\n    x21 = compose(x20, toindices)\n    x22 = rbind(sfilter, x18)\n    x23 = chain(merge, x22, x21)\n    x24 = fork(recolor, color, x23)\n    x25 = mapply(x24, x17)\n    x26 = paint(I, x25)\n    x27 = paint(x26, x2)\n    return x27\n\n",
    "annotated": "def verify_06df4c85(I: Grid) -> Grid:\n    # Convert the input grid to an object representation\n    x0 = asobject(I)\n    # Identify all frontiers (continuous lines) in the input grid\n    x1 = frontiers(I)\n    # Merge all frontiers into a single object\n    x2 = merge(x1)\n    # Remove the frontiers from the grid object, leaving only the colored shapes\n    x3 = difference(x0, x2)\n    # Find the most common color among the remaining shapes (background color)\n    x4 = mostcolor(x3)\n    # Identify all objects in the grid, considering 4-connectivity and ignoring background\n    x5 = objects(I, T, F, F)\n    # Get the color of the frontiers\n    x6 = color(x2)\n    # Create a function that checks if an object has the same color as the frontiers\n    x7 = matcher(color, x6)\n    # Create a function that checks if an object has the same color as the background\n    x8 = matcher(color, x4)\n    # Combine the two color-checking functions with a logical OR\n    x9 = fork(either, x7, x8)\n    # Invert the combined color-checking function\n    x10 = compose(flip, x9)\n    # Filter out objects that have the same color as frontiers or background\n    x11 = sfilter(x5, x10)\n    # Merge all remaining objects into a single object\n    x12 = merge(x11)\n    # Get the palette of colors used in the remaining objects\n    x13 = palette(x12)\n    # Prepare a function to filter objects by color\n    x14 = lbind(mfilter, x11)\n    # Prepare a function to match colors\n    x15 = lbind(matcher, color)\n    # Combine the color filtering and matching functions\n    x16 = compose(x14, x15)\n    # Group objects by their colors\n    x17 = apply(x16, x13)\n    # Create a function to check if a set of indices forms a vertical or horizontal line\n    x18 = fork(either, vline, hline)\n    # Prepare a function to connect points\n    x19 = lbind(prapply, connect)\n    # Create a function that applies the connection function to an object's indices\n    x20 = fork(x19, identity, identity)\n    # Convert object to indices and apply the connection function\n    x21 = compose(x20, toindices)\n    # Prepare a function to filter for vertical or horizontal lines\n    x22 = rbind(sfilter, x18)\n    # Chain functions to connect points, filter lines, and merge results\n    x23 = chain(merge, x22, x21)\n    # Create a function to recolor the connected lines with their original color\n    x24 = fork(recolor, color, x23)\n    # Apply the recoloring function to each group of objects\n    x25 = mapply(x24, x17)\n    # Paint the connected lines onto the input grid\n    x26 = paint(I, x25)\n    # Paint the original frontiers back onto the grid\n    x27 = paint(x26, x2)\n    # Return the final grid with extended color regions and original frontiers\n    return x27\n"
  },
  "08ed6ac7": {
    "original": "def verify_08ed6ac7(I: Grid) -> Grid:\n    x0 = first(I)\n    x1 = mostcommon(x0)\n    x2 = dmirror(I)\n    x3 = matcher(identity, x1)\n    x4 = rbind(sfilter, x3)\n    x5 = compose(size, x4)\n    x6 = apply(x5, x2)\n    x7 = dedupe(x6)\n    x8 = order(x7, identity)\n    x9 = size(x8)\n    x10 = increment(x9)\n    x11 = increment(x10)\n    x12 = interval(ONE, x11, ONE)\n    x13 = pair(x8, x12)\n    x14 = height(I)\n    x15 = astuple(x14, x1)\n    x16 = repeat(x15, ONE)\n    x17 = combine(x16, x13)\n    x18 = lbind(extract, x17)\n    x19 = lbind(matcher, first)\n    x20 = chain(last, x18, x19)\n    x21 = compose(x20, x5)\n    x22 = fork(subtract, height, x5)\n    x23 = fork(repeat, x21, x22)\n    x24 = lbind(repeat, x1)\n    x25 = compose(x24, x5)\n    x26 = fork(combine, x25, x23)\n    x27 = apply(x26, x2)\n    x28 = dmirror(x27)\n    return x28\n\n",
    "annotated": "def verify_08ed6ac7(I: Grid) -> Grid:\n    # Get the first row of the input grid\n    x0 = first(I)\n    # Find the most common color in the first row (background color)\n    x1 = mostcommon(x0)\n    # Mirror the input grid diagonally\n    x2 = dmirror(I)\n    # Create a function that checks if a value is equal to the background color\n    x3 = matcher(identity, x1)\n    # Create a function that filters elements based on the background color\n    x4 = rbind(sfilter, x3)\n    # Create a function that counts non-background elements in a row\n    x5 = compose(size, x4)\n    # Apply the counting function to each column of the original grid\n    x6 = apply(x5, x2)\n    # Remove duplicate counts\n    x7 = dedupe(x6)\n    # Sort the unique counts in ascending order\n    x8 = order(x7, identity)\n    # Count the number of unique bar heights\n    x9 = size(x8)\n    # Add 1 to the count (to start coloring from 1)\n    x10 = increment(x9)\n    # Add another 1 (to include the upper bound in the interval)\n    x11 = increment(x10)\n    # Create a range of integers from 1 to the number of unique heights + 1\n    x12 = interval(ONE, x11, ONE)\n    # Pair each unique height with its corresponding color (1, 2, 3, ...)\n    x13 = pair(x8, x12)\n    # Get the height of the input grid\n    x14 = height(I)\n    # Create a tuple of (grid height, background color)\n    x15 = astuple(x14, x1)\n    # Create a single-element tuple containing x15\n    x16 = repeat(x15, ONE)\n    # Combine the height-color tuple with the height-newcolor pairs\n    x17 = combine(x16, x13)\n    # Create a function to extract an element from x17\n    x18 = lbind(extract, x17)\n    # Create a function to match the first element of a pair\n    x19 = lbind(matcher, first)\n    # Create a function to get the new color for a given bar height\n    x20 = chain(last, x18, x19)\n    # Create a function to get the new color for a column\n    x21 = compose(x20, x5)\n    # Create a function to calculate the height of each bar\n    x22 = fork(subtract, height, x5)\n    # Create a function to repeat the new color for each bar's height\n    x23 = fork(repeat, x21, x22)\n    # Create a function to repeat the background color\n    x24 = lbind(repeat, x1)\n    # Create a function to repeat the background color for empty space above bar\n    x25 = compose(x24, x5)\n    # Create a function to combine background and bar colors for each column\n    x26 = fork(combine, x25, x23)\n    # Apply the color transformation to each column of the grid\n    x27 = apply(x26, x2)\n    # Mirror the result back to the original orientation\n    x28 = dmirror(x27)\n    # Return the transformed grid\n    return x28\n"
  },
  "09629e4f": {
    "original": "def verify_09629e4f(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = sfilter(x0, vline)\n    x3 = size(x1)\n    x4 = size(x2)\n    x5 = merge(x0)\n    x6 = color(x5)\n    x7 = shape(I)\n    x8 = canvas(x6, x7)\n    x9 = hconcat(I, x8)\n    x10 = objects(x9, F, T, T)\n    x11 = argmin(x10, numcolors)\n    x12 = normalize(x11)\n    x13 = toindices(x12)\n    x14 = increment(x3)\n    x15 = increment(x14)\n    x16 = increment(x4)\n    x17 = increment(x16)\n    x18 = astuple(x15, x17)\n    x19 = lbind(shift, x13)\n    x20 = rbind(multiply, x18)\n    x21 = chain(x19, x20, last)\n    x22 = fork(recolor, first, x21)\n    x23 = normalize(x11)\n    x24 = mapply(x22, x23)\n    x25 = paint(x8, x24)\n    return x25\n\n",
    "annotated": "def verify_09629e4f(I: Grid) -> Grid:\n    # Get all frontiers (horizontal and vertical lines) from the input grid\n    x0 = frontiers(I)\n    # Filter out horizontal lines from the frontiers\n    x1 = sfilter(x0, hline)\n    # Filter out vertical lines from the frontiers\n    x2 = sfilter(x0, vline)\n    # Count the number of horizontal lines\n    x3 = size(x1)\n    # Count the number of vertical lines\n    x4 = size(x2)\n    # Merge all frontiers into a single object\n    x5 = merge(x0)\n    # Get the color of the merged frontiers (bar color)\n    x6 = color(x5)\n    # Get the shape (dimensions) of the input grid\n    x7 = shape(I)\n    # Create a new canvas with the bar color and same dimensions as input\n    x8 = canvas(x6, x7)\n    # Concatenate the input grid and the new canvas horizontally\n    x9 = hconcat(I, x8)\n    # Find all objects in the concatenated grid, allowing diagonal connections and ignoring background\n    x10 = objects(x9, F, T, T)\n    # Find the object with the least number of colors (likely the target subgrid)\n    x11 = argmin(x10, numcolors)\n    # Normalize the position of the target subgrid\n    x12 = normalize(x11)\n    # Get the indices of the normalized target subgrid\n    x13 = toindices(x12)\n    # Calculate the number of rows in the output grid\n    x14 = increment(x3)\n    x15 = increment(x14)\n    # Calculate the number of columns in the output grid\n    x16 = increment(x4)\n    x17 = increment(x16)\n    # Create a tuple of the calculated dimensions\n    x18 = astuple(x15, x17)\n    # Prepare a function to shift the target subgrid\n    x19 = lbind(shift, x13)\n    # Prepare a function to multiply coordinates\n    x20 = rbind(multiply, x18)\n    # Chain functions to get the new position of each cell in the enlarged subgrid\n    x21 = chain(x19, x20, last)\n    # Prepare a function to recolor cells at their new positions\n    x22 = fork(recolor, first, x21)\n    # Normalize the target subgrid again\n    x23 = normalize(x11)\n    # Apply the recoloring function to create the enlarged subgrid\n    x24 = mapply(x22, x23)\n    # Paint the enlarged subgrid onto the output canvas\n    x25 = paint(x8, x24)\n    # Return the final output grid\n    return x25\n"
  },
  "0962bcdd": {
    "original": "def verify_0962bcdd(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = lbind(mapply, dneighbors)\n    x2 = compose(x1, toindices)\n    x3 = fork(recolor, mostcolor, x2)\n    x4 = compose(decrement, ulcorner)\n    x5 = compose(increment, lrcorner)\n    x6 = fork(connect, x4, x5)\n    x7 = compose(hmirror, x6)\n    x8 = fork(combine, x6, x7)\n    x9 = fork(recolor, leastcolor, x8)\n    x10 = mapply(x3, x0)\n    x11 = paint(I, x10)\n    x12 = mapply(x9, x0)\n    x13 = paint(x11, x12)\n    return x13\n\n",
    "annotated": "def verify_0962bcdd(I: Grid) -> Grid:\n    # Identify all objects in the input grid, including diagonally connected cells\n    x0 = objects(I, F, T, T)\n    \n    # Create a function that applies dneighbors to each object\n    x1 = lbind(mapply, dneighbors)\n    \n    # Create a function that converts objects to indices and then finds their direct neighbors\n    x2 = compose(x1, toindices)\n    \n    # Create a function that recolors the neighbors with the most common color of the object\n    x3 = fork(recolor, mostcolor, x2)\n    \n    # Create a function that finds the upper-left corner and moves it one step up-left\n    x4 = compose(decrement, ulcorner)\n    \n    # Create a function that finds the lower-right corner and moves it one step down-right\n    x5 = compose(increment, lrcorner)\n    \n    # Create a function that connects the expanded corners to form a diagonal line\n    x6 = fork(connect, x4, x5)\n    \n    # Create a function that mirrors the diagonal line horizontally\n    x7 = compose(hmirror, x6)\n    \n    # Create a function that combines both diagonal lines to form an X\n    x8 = fork(combine, x6, x7)\n    \n    # Create a function that recolors the X with the least common color of the object\n    x9 = fork(recolor, leastcolor, x8)\n    \n    # Apply the neighbor recoloring function to all objects\n    x10 = mapply(x3, x0)\n    \n    # Paint the recolored neighbors onto the input grid\n    x11 = paint(I, x10)\n    \n    # Apply the X-drawing function to all objects\n    x12 = mapply(x9, x0)\n    \n    # Paint the X patterns onto the grid with recolored neighbors\n    x13 = paint(x11, x12)\n    \n    # Return the final transformed grid\n    return x13\n"
  },
  "0a938d79": {
    "original": "def verify_0a938d79(I: Grid) -> Grid:\n    x0 = portrait(I)\n    x1 = branch(x0, dmirror, identity)\n    x2 = x1(I)\n    x3 = objects(x2, T, F, T)\n    x4 = argmin(x3, leftmost)\n    x5 = argmax(x3, leftmost)\n    x6 = color(x4)\n    x7 = color(x5)\n    x8 = leftmost(x4)\n    x9 = leftmost(x5)\n    x10 = subtract(x9, x8)\n    x11 = double(x10)\n    x12 = multiply(THREE, TEN)\n    x13 = interval(x8, x12, x11)\n    x14 = interval(x9, x12, x11)\n    x15 = compose(vfrontier, tojvec)\n    x16 = mapply(x15, x13)\n    x17 = mapply(x15, x14)\n    x18 = recolor(x6, x16)\n    x19 = recolor(x7, x17)\n    x20 = combine(x18, x19)\n    x21 = paint(x2, x20)\n    x22 = x1(x21)\n    return x22\n\n",
    "annotated": "def verify_0a938d79(I: Grid) -> Grid:\n    # Check if the input grid is portrait-oriented (taller than wide)\n    x0 = portrait(I)\n    \n    # If portrait, apply diagonal mirror; otherwise, keep as is\n    # This effectively rotates the grid if it's portrait-oriented\n    x1 = branch(x0, dmirror, identity)\n    \n    # Apply the rotation/mirroring to the input grid\n    x2 = x1(I)\n    \n    # Find all objects in the rotated grid, allowing diagonal connections\n    x3 = objects(x2, T, F, T)\n    \n    # Find the leftmost object (likely the first color stripe)\n    x4 = argmin(x3, leftmost)\n    \n    # Find the rightmost object (likely the second color stripe)\n    x5 = argmax(x3, leftmost)\n    \n    # Get the color of the leftmost object\n    x6 = color(x4)\n    \n    # Get the color of the rightmost object\n    x7 = color(x5)\n    \n    # Get the leftmost position of the first color stripe\n    x8 = leftmost(x4)\n    \n    # Get the leftmost position of the second color stripe\n    x9 = leftmost(x5)\n    \n    # Calculate the distance between the two color stripes\n    x10 = subtract(x9, x8)\n    \n    # Double the distance to get the stripe width\n    x11 = double(x10)\n    \n    # Calculate the maximum width (30 * 3 = 90)\n    x12 = multiply(THREE, TEN)\n    \n    # Create a range for the first color's stripes\n    x13 = interval(x8, x12, x11)\n    \n    # Create a range for the second color's stripes\n    x14 = interval(x9, x12, x11)\n    \n    # Create a function to generate vertical frontiers\n    x15 = compose(vfrontier, tojvec)\n    \n    # Generate vertical frontiers for the first color\n    x16 = mapply(x15, x13)\n    \n    # Generate vertical frontiers for the second color\n    x17 = mapply(x15, x14)\n    \n    # Color the frontiers with the first color\n    x18 = recolor(x6, x16)\n    \n    # Color the frontiers with the second color\n    x19 = recolor(x7, x17)\n    \n    # Combine both colored frontiers\n    x20 = combine(x18, x19)\n    \n    # Paint the colored frontiers onto the rotated grid\n    x21 = paint(x2, x20)\n    \n    # Reverse the initial rotation/mirroring to get the final output\n    x22 = x1(x21)\n    \n    return x22\n"
  },
  "0b148d64": {
    "original": "def verify_0b148d64(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmin(x0, x1)\n    x3 = subgrid(x2, I)\n    return x3\n\n",
    "annotated": "def verify_0b148d64(I: Grid) -> Grid:\n    # Partition the input grid I into objects based on color\n    # This creates a set of objects, where each object is a set of cells with the same color\n    x0 = partition(I)\n\n    # Create a function that multiplies the height and width of an object\n    # This calculates the area of each object\n    x1 = fork(multiply, height, width)\n\n    # Find the object with the smallest area\n    # This identifies the quadrant we're looking for, as it's likely to be the smallest partition\n    x2 = argmin(x0, x1)\n\n    # Extract the subgrid corresponding to the smallest object (quadrant)\n    # This isolates the target quadrant from the rest of the grid\n    x3 = subgrid(x2, I)\n\n    # Return the extracted subgrid as the solution\n    return x3\n"
  },
  "0ca9ddb6": {
    "original": "def verify_0ca9ddb6(I: Grid) -> Grid:\n    x0 = ofcolor(I, ONE)\n    x1 = ofcolor(I, TWO)\n    x2 = mapply(dneighbors, x0)\n    x3 = mapply(ineighbors, x1)\n    x4 = fill(I, SEVEN, x2)\n    x5 = fill(x4, FOUR, x3)\n    return x5\n\n",
    "annotated": "def verify_0ca9ddb6(I: Grid) -> Grid:\n    # Find all cells with color 1 in the input grid\n    # These represent the centers of 'c' objects\n    x0 = ofcolor(I, ONE)\n\n    # Find all cells with color 2 in the input grid\n    # These represent the centers of 'b' objects\n    x1 = ofcolor(I, TWO)\n\n    # Get the direct neighbors (up, down, left, right) of all cells with color 1\n    # This will be used to create the cross pattern around 'c' objects\n    x2 = mapply(dneighbors, x0)\n\n    # Get the diagonal neighbors of all cells with color 2\n    # This will be used to create the diagonal pattern around 'b' objects\n    x3 = mapply(ineighbors, x1)\n\n    # Fill the direct neighbors of color 1 cells with color 7\n    # This creates the cross pattern around 'c' objects\n    x4 = fill(I, SEVEN, x2)\n\n    # Fill the diagonal neighbors of color 2 cells with color 4\n    # This creates the diagonal pattern around 'b' objects\n    # The result is the final output grid\n    x5 = fill(x4, FOUR, x3)\n\n    # Return the modified grid as the output\n    return x5\n"
  },
  "0d3d703e": {
    "original": "def verify_0d3d703e(I: Grid) -> Grid:\n    x0 = switch(I, THREE, FOUR)\n    x1 = switch(x0, EIGHT, NINE)\n    x2 = switch(x1, TWO, SIX)\n    x3 = switch(x2, ONE, FIVE)\n    return x3\n\n",
    "annotated": "def verify_0d3d703e(I: Grid) -> Grid:\n    # Switch color 3 with color 4 in the input grid\n    # This is the first step in the color mapping transformation\n    x0 = switch(I, THREE, FOUR)\n\n    # Switch color 8 with color 9 in the resulting grid from the previous step\n    # This continues the color mapping transformation\n    x1 = switch(x0, EIGHT, NINE)\n\n    # Switch color 2 with color 6 in the grid from the previous step\n    # Further progressing the color mapping\n    x2 = switch(x1, TWO, SIX)\n\n    # Switch color 1 with color 5 in the grid from the previous step\n    # This is the final step in the color mapping transformation\n    x3 = switch(x2, ONE, FIVE)\n\n    # Return the final transformed grid\n    # The overall effect is a specific color mapping: 3->4, 4->3, 8->9, 9->8, 2->6, 6->2, 1->5, 5->1\n    return x3\n"
  },
  "0dfd9992": {
    "original": "def verify_0dfd9992(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = objects(I, T, F, F)\n    x2 = lbind(colorfilter, x1)\n    x3 = compose(size, x2)\n    x4 = valmin(x0, x3)\n    x5 = matcher(x3, x4)\n    x6 = sfilter(x0, x5)\n    x7 = lbind(colorcount, I)\n    x8 = argmin(x6, x7)\n    x9 = asobject(I)\n    x10 = matcher(first, x8)\n    x11 = compose(flip, x10)\n    x12 = sfilter(x9, x11)\n    x13 = lbind(contained, x8)\n    x14 = compose(flip, x13)\n    x15 = sfilter(I, x14)\n    x16 = asobject(x15)\n    x17 = hperiod(x16)\n    x18 = dmirror(I)\n    x19 = sfilter(x18, x14)\n    x20 = asobject(x19)\n    x21 = hperiod(x20)\n    x22 = (x21, x17)\n    x23 = lbind(multiply, x22)\n    x24 = neighbors(ORIGIN)\n    x25 = mapply(neighbors, x24)\n    x26 = apply(x23, x25)\n    x27 = lbind(shift, x12)\n    x28 = mapply(x27, x26)\n    x29 = paint(I, x28)\n    return x29\n\n",
    "annotated": "def verify_0dfd9992(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Identify all objects in the grid, considering diagonal connections and ignoring the background\n    x1 = objects(I, T, F, F)\n    \n    # Create a function to filter objects by color\n    x2 = lbind(colorfilter, x1)\n    \n    # Create a function to get the size of color-filtered objects\n    x3 = compose(size, x2)\n    \n    # Find the color with the smallest total object size\n    x4 = valmin(x0, x3)\n    \n    # Create a function to match colors with the smallest total object size\n    x5 = matcher(x3, x4)\n    \n    # Filter the palette to only include colors with the smallest total object size\n    x6 = sfilter(x0, x5)\n    \n    # Create a function to count the occurrences of a color in the input grid\n    x7 = lbind(colorcount, I)\n    \n    # Find the least common color among those with the smallest total object size\n    x8 = argmin(x6, x7)\n    \n    # Convert the input grid to an object representation\n    x9 = asobject(I)\n    \n    # Create a function to match cells that are not the identified background color\n    x10 = matcher(first, x8)\n    x11 = compose(flip, x10)\n    \n    # Filter the grid object to keep only non-background cells\n    x12 = sfilter(x9, x11)\n    \n    # Create a function to check if a cell's color is not the background color\n    x13 = lbind(contained, x8)\n    x14 = compose(flip, x13)\n    \n    # Filter the input grid to keep only non-background cells\n    x15 = sfilter(I, x14)\n    \n    # Convert the filtered grid to an object\n    x16 = asobject(x15)\n    \n    # Calculate the horizontal periodicity of the pattern\n    x17 = hperiod(x16)\n    \n    # Mirror the input grid diagonally\n    x18 = dmirror(I)\n    \n    # Filter the mirrored grid to keep only non-background cells\n    x19 = sfilter(x18, x14)\n    \n    # Convert the filtered mirrored grid to an object\n    x20 = asobject(x19)\n    \n    # Calculate the horizontal periodicity of the mirrored pattern (vertical periodicity of original)\n    x21 = hperiod(x20)\n    \n    # Combine the horizontal and vertical periodicities\n    x22 = (x21, x17)\n    \n    # Create a function to multiply by the periodicity\n    x23 = lbind(multiply, x22)\n    \n    # Get the neighboring cells of the origin\n    x24 = neighbors(ORIGIN)\n    \n    # Get the neighbors of the neighbors (effectively a 5x5 grid around origin)\n    x25 = mapply(neighbors, x24)\n    \n    # Apply the periodicity multiplication to the 5x5 grid\n    x26 = apply(x23, x25)\n    \n    # Create a function to shift the non-background pattern\n    x27 = lbind(shift, x12)\n    \n    # Apply the shift to all calculated positions\n    x28 = mapply(x27, x26)\n    \n    # Paint the shifted pattern onto the input grid, effectively removing noise\n    x29 = paint(I, x28)\n    \n    # Return the cleaned grid with the noise removed\n    return x29\n"
  },
  "0e206a2e": {
    "original": "def verify_0e206a2e(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = matcher(numcolors, FOUR)\n    x2 = sfilter(x0, x1)\n    x3 = apply(normalize, x2)\n    x4 = merge(x2)\n    x5 = cover(I, x4)\n    x6 = lbind(compose, flip)\n    x7 = lbind(matcher, first)\n    x8 = chain(x6, x7, mostcolor)\n    x9 = fork(sfilter, identity, x8)\n    x10 = chain(invert, ulcorner, x9)\n    x11 = lbind(lbind, shift)\n    x12 = fork(shift, identity, x10)\n    x13 = compose(x11, x12)\n    x14 = lbind(fork, mapply)\n    x15 = lbind(x14, x13)\n    x16 = rbind(compose, x9)\n    x17 = lbind(lbind, occurrences)\n    x18 = chain(x15, x16, x17)\n    x19 = rbind(mapply, x3)\n    x20 = compose(x19, x18)\n    x21 = fork(paint, identity, x20)\n    x22 = chain(identity, x21, identity)\n    x23 = chain(dmirror, x21, dmirror)\n    x24 = chain(cmirror, x21, cmirror)\n    x25 = chain(hmirror, x21, hmirror)\n    x26 = chain(vmirror, x21, vmirror)\n    x27 = chain(rot90, x21, rot270)\n    x28 = chain(rot180, x21, rot180)\n    x29 = chain(rot270, x21, rot90)\n    x30 = chain(x29, x28, x27)\n    x31 = chain(x26, x25, x24)\n    x32 = compose(x23, x22)\n    x33 = chain(x30, x31, x32)\n    x34 = x33(x5)\n    return x34\n\n",
    "annotated": "def verify_0e206a2e(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering background and allowing diagonal connections\n    x0 = objects(I, F, F, T)\n    \n    # Create a function that checks if an object has exactly 4 colors\n    x1 = matcher(numcolors, FOUR)\n    \n    # Filter objects to keep only those with 4 colors\n    x2 = sfilter(x0, x1)\n    \n    # Normalize all filtered objects (move them to origin)\n    x3 = apply(normalize, x2)\n    \n    # Merge all filtered objects into a single set\n    x4 = merge(x2)\n    \n    # Remove all identified objects from the input grid, leaving only the background\n    x5 = cover(I, x4)\n    \n    # Create a function composition that flips a boolean\n    x6 = lbind(compose, flip)\n    \n    # Create a function that matches the first element of a tuple\n    x7 = lbind(matcher, first)\n    \n    # Chain functions to find the most common color and create a matching function\n    x8 = chain(x6, x7, mostcolor)\n    \n    # Create a function that filters objects based on their most common color\n    x9 = fork(sfilter, identity, x8)\n    \n    # Find the inverse of the upper-left corner of filtered objects\n    x10 = chain(invert, ulcorner, x9)\n    \n    # Prepare a function for shifting objects\n    x11 = lbind(lbind, shift)\n    \n    # Create a function that shifts objects based on their position\n    x12 = fork(shift, identity, x10)\n    \n    # Compose shifting functions\n    x13 = compose(x11, x12)\n    \n    # Prepare a function for applying a function to multiple arguments\n    x14 = lbind(fork, mapply)\n    \n    # Create a function that applies the shifting to multiple objects\n    x15 = lbind(x14, x13)\n    \n    # Prepare a function composition for filtering objects\n    x16 = rbind(compose, x9)\n    \n    # Prepare a function for finding occurrences of objects\n    x17 = lbind(lbind, occurrences)\n    \n    # Chain functions to shift, filter, and find occurrences of objects\n    x18 = chain(x15, x16, x17)\n    \n    # Apply normalization to multiple objects\n    x19 = rbind(mapply, x3)\n    \n    # Compose functions for object transformation and occurrence finding\n    x20 = compose(x19, x18)\n    \n    # Create a function that paints transformed objects onto the grid\n    x21 = fork(paint, identity, x20)\n    \n    # Chain of identity transformations (no change)\n    x22 = chain(identity, x21, identity)\n    \n    # Chain of diagonal mirror transformations\n    x23 = chain(dmirror, x21, dmirror)\n    \n    # Chain of counter-diagonal mirror transformations\n    x24 = chain(cmirror, x21, cmirror)\n    \n    # Chain of horizontal mirror transformations\n    x25 = chain(hmirror, x21, hmirror)\n    \n    # Chain of vertical mirror transformations\n    x26 = chain(vmirror, x21, vmirror)\n    \n    # Chain of 90-degree rotation transformations\n    x27 = chain(rot90, x21, rot270)\n    \n    # Chain of 180-degree rotation transformations\n    x28 = chain(rot180, x21, rot180)\n    \n    # Chain of 270-degree rotation transformations\n    x29 = chain(rot270, x21, rot90)\n    \n    # Combine rotation transformations\n    x30 = chain(x29, x28, x27)\n    \n    # Combine mirror transformations\n    x31 = chain(x26, x25, x24)\n    \n    # Combine identity and diagonal mirror transformations\n    x32 = compose(x23, x22)\n    \n    # Combine all transformations into a single function\n    x33 = chain(x30, x31, x32)\n    \n    # Apply all transformations to the background grid\n    x34 = x33(x5)\n    \n    # Return the final transformed grid\n    return x34\n"
  },
  "10fcaaa3": {
    "original": "def verify_10fcaaa3(I: Grid) -> Grid:\n    x0 = hconcat(I, I)\n    x1 = vconcat(x0, x0)\n    x2 = asindices(x1)\n    x3 = mostcolor(I)\n    x4 = ofcolor(x1, x3)\n    x5 = difference(x2, x4)\n    x6 = mapply(ineighbors, x5)\n    x7 = underfill(x1, EIGHT, x6)\n    return x7\n\n",
    "annotated": "def verify_10fcaaa3(I: Grid) -> Grid:\n    # Create a 2x2 tiled version of the input grid by concatenating it horizontally and vertically\n    x0 = hconcat(I, I)\n    x1 = vconcat(x0, x0)\n\n    # Get all possible indices in the tiled grid\n    x2 = asindices(x1)\n\n    # Find the most common color in the original input grid (background color)\n    x3 = mostcolor(I)\n\n    # Get all indices of the background color in the tiled grid\n    x4 = ofcolor(x1, x3)\n\n    # Find all non-background colored cells in the tiled grid\n    x5 = difference(x2, x4)\n\n    # Get the diagonal neighbors of all non-background colored cells\n    x6 = mapply(ineighbors, x5)\n\n    # Fill the diagonal neighbors of non-background cells with color 8,\n    # but only if they were originally background colored\n    x7 = underfill(x1, EIGHT, x6)\n\n    # Return the final modified grid\n    return x7\n"
  },
  "11852cab": {
    "original": "def verify_11852cab(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = lbind(remove, x0)\n    x2 = chain(positive, size, x1)\n    x3 = compose(x2, palette)\n    x4 = multiply(FIVE, UNITY)\n    x5 = canvas(ZERO, x4)\n    x6 = asindices(x5)\n    x7 = fork(add, first, last)\n    x8 = chain(flip, even, x7)\n    x9 = sfilter(x6, x8)\n    x10 = initset(x0)\n    x11 = box(x6)\n    x12 = inbox(x6)\n    x13 = center(x6)\n    x14 = initset(x13)\n    x15 = lbind(toobject, x11)\n    x16 = compose(x3, x15)\n    x17 = lbind(toobject, x12)\n    x18 = compose(x3, x17)\n    x19 = lbind(toobject, x14)\n    x20 = compose(x3, x19)\n    x21 = fork(both, x18, x20)\n    x22 = fork(both, x16, x21)\n    x23 = compose(x22, trim)\n    x24 = compose(box, asindices)\n    x25 = fork(toobject, x24, identity)\n    x26 = compose(palette, x25)\n    x27 = matcher(x26, x10)\n    x28 = lbind(toobject, x9)\n    x29 = chain(palette, x28, trim)\n    x30 = matcher(x29, x10)\n    x31 = compose(minimum, shape)\n    x32 = chain(x31, merge, fgpartition)\n    x33 = matcher(x32, FIVE)\n    x34 = fork(both, x23, x27)\n    x35 = fork(both, x30, x33)\n    x36 = fork(both, x34, x35)\n    x37 = height(I)\n    x38 = subtract(x37, THREE)\n    x39 = interval(ONE, x38, ONE)\n    x40 = width(I)\n    x41 = subtract(x40, THREE)\n    x42 = interval(ONE, x41, ONE)\n    x43 = multiply(SEVEN, UNITY)\n    x44 = lbind(crop, I)\n    x45 = rbind(x44, x43)\n    x46 = chain(x36, x45, decrement)\n    x47 = product(x39, x42)\n    x48 = sfilter(x47, x46)\n    x49 = matcher(first, x0)\n    x50 = compose(flip, x49)\n    x51 = rbind(sfilter, x50)\n    x52 = compose(x51, dmirror)\n    x53 = fork(combine, x51, x52)\n    x54 = compose(x51, cmirror)\n    x55 = compose(x51, hmirror)\n    x56 = compose(x51, vmirror)\n    x57 = fork(combine, x55, x56)\n    x58 = fork(combine, x54, x57)\n    x59 = fork(combine, x53, x58)\n    x60 = multiply(FOUR, UNITY)\n    x61 = rbind(add, x60)\n    x62 = fork(insert, x61, initset)\n    x63 = compose(backdrop, x62)\n    x64 = rbind(toobject, I)\n    x65 = chain(x59, x64, x63)\n    x66 = mapply(x65, x48)\n    x67 = paint(I, x66)\n    return x67\n\n",
    "annotated": "def verify_11852cab(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Create a function to remove the background color from a set of colors\n    x1 = lbind(remove, x0)\n    # Create a function to check if there are any colors left after removing the background color\n    x2 = chain(positive, size, x1)\n    # Create a function to check if there are non-background colors in a grid\n    x3 = compose(x2, palette)\n    # Create a 5x5 tuple\n    x4 = multiply(FIVE, UNITY)\n    # Create a 5x5 grid filled with zeros\n    x5 = canvas(ZERO, x4)\n    # Get all indices of the 5x5 grid\n    x6 = asindices(x5)\n    # Create a function to add the first and last elements of a tuple\n    x7 = fork(add, first, last)\n    # Create a function to check if the sum of coordinates is odd\n    x8 = chain(flip, even, x7)\n    # Filter the 5x5 grid indices to get a checkerboard pattern\n    x9 = sfilter(x6, x8)\n    # Create a set containing only the background color\n    x10 = initset(x0)\n    # Get the outline of the 5x5 grid\n    x11 = box(x6)\n    # Get the inner box of the 5x5 grid\n    x12 = inbox(x6)\n    # Get the center point of the 5x5 grid\n    x13 = center(x6)\n    # Create a set with the center point\n    x14 = initset(x13)\n    # Create a function to convert the outline to an object\n    x15 = lbind(toobject, x11)\n    # Create a function to check if the outline has non-background colors\n    x16 = compose(x3, x15)\n    # Create a function to convert the inner box to an object\n    x17 = lbind(toobject, x12)\n    # Create a function to check if the inner box has non-background colors\n    x18 = compose(x3, x17)\n    # Create a function to convert the center point to an object\n    x19 = lbind(toobject, x14)\n    # Create a function to check if the center point has a non-background color\n    x20 = compose(x3, x19)\n    # Create a function to check if both inner box and center have non-background colors\n    x21 = fork(both, x18, x20)\n    # Create a function to check if outline, inner box, and center have non-background colors\n    x22 = fork(both, x16, x21)\n    # Create a function to check if a 5x5 grid has the correct color pattern\n    x23 = compose(x22, trim)\n    # Create a function to get the box of a grid's indices\n    x24 = compose(box, asindices)\n    # Create a function to convert a grid to an object with its box\n    x25 = fork(toobject, x24, identity)\n    # Create a function to get the palette of a grid's box\n    x26 = compose(palette, x25)\n    # Create a function to check if a grid's box contains only the background color\n    x27 = matcher(x26, x10)\n    # Create a function to convert the checkerboard pattern to an object\n    x28 = lbind(toobject, x9)\n    # Create a function to get the palette of the checkerboard pattern in a 5x5 grid\n    x29 = chain(palette, x28, trim)\n    # Create a function to check if the checkerboard pattern contains only the background color\n    x30 = matcher(x29, x10)\n    # Create a function to get the minimum dimension of a shape\n    x31 = compose(minimum, shape)\n    # Create a function to get the minimum dimension of the smallest foreground object\n    x32 = chain(x31, merge, fgpartition)\n    # Create a function to check if the smallest foreground object is 5x5\n    x33 = matcher(x32, FIVE)\n    # Combine checks for correct color pattern and box containing only background color\n    x34 = fork(both, x23, x27)\n    # Combine checks for checkerboard pattern and smallest foreground object size\n    x35 = fork(both, x30, x33)\n    # Combine all checks for a valid 5x5 object\n    x36 = fork(both, x34, x35)\n    # Get the height of the input grid\n    x37 = height(I)\n    # Calculate the maximum row index for placing 5x5 objects\n    x38 = subtract(x37, THREE)\n    # Create a range of valid row indices for placing 5x5 objects\n    x39 = interval(ONE, x38, ONE)\n    # Get the width of the input grid\n    x40 = width(I)\n    # Calculate the maximum column index for placing 5x5 objects\n    x41 = subtract(x40, THREE)\n    # Create a range of valid column indices for placing 5x5 objects\n    x42 = interval(ONE, x41, ONE)\n    # Create a 7x7 tuple\n    x43 = multiply(SEVEN, UNITY)\n    # Create a function to crop the input grid\n    x44 = lbind(crop, I)\n    # Create a function to crop a 7x7 area from the input grid\n    x45 = rbind(x44, x43)\n    # Create a function to check if a 7x7 area contains a valid 5x5 object\n    x46 = chain(x36, x45, decrement)\n    # Create all possible 5x5 object positions in the grid\n    x47 = product(x39, x42)\n    # Filter the positions to find all valid 5x5 objects in the grid\n    x48 = sfilter(x47, x46)\n    # Create a function to check if a color matches the background color\n    x49 = matcher(first, x0)\n    # Create a function to check if a color is not the background color\n    x50 = compose(flip, x49)\n    # Create a function to filter non-background colors\n    x51 = rbind(sfilter, x50)\n    # Create a function to filter non-background colors after diagonal mirroring\n    x52 = compose(x51, dmirror)\n    # Create a function to combine original and diagonally mirrored non-background colors\n    x53 = fork(combine, x51, x52)\n    # Create a function to filter non-background colors after counter-diagonal mirroring\n    x54 = compose(x51, cmirror)\n    # Create a function to filter non-background colors after horizontal mirroring\n    x55 = compose(x51, hmirror)\n    # Create a function to filter non-background colors after vertical mirroring\n    x56 = compose(x51, vmirror)\n    # Create a function to combine horizontally and vertically mirrored non-background colors\n    x57 = fork(combine, x55, x56)\n    # Create a function to combine counter-diagonally, horizontally, and vertically mirrored non-background colors\n    x58 = fork(combine, x54, x57)\n    # Create a function to combine all mirrored non-background colors\n    x59 = fork(combine, x53, x58)\n    # Create a 4x4 tuple\n    x60 = multiply(FOUR, UNITY)\n    # Create a function to add 4 to both dimensions\n    x61 = rbind(add, x60)\n    # Create a function to insert the result of adding 4 to both dimensions into a set\n    x62 = fork(insert, x61, initset)\n    # Create a function to get the backdrop of the expanded area\n    x63 = compose(backdrop, x62)\n    # Create a function to convert a grid area to an object\n    x64 = rbind(toobject, I)\n    # Create a function to apply all transformations to a grid area\n    x65 = chain(x59, x64, x63)\n    # Apply the transformations to all valid 5x5 objects in the grid\n    x66 = mapply(x65, x48)\n    # Paint the transformed objects onto the input grid to create the output grid\n    x67 = paint(I, x66)\n    return x67\n"
  },
  "1190e5a7": {
    "original": "def verify_1190e5a7(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = corners(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = palette(I)\n    x5 = rbind(equality, x3)\n    x6 = argmin(x4, x5)\n    x7 = asindices(I)\n    x8 = ofcolor(I, x3)\n    x9 = difference(x7, x8)\n    x10 = fill(I, x6, x9)\n    x11 = frontiers(x10)\n    x12 = sfilter(x11, vline)\n    x13 = difference(x11, x12)\n    x14 = astuple(x13, x12)\n    x15 = apply(size, x14)\n    x16 = increment(x15)\n    x17 = canvas(x3, x16)\n    return x17\n\n",
    "annotated": "def verify_1190e5a7(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    # Find the corner indices of the grid\n    x1 = corners(x0)\n    # Create an object from the corner indices and their colors in the input grid\n    x2 = toobject(x1, I)\n    # Find the most common color in the corner object (likely the background color)\n    x3 = mostcolor(x2)\n    # Get all unique colors used in the input grid\n    x4 = palette(I)\n    # Create a function that checks if a color is equal to the background color\n    x5 = rbind(equality, x3)\n    # Find the color in the palette that is not the background color\n    x6 = argmin(x4, x5)\n    # Get all indices of the input grid (again)\n    x7 = asindices(I)\n    # Find all indices with the background color\n    x8 = ofcolor(I, x3)\n    # Find all indices that are not the background color (i.e., the frontier cells)\n    x9 = difference(x7, x8)\n    # Create a new grid by filling the frontier cells with the non-background color\n    x10 = fill(I, x6, x9)\n    # Identify all frontiers in the new grid\n    x11 = frontiers(x10)\n    # Filter out vertical frontiers\n    x12 = sfilter(x11, vline)\n    # Get horizontal frontiers by removing vertical frontiers from all frontiers\n    x13 = difference(x11, x12)\n    # Create a tuple of (horizontal frontiers, vertical frontiers)\n    x14 = astuple(x13, x12)\n    # Count the number of horizontal and vertical frontiers\n    x15 = apply(size, x14)\n    # Add 1 to each count (to get the number of regions, not lines)\n    x16 = increment(x15)\n    # Create the output grid with background color and dimensions based on frontier counts\n    x17 = canvas(x3, x16)\n    # Return the output grid\n    return x17\n"
  },
  "137eaa0f": {
    "original": "def verify_137eaa0f(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = palette(x1)\n    x3 = objects(I, T, F, T)\n    x4 = totuple(x3)\n    x5 = apply(color, x4)\n    x6 = lbind(sfilter, x5)\n    x7 = lbind(matcher, identity)\n    x8 = chain(size, x6, x7)\n    x9 = valmax(x2, x8)\n    x10 = matcher(x8, x9)\n    x11 = sfilter(x2, x10)\n    x12 = lbind(colorcount, I)\n    x13 = argmin(x11, x12)\n    x14 = ofcolor(I, x13)\n    x15 = recolor(x13, x14)\n    x16 = apply(initset, x15)\n    x17 = remove(x15, x0)\n    x18 = lbind(argmin, x16)\n    x19 = lbind(rbind, manhattan)\n    x20 = compose(x18, x19)\n    x21 = fork(combine, identity, x20)\n    x22 = apply(x21, x17)\n    x23 = matcher(first, x13)\n    x24 = rbind(sfilter, x23)\n    x25 = chain(invert, ulcorner, x24)\n    x26 = fork(shift, identity, x25)\n    x27 = mapply(x26, x22)\n    x28 = normalize(x27)\n    x29 = shape(x28)\n    x30 = canvas(ZERO, x29)\n    x31 = paint(x30, x28)\n    return x31\n\n",
    "annotated": "def verify_137eaa0f(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background\n    x0 = fgpartition(I)\n    \n    # Merge all objects into a single set of cells\n    x1 = merge(x0)\n    \n    # Get the set of unique colors used in the merged objects\n    x2 = palette(x1)\n    \n    # Find all objects in the input grid, including diagonally connected cells, excluding the background\n    x3 = objects(I, T, F, T)\n    \n    # Convert the set of objects to a tuple\n    x4 = totuple(x3)\n    \n    # Extract the color of each object\n    x5 = apply(color, x4)\n    \n    # Create a function to filter objects by color\n    x6 = lbind(sfilter, x5)\n    \n    # Create a function to match the identity of an object\n    x7 = lbind(matcher, identity)\n    \n    # Create a function to count objects of a specific color\n    x8 = chain(size, x6, x7)\n    \n    # Find the color with the maximum number of objects\n    x9 = valmax(x2, x8)\n    \n    # Create a function to match the color with the maximum number of objects\n    x10 = matcher(x8, x9)\n    \n    # Filter the palette to keep only the color with the maximum number of objects\n    x11 = sfilter(x2, x10)\n    \n    # Create a function to count cells of a specific color in the input grid\n    x12 = lbind(colorcount, I)\n    \n    # Find the color with the minimum number of cells among the filtered colors\n    x13 = argmin(x11, x12)\n    \n    # Get the indices of all cells with the chosen color\n    x14 = ofcolor(I, x13)\n    \n    # Create an object with the chosen color and its indices\n    x15 = recolor(x13, x14)\n    \n    # Convert each cell of the chosen color object to a singleton set\n    x16 = apply(initset, x15)\n    \n    # Remove the chosen color object from the original partition\n    x17 = remove(x15, x0)\n    \n    # Create a function to find the cell closest to a given object\n    x18 = lbind(argmin, x16)\n    x19 = lbind(rbind, manhattan)\n    x20 = compose(x18, x19)\n    \n    # Create a function to combine an object with its closest cell from the chosen color\n    x21 = fork(combine, identity, x20)\n    \n    # Apply the combining function to all remaining objects\n    x22 = apply(x21, x17)\n    \n    # Create a function to filter cells by the chosen color\n    x23 = matcher(first, x13)\n    x24 = rbind(sfilter, x23)\n    \n    # Create a function to find the offset to normalize an object\n    x25 = chain(invert, ulcorner, x24)\n    \n    # Create a function to shift an object by its normalization offset\n    x26 = fork(shift, identity, x25)\n    \n    # Apply the shift function to all combined objects and merge the results\n    x27 = mapply(x26, x22)\n    \n    # Normalize the merged result to bring it to the origin\n    x28 = normalize(x27)\n    \n    # Get the dimensions of the normalized result\n    x29 = shape(x28)\n    \n    # Create an empty canvas with the same dimensions as the normalized result\n    x30 = canvas(ZERO, x29)\n    \n    # Paint the normalized result onto the empty canvas\n    x31 = paint(x30, x28)\n    \n    # Return the final grid, which represents the extracted pattern\n    return x31\n"
  },
  "150deff5": {
    "original": "def verify_150deff5(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = leastcolor(I)\n    x2 = shape(I)\n    x3 = add(TWO, x2)\n    x4 = canvas(x0, x3)\n    x5 = asobject(I)\n    x6 = shift(x5, UNITY)\n    x7 = paint(x4, x6)\n    x8 = astuple(TWO, ONE)\n    x9 = dneighbors(UNITY)\n    x10 = remove(x8, x9)\n    x11 = recolor(x0, x10)\n    x12 = initset(UNITY)\n    x13 = recolor(x1, x12)\n    x14 = combine(x11, x13)\n    x15 = astuple(THREE, ONE)\n    x16 = connect(UNITY, x15)\n    x17 = recolor(TWO, x16)\n    x18 = initset(TWO_BY_TWO)\n    x19 = insert(UNITY, x18)\n    x20 = backdrop(x19)\n    x21 = astuple(TWO, THREE)\n    x22 = astuple(THREE, TWO)\n    x23 = initset(x22)\n    x24 = insert(x21, x23)\n    x25 = insert(THREE_BY_THREE, x24)\n    x26 = recolor(x1, x20)\n    x27 = outbox(x20)\n    x28 = difference(x27, x25)\n    x29 = recolor(x0, x28)\n    x30 = combine(x26, x29)\n    x31 = recolor(EIGHT, x20)\n    x32 = lbind(lbind, shift)\n    x33 = compose(x32, last)\n    x34 = lbind(fork, paint)\n    x35 = lbind(x34, identity)\n    x36 = lbind(lbind, mapply)\n    x37 = compose(x36, x33)\n    x38 = lbind(rbind, occurrences)\n    x39 = compose(x38, first)\n    x40 = fork(compose, x37, x39)\n    x41 = compose(x35, x40)\n    x42 = astuple(x14, x17)\n    x43 = x41(x42)\n    x44 = compose(rot90, x43)\n    x45 = power(x44, FOUR)\n    x46 = astuple(x30, x31)\n    x47 = x41(x46)\n    x48 = compose(rot90, x47)\n    x49 = power(x48, FOUR)\n    x50 = compose(x45, x49)\n    x51 = initset(ORIGIN)\n    x52 = difference(x51, x51)\n    x53 = lbind(recolor, TWO)\n    x54 = rbind(ofcolor, TWO)\n    x55 = compose(x53, x54)\n    x56 = lbind(recolor, EIGHT)\n    x57 = rbind(ofcolor, EIGHT)\n    x58 = compose(x56, x57)\n    x59 = fork(combine, x55, x58)\n    x60 = lbind(recolor, x0)\n    x61 = compose(x60, x59)\n    x62 = fork(paint, identity, x61)\n    x63 = chain(x62, x50, first)\n    x64 = chain(x59, x50, first)\n    x65 = fork(combine, last, x64)\n    x66 = fork(astuple, x63, x65)\n    x67 = astuple(x7, x52)\n    x68 = power(x66, FIVE)\n    x69 = x68(x67)\n    x70 = first(x69)\n    x71 = last(x69)\n    x72 = paint(x70, x71)\n    x73 = trim(x72)\n    return x73\n\n",
    "annotated": "def verify_150deff5(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Get the least common color in the input grid (foreground color)\n    x1 = leastcolor(I)\n    # Get the dimensions (shape) of the input grid\n    x2 = shape(I)\n    # Add 2 to each dimension of the input grid shape\n    x3 = add(TWO, x2)\n    # Create a new canvas with the background color and increased dimensions\n    x4 = canvas(x0, x3)\n    # Convert the input grid to an object representation\n    x5 = asobject(I)\n    # Shift the input object by (1,1), effectively creating a 1-cell border\n    x6 = shift(x5, UNITY)\n    # Paint the shifted input onto the new larger canvas\n    x7 = paint(x4, x6)\n    # Create a tuple (2,1)\n    x8 = astuple(TWO, ONE)\n    # Get the direct neighbors of (1,1)\n    x9 = dneighbors(UNITY)\n    # Remove (2,1) from the neighbors of (1,1)\n    x10 = remove(x8, x9)\n    # Recolor the remaining neighbors to the background color\n    x11 = recolor(x0, x10)\n    # Create a set with just (1,1)\n    x12 = initset(UNITY)\n    # Recolor (1,1) to the foreground color\n    x13 = recolor(x1, x12)\n    # Combine the recolored neighbors and (1,1)\n    x14 = combine(x11, x13)\n    # Create a tuple (3,1)\n    x15 = astuple(THREE, ONE)\n    # Create a line from (1,1) to (3,1)\n    x16 = connect(UNITY, x15)\n    # Recolor this line to color 2 (red)\n    x17 = recolor(TWO, x16)\n    # Create a set with (2,2)\n    x18 = initset(TWO_BY_TWO)\n    # Insert (1,1) into this set\n    x19 = insert(UNITY, x18)\n    # Get the backdrop (bounding box) of this set\n    x20 = backdrop(x19)\n    # Create a tuple (2,3)\n    x21 = astuple(TWO, THREE)\n    # Create a tuple (3,2)\n    x22 = astuple(THREE, TWO)\n    # Create a set with (3,2)\n    x23 = initset(x22)\n    # Insert (2,3) into this set\n    x24 = insert(x21, x23)\n    # Insert (3,3) into this set\n    x25 = insert(THREE_BY_THREE, x24)\n    # Recolor the backdrop to the foreground color\n    x26 = recolor(x1, x20)\n    # Get the outbox of the backdrop\n    x27 = outbox(x20)\n    # Remove the set {(2,3), (3,2), (3,3)} from the outbox\n    x28 = difference(x27, x25)\n    # Recolor the remaining outbox to the background color\n    x29 = recolor(x0, x28)\n    # Combine the recolored backdrop and outbox\n    x30 = combine(x26, x29)\n    # Recolor the backdrop to color 8 (blue)\n    x31 = recolor(EIGHT, x20)\n    # Create a partially applied function for shifting\n    x32 = lbind(lbind, shift)\n    # Compose this with the 'last' function\n    x33 = compose(x32, last)\n    # Create a partially applied function for painting\n    x34 = lbind(fork, paint)\n    # Further partial application\n    x35 = lbind(x34, identity)\n    # Create a partially applied function for mapping\n    x36 = lbind(lbind, mapply)\n    # Compose this with the previous function\n    x37 = compose(x36, x33)\n    # Create a partially applied function for finding occurrences\n    x38 = lbind(rbind, occurrences)\n    # Compose this with the 'first' function\n    x39 = compose(x38, first)\n    # Combine the previous functions\n    x40 = fork(compose, x37, x39)\n    # Further composition\n    x41 = compose(x35, x40)\n    # Create a tuple of the previously created objects\n    x42 = astuple(x14, x17)\n    # Apply the composed function to this tuple\n    x43 = x41(x42)\n    # Compose rotation with the previous result\n    x44 = compose(rot90, x43)\n    # Apply this rotation 4 times\n    x45 = power(x44, FOUR)\n    # Create another tuple of previously created objects\n    x46 = astuple(x30, x31)\n    # Apply the composed function to this tuple\n    x47 = x41(x46)\n    # Compose rotation with the previous result\n    x48 = compose(rot90, x47)\n    # Apply this rotation 4 times\n    x49 = power(x48, FOUR)\n    # Compose the two rotation sequences\n    x50 = compose(x45, x49)\n    # Create a set with just the origin (0,0)\n    x51 = initset(ORIGIN)\n    # Create an empty set by subtracting a set from itself\n    x52 = difference(x51, x51)\n    # Create a function to recolor to red (2)\n    x53 = lbind(recolor, TWO)\n    # Create a function to find red (2) cells\n    x54 = rbind(ofcolor, TWO)\n    # Compose these functions\n    x55 = compose(x53, x54)\n    # Create a function to recolor to blue (8)\n    x56 = lbind(recolor, EIGHT)\n    # Create a function to find blue (8) cells\n    x57 = rbind(ofcolor, EIGHT)\n    # Compose these functions\n    x58 = compose(x56, x57)\n    # Combine the red and blue recoloring functions\n    x59 = fork(combine, x55, x58)\n    # Create a function to recolor to the background color\n    x60 = lbind(recolor, x0)\n    # Compose this with the previous combined function\n    x61 = compose(x60, x59)\n    # Create a function to paint while preserving identity\n    x62 = fork(paint, identity, x61)\n    # Chain multiple functions together\n    x63 = chain(x62, x50, first)\n    # Chain another set of functions\n    x64 = chain(x59, x50, first)\n    # Combine the last element with the result of x64\n    x65 = fork(combine, last, x64)\n    # Create a tuple of x63 and x65\n    x66 = fork(astuple, x63, x65)\n    # Create a tuple of the enlarged input and an empty set\n    x67 = astuple(x7, x52)\n    # Apply the function x66 five times\n    x68 = power(x66, FIVE)\n    # Apply this to x67\n    x69 = x68(x67)\n    # Get the first element of the result\n    x70 = first(x69)\n    # Get the last element of the result\n    x71 = last(x69)\n    # Paint the last element onto the first\n    x72 = paint(x70, x71)\n    # Trim the result to remove the added border\n    x73 = trim(x72)\n    # Return the final processed grid\n    return x73\n"
  },
  "178fcbfb": {
    "original": "def verify_178fcbfb(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = ofcolor(I, THREE)\n    x2 = ofcolor(I, ONE)\n    x3 = mapply(vfrontier, x0)\n    x4 = mapply(hfrontier, x1)\n    x5 = mapply(hfrontier, x2)\n    x6 = fill(I, TWO, x3)\n    x7 = fill(x6, THREE, x4)\n    x8 = fill(x7, ONE, x5)\n    return x8\n\n",
    "annotated": "def verify_178fcbfb(I: Grid) -> Grid:\n    # Find all cells in the input grid I that have color 2\n    x0 = ofcolor(I, TWO)\n    \n    # Find all cells in the input grid I that have color 3\n    x1 = ofcolor(I, THREE)\n    \n    # Find all cells in the input grid I that have color 1\n    x2 = ofcolor(I, ONE)\n    \n    # For each cell with color 2, create a vertical line (column) through the entire grid\n    x3 = mapply(vfrontier, x0)\n    \n    # For each cell with color 3, create a horizontal line (row) through the entire grid\n    x4 = mapply(hfrontier, x1)\n    \n    # For each cell with color 1, create a horizontal line (row) through the entire grid\n    x5 = mapply(hfrontier, x2)\n    \n    # Fill all vertical lines (columns) created from color 2 cells with color 2\n    # This expands color 2 dots into full columns\n    x6 = fill(I, TWO, x3)\n    \n    # Fill all horizontal lines (rows) created from color 3 cells with color 3\n    # This expands color 3 dots into full rows\n    x7 = fill(x6, THREE, x4)\n    \n    # Fill all horizontal lines (rows) created from color 1 cells with color 1\n    # This expands color 1 dots into full rows\n    x8 = fill(x7, ONE, x5)\n    \n    # Return the final grid where all dots have been expanded into full rows or columns\n    return x8\n"
  },
  "1a07d186": {
    "original": "def verify_1a07d186(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = mostcolor(I)\n    x2 = asindices(I)\n    x3 = ofcolor(I, x1)\n    x4 = difference(x2, x3)\n    x5 = mapply(toindices, x0)\n    x6 = difference(x4, x5)\n    x7 = toobject(x6, I)\n    x8 = apply(initset, x7)\n    x9 = fill(I, x1, x6)\n    x10 = lbind(fork, shift)\n    x11 = lbind(x10, identity)\n    x12 = lbind(rbind, gravitate)\n    x13 = compose(x11, x12)\n    x14 = lbind(colorfilter, x8)\n    x15 = compose(x14, color)\n    x16 = fork(mapply, x13, x15)\n    x17 = mapply(x16, x0)\n    x18 = paint(x9, x17)\n    return x18\n\n",
    "annotated": "def verify_1a07d186(I: Grid) -> Grid:\n    # Find all frontiers (continuous lines) in the input grid\n    x0 = frontiers(I)\n    \n    # Determine the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Get all indices of the input grid\n    x2 = asindices(I)\n    \n    # Find all indices with the background color\n    x3 = ofcolor(I, x1)\n    \n    # Get all non-background indices (dots and lines)\n    x4 = difference(x2, x3)\n    \n    # Convert frontiers to indices\n    x5 = mapply(toindices, x0)\n    \n    # Get all dot indices by removing line indices from non-background indices\n    x6 = difference(x4, x5)\n    \n    # Create an object representation of the dots with their colors\n    x7 = toobject(x6, I)\n    \n    # Create a set of single-element sets, each containing one dot object\n    x8 = apply(initset, x7)\n    \n    # Create a new grid by filling all dot positions with the background color\n    x9 = fill(I, x1, x6)\n    \n    # Prepare a function to shift objects\n    x10 = lbind(fork, shift)\n    x11 = lbind(x10, identity)\n    \n    # Prepare a function to calculate gravitation direction\n    x12 = lbind(rbind, gravitate)\n    \n    # Combine shift and gravitation functions\n    x13 = compose(x11, x12)\n    \n    # Prepare a function to filter objects by color\n    x14 = lbind(colorfilter, x8)\n    x15 = compose(x14, color)\n    \n    # Combine shift/gravitation and color filtering functions\n    x16 = fork(mapply, x13, x15)\n    \n    # Apply the combined function to move dots next to their corresponding lines\n    x17 = mapply(x16, x0)\n    \n    # Paint the moved dots onto the grid, creating the output\n    x18 = paint(x9, x17)\n    \n    # Return the final output grid\n    return x18\n"
  },
  "1b2d62fb": {
    "original": "def verify_1b2d62fb(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = halve(x0)\n    x2 = tojvec(x1)\n    x3 = height(I)\n    x4 = decrement(x3)\n    x5 = astuple(x4, x1)\n    x6 = connect(x2, x5)\n    x7 = toobject(x6, I)\n    x8 = numcolors(x7)\n    x9 = equality(x8, ONE)\n    x10 = branch(x9, lefthalf, tophalf)\n    x11 = branch(x9, righthalf, bottomhalf)\n    x12 = x10(I)\n    x13 = x11(I)\n    x14 = shape(x12)\n    x15 = canvas(ZERO, x14)\n    x16 = ofcolor(x12, ZERO)\n    x17 = ofcolor(x13, ZERO)\n    x18 = intersection(x16, x17)\n    x19 = fill(x15, EIGHT, x18)\n    return x19\n\n",
    "annotated": "def verify_1b2d62fb(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    \n    # Calculate half of the width (for finding the middle column)\n    x1 = halve(x0)\n    \n    # Create a vector pointing to the middle column (0, half_width)\n    x2 = tojvec(x1)\n    \n    # Get the height of the input grid\n    x3 = height(I)\n    \n    # Decrement the height by 1 (for the bottom row)\n    x4 = decrement(x3)\n    \n    # Create a tuple (height-1, half_width) for the bottom of the middle column\n    x5 = astuple(x4, x1)\n    \n    # Create a line from the top to the bottom of the middle column\n    x6 = connect(x2, x5)\n    \n    # Convert the middle column line to an object based on the input grid\n    x7 = toobject(x6, I)\n    \n    # Count the number of colors in the middle column object\n    x8 = numcolors(x7)\n    \n    # Check if the middle column has only one color (True if it's a vertical bar)\n    x9 = equality(x8, ONE)\n    \n    # Choose lefthalf if vertical bar, tophalf if horizontal bar\n    x10 = branch(x9, lefthalf, tophalf)\n    \n    # Choose righthalf if vertical bar, bottomhalf if horizontal bar\n    x11 = branch(x9, righthalf, bottomhalf)\n    \n    # Apply the chosen function to get the left/top half of the input\n    x12 = x10(I)\n    \n    # Apply the chosen function to get the right/bottom half of the input\n    x13 = x11(I)\n    \n    # Get the shape (dimensions) of the left/top half\n    x14 = shape(x12)\n    \n    # Create a blank canvas with the same shape as the left/top half\n    x15 = canvas(ZERO, x14)\n    \n    # Find all cells with color 0 (background) in the left/top half\n    x16 = ofcolor(x12, ZERO)\n    \n    # Find all cells with color 0 (background) in the right/bottom half\n    x17 = ofcolor(x13, ZERO)\n    \n    # Find the intersection of background cells from both halves\n    x18 = intersection(x16, x17)\n    \n    # Fill the blank canvas with color 8 where both halves had background color\n    # This creates the output grid with color 8 in cells that were background in both halves\n    x19 = fill(x15, EIGHT, x18)\n    \n    # Return the final output grid\n    return x19\n"
  },
  "1b60fb0c": {
    "original": "def verify_1b60fb0c(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = mapply(toindices, x0)\n    x2 = rot90(I)\n    x3 = fgpartition(x2)\n    x4 = mapply(toindices, x3)\n    x5 = normalize(x4)\n    x6 = ulcorner(x1)\n    x7 = shift(x5, x6)\n    x8 = shape(x1)\n    x9 = maximum(x8)\n    x10 = minimum(x8)\n    x11 = subtract(x9, x10)\n    x12 = increment(x11)\n    x13 = power(outbox, x12)\n    x14 = center(x7)\n    x15 = x13(x7)\n    x16 = backdrop(x15)\n    x17 = invert(x14)\n    x18 = shift(x16, x17)\n    x19 = lbind(combine, x1)\n    x20 = lbind(shift, x7)\n    x21 = compose(x19, x20)\n    x22 = rbind(ofcolor, ONE)\n    x23 = lbind(canvas, ZERO)\n    x24 = chain(x23, shape, x21)\n    x25 = lbind(recolor, ONE)\n    x26 = chain(x25, normalize, x21)\n    x27 = fork(paint, x24, x26)\n    x28 = chain(x22, rot90, x27)\n    x29 = compose(normalize, x21)\n    x30 = fork(equality, x29, x28)\n    x31 = sfilter(x18, x30)\n    x32 = lbind(intersection, x1)\n    x33 = lbind(shift, x7)\n    x34 = chain(size, x32, x33)\n    x35 = argmax(x31, x34)\n    x36 = shift(x7, x35)\n    x37 = difference(x36, x1)\n    x38 = fill(I, TWO, x37)\n    return x38\n\n",
    "annotated": "def verify_1b60fb0c(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    # Convert each object in the partition to indices\n    x1 = mapply(toindices, x0)\n    # Rotate the input grid 90 degrees clockwise\n    x2 = rot90(I)\n    # Partition the foreground objects in the rotated grid\n    x3 = fgpartition(x2)\n    # Convert each object in the rotated partition to indices\n    x4 = mapply(toindices, x3)\n    # Normalize the rotated partition (move to origin)\n    x5 = normalize(x4)\n    # Get the upper-left corner of the original partition\n    x6 = ulcorner(x1)\n    # Shift the normalized rotated partition to align with the original\n    x7 = shift(x5, x6)\n    # Get the shape (dimensions) of the original partition\n    x8 = shape(x1)\n    # Find the maximum dimension\n    x9 = maximum(x8)\n    # Find the minimum dimension\n    x10 = minimum(x8)\n    # Calculate the difference between max and min dimensions\n    x11 = subtract(x9, x10)\n    # Increment the difference (to ensure we cover all possibilities)\n    x12 = increment(x11)\n    # Create a function that applies 'outbox' multiple times\n    x13 = power(outbox, x12)\n    # Find the center of the shifted rotated partition\n    x14 = center(x7)\n    # Apply the multi-outbox function to the shifted rotated partition\n    x15 = x13(x7)\n    # Get all indices within the multi-outbox\n    x16 = backdrop(x15)\n    # Invert the center coordinates\n    x17 = invert(x14)\n    # Shift the backdrop by the inverted center (centering it)\n    x18 = shift(x16, x17)\n    # Create a function to combine with the original partition\n    x19 = lbind(combine, x1)\n    # Create a function to shift by the rotated partition\n    x20 = lbind(shift, x7)\n    # Compose the combine and shift functions\n    x21 = compose(x19, x20)\n    # Create a function to filter cells with color 1\n    x22 = rbind(ofcolor, ONE)\n    # Create a function to make a canvas of 0s\n    x23 = lbind(canvas, ZERO)\n    # Chain functions to create a canvas of the right shape\n    x24 = chain(x23, shape, x21)\n    # Create a function to recolor to 1\n    x25 = lbind(recolor, ONE)\n    # Chain functions to normalize and recolor\n    x26 = chain(x25, normalize, x21)\n    # Create a function to paint the recolored shape on the canvas\n    x27 = fork(paint, x24, x26)\n    # Chain functions to rotate, paint, and filter color 1\n    x28 = chain(x22, rot90, x27)\n    # Create a function to normalize the combined shape\n    x29 = compose(normalize, x21)\n    # Create a function to check equality of normalized shapes\n    x30 = fork(equality, x29, x28)\n    # Filter the centered backdrop based on shape equality\n    x31 = sfilter(x18, x30)\n    # Create a function to intersect with the original partition\n    x32 = lbind(intersection, x1)\n    # Create a function to shift by the rotated partition\n    x33 = lbind(shift, x7)\n    # Chain functions to get size of intersection after shifting\n    x34 = chain(size, x32, x33)\n    # Find the position with maximum intersection size\n    x35 = argmax(x31, x34)\n    # Shift the rotated partition to the best position\n    x36 = shift(x7, x35)\n    # Find the difference between the shifted rotated partition and original\n    x37 = difference(x36, x1)\n    # Fill the difference with color 2 on the input grid\n    x38 = fill(I, TWO, x37)\n    # Return the modified grid (original input with missing part filled in)\n    return x38\n"
  },
  "1bfc4729": {
    "original": "def verify_1bfc4729(I: Grid) -> Grid:\n    x0 = tophalf(I)\n    x1 = bottomhalf(I)\n    x2 = leastcolor(x0)\n    x3 = leastcolor(x1)\n    x4 = ofcolor(I, x2)\n    x5 = center(x4)\n    x6 = ofcolor(I, x3)\n    x7 = center(x6)\n    x8 = height(I)\n    x9 = width(I)\n    x10 = hfrontier(x5)\n    x11 = fill(I, x2, x10)\n    x12 = hfrontier(x7)\n    x13 = fill(x11, x3, x12)\n    x14 = decrement(x9)\n    x15 = decrement(x8)\n    x16 = halve(x8)\n    x17 = tojvec(x14)\n    x18 = connect(ORIGIN, x17)\n    x19 = fill(x13, x2, x18)\n    x20 = toivec(x15)\n    x21 = astuple(x15, x14)\n    x22 = connect(x20, x21)\n    x23 = fill(x19, x3, x22)\n    x24 = decrement(x16)\n    x25 = toivec(x24)\n    x26 = connect(ORIGIN, x25)\n    x27 = fill(x23, x2, x26)\n    x28 = tojvec(x14)\n    x29 = decrement(x16)\n    x30 = astuple(x29, x14)\n    x31 = connect(x28, x30)\n    x32 = fill(x27, x2, x31)\n    x33 = toivec(x16)\n    x34 = toivec(x15)\n    x35 = connect(x33, x34)\n    x36 = fill(x32, x3, x35)\n    x37 = astuple(x16, x14)\n    x38 = astuple(x15, x14)\n    x39 = connect(x37, x38)\n    x40 = fill(x36, x3, x39)\n    return x40\n\n",
    "annotated": "def verify_1bfc4729(I: Grid) -> Grid:\n    # Split the input grid into top and bottom halves\n    x0 = tophalf(I)\n    x1 = bottomhalf(I)\n    \n    # Find the least common color in the top half (color of point A)\n    x2 = leastcolor(x0)\n    # Find the least common color in the bottom half (color of point B)\n    x3 = leastcolor(x1)\n    \n    # Get all cells with the color of point A\n    x4 = ofcolor(I, x2)\n    # Find the center of point A\n    x5 = center(x4)\n    \n    # Get all cells with the color of point B\n    x6 = ofcolor(I, x3)\n    # Find the center of point B\n    x7 = center(x6)\n    \n    # Get the height and width of the input grid\n    x8 = height(I)\n    x9 = width(I)\n    \n    # Create a horizontal line through point A\n    x10 = hfrontier(x5)\n    # Fill the horizontal line through A with A's color\n    x11 = fill(I, x2, x10)\n    \n    # Create a horizontal line through point B\n    x12 = hfrontier(x7)\n    # Fill the horizontal line through B with B's color\n    x13 = fill(x11, x3, x12)\n    \n    # Calculate grid dimensions for border drawing\n    x14 = decrement(x9)  # Width - 1\n    x15 = decrement(x8)  # Height - 1\n    x16 = halve(x8)      # Half height\n    \n    # Draw top border with A's color\n    x17 = tojvec(x14)\n    x18 = connect(ORIGIN, x17)\n    x19 = fill(x13, x2, x18)\n    \n    # Draw bottom border with B's color\n    x20 = toivec(x15)\n    x21 = astuple(x15, x14)\n    x22 = connect(x20, x21)\n    x23 = fill(x19, x3, x22)\n    \n    # Draw left half of left border with A's color\n    x24 = decrement(x16)\n    x25 = toivec(x24)\n    x26 = connect(ORIGIN, x25)\n    x27 = fill(x23, x2, x26)\n    \n    # Draw right half of left border with A's color\n    x28 = tojvec(x14)\n    x29 = decrement(x16)\n    x30 = astuple(x29, x14)\n    x31 = connect(x28, x30)\n    x32 = fill(x27, x2, x31)\n    \n    # Draw left half of right border with B's color\n    x33 = toivec(x16)\n    x34 = toivec(x15)\n    x35 = connect(x33, x34)\n    x36 = fill(x32, x3, x35)\n    \n    # Draw right half of right border with B's color\n    x37 = astuple(x16, x14)\n    x38 = astuple(x15, x14)\n    x39 = connect(x37, x38)\n    x40 = fill(x36, x3, x39)\n    \n    # Return the final grid with all modifications\n    return x40\n"
  },
  "1c786137": {
    "original": "def verify_1c786137(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = lbind(colorfilter, x0)\n    x2 = compose(size, x1)\n    x3 = matcher(x2, ONE)\n    x4 = palette(I)\n    x5 = sfilter(x4, x3)\n    x6 = fork(equality, toindices, box)\n    x7 = rbind(contained, x5)\n    x8 = compose(x7, color)\n    x9 = sfilter(x0, x8)\n    x10 = rbind(greater, SEVEN)\n    x11 = compose(x10, size)\n    x12 = sfilter(x9, x11)\n    x13 = extract(x12, x6)\n    x14 = subgrid(x13, I)\n    x15 = trim(x14)\n    return x15\n\n",
    "annotated": "def verify_1c786137(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that filters objects by color\n    x1 = lbind(colorfilter, x0)\n    \n    # Create a function that returns the size of a color-filtered set of objects\n    x2 = compose(size, x1)\n    \n    # Create a function that checks if the size of a color-filtered set is equal to 1\n    x3 = matcher(x2, ONE)\n    \n    # Get the set of all colors used in the input grid\n    x4 = palette(I)\n    \n    # Filter the palette to find colors that are used exactly once in the grid\n    x5 = sfilter(x4, x3)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x6 = fork(equality, toindices, box)\n    \n    # Create a function that checks if an object's color is in the set of unique colors\n    x7 = rbind(contained, x5)\n    \n    # Create a function that checks if an object's color is unique\n    x8 = compose(x7, color)\n    \n    # Filter objects to keep only those with unique colors\n    x9 = sfilter(x0, x8)\n    \n    # Create a function that checks if a value is greater than 7\n    x10 = rbind(greater, SEVEN)\n    \n    # Create a function that checks if an object's size is greater than 7\n    x11 = compose(x10, size)\n    \n    # Filter objects to keep only those with size greater than 7 and unique color\n    x12 = sfilter(x9, x11)\n    \n    # Extract the object that forms a perfect rectangle (indices match bounding box)\n    x13 = extract(x12, x6)\n    \n    # Get the subgrid of the input that corresponds to the extracted object\n    x14 = subgrid(x13, I)\n    \n    # Remove the outer border of the subgrid\n    x15 = trim(x14)\n    \n    # Return the trimmed subgrid as the output\n    return x15\n"
  },
  "1caeab9d": {
    "original": "def verify_1caeab9d(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = ofcolor(I, ONE)\n    x2 = lowermost(x1)\n    x3 = lbind(subtract, x2)\n    x4 = chain(toivec, x3, lowermost)\n    x5 = fork(shift, identity, x4)\n    x6 = merge(x0)\n    x7 = cover(I, x6)\n    x8 = mapply(x5, x0)\n    x9 = paint(x7, x8)\n    return x9\n\n",
    "annotated": "def verify_1caeab9d(I: Grid) -> Grid:\n    # Identify all objects in the input grid, including background\n    x0 = objects(I, T, T, T)\n    \n    # Find all cells with color 1 (the reference object)\n    x1 = ofcolor(I, ONE)\n    \n    # Get the row index of the lowermost cell of color 1\n    x2 = lowermost(x1)\n    \n    # Create a function that subtracts x2 from its input\n    x3 = lbind(subtract, x2)\n    \n    # Create a function chain: get lowermost point, subtract x2, convert to vertical vector\n    x4 = chain(toivec, x3, lowermost)\n    \n    # Create a function that shifts an object by the vector calculated in x4\n    x5 = fork(shift, identity, x4)\n    \n    # Merge all objects into a single set of cells\n    x6 = merge(x0)\n    \n    # Create a new grid by covering all objects with the background color\n    x7 = cover(I, x6)\n    \n    # Apply the shifting function to all objects\n    # This aligns all objects to the same row as the reference object\n    x8 = mapply(x5, x0)\n    \n    # Paint the shifted objects onto the background grid\n    # This creates the final output with all objects aligned\n    x9 = paint(x7, x8)\n    \n    # Return the final grid with aligned objects\n    return x9\n"
  },
  "1cf80156": {
    "original": "def verify_1cf80156(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = palette(I)\n    x4 = other(x3, x2)\n    x5 = objects(I, T, T, F)\n    x6 = matcher(color, x4)\n    x7 = extract(x5, x6)\n    x8 = subgrid(x7, I)\n    return x8\n\n",
    "annotated": "def verify_1cf80156(I: Grid) -> Grid:\n    # Find all frontiers (continuous lines of the same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Get the color of the merged frontiers (this will be the background color)\n    x2 = color(x1)\n    \n    # Get the palette (set of all colors) used in the input grid\n    x3 = palette(I)\n    \n    # Find the color that is not the background color (i.e., the foreground color)\n    x4 = other(x3, x2)\n    \n    # Find all objects in the grid, including diagonally connected cells, excluding the background\n    x5 = objects(I, T, T, F)\n    \n    # Create a function that checks if an object's color matches the foreground color\n    x6 = matcher(color, x4)\n    \n    # Extract the object from x5 that matches the foreground color\n    x7 = extract(x5, x6)\n    \n    # Extract the subgrid containing only the foreground object\n    x8 = subgrid(x7, I)\n    \n    # Return the extracted subgrid, which is the shape isolated from the background\n    return x8\n"
  },
  "1e0a9b12": {
    "original": "def verify_1e0a9b12(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = rot270(I)\n    x2 = matcher(identity, x0)\n    x3 = rbind(sfilter, x2)\n    x4 = compose(flip, x2)\n    x5 = rbind(sfilter, x4)\n    x6 = fork(combine, x3, x5)\n    x7 = apply(x6, x1)\n    x8 = rot90(x7)\n    return x8\n\n",
    "annotated": "def verify_1e0a9b12(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Rotate the input grid 270 degrees counterclockwise (equivalent to 90 degrees clockwise)\n    x1 = rot270(I)\n    \n    # Create a function that checks if a value is equal to the background color\n    x2 = matcher(identity, x0)\n    \n    # Create a function that filters elements equal to the background color\n    x3 = rbind(sfilter, x2)\n    \n    # Create a function that checks if a value is not equal to the background color\n    x4 = compose(flip, x2)\n    \n    # Create a function that filters elements not equal to the background color\n    x5 = rbind(sfilter, x4)\n    \n    # Create a function that combines background and non-background elements\n    x6 = fork(combine, x3, x5)\n    \n    # Apply the combining function to each column of the rotated input\n    # This effectively sorts each column, keeping background color at the bottom\n    x7 = apply(x6, x1)\n    \n    # Rotate the sorted grid 90 degrees counterclockwise to restore original orientation\n    x8 = rot90(x7)\n    \n    # Return the final sorted grid\n    return x8\n\n# In abstract terms, this function:\n# 1. Identifies the background color\n# 2. Rotates the grid to work with columns instead of rows\n# 3. Sorts each column, keeping background color at the bottom\n# 4. Rotates the grid back to its original orientation\n# The result is a grid where each column is sorted with non-background colors at the top\n"
  },
  "1e32b0e9": {
    "original": "def verify_1e32b0e9(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = leastcommon(x2)\n    x4 = matcher(color, x3)\n    x5 = sfilter(x0, x4)\n    x6 = merge(x5)\n    x7 = color(x6)\n    x8 = shape(I)\n    x9 = canvas(x7, x8)\n    x10 = hconcat(I, x9)\n    x11 = objects(x10, F, T, T)\n    x12 = first(x11)\n    x13 = box(x12)\n    x14 = rbind(contained, x13)\n    x15 = compose(x14, last)\n    x16 = sfilter(x12, x15)\n    x17 = color(x16)\n    x18 = palette(I)\n    x19 = remove(x7, x18)\n    x20 = other(x19, x17)\n    x21 = rbind(colorcount, x17)\n    x22 = argmin(x11, x21)\n    x23 = apply(ulcorner, x11)\n    x24 = normalize(x22)\n    x25 = matcher(first, x20)\n    x26 = sfilter(x24, x25)\n    x27 = toindices(x26)\n    x28 = lbind(shift, x27)\n    x29 = mapply(x28, x23)\n    x30 = ofcolor(I, x20)\n    x31 = difference(x29, x30)\n    x32 = fill(I, x7, x31)\n    return x32\n\n",
    "annotated": "def verify_1e32b0e9(I: Grid) -> Grid:\n    # Find all frontiers (rows or columns with the same color) in the input grid\n    x0 = frontiers(I)\n    # Convert the set of frontiers to a tuple\n    x1 = totuple(x0)\n    # Get the color of each frontier\n    x2 = apply(color, x1)\n    # Find the least common color among the frontiers (likely the line color)\n    x3 = leastcommon(x2)\n    # Create a function that matches the least common color\n    x4 = matcher(color, x3)\n    # Filter frontiers to keep only those with the least common color\n    x5 = sfilter(x0, x4)\n    # Merge all frontiers with the least common color into a single object\n    x6 = merge(x5)\n    # Get the color of the merged frontier object (line color)\n    x7 = color(x6)\n    # Get the dimensions of the input grid\n    x8 = shape(I)\n    # Create a new grid with the same dimensions as input, filled with the line color\n    x9 = canvas(x7, x8)\n    # Concatenate the input grid and the new grid horizontally\n    x10 = hconcat(I, x9)\n    # Find all objects in the concatenated grid, allowing diagonal connections\n    x11 = objects(x10, F, T, T)\n    # Get the first object (likely the largest one spanning both grids)\n    x12 = first(x11)\n    # Get the bounding box of the first object\n    x13 = box(x12)\n    # Create a function that checks if a point is contained in the bounding box\n    x14 = rbind(contained, x13)\n    # Create a function that checks if the last element is in the bounding box\n    x15 = compose(x14, last)\n    # Filter the first object to keep only cells within its bounding box\n    x16 = sfilter(x12, x15)\n    # Get the color of the filtered object (likely the background color)\n    x17 = color(x16)\n    # Get all colors used in the input grid\n    x18 = palette(I)\n    # Remove the line color from the palette\n    x19 = remove(x7, x18)\n    # Get the other color (foreground color) by removing background color\n    x20 = other(x19, x17)\n    # Create a function that counts cells of the background color\n    x21 = rbind(colorcount, x17)\n    # Find the object with the least number of background color cells (source subgrid)\n    x22 = argmin(x11, x21)\n    # Get the upper-left corners of all objects\n    x23 = apply(ulcorner, x11)\n    # Normalize the source subgrid (move it to origin)\n    x24 = normalize(x22)\n    # Create a function that matches the foreground color\n    x25 = matcher(first, x20)\n    # Filter the normalized source subgrid to keep only foreground color cells\n    x26 = sfilter(x24, x25)\n    # Get the indices of the foreground color cells in the source subgrid\n    x27 = toindices(x26)\n    # Create a function that shifts the foreground color cells\n    x28 = lbind(shift, x27)\n    # Apply the shift to all object positions, creating the complete shape for each subgrid\n    x29 = mapply(x28, x23)\n    # Find all cells with the foreground color in the input grid\n    x30 = ofcolor(I, x20)\n    # Get the cells that should be filled to complete all shapes\n    x31 = difference(x29, x30)\n    # Fill the input grid with the line color in the cells that complete the shapes\n    x32 = fill(I, x7, x31)\n    # Return the modified grid with completed shapes\n    return x32\n"
  },
  "1f0c79e5": {
    "original": "def verify_1f0c79e5(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = rbind(other, TWO)\n    x2 = compose(x1, palette)\n    x3 = matcher(first, TWO)\n    x4 = rbind(sfilter, x3)\n    x5 = compose(x4, normalize)\n    x6 = lbind(apply, double)\n    x7 = chain(x6, toindices, x5)\n    x8 = rbind(add, NEG_ONE)\n    x9 = lbind(apply, x8)\n    x10 = compose(x9, x7)\n    x11 = lbind(rbind, shoot)\n    x12 = rbind(compose, x11)\n    x13 = lbind(rbind, mapply)\n    x14 = chain(x12, x13, toindices)\n    x15 = fork(mapply, x14, x10)\n    x16 = fork(recolor, x2, x15)\n    x17 = mapply(x16, x0)\n    x18 = paint(I, x17)\n    return x18\n\n",
    "annotated": "def verify_1f0c79e5(I: Grid) -> Grid:\n    # Get all objects from the input grid, ignoring background\n    x0 = objects(I, F, F, T)\n    \n    # Create a function to get the other color (not 2) from a palette\n    x1 = rbind(other, TWO)\n    \n    # Compose x1 with palette to get the non-2 color from an object\n    x2 = compose(x1, palette)\n    \n    # Create a function to check if the first element is 2\n    x3 = matcher(first, TWO)\n    \n    # Create a function to filter elements where the first element is 2\n    x4 = rbind(sfilter, x3)\n    \n    # Compose x4 with normalize to filter and normalize objects\n    x5 = compose(x4, normalize)\n    \n    # Create a function to double all elements in a container\n    x6 = lbind(apply, double)\n    \n    # Chain functions to get doubled indices of normalized objects with color 2\n    x7 = chain(x6, toindices, x5)\n    \n    # Create a function to decrement all elements by 1\n    x8 = rbind(add, NEG_ONE)\n    \n    # Create a function to apply x8 to all elements in a container\n    x9 = lbind(apply, x8)\n    \n    # Compose x9 with x7 to get decremented doubled indices\n    x10 = compose(x9, x7)\n    \n    # Create a partial function for shooting in a direction\n    x11 = lbind(rbind, shoot)\n    \n    # Compose x11 with itself to create a higher-order function\n    x12 = rbind(compose, x11)\n    \n    # Create a partial function for mapping over a container\n    x13 = lbind(rbind, mapply)\n    \n    # Chain functions to create a shooting function for object indices\n    x14 = chain(x12, x13, toindices)\n    \n    # Create a function to apply x14 and x10 to an object and combine results\n    x15 = fork(mapply, x14, x10)\n    \n    # Create a function to recolor objects based on x2 and x15\n    x16 = fork(recolor, x2, x15)\n    \n    # Apply x16 to all objects in x0, creating new objects with lines\n    x17 = mapply(x16, x0)\n    \n    # Paint the new objects onto the input grid, creating the output\n    x18 = paint(I, x17)\n    \n    # Return the final output grid\n    return x18\n"
  },
  "1f642eb9": {
    "original": "def verify_1f642eb9(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = sfilter(x0, x2)\n    x4 = argmax(x3, size)\n    x5 = outbox(x4)\n    x6 = corners(x5)\n    x7 = toobject(x6, I)\n    x8 = color(x7)\n    x9 = asindices(I)\n    x10 = ofcolor(I, x8)\n    x11 = toindices(x4)\n    x12 = combine(x10, x11)\n    x13 = difference(x9, x12)\n    x14 = toobject(x13, I)\n    x15 = apply(initset, x14)\n    x16 = rbind(gravitate, x4)\n    x17 = compose(crement, x16)\n    x18 = fork(shift, identity, x17)\n    x19 = mapply(x18, x15)\n    x20 = paint(I, x19)\n    return x20\n\n",
    "annotated": "def verify_1f642eb9(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its height * width\n    x2 = fork(equality, size, x1)\n    \n    # Filter objects to keep only those that are rectangular (size == height * width)\n    x3 = sfilter(x0, x2)\n    \n    # Find the largest rectangular object (inner rectangle)\n    x4 = argmax(x3, size)\n    \n    # Get the outbox (surrounding border) of the largest rectangular object\n    x5 = outbox(x4)\n    \n    # Get the corner positions of the outbox\n    x6 = corners(x5)\n    \n    # Create an object from the corner positions, getting their colors from the input grid\n    x7 = toobject(x6, I)\n    \n    # Get the color of the corners (background color)\n    x8 = color(x7)\n    \n    # Get all indices of the input grid\n    x9 = asindices(I)\n    \n    # Get all indices of the background color in the input grid\n    x10 = ofcolor(I, x8)\n    \n    # Get the indices of the inner rectangle\n    x11 = toindices(x4)\n    \n    # Combine the background indices and inner rectangle indices\n    x12 = combine(x10, x11)\n    \n    # Get all indices that are not background or inner rectangle (colored cells on the border)\n    x13 = difference(x9, x12)\n    \n    # Create an object from the colored cells on the border\n    x14 = toobject(x13, I)\n    \n    # Create a set of single-cell objects for each colored cell on the border\n    x15 = apply(initset, x14)\n    \n    # Create a function that finds the direction to move towards the inner rectangle\n    x16 = rbind(gravitate, x4)\n    \n    # Modify the gravitation function to stop one step before reaching the destination\n    x17 = compose(crement, x16)\n    \n    # Create a function that shifts an object based on the modified gravitation\n    x18 = fork(shift, identity, x17)\n    \n    # Apply the shift function to all colored cells, moving them towards the inner rectangle\n    x19 = mapply(x18, x15)\n    \n    # Paint the shifted colored cells onto the input grid, creating the output grid\n    x20 = paint(I, x19)\n    \n    # Return the modified grid as the output\n    return x20\n"
  },
  "1f85a75f": {
    "original": "def verify_1f85a75f(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = lbind(sfilter, x2)\n    x4 = lbind(matcher, identity)\n    x5 = chain(size, x3, x4)\n    x6 = matcher(x5, ONE)\n    x7 = sfilter(x2, x6)\n    x8 = lbind(colorcount, I)\n    x9 = argmax(x7, x8)\n    x10 = matcher(color, x9)\n    x11 = extract(x0, x10)\n    x12 = subgrid(x11, I)\n    return x12\n\n",
    "annotated": "def verify_1f85a75f(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing diagonal connections and excluding the background\n    x0 = objects(I, T, F, T)\n    \n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    \n    # Get the color of each object\n    x2 = apply(color, x1)\n    \n    # Create a function that filters a container based on the colors in x2\n    x3 = lbind(sfilter, x2)\n    \n    # Create a function that matches based on identity\n    x4 = lbind(matcher, identity)\n    \n    # Create a function that counts the number of objects of each color\n    x5 = chain(size, x3, x4)\n    \n    # Create a function that checks if there's exactly one object of a color\n    x6 = matcher(x5, ONE)\n    \n    # Filter the colors to find those with exactly one object\n    x7 = sfilter(x2, x6)\n    \n    # Create a function that counts the occurrences of each color in the input grid\n    x8 = lbind(colorcount, I)\n    \n    # Find the color with the most occurrences among those with exactly one object\n    x9 = argmax(x7, x8)\n    \n    # Create a function that matches objects with the color found in x9\n    x10 = matcher(color, x9)\n    \n    # Extract the object with the most common color (excluding background)\n    x11 = extract(x0, x10)\n    \n    # Get the subgrid containing only the extracted object\n    x12 = subgrid(x11, I)\n    \n    # Return the subgrid, which is the normalized object without noise\n    return x12\n"
  },
  "1f876c06": {
    "original": "def verify_1f876c06(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = compose(last, first)\n    x2 = power(last, TWO)\n    x3 = fork(connect, x1, x2)\n    x4 = fork(recolor, color, x3)\n    x5 = mapply(x4, x0)\n    x6 = paint(I, x5)\n    return x6\n\n",
    "annotated": "def verify_1f876c06(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that gets the last element of the first element\n    # This will be used to get one endpoint of a line\n    x1 = compose(last, first)\n    \n    # Create a function that gets the last element twice\n    # This will be used to get the other endpoint of a line\n    x2 = power(last, TWO)\n    \n    # Create a function that connects two points\n    # It uses x1 and x2 to get the endpoints of a line\n    x3 = fork(connect, x1, x2)\n    \n    # Create a function that recolors a connected line\n    # It uses the color of the original object and the connected line from x3\n    x4 = fork(recolor, color, x3)\n    \n    # Apply the recoloring function to all partitioned objects\n    # This creates full lines between the endpoints\n    x5 = mapply(x4, x0)\n    \n    # Paint the full lines onto the original input grid\n    # This creates the output grid with completed lines\n    x6 = paint(I, x5)\n    \n    # Return the completed grid\n    return x6\n"
  },
  "1fad071e": {
    "original": "def verify_1fad071e(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = colorfilter(x0, ONE)\n    x2 = sizefilter(x1, FOUR)\n    x3 = fork(equality, height, width)\n    x4 = sfilter(x2, x3)\n    x5 = size(x4)\n    x6 = subtract(FIVE, x5)\n    x7 = astuple(ONE, x5)\n    x8 = canvas(ONE, x7)\n    x9 = astuple(ONE, x6)\n    x10 = mostcolor(I)\n    x11 = canvas(x10, x9)\n    x12 = hconcat(x8, x11)\n    return x12\n\n",
    "annotated": "def verify_1fad071e(I: Grid) -> Grid:\n    # Get all objects from the input grid, considering diagonally adjacent cells as part of the same object\n    x0 = objects(I, T, F, T)\n    \n    # Filter objects to keep only those with color 1 (blue)\n    x1 = colorfilter(x0, ONE)\n    \n    # Filter objects to keep only those with size 4 (2x2 squares)\n    x2 = sizefilter(x1, FOUR)\n    \n    # Create a function that checks if an object's height equals its width\n    x3 = fork(equality, height, width)\n    \n    # Filter objects to keep only those that are square (height == width)\n    x4 = sfilter(x2, x3)\n    \n    # Count the number of 2x2 blue squares\n    x5 = size(x4)\n    \n    # Calculate how many background color squares are needed to make a total of 5\n    x6 = subtract(FIVE, x5)\n    \n    # Create a tuple (1, number_of_blue_squares) for canvas dimensions\n    x7 = astuple(ONE, x5)\n    \n    # Create a 1xN canvas filled with blue (1), where N is the number of blue squares\n    x8 = canvas(ONE, x7)\n    \n    # Create a tuple (1, number_of_background_squares) for canvas dimensions\n    x9 = astuple(ONE, x6)\n    \n    # Get the most common color from the input grid (background color)\n    x10 = mostcolor(I)\n    \n    # Create a 1xM canvas filled with the background color, where M is the number of background squares\n    x11 = canvas(x10, x9)\n    \n    # Concatenate the blue canvas and background canvas horizontally\n    x12 = hconcat(x8, x11)\n    \n    # Return the final 1x5 output grid\n    return x12\n"
  },
  "2013d3e2": {
    "original": "def verify_2013d3e2(I: Grid) -> Grid:\n    x0 = lbind(apply, last)\n    x1 = compose(positive, first)\n    x2 = lbind(interval, ZERO)\n    x3 = rbind(x2, ONE)\n    x4 = rbind(sfilter, x1)\n    x5 = compose(x3, size)\n    x6 = fork(pair, x5, identity)\n    x7 = chain(x0, x4, x6)\n    x8 = rbind(branch, identity)\n    x9 = rbind(x8, x7)\n    x10 = chain(size, dedupe, first)\n    x11 = lbind(equality, ONE)\n    x12 = chain(x9, x11, x10)\n    x13 = compose(initset, x12)\n    x14 = fork(rapply, x13, identity)\n    x15 = compose(first, x14)\n    x16 = rbind(branch, identity)\n    x17 = rbind(x16, x15)\n    x18 = chain(x17, positive, size)\n    x19 = compose(initset, x18)\n    x20 = fork(rapply, x19, identity)\n    x21 = compose(first, x20)\n    x22 = multiply(TEN, THREE)\n    x23 = power(x21, x22)\n    x24 = compose(rot90, x23)\n    x25 = power(x24, FOUR)\n    x26 = x25(I)\n    x27 = lefthalf(x26)\n    x28 = tophalf(x27)\n    return x28\n\n",
    "annotated": "def verify_2013d3e2(I: Grid) -> Grid:\n    # Create a function that applies the 'last' function to the result of 'apply'\n    x0 = lbind(apply, last)\n    \n    # Create a function that checks if the first element of a tuple is positive\n    x1 = compose(positive, first)\n    \n    # Create a function that generates an interval starting from 0\n    x2 = lbind(interval, ZERO)\n    \n    # Modify x2 to always use 1 as the step size\n    x3 = rbind(x2, ONE)\n    \n    # Create a function that filters elements based on x1 (positive first element)\n    x4 = rbind(sfilter, x1)\n    \n    # Create a function that generates an interval from 0 to the size of the input\n    x5 = compose(x3, size)\n    \n    # Create a function that pairs the result of x5 with the identity of the input\n    x6 = fork(pair, x5, identity)\n    \n    # Chain together x0, x4, and x6\n    x7 = chain(x0, x4, x6)\n    \n    # Create a function that branches based on the identity of the input\n    x8 = rbind(branch, identity)\n    \n    # Modify x8 to use x7 as the else condition\n    x9 = rbind(x8, x7)\n    \n    # Create a function that gets the size of unique first elements\n    x10 = chain(size, dedupe, first)\n    \n    # Create a function that checks if a value equals 1\n    x11 = lbind(equality, ONE)\n    \n    # Chain together x9, x11, and x10\n    x12 = chain(x9, x11, x10)\n    \n    # Create a function that initializes a set with the result of x12\n    x13 = compose(initset, x12)\n    \n    # Create a function that applies x13 to the identity of the input\n    x14 = fork(rapply, x13, identity)\n    \n    # Create a function that gets the first element of the result of x14\n    x15 = compose(first, x14)\n    \n    # Create a function that branches based on the identity of the input\n    x16 = rbind(branch, identity)\n    \n    # Modify x16 to use x15 as the else condition\n    x17 = rbind(x16, x15)\n    \n    # Chain together x17, positive, and size\n    x18 = chain(x17, positive, size)\n    \n    # Create a function that initializes a set with the result of x18\n    x19 = compose(initset, x18)\n    \n    # Create a function that applies x19 to the identity of the input\n    x20 = fork(rapply, x19, identity)\n    \n    # Create a function that gets the first element of the result of x20\n    x21 = compose(first, x20)\n    \n    # Calculate 30 (10 * 3)\n    x22 = multiply(TEN, THREE)\n    \n    # Create a function that applies x21 30 times\n    x23 = power(x21, x22)\n    \n    # Create a function that rotates the result of x23 by 90 degrees\n    x24 = compose(rot90, x23)\n    \n    # Create a function that applies x24 4 times (full 360-degree rotation)\n    x25 = power(x24, FOUR)\n    \n    # Apply x25 to the input grid I\n    x26 = x25(I)\n    \n    # Get the left half of the result\n    x27 = lefthalf(x26)\n    \n    # Get the top half of the left half, which is the final output\n    x28 = tophalf(x27)\n    \n    return x28\n"
  },
  "2204b7a8": {
    "original": "def verify_2204b7a8(I: Grid) -> Grid:\n    x0 = first(I)\n    x1 = dedupe(x0)\n    x2 = size(x1)\n    x3 = equality(x2, ONE)\n    x4 = flip(x3)\n    x5 = branch(x4, lefthalf, tophalf)\n    x6 = branch(x4, righthalf, bottomhalf)\n    x7 = branch(x4, hconcat, vconcat)\n    x8 = x5(I)\n    x9 = x6(I)\n    x10 = index(x8, ORIGIN)\n    x11 = shape(x9)\n    x12 = decrement(x11)\n    x13 = index(x9, x12)\n    x14 = mostcolor(I)\n    x15 = mostcolor(I)\n    x16 = palette(I)\n    x17 = remove(x10, x16)\n    x18 = remove(x13, x17)\n    x19 = remove(x15, x18)\n    x20 = first(x19)\n    x21 = replace(x8, x20, x10)\n    x22 = branch(x4, dmirror, identity)\n    x23 = branch(x4, height, width)\n    x24 = x23(I)\n    x25 = astuple(ONE, x24)\n    x26 = canvas(x14, x25)\n    x27 = x22(x26)\n    x28 = replace(x9, x20, x13)\n    x29 = x7(x21, x27)\n    x30 = branch(x4, width, height)\n    x31 = x30(I)\n    x32 = even(x31)\n    x33 = branch(x32, x21, x29)\n    x34 = x7(x33, x28)\n    return x34\n\n",
    "annotated": "def verify_2204b7a8(I: Grid) -> Grid:\n    x0 = first(I)  # Get the first row of the input grid\n    x1 = dedupe(x0)  # Remove duplicates from the first row\n    x2 = size(x1)  # Count the number of unique elements in the first row\n    x3 = equality(x2, ONE)  # Check if there's only one unique element in the first row\n    x4 = flip(x3)  # Invert the boolean result (True if more than one unique element)\n    x5 = branch(x4, lefthalf, tophalf)  # Choose lefthalf if x4 is True, else tophalf\n    x6 = branch(x4, righthalf, bottomhalf)  # Choose righthalf if x4 is True, else bottomhalf\n    x7 = branch(x4, hconcat, vconcat)  # Choose horizontal concatenation if x4 is True, else vertical\n    x8 = x5(I)  # Apply the chosen split function (left or top half) to the input grid\n    x9 = x6(I)  # Apply the other chosen split function (right or bottom half) to the input grid\n    x10 = index(x8, ORIGIN)  # Get the color of the top-left cell of the left/top half\n    x11 = shape(x9)  # Get the dimensions of the right/bottom half\n    x12 = decrement(x11)  # Decrease each dimension by 1 to get the bottom-right corner index\n    x13 = index(x9, x12)  # Get the color of the bottom-right cell of the right/bottom half\n    x14 = mostcolor(I)  # Get the most common color in the input grid (background color)\n    x15 = mostcolor(I)  # Get the most common color again (redundant, same as x14)\n    x16 = palette(I)  # Get all unique colors used in the input grid\n    x17 = remove(x10, x16)  # Remove the left/top border color from the palette\n    x18 = remove(x13, x17)  # Remove the right/bottom border color from the remaining colors\n    x19 = remove(x15, x18)  # Remove the background color from the remaining colors\n    x20 = first(x19)  # Get the remaining color (the center cell color)\n    x21 = replace(x8, x20, x10)  # Replace center color with left/top border color in left/top half\n    x22 = branch(x4, dmirror, identity)  # Choose diagonal mirror if x4 is True, else identity function\n    x23 = branch(x4, height, width)  # Choose height if x4 is True, else width\n    x24 = x23(I)  # Get the chosen dimension (height or width) of the input grid\n    x25 = astuple(ONE, x24)  # Create a tuple (1, chosen_dimension)\n    x26 = canvas(x14, x25)  # Create a 1xchosen_dimension canvas with the background color\n    x27 = x22(x26)  # Apply diagonal mirror or identity to the canvas\n    x28 = replace(x9, x20, x13)  # Replace center color with right/bottom border color in right/bottom half\n    x29 = x7(x21, x27)  # Concatenate modified left/top half with the canvas\n    x30 = branch(x4, width, height)  # Choose width if x4 is True, else height\n    x31 = x30(I)  # Get the chosen dimension (width or height) of the input grid\n    x32 = even(x31)  # Check if the chosen dimension is even\n    x33 = branch(x32, x21, x29)  # If even, use modified left/top half; if odd, use concatenated result\n    x34 = x7(x33, x28)  # Concatenate the chosen half with the modified right/bottom half\n    return x34  # Return the final transformed grid\n"
  },
  "22168020": {
    "original": "def verify_22168020(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = mostcolor(I)\n    x2 = remove(x1, x0)\n    x3 = lbind(ofcolor, I)\n    x4 = lbind(prapply, connect)\n    x5 = fork(x4, x3, x3)\n    x6 = compose(merge, x5)\n    x7 = fork(recolor, identity, x6)\n    x8 = mapply(x7, x2)\n    x9 = paint(I, x8)\n    return x9\n\n",
    "annotated": "def verify_22168020(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Remove the background color from the set of colors, leaving only the shape colors\n    x2 = remove(x1, x0)\n    \n    # Create a function that finds all cells of a specific color in the input grid\n    x3 = lbind(ofcolor, I)\n    \n    # Create a function that applies the 'connect' function to pairs of points\n    x4 = lbind(prapply, connect)\n    \n    # Create a function that finds cells of a color and connects them\n    x5 = fork(x4, x3, x3)\n    \n    # Create a function that merges all connected lines for a color\n    x6 = compose(merge, x5)\n    \n    # Create a function that recolors the merged lines with their original color\n    x7 = fork(recolor, identity, x6)\n    \n    # Apply the recoloring function to all shape colors, creating filled shapes\n    x8 = mapply(x7, x2)\n    \n    # Paint the filled shapes onto the input grid, creating the output grid\n    x9 = paint(I, x8)\n    \n    # Return the output grid with filled shapes\n    return x9\n"
  },
  "22233c11": {
    "original": "def verify_22233c11(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = rbind(upscale, TWO)\n    x2 = chain(invert, halve, shape)\n    x3 = fork(combine, hfrontier, vfrontier)\n    x4 = compose(x1, vmirror)\n    x5 = fork(shift, x4, x2)\n    x6 = compose(toindices, x5)\n    x7 = lbind(mapply, x3)\n    x8 = compose(x7, toindices)\n    x9 = fork(difference, x6, x8)\n    x10 = mapply(x9, x0)\n    x11 = fill(I, EIGHT, x10)\n    return x11\n\n",
    "annotated": "def verify_22233c11(I: Grid) -> Grid:\n    # Identify all objects in the input grid, including background and diagonally connected cells\n    x0 = objects(I, T, T, T)\n    \n    # Create a function that upscales by a factor of 2\n    x1 = rbind(upscale, TWO)\n    \n    # Create a function that inverts, halves, and gets the shape of an object\n    x2 = chain(invert, halve, shape)\n    \n    # Create a function that combines horizontal and vertical frontiers\n    x3 = fork(combine, hfrontier, vfrontier)\n    \n    # Create a function that vertically mirrors and then upscales by 2\n    x4 = compose(x1, vmirror)\n    \n    # Create a function that shifts an object based on its mirrored, upscaled version and half its inverted shape\n    x5 = fork(shift, x4, x2)\n    \n    # Create a function that gets the indices of the shifted, mirrored, and upscaled object\n    x6 = compose(toindices, x5)\n    \n    # Create a function that applies the frontier combination to a set of indices\n    x7 = lbind(mapply, x3)\n    \n    # Create a function that gets the indices of the frontiers\n    x8 = compose(x7, toindices)\n    \n    # Create a function that finds the difference between the expanded object and its frontiers\n    x9 = fork(difference, x6, x8)\n    \n    # Apply the difference function to all objects in the input grid\n    # This effectively finds the outline positions for each object\n    x10 = mapply(x9, x0)\n    \n    # Fill the input grid with color 8 (outline color) at the calculated outline positions\n    # This adds the outline to each object in the grid\n    x11 = fill(I, EIGHT, x10)\n    \n    # Return the modified grid with outlines added to all objects\n    return x11\n"
  },
  "2281f1f4": {
    "original": "def verify_2281f1f4(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = apply(first, x1)\n    x3 = apply(last, x1)\n    x4 = product(x2, x3)\n    x5 = difference(x4, x1)\n    x6 = fill(I, TWO, x5)\n    x7 = lbind(fork, either)\n    x8 = lbind(matcher, first)\n    x9 = compose(x8, first)\n    x10 = lbind(matcher, last)\n    x11 = compose(x10, last)\n    x12 = fork(x7, x9, x11)\n    x13 = lbind(sfilter, x1)\n    x14 = chain(size, x13, x12)\n    x15 = asindices(I)\n    x16 = corners(x15)\n    x17 = argmax(x16, x14)\n    x18 = mostcolor(I)\n    x19 = initset(x17)\n    x20 = fill(x6, x18, x19)\n    return x20\n\n",
    "annotated": "def verify_2281f1f4(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    x0 = leastcolor(I)\n    \n    # Get all cells with the least common color (marker color)\n    x1 = ofcolor(I, x0)\n    \n    # Get the first (top) row of marker positions\n    x2 = apply(first, x1)\n    \n    # Get the last (right) column of marker positions\n    x3 = apply(last, x1)\n    \n    # Create all possible intersection points between top and right markers\n    x4 = product(x2, x3)\n    \n    # Find intersection points that don't already have markers\n    x5 = difference(x4, x1)\n    \n    # Fill these intersection points with color 2 (creating the output grid)\n    x6 = fill(I, TWO, x5)\n    \n    # Prepare a function to check if a point is either in the first row or last column\n    x7 = lbind(fork, either)\n    \n    # Create a function to check if a point is in the first row\n    x8 = lbind(matcher, first)\n    x9 = compose(x8, first)\n    \n    # Create a function to check if a point is in the last column\n    x10 = lbind(matcher, last)\n    x11 = compose(x10, last)\n    \n    # Combine the row and column checking functions\n    x12 = fork(x7, x9, x11)\n    \n    # Prepare a function to filter marker positions\n    x13 = lbind(sfilter, x1)\n    \n    # Create a function to count markers in the same row or column as a given point\n    x14 = chain(size, x13, x12)\n    \n    # Get all indices of the input grid\n    x15 = asindices(I)\n    \n    # Find the corner positions of the grid\n    x16 = corners(x15)\n    \n    # Find the corner with the most markers in its row and column\n    x17 = argmax(x16, x14)\n    \n    # Get the most common color in the input grid (background color)\n    x18 = mostcolor(I)\n    \n    # Create a set with only the selected corner\n    x19 = initset(x17)\n    \n    # Fill the selected corner with the background color (removing the marker)\n    x20 = fill(x6, x18, x19)\n    \n    # Return the final output grid\n    return x20\n"
  },
  "228f6490": {
    "original": "def verify_228f6490(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, T, F)\n    x2 = colorfilter(x1, x0)\n    x3 = compose(normalize, toindices)\n    x4 = difference(x1, x2)\n    x5 = rbind(bordering, I)\n    x6 = compose(flip, x5)\n    x7 = sfilter(x2, x6)\n    x8 = rbind(toobject, I)\n    x9 = lbind(mapply, neighbors)\n    x10 = compose(x9, toindices)\n    x11 = fork(difference, x10, identity)\n    x12 = chain(mostcolor, x8, x11)\n    x13 = totuple(x7)\n    x14 = apply(x12, x13)\n    x15 = mostcommon(x14)\n    x16 = matcher(x12, x15)\n    x17 = sfilter(x7, x16)\n    x18 = lbind(argmax, x4)\n    x19 = lbind(matcher, x3)\n    x20 = chain(x18, x19, x3)\n    x21 = compose(color, x20)\n    x22 = fork(recolor, x21, identity)\n    x23 = mapply(x20, x17)\n    x24 = cover(I, x23)\n    x25 = mapply(x22, x17)\n    x26 = paint(x24, x25)\n    return x26\n\n",
    "annotated": "def verify_228f6490(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Identify all objects in the grid, including diagonally connected and multi-colored objects\n    x1 = objects(I, T, T, F)\n    \n    # Filter objects that have the background color\n    x2 = colorfilter(x1, x0)\n    \n    # Create a function that normalizes the indices of an object (shifts to origin)\n    x3 = compose(normalize, toindices)\n    \n    # Get all non-background objects\n    x4 = difference(x1, x2)\n    \n    # Create a function that checks if an object is bordering the grid\n    x5 = rbind(bordering, I)\n    \n    # Invert the bordering function (True if not bordering)\n    x6 = compose(flip, x5)\n    \n    # Filter background-colored objects that are not bordering the grid (potential outer squares)\n    x7 = sfilter(x2, x6)\n    \n    # Create a function that converts indices to an object on the input grid\n    x8 = rbind(toobject, I)\n    \n    # Create a function that finds neighboring cells of an object\n    x9 = lbind(mapply, neighbors)\n    \n    # Create a function that finds indices of neighboring cells\n    x10 = compose(x9, toindices)\n    \n    # Create a function that finds cells inside an object (by subtracting neighbors from the object)\n    x11 = fork(difference, x10, identity)\n    \n    # Create a function that finds the most common color inside an object\n    x12 = chain(mostcolor, x8, x11)\n    \n    # Convert filtered background objects to a tuple\n    x13 = totuple(x7)\n    \n    # Find the most common color inside each potential outer square\n    x14 = apply(x12, x13)\n    \n    # Determine the most common inner color among all potential outer squares\n    x15 = mostcommon(x14)\n    \n    # Create a function that checks if an object has the most common inner color\n    x16 = matcher(x12, x15)\n    \n    # Filter outer squares that have the most common inner color\n    x17 = sfilter(x7, x16)\n    \n    # Create a function that finds the largest non-background object with a specific normalized shape\n    x18 = lbind(argmax, x4)\n    x19 = lbind(matcher, x3)\n    x20 = chain(x18, x19, x3)\n    \n    # Create a function that determines the color of the largest matching non-background object\n    x21 = compose(color, x20)\n    \n    # Create a function that recolors an object with the color of its matching inner object\n    x22 = fork(recolor, x21, identity)\n    \n    # Find the largest matching non-background object for each outer square\n    x23 = mapply(x20, x17)\n    \n    # Remove all identified outer squares from the input grid\n    x24 = cover(I, x23)\n    \n    # Recolor each outer square with its matching inner object color\n    x25 = mapply(x22, x17)\n    \n    # Paint the recolored outer squares onto the modified input grid\n    x26 = paint(x24, x25)\n    \n    # Return the final output grid with filled-in squares\n    return x26\n"
  },
  "22eb0ac0": {
    "original": "def verify_22eb0ac0(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = asobject(I)\n    x2 = matcher(first, x0)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x1, x3)\n    x5 = apply(initset, x4)\n    x6 = product(x5, x5)\n    x7 = compose(color, first)\n    x8 = compose(color, last)\n    x9 = fork(equality, x7, x8)\n    x10 = sfilter(x6, x9)\n    x11 = compose(leftmost, first)\n    x12 = compose(leftmost, last)\n    x13 = fork(equality, x11, x12)\n    x14 = compose(uppermost, first)\n    x15 = compose(uppermost, last)\n    x16 = fork(equality, x14, x15)\n    x17 = fork(either, x13, x16)\n    x18 = sfilter(x10, x17)\n    x19 = compose(color, first)\n    x20 = compose(center, first)\n    x21 = compose(center, last)\n    x22 = fork(connect, x20, x21)\n    x23 = fork(recolor, x19, x22)\n    x24 = height(I)\n    x25 = width(I)\n    x26 = matcher(last, ZERO)\n    x27 = decrement(x25)\n    x28 = matcher(last, x27)\n    x29 = fork(either, x26, x28)\n    x30 = matcher(first, ZERO)\n    x31 = decrement(x24)\n    x32 = matcher(first, x31)\n    x33 = fork(either, x30, x32)\n    x34 = toindices(x4)\n    x35 = sfilter(x34, x29)\n    x36 = equality(x34, x35)\n    x37 = mapply(x23, x18)\n    x38 = paint(I, x37)\n    x39 = branch(x36, x29, x33)\n    x40 = asindices(I)\n    x41 = sfilter(x40, x39)\n    x42 = toobject(x41, I)\n    x43 = paint(x38, x42)\n    return x43\n\n",
    "annotated": "def verify_22eb0ac0(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Convert the input grid to an object representation\n    x1 = asobject(I)\n    \n    # Create a function that checks if the first element of a tuple is equal to the background color\n    x2 = matcher(first, x0)\n    \n    # Create a function that checks if the first element of a tuple is NOT equal to the background color\n    x3 = compose(flip, x2)\n    \n    # Filter the object representation to keep only non-background colored cells\n    x4 = sfilter(x1, x3)\n    \n    # Create a set of single-element sets, each containing a non-background colored cell\n    x5 = apply(initset, x4)\n    \n    # Create all possible pairs of non-background colored cells\n    x6 = product(x5, x5)\n    \n    # Create a function that gets the color of the first element in a pair\n    x7 = compose(color, first)\n    \n    # Create a function that gets the color of the second element in a pair\n    x8 = compose(color, last)\n    \n    # Create a function that checks if the colors of both elements in a pair are equal\n    x9 = fork(equality, x7, x8)\n    \n    # Filter pairs to keep only those with matching colors\n    x10 = sfilter(x6, x9)\n    \n    # Create a function that gets the leftmost coordinate of the first element in a pair\n    x11 = compose(leftmost, first)\n    \n    # Create a function that gets the leftmost coordinate of the second element in a pair\n    x12 = compose(leftmost, last)\n    \n    # Create a function that checks if the leftmost coordinates of both elements in a pair are equal\n    x13 = fork(equality, x11, x12)\n    \n    # Create a function that gets the uppermost coordinate of the first element in a pair\n    x14 = compose(uppermost, first)\n    \n    # Create a function that gets the uppermost coordinate of the second element in a pair\n    x15 = compose(uppermost, last)\n    \n    # Create a function that checks if the uppermost coordinates of both elements in a pair are equal\n    x16 = fork(equality, x14, x15)\n    \n    # Create a function that checks if either the leftmost or uppermost coordinates of both elements in a pair are equal\n    x17 = fork(either, x13, x16)\n    \n    # Filter pairs to keep only those with matching leftmost or uppermost coordinates (i.e., on the same row or column)\n    x18 = sfilter(x10, x17)\n    \n    # Create a function that gets the color of the first element in a pair\n    x19 = compose(color, first)\n    \n    # Create a function that gets the center coordinate of the first element in a pair\n    x20 = compose(center, first)\n    \n    # Create a function that gets the center coordinate of the second element in a pair\n    x21 = compose(center, last)\n    \n    # Create a function that connects the centers of both elements in a pair\n    x22 = fork(connect, x20, x21)\n    \n    # Create a function that recolors the connected line with the color of the first element in a pair\n    x23 = fork(recolor, x19, x22)\n    \n    # Get the height of the input grid\n    x24 = height(I)\n    \n    # Get the width of the input grid\n    x25 = width(I)\n    \n    # Create a function that checks if the last coordinate is 0 (leftmost column)\n    x26 = matcher(last, ZERO)\n    \n    # Get the index of the rightmost column\n    x27 = decrement(x25)\n    \n    # Create a function that checks if the last coordinate is the rightmost column\n    x28 = matcher(last, x27)\n    \n    # Create a function that checks if a coordinate is on either the leftmost or rightmost column\n    x29 = fork(either, x26, x28)\n    \n    # Create a function that checks if the first coordinate is 0 (topmost row)\n    x30 = matcher(first, ZERO)\n    \n    # Get the index of the bottommost row\n    x31 = decrement(x24)\n    \n    # Create a function that checks if the first coordinate is the bottommost row\n    x32 = matcher(first, x31)\n    \n    # Create a function that checks if a coordinate is on either the topmost or bottommost row\n    x33 = fork(either, x30, x32)\n    \n    # Get the indices of all non-background colored cells\n    x34 = toindices(x4)\n    \n    # Filter the indices to keep only those on the leftmost or rightmost column\n    x35 = sfilter(x34, x29)\n    \n    # Check if all non-background colored cells are on the leftmost or rightmost column\n    x36 = equality(x34, x35)\n    \n    # Apply the line-drawing function to all pairs of cells with matching colors and on the same row or column\n    x37 = mapply(x23, x18)\n    \n    # Paint the lines on the input grid\n    x38 = paint(I, x37)\n    \n    # Choose the appropriate filter function based on whether all non-background cells are on the edges\n    x39 = branch(x36, x29, x33)\n    \n    # Get all indices of the input grid\n    x40 = asindices(I)\n    \n    # Filter the indices to keep only those on the edges (either columns or rows, depending on the previous check)\n    x41 = sfilter(x40, x39)\n    \n    # Convert the filtered indices back to an object representation\n    x42 = toobject(x41, I)\n    \n    # Paint the edge cells on the grid with lines, preserving their original colors\n    x43 = paint(x38, x42)\n    \n    # Return the final transformed grid\n    return x43\n"
  },
  "234bbc79": {
    "original": "def verify_234bbc79(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = order(x0, leftmost)\n    x2 = astuple(ONE, TWO)\n    x3 = rbind(contained, x2)\n    x4 = lbind(compose, x3)\n    x5 = lbind(rbind, colorcount)\n    x6 = compose(x4, x5)\n    x7 = lbind(sfilter, x0)\n    x8 = chain(size, x7, x6)\n    x9 = size(x0)\n    x10 = matcher(x8, x9)\n    x11 = palette(I)\n    x12 = sfilter(x11, x10)\n    x13 = lbind(colorcount, I)\n    x14 = argmin(x12, x13)\n    x15 = matcher(first, x14)\n    x16 = rbind(extract, x15)\n    x17 = compose(x16, first)\n    x18 = fork(remove, x17, first)\n    x19 = rbind(compose, initset)\n    x20 = lbind(rbind, manhattan)\n    x21 = compose(initset, x17)\n    x22 = chain(x19, x20, x21)\n    x23 = fork(argmin, x18, x22)\n    x24 = compose(last, x17)\n    x25 = compose(first, x23)\n    x26 = fork(astuple, x25, x24)\n    x27 = fork(insert, x26, x18)\n    x28 = compose(last, last)\n    x29 = rbind(argmin, x28)\n    x30 = rbind(sfilter, x15)\n    x31 = compose(first, last)\n    x32 = chain(x29, x30, x31)\n    x33 = compose(flip, x15)\n    x34 = rbind(sfilter, x33)\n    x35 = compose(first, last)\n    x36 = fork(remove, x32, x35)\n    x37 = compose(x34, x36)\n    x38 = rbind(compose, initset)\n    x39 = lbind(rbind, manhattan)\n    x40 = compose(initset, x32)\n    x41 = chain(x38, x39, x40)\n    x42 = fork(argmin, x37, x41)\n    x43 = compose(first, x42)\n    x44 = compose(last, x32)\n    x45 = fork(astuple, x43, x44)\n    x46 = compose(first, last)\n    x47 = fork(remove, x32, x46)\n    x48 = fork(insert, x45, x47)\n    x49 = rbind(shift, RIGHT)\n    x50 = compose(last, x32)\n    x51 = fork(subtract, x24, x50)\n    x52 = fork(shift, x48, x51)\n    x53 = compose(x49, x52)\n    x54 = fork(combine, x27, x53)\n    x55 = compose(first, last)\n    x56 = fork(remove, x55, last)\n    x57 = fork(astuple, x54, x56)\n    x58 = size(x0)\n    x59 = decrement(x58)\n    x60 = power(x57, x59)\n    x61 = first(x1)\n    x62 = remove(x61, x1)\n    x63 = astuple(x61, x62)\n    x64 = x60(x63)\n    x65 = first(x64)\n    x66 = merge(x0)\n    x67 = cover(I, x66)\n    x68 = paint(x67, x65)\n    x69 = height(I)\n    x70 = width(x65)\n    x71 = (x69, x70)\n    x72 = crop(x68, ORIGIN, x71)\n    x73 = ofcolor(x72, x14)\n    x74 = mostcolor(I)\n    x75 = palette(x72)\n    x76 = contained(x14, x75)\n    x77 = matcher(first, x74)\n    x78 = compose(flip, x77)\n    x79 = rbind(sfilter, x78)\n    x80 = mapply(dneighbors, x73)\n    x81 = lbind(toobject, x80)\n    x82 = compose(x79, x81)\n    x83 = rbind(recolor, x73)\n    x84 = chain(x83, mostcolor, x82)\n    x85 = fork(paint, identity, x84)\n    x86 = branch(x76, x85, identity)\n    x87 = x86(x72)\n    return x87\n\n",
    "annotated": "def verify_234bbc79(I: Grid) -> Grid:\n    # Extract all objects from the input grid, ignoring background\n    x0 = objects(I, F, F, T)\n    # Order the objects based on their leftmost position\n    x1 = order(x0, leftmost)\n    # Create a tuple (1, 2)\n    x2 = astuple(ONE, TWO)\n    # Create a function that checks if a value is in (1, 2)\n    x3 = rbind(contained, x2)\n    # Compose the above function with another (to be defined later)\n    x4 = lbind(compose, x3)\n    # Prepare a function to count colors in an object\n    x5 = lbind(rbind, colorcount)\n    # Compose the color counting function with the (1, 2) checking function\n    x6 = compose(x4, x5)\n    # Prepare a function to filter objects\n    x7 = lbind(sfilter, x0)\n    # Chain functions to count objects with 1 or 2 colors\n    x8 = chain(size, x7, x6)\n    # Count total number of objects\n    x9 = size(x0)\n    # Create a function to check if all objects have 1 or 2 colors\n    x10 = matcher(x8, x9)\n    # Get the palette of colors used in the input grid\n    x11 = palette(I)\n    # Filter the palette to colors used in objects with 1 or 2 colors\n    x12 = sfilter(x11, x10)\n    # Prepare a function to count occurrences of a color in the input grid\n    x13 = lbind(colorcount, I)\n    # Find the least common color among those used in 1-2 color objects\n    x14 = argmin(x12, x13)\n    # Create a function to check if an object's first color matches the least common color\n    x15 = matcher(first, x14)\n    # Prepare a function to extract objects with the least common color\n    x16 = rbind(extract, x15)\n    # Compose functions to get the first object with the least common color\n    x17 = compose(x16, first)\n    # Create a function to remove the first object with the least common color\n    x18 = fork(remove, x17, first)\n    # Prepare functions for distance calculations\n    x19 = rbind(compose, initset)\n    x20 = lbind(rbind, manhattan)\n    x21 = compose(initset, x17)\n    x22 = chain(x19, x20, x21)\n    # Find the object closest to the first object with the least common color\n    x23 = fork(argmin, x18, x22)\n    # Get the last cell of the first object with the least common color\n    x24 = compose(last, x17)\n    # Get the first cell of the closest object\n    x25 = compose(first, x23)\n    # Create a tuple of the end of the first object and start of the second\n    x26 = fork(astuple, x25, x24)\n    # Insert this tuple into the set of objects (connecting them)\n    x27 = fork(insert, x26, x18)\n    # Prepare functions to find the rightmost object\n    x28 = compose(last, last)\n    x29 = rbind(argmin, x28)\n    x30 = rbind(sfilter, x15)\n    x31 = compose(first, last)\n    x32 = chain(x29, x30, x31)\n    # Prepare functions to find objects not of the least common color\n    x33 = compose(flip, x15)\n    x34 = rbind(sfilter, x33)\n    x35 = compose(first, last)\n    x36 = fork(remove, x32, x35)\n    x37 = compose(x34, x36)\n    # Prepare functions for more distance calculations\n    x38 = rbind(compose, initset)\n    x39 = lbind(rbind, manhattan)\n    x40 = compose(initset, x32)\n    x41 = chain(x38, x39, x40)\n    # Find the object closest to the rightmost object\n    x42 = fork(argmin, x37, x41)\n    # Get the first cell of this closest object\n    x43 = compose(first, x42)\n    # Get the last cell of the rightmost object\n    x44 = compose(last, x32)\n    # Create a tuple connecting these objects\n    x45 = fork(astuple, x43, x44)\n    x46 = compose(first, last)\n    x47 = fork(remove, x32, x46)\n    # Insert this new connection\n    x48 = fork(insert, x45, x47)\n    # Prepare functions to shift objects\n    x49 = rbind(shift, RIGHT)\n    x50 = compose(last, x32)\n    x51 = fork(subtract, x24, x50)\n    x52 = fork(shift, x48, x51)\n    x53 = compose(x49, x52)\n    # Combine the connected objects\n    x54 = fork(combine, x27, x53)\n    x55 = compose(first, last)\n    x56 = fork(remove, x55, last)\n    # Create a function to connect and combine objects\n    x57 = fork(astuple, x54, x56)\n    # Count the number of objects minus one\n    x58 = size(x0)\n    x59 = decrement(x58)\n    # Create a function to repeatedly connect objects\n    x60 = power(x57, x59)\n    # Get the first and remaining objects\n    x61 = first(x1)\n    x62 = remove(x61, x1)\n    x63 = astuple(x61, x62)\n    # Connect all objects into one\n    x64 = x60(x63)\n    x65 = first(x64)\n    # Merge all original objects\n    x66 = merge(x0)\n    # Cover the original objects on the input grid\n    x67 = cover(I, x66)\n    # Paint the connected object onto the grid\n    x68 = paint(x67, x65)\n    # Get the height of the input grid\n    x69 = height(I)\n    # Get the width of the connected object\n    x70 = width(x65)\n    x71 = (x69, x70)\n    # Crop the grid to the height of input and width of connected object\n    x72 = crop(x68, ORIGIN, x71)\n    # Find all cells of the least common color\n    x73 = ofcolor(x72, x14)\n    # Get the most common color (background) of the input grid\n    x74 = mostcolor(I)\n    # Get the palette of the cropped grid\n    x75 = palette(x72)\n    # Check if the least common color is in the cropped grid\n    x76 = contained(x14, x75)\n    # Create a function to check if a color is not the background color\n    x77 = matcher(first, x74)\n    x78 = compose(flip, x77)\n    x79 = rbind(sfilter, x78)\n    # Get all neighbors of the least common color cells\n    x80 = mapply(dneighbors, x73)\n    x81 = lbind(toobject, x80)\n    # Filter these neighbors to non-background colors\n    x82 = compose(x79, x81)\n    # Prepare a function to recolor the least common color cells\n    x83 = rbind(recolor, x73)\n    # Recolor the least common color cells to the most common non-background color of their neighbors\n    x84 = chain(x83, mostcolor, x82)\n    x85 = fork(paint, identity, x84)\n    # If the least common color is in the cropped grid, apply the recoloring; otherwise, do nothing\n    x86 = branch(x76, x85, identity)\n    # Apply the final transformation to the cropped grid\n    x87 = x86(x72)\n    return x87\n"
  },
  "23581191": {
    "original": "def verify_23581191(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = totuple(x2)\n    x4 = fork(combine, hfrontier, vfrontier)\n    x5 = lbind(mapply, x4)\n    x6 = lbind(ofcolor, I)\n    x7 = compose(x5, x6)\n    x8 = first(x3)\n    x9 = last(x3)\n    x10 = x7(x8)\n    x11 = x7(x9)\n    x12 = ofcolor(I, x0)\n    x13 = intersection(x12, x10)\n    x14 = intersection(x12, x11)\n    x15 = intersection(x10, x11)\n    x16 = intersection(x12, x15)\n    x17 = fill(I, x8, x13)\n    x18 = fill(x17, x9, x14)\n    x19 = fill(x18, TWO, x16)\n    return x19\n\n",
    "annotated": "def verify_23581191(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    # Remove the background color from the set of colors\n    x2 = remove(x0, x1)\n    # Convert the remaining colors to a tuple\n    x3 = totuple(x2)\n    # Create a function that combines horizontal and vertical frontiers\n    x4 = fork(combine, hfrontier, vfrontier)\n    # Partially apply mapply function with x4\n    x5 = lbind(mapply, x4)\n    # Partially apply ofcolor function with input grid I\n    x6 = lbind(ofcolor, I)\n    # Compose x5 and x6 functions\n    x7 = compose(x5, x6)\n    # Get the first non-background color (color of first object)\n    x8 = first(x3)\n    # Get the second non-background color (color of second object)\n    x9 = last(x3)\n    # Get the frontiers of the first object\n    x10 = x7(x8)\n    # Get the frontiers of the second object\n    x11 = x7(x9)\n    # Get all background color cells\n    x12 = ofcolor(I, x0)\n    # Get the intersection of background cells and first object frontiers\n    x13 = intersection(x12, x10)\n    # Get the intersection of background cells and second object frontiers\n    x14 = intersection(x12, x11)\n    # Get the intersection of both object frontiers\n    x15 = intersection(x10, x11)\n    # Get the intersection of background cells and both object frontiers\n    x16 = intersection(x12, x15)\n    # Fill the first object's frontiers with its color\n    x17 = fill(I, x8, x13)\n    # Fill the second object's frontiers with its color\n    x18 = fill(x17, x9, x14)\n    # Fill the intersection of both frontiers with color 2 (creating the cross pattern)\n    x19 = fill(x18, TWO, x16)\n    # Return the final transformed grid\n    return x19\n"
  },
  "239be575": {
    "original": "def verify_239be575(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = lbind(apply, normalize)\n    x2 = lbind(colorfilter, x0)\n    x3 = chain(size, x1, x2)\n    x4 = matcher(x3, ONE)\n    x5 = lbind(colorcount, I)\n    x6 = matcher(x5, EIGHT)\n    x7 = lbind(colorfilter, x0)\n    x8 = compose(size, x7)\n    x9 = matcher(x8, TWO)\n    x10 = fork(both, x6, x9)\n    x11 = fork(both, x10, x4)\n    x12 = palette(I)\n    x13 = extract(x12, x11)\n    x14 = colorfilter(x0, x13)\n    x15 = totuple(x14)\n    x16 = first(x15)\n    x17 = last(x15)\n    x18 = palette(I)\n    x19 = remove(ZERO, x18)\n    x20 = remove(x13, x19)\n    x21 = first(x20)\n    x22 = colorfilter(x0, x21)\n    x23 = rbind(adjacent, x16)\n    x24 = rbind(adjacent, x17)\n    x25 = fork(both, x23, x24)\n    x26 = sfilter(x22, x25)\n    x27 = size(x26)\n    x28 = positive(x27)\n    x29 = branch(x28, x21, ZERO)\n    x30 = canvas(x29, UNITY)\n    return x30\n\n",
    "annotated": "def verify_239be575(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that normalizes objects (shifts them to origin)\n    x1 = lbind(apply, normalize)\n    \n    # Create a function that filters objects by color\n    x2 = lbind(colorfilter, x0)\n    \n    # Create a function that counts the number of normalized objects of a specific color\n    x3 = chain(size, x1, x2)\n    \n    # Create a function that checks if there's exactly one normalized object of a color\n    x4 = matcher(x3, ONE)\n    \n    # Create a function that counts the number of cells of a specific color in the input grid\n    x5 = lbind(colorcount, I)\n    \n    # Create a function that checks if there are exactly 8 cells of a specific color\n    x6 = matcher(x5, EIGHT)\n    \n    # Create a function that counts the number of objects of a specific color\n    x7 = lbind(colorfilter, x0)\n    x8 = compose(size, x7)\n    \n    # Create a function that checks if there are exactly 2 objects of a specific color\n    x9 = matcher(x8, TWO)\n    \n    # Combine the checks for 8 cells and 2 objects\n    x10 = fork(both, x6, x9)\n    \n    # Combine all checks: 8 cells, 2 objects, and 1 normalized object\n    x11 = fork(both, x10, x4)\n    \n    # Get the palette (unique colors) of the input grid\n    x12 = palette(I)\n    \n    # Extract the color that satisfies all the conditions (should be the square color)\n    x13 = extract(x12, x11)\n    \n    # Filter objects to get only the squares\n    x14 = colorfilter(x0, x13)\n    \n    # Convert the filtered objects (squares) to a tuple\n    x15 = totuple(x14)\n    \n    # Get the first square\n    x16 = first(x15)\n    \n    # Get the second square\n    x17 = last(x15)\n    \n    # Get the palette again\n    x18 = palette(I)\n    \n    # Remove the background color (0) from the palette\n    x19 = remove(ZERO, x18)\n    \n    # Remove the square color from the remaining colors to get the marking color\n    x20 = remove(x13, x19)\n    \n    # Get the marking color\n    x21 = first(x20)\n    \n    # Filter objects to get only the markings\n    x22 = colorfilter(x0, x21)\n    \n    # Create a function that checks if an object is adjacent to the first square\n    x23 = rbind(adjacent, x16)\n    \n    # Create a function that checks if an object is adjacent to the second square\n    x24 = rbind(adjacent, x17)\n    \n    # Combine the adjacency checks for both squares\n    x25 = fork(both, x23, x24)\n    \n    # Filter markings to find those adjacent to both squares\n    x26 = sfilter(x22, x25)\n    \n    # Count the number of markings adjacent to both squares\n    x27 = size(x26)\n    \n    # Check if there's at least one marking adjacent to both squares\n    x28 = positive(x27)\n    \n    # If there's a connecting marking, use the marking color; otherwise, use 0\n    x29 = branch(x28, x21, ZERO)\n    \n    # Create a 1x1 grid with the result color\n    x30 = canvas(x29, UNITY)\n    \n    # Return the result grid\n    return x30\n"
  },
  "23b5c85d": {
    "original": "def verify_23b5c85d(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = sfilter(x0, x2)\n    x4 = argmin(x3, x1)\n    x5 = subgrid(x4, I)\n    return x5\n\n",
    "annotated": "def verify_23b5c85d(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies height and width (calculates area)\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its area\n    # This identifies rectangular objects\n    x2 = fork(equality, size, x1)\n    \n    # Filter the partitioned objects, keeping only rectangular ones\n    x3 = sfilter(x0, x2)\n    \n    # Find the smallest rectangular object based on area\n    x4 = argmin(x3, x1)\n    \n    # Extract the subgrid corresponding to the smallest rectangular object\n    x5 = subgrid(x4, I)\n    \n    # Return the extracted subgrid (smallest rectangular object)\n    return x5\n"
  },
  "253bf280": {
    "original": "def verify_253bf280(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = prapply(connect, x1, x1)\n    x3 = rbind(greater, ONE)\n    x4 = compose(x3, size)\n    x5 = sfilter(x2, x4)\n    x6 = fork(either, vline, hline)\n    x7 = mfilter(x5, x6)\n    x8 = fill(I, THREE, x7)\n    x9 = leastcolor(I)\n    x10 = fill(x8, x9, x1)\n    return x10\n\n",
    "annotated": "def verify_253bf280(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all indices of cells with the background color\n    x1 = ofcolor(I, x0)\n    \n    # Generate all possible connections between background color cells\n    x2 = prapply(connect, x1, x1)\n    \n    # Create a function that checks if a value is greater than 1\n    x3 = rbind(greater, ONE)\n    \n    # Create a function that checks if the size of something is greater than 1\n    x4 = compose(x3, size)\n    \n    # Filter connections to keep only those with more than one cell\n    x5 = sfilter(x2, x4)\n    \n    # Create a function that checks if a line is either vertical or horizontal\n    x6 = fork(either, vline, hline)\n    \n    # Filter and merge to keep only vertical or horizontal lines\n    x7 = mfilter(x5, x6)\n    \n    # Fill the selected lines with color 3 (drawing the lines)\n    x8 = fill(I, THREE, x7)\n    \n    # Find the least common color in the original input grid again (foreground color)\n    x9 = leastcolor(I)\n    \n    # Fill the cells of the original foreground color back into the grid\n    x10 = fill(x8, x9, x1)\n    \n    # Return the final grid with drawn lines and original foreground cells\n    return x10\n"
  },
  "25d487eb": {
    "original": "def verify_25d487eb(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = lbind(matcher, first)\n    x2 = compose(x1, leastcolor)\n    x3 = lbind(matcher, first)\n    x4 = compose(x3, mostcolor)\n    x5 = fork(extract, identity, x2)\n    x6 = compose(last, x5)\n    x7 = compose(dneighbors, x6)\n    x8 = lbind(apply, last)\n    x9 = fork(sfilter, identity, x4)\n    x10 = compose(x8, x9)\n    x11 = fork(difference, x7, x10)\n    x12 = compose(first, x11)\n    x13 = fork(subtract, x6, x12)\n    x14 = fork(shoot, x6, x13)\n    x15 = fork(recolor, leastcolor, x14)\n    x16 = mapply(x15, x0)\n    x17 = underpaint(I, x16)\n    return x17\n\n",
    "annotated": "def verify_25d487eb(I: Grid) -> Grid:\n    # Extract objects from the input grid, ignoring background color\n    x0 = objects(I, F, F, T)\n    # Create a function to match the first element of a tuple\n    x1 = lbind(matcher, first)\n    # Create a function to find and match the least common color\n    x2 = compose(x1, leastcolor)\n    # Create another function to match the first element of a tuple\n    x3 = lbind(matcher, first)\n    # Create a function to find and match the most common color\n    x4 = compose(x3, mostcolor)\n    # Extract the object with the least common color\n    x5 = fork(extract, identity, x2)\n    # Get the last cell of the extracted object (bottom-right corner of the diamond)\n    x6 = compose(last, x5)\n    # Find the direct neighbors of the bottom-right corner of the diamond\n    x7 = compose(dneighbors, x6)\n    # Create a function to get the last element (position) of each cell\n    x8 = lbind(apply, last)\n    # Filter objects to keep only those of the most common color\n    x9 = fork(sfilter, identity, x4)\n    # Get the positions of cells with the most common color\n    x10 = compose(x8, x9)\n    # Find neighbors of the diamond that are not of the most common color\n    x11 = fork(difference, x7, x10)\n    # Get the first of these neighbors (the start of the line)\n    x12 = compose(first, x11)\n    # Calculate the direction vector from the start to the bottom-right corner\n    x13 = fork(subtract, x6, x12)\n    # Create a line (shoot) from the bottom-right corner in the calculated direction\n    x14 = fork(shoot, x6, x13)\n    # Color the line with the least common color\n    x15 = fork(recolor, leastcolor, x14)\n    # Apply the line coloring to all objects\n    x16 = mapply(x15, x0)\n    # Paint the lines on the input grid, preserving existing colors\n    x17 = underpaint(I, x16)\n    # Return the modified grid with added lines\n    return x17\n"
  },
  "25d8a9c8": {
    "original": "def verify_25d8a9c8(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = rbind(branch, ZERO)\n    x2 = rbind(x1, FIVE)\n    x3 = compose(size, dedupe)\n    x4 = matcher(x3, ONE)\n    x5 = compose(x2, x4)\n    x6 = rbind(repeat, x0)\n    x7 = compose(x6, x5)\n    x8 = apply(x7, I)\n    return x8\n\n",
    "annotated": "def verify_25d8a9c8(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    \n    # Create a function that branches based on a condition, defaulting to 0 if the condition is false\n    x1 = rbind(branch, ZERO)\n    \n    # Modify the branch function to return 5 instead of 0 when the condition is false\n    x2 = rbind(x1, FIVE)\n    \n    # Create a function that counts the number of unique elements in a container\n    x3 = compose(size, dedupe)\n    \n    # Create a function that checks if the number of unique elements is exactly 1\n    x4 = matcher(x3, ONE)\n    \n    # Compose the branching function with the uniqueness check\n    # This will return 5 if a row has only one unique element, and 0 otherwise\n    x5 = compose(x2, x4)\n    \n    # Create a function that repeats a value x0 (width of the grid) times\n    x6 = rbind(repeat, x0)\n    \n    # Compose the repetition function with the branching function\n    # This will create a row of 5s or 0s, depending on the uniqueness of the input row\n    x7 = compose(x6, x5)\n    \n    # Apply the composed function to each row of the input grid\n    # This transforms each row into either all 5s (if the input row was a single color) \n    # or all 0s (if the input row had multiple colors)\n    x8 = apply(x7, I)\n    \n    # Return the transformed grid\n    # The output grid will have the same dimensions as the input, but each row will be\n    # either all 5s (indicating a single-color row in the input) or all 0s (indicating\n    # a multi-color row in the input)\n    return x8\n"
  },
  "25ff71a9": {
    "original": "def verify_25ff71a9(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = first(x0)\n    x2 = move(I, x1, DOWN)\n    return x2\n\n",
    "annotated": "def verify_25ff71a9(I: Grid) -> Grid:\n    # Extract all objects from the input grid I\n    # T, T, T parameters mean: univalued=True, diagonal=True, without_bg=True\n    # This finds all contiguous regions of the same color, including diagonally connected cells, excluding the background color\n    x0 = objects(I, T, T, T)\n\n    # Select the first (and only) object from the set of objects\n    # This represents the shape we want to move\n    x1 = first(x0)\n\n    # Move the selected object one cell down on the grid\n    # DOWN is a constant defined as (1, 0), representing downward movement\n    # This creates a new grid with the shape moved down by one cell\n    x2 = move(I, x1, DOWN)\n\n    # Return the modified grid with the shape moved down\n    return x2\n"
  },
  "264363fd": {
    "original": "def verify_264363fd(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = mostcolor(x2)\n    x4 = shape(I)\n    x5 = canvas(x3, x4)\n    x6 = hconcat(I, x5)\n    x7 = objects(x6, F, F, T)\n    x8 = argmin(x7, size)\n    x9 = cover(I, x8)\n    x10 = normalize(x8)\n    x11 = remove(x8, x7)\n    x12 = toindices(x10)\n    x13 = lbind(intersection, x12)\n    x14 = chain(x13, dneighbors, last)\n    x15 = rbind(greater, ONE)\n    x16 = chain(x15, size, x14)\n    x17 = sfilter(x10, x16)\n    x18 = center(x17)\n    x19 = matcher(last, x18)\n    x20 = extract(x17, x19)\n    x21 = first(x20)\n    x22 = difference(x10, x17)\n    x23 = color(x22)\n    x24 = center(x17)\n    x25 = invert(x24)\n    x26 = shift(x10, x25)\n    x27 = invert(x24)\n    x28 = shift(x22, x27)\n    x29 = toindices(x28)\n    x30 = rbind(mapply, x29)\n    x31 = lbind(lbind, shoot)\n    x32 = compose(x30, x31)\n    x33 = power(outbox, TWO)\n    x34 = chain(backdrop, x33, initset)\n    x35 = fork(difference, x32, x34)\n    x36 = lbind(recolor, x23)\n    x37 = compose(x36, x35)\n    x38 = lbind(shift, x26)\n    x39 = fork(combine, x37, x38)\n    x40 = lbind(mapply, x39)\n    x41 = rbind(ofcolor, x21)\n    x42 = compose(x40, x41)\n    x43 = fork(paint, identity, x42)\n    x44 = rbind(subgrid, I)\n    x45 = chain(asobject, x43, x44)\n    x46 = fork(shift, x45, ulcorner)\n    x47 = mapply(x46, x11)\n    x48 = paint(x9, x47)\n    return x48\n\n",
    "annotated": "def verify_264363fd(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    # Create a function that multiplies height and width\n    x1 = fork(multiply, height, width)\n    # Find the largest object based on area (height * width)\n    x2 = argmax(x0, x1)\n    # Get the most common color in the largest object\n    x3 = mostcolor(x2)\n    # Get the dimensions of the input grid\n    x4 = shape(I)\n    # Create a new canvas with the same size as input, filled with the most common color from the largest object\n    x5 = canvas(x3, x4)\n    # Concatenate the input grid with the new canvas horizontally\n    x6 = hconcat(I, x5)\n    # Get all objects in the concatenated grid, ignoring the background\n    x7 = objects(x6, F, F, T)\n    # Find the smallest object in the concatenated grid\n    x8 = argmin(x7, size)\n    # Remove the smallest object from the input grid\n    x9 = cover(I, x8)\n    # Normalize the position of the smallest object (move to origin)\n    x10 = normalize(x8)\n    # Remove the smallest object from the set of all objects\n    x11 = remove(x8, x7)\n    # Get the indices of the normalized smallest object\n    x12 = toindices(x10)\n    # Create a function to find the intersection with the normalized object indices\n    x13 = lbind(intersection, x12)\n    # Create a function to find the last direct neighbor of the intersection\n    x14 = chain(x13, dneighbors, last)\n    # Create a function to check if a value is greater than 1\n    x15 = rbind(greater, ONE)\n    # Create a function to check if the size of the last neighbor intersection is greater than 1\n    x16 = chain(x15, size, x14)\n    # Filter the normalized object to keep only parts with more than one neighbor\n    x17 = sfilter(x10, x16)\n    # Find the center of the filtered object\n    x18 = center(x17)\n    # Create a function to match the last element with the center\n    x19 = matcher(last, x18)\n    # Extract the part of the filtered object that matches the center\n    x20 = extract(x17, x19)\n    # Get the color of the central part\n    x21 = first(x20)\n    # Get the part of the object that's not in the filtered version (the \"spikes\")\n    x22 = difference(x10, x17)\n    # Get the color of the spikes\n    x23 = color(x22)\n    # Find the center of the filtered object again\n    x24 = center(x17)\n    # Invert the center coordinates\n    x25 = invert(x24)\n    # Shift the normalized object by the inverted center (centering it)\n    x26 = shift(x10, x25)\n    # Invert the center coordinates again\n    x27 = invert(x24)\n    # Shift the spike part by the center coordinates\n    x28 = shift(x22, x27)\n    # Get the indices of the shifted spike part\n    x29 = toindices(x28)\n    # Create a function to apply a function to the spike indices\n    x30 = rbind(mapply, x29)\n    # Create a function to bind the shoot function as the leftmost argument\n    x31 = lbind(lbind, shoot)\n    # Compose the above two functions\n    x32 = compose(x30, x31)\n    # Create a function that applies the outbox function twice\n    x33 = power(outbox, TWO)\n    # Create a function chain: initialize a set, apply outbox twice, then get the backdrop\n    x34 = chain(backdrop, x33, initset)\n    # Create a function to find the difference between the shot spikes and the backdrop\n    x35 = fork(difference, x32, x34)\n    # Create a function to recolor with the spike color\n    x36 = lbind(recolor, x23)\n    # Compose the recoloring function with the difference function\n    x37 = compose(x36, x35)\n    # Create a function to shift by the centered object\n    x38 = lbind(shift, x26)\n    # Create a function to combine the recolored spikes with the shifted object\n    x39 = fork(combine, x37, x38)\n    # Create a function to apply the combining function\n    x40 = lbind(mapply, x39)\n    # Create a function to find cells of the central color\n    x41 = rbind(ofcolor, x21)\n    # Compose the applying function with the color finding function\n    x42 = compose(x40, x41)\n    # Create a function to paint the result onto the identity (input) grid\n    x43 = fork(paint, identity, x42)\n    # Create a function to get the subgrid from the input\n    x44 = rbind(subgrid, I)\n    # Create a function chain: get subgrid, apply painting, convert to object\n    x45 = chain(asobject, x43, x44)\n    # Create a function to shift the result by its upper left corner\n    x46 = fork(shift, x45, ulcorner)\n    # Apply the shifting function to all objects except the smallest\n    x47 = mapply(x46, x11)\n    # Paint the shifted objects onto the grid with the smallest object removed\n    x48 = paint(x9, x47)\n    # Return the final grid\n    return x48\n"
  },
  "272f95fa": {
    "original": "def verify_272f95fa(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = index(I, ORIGIN)\n    x2 = colorfilter(x0, x1)\n    x3 = apply(toindices, x2)\n    x4 = rbind(bordering, I)\n    x5 = compose(flip, x4)\n    x6 = extract(x3, x5)\n    x7 = remove(x6, x3)\n    x8 = lbind(vmatching, x6)\n    x9 = lbind(hmatching, x6)\n    x10 = sfilter(x7, x8)\n    x11 = sfilter(x7, x9)\n    x12 = argmin(x10, uppermost)\n    x13 = argmax(x10, uppermost)\n    x14 = argmin(x11, leftmost)\n    x15 = argmax(x11, leftmost)\n    x16 = fill(I, SIX, x6)\n    x17 = fill(x16, TWO, x12)\n    x18 = fill(x17, ONE, x13)\n    x19 = fill(x18, FOUR, x14)\n    x20 = fill(x19, THREE, x15)\n    return x20\n\n",
    "annotated": "def verify_272f95fa(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering only directly adjacent cells\n    x0 = objects(I, T, F, F)\n    \n    # Get the color of the top-left corner cell (background color)\n    x1 = index(I, ORIGIN)\n    \n    # Filter objects to keep only those with the background color\n    x2 = colorfilter(x0, x1)\n    \n    # Convert objects to sets of indices\n    x3 = apply(toindices, x2)\n    \n    # Create a function that checks if an object borders the grid\n    x4 = rbind(bordering, I)\n    \n    # Create a function that checks if an object does NOT border the grid\n    x5 = compose(flip, x4)\n    \n    # Find the object that doesn't border the grid (the 'pink' object)\n    x6 = extract(x3, x5)\n    \n    # Remove the 'pink' object from the set of background objects\n    x7 = remove(x6, x3)\n    \n    # Create a function to check vertical matching with the 'pink' object\n    x8 = lbind(vmatching, x6)\n    \n    # Create a function to check horizontal matching with the 'pink' object\n    x9 = lbind(hmatching, x6)\n    \n    # Filter objects that vertically match with the 'pink' object\n    x10 = sfilter(x7, x8)\n    \n    # Filter objects that horizontally match with the 'pink' object\n    x11 = sfilter(x7, x9)\n    \n    # Find the topmost object among vertically matching objects (the 'red' object)\n    x12 = argmin(x10, uppermost)\n    \n    # Find the bottommost object among vertically matching objects (the 'blue' object)\n    x13 = argmax(x10, uppermost)\n    \n    # Find the leftmost object among horizontally matching objects (the 'yellow' object)\n    x14 = argmin(x11, leftmost)\n    \n    # Find the rightmost object among horizontally matching objects (the 'green' object)\n    x15 = argmax(x11, leftmost)\n    \n    # Color the 'pink' object with color 6\n    x16 = fill(I, SIX, x6)\n    \n    # Color the 'red' object with color 2\n    x17 = fill(x16, TWO, x12)\n    \n    # Color the 'blue' object with color 1\n    x18 = fill(x17, ONE, x13)\n    \n    # Color the 'yellow' object with color 4\n    x19 = fill(x18, FOUR, x14)\n    \n    # Color the 'green' object with color 3\n    x20 = fill(x19, THREE, x15)\n    \n    # Return the final colored grid\n    return x20\n"
  },
  "27a28665": {
    "original": "def verify_27a28665(I: Grid) -> Grid:\n    x0 = lbind(apply, last)\n    x1 = compose(positive, first)\n    x2 = lbind(interval, ZERO)\n    x3 = rbind(x2, ONE)\n    x4 = rbind(sfilter, x1)\n    x5 = compose(x3, size)\n    x6 = fork(pair, x5, identity)\n    x7 = chain(x0, x4, x6)\n    x8 = rbind(branch, identity)\n    x9 = rbind(x8, x7)\n    x10 = chain(size, dedupe, first)\n    x11 = lbind(equality, ONE)\n    x12 = chain(x9, x11, x10)\n    x13 = compose(initset, x12)\n    x14 = fork(rapply, x13, identity)\n    x15 = compose(first, x14)\n    x16 = rbind(branch, identity)\n    x17 = rbind(x16, x15)\n    x18 = chain(x17, positive, size)\n    x19 = compose(initset, x18)\n    x20 = fork(rapply, x19, identity)\n    x21 = compose(first, x20)\n    x22 = multiply(TEN, THREE)\n    x23 = power(x21, x22)\n    x24 = compose(rot90, x23)\n    x25 = power(x24, FOUR)\n    x26 = x25(I)\n    x27 = width(x26)\n    x28 = divide(x27, THREE)\n    x29 = downscale(x26, x28)\n    x30 = objects(x29, T, F, F)\n    x31 = valmax(x30, size)\n    x32 = equality(x31, ONE)\n    x33 = equality(x31, FOUR)\n    x34 = equality(x31, FIVE)\n    x35 = branch(x32, TWO, ONE)\n    x36 = branch(x33, THREE, x35)\n    x37 = branch(x34, SIX, x36)\n    x38 = canvas(x37, UNITY)\n    return x38\n\n",
    "annotated": "def verify_27a28665(I: Grid) -> Grid:\n    # Create a function that applies the 'last' function to the result of 'apply'\n    x0 = lbind(apply, last)\n    \n    # Create a function that checks if the first element is positive\n    x1 = compose(positive, first)\n    \n    # Create a function that generates an interval starting from 0\n    x2 = lbind(interval, ZERO)\n    \n    # Create a function that generates an interval from 0 to 1\n    x3 = rbind(x2, ONE)\n    \n    # Create a function that filters elements based on the positivity of their first element\n    x4 = rbind(sfilter, x1)\n    \n    # Create a function that returns the size of an interval from 0 to 1\n    x5 = compose(x3, size)\n    \n    # Create a function that pairs the result of x5 with the identity of its input\n    x6 = fork(pair, x5, identity)\n    \n    # Chain functions to filter, pair, and get the last element\n    x7 = chain(x0, x4, x6)\n    \n    # Create a function that branches based on a condition, returning the identity if true\n    x8 = rbind(branch, identity)\n    \n    # Extend x8 to use x7 as its condition\n    x9 = rbind(x8, x7)\n    \n    # Create a function that gets the size of unique first elements\n    x10 = chain(size, dedupe, first)\n    \n    # Create a function that checks if a value equals 1\n    x11 = lbind(equality, ONE)\n    \n    # Chain functions to check if there's only one unique first element\n    x12 = chain(x9, x11, x10)\n    \n    # Create a function that initializes a set with the result of x12\n    x13 = compose(initset, x12)\n    \n    # Create a function that applies x13 to its input and returns the result\n    x14 = fork(rapply, x13, identity)\n    \n    # Create a function that gets the first element of x14's result\n    x15 = compose(first, x14)\n    \n    # Create a function that branches based on a condition, returning the identity if true\n    x16 = rbind(branch, identity)\n    \n    # Extend x16 to use x15 as its condition\n    x17 = rbind(x16, x15)\n    \n    # Chain functions to check if the size is positive\n    x18 = chain(x17, positive, size)\n    \n    # Create a function that initializes a set with the result of x18\n    x19 = compose(initset, x18)\n    \n    # Create a function that applies x19 to its input and returns the result\n    x20 = fork(rapply, x19, identity)\n    \n    # Create a function that gets the first element of x20's result\n    x21 = compose(first, x20)\n    \n    # Calculate 30 (10 * 3)\n    x22 = multiply(TEN, THREE)\n    \n    # Create a function that applies x21 30 times\n    x23 = power(x21, x22)\n    \n    # Create a function that rotates the result of x23 by 90 degrees\n    x24 = compose(rot90, x23)\n    \n    # Create a function that applies x24 4 times (full 360-degree rotation)\n    x25 = power(x24, FOUR)\n    \n    # Apply x25 to the input grid I\n    x26 = x25(I)\n    \n    # Get the width of the transformed grid\n    x27 = width(x26)\n    \n    # Calculate one-third of the width\n    x28 = divide(x27, THREE)\n    \n    # Downscale the transformed grid by one-third\n    x29 = downscale(x26, x28)\n    \n    # Find objects in the downscaled grid (univalued, not diagonal, with background)\n    x30 = objects(x29, T, F, F)\n    \n    # Get the size of the largest object\n    x31 = valmax(x30, size)\n    \n    # Check if the largest object has size 1\n    x32 = equality(x31, ONE)\n    \n    # Check if the largest object has size 4\n    x33 = equality(x31, FOUR)\n    \n    # Check if the largest object has size 5\n    x34 = equality(x31, FIVE)\n    \n    # If largest object has size 1, return 2; otherwise return 1\n    x35 = branch(x32, TWO, ONE)\n    \n    # If largest object has size 4, return 3; otherwise use previous result\n    x36 = branch(x33, THREE, x35)\n    \n    # If largest object has size 5, return 6; otherwise use previous result\n    x37 = branch(x34, SIX, x36)\n    \n    # Create a 1x1 grid with the final determined color\n    x38 = canvas(x37, UNITY)\n    \n    # Return the 1x1 grid representing the identified shape\n    return x38\n"
  },
  "28bf18c6": {
    "original": "def verify_28bf18c6(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = first(x0)\n    x2 = subgrid(x1, I)\n    x3 = hconcat(x2, x2)\n    return x3\n\n",
    "annotated": "def verify_28bf18c6(I: Grid) -> Grid:\n    # Extract all objects from the input grid I\n    # This includes all connected components of non-background color\n    # T, T, T parameters mean: univalued=True, diagonal=True, without_bg=True\n    x0 = objects(I, T, T, T)\n\n    # Select the first (and only) object from the set of objects\n    # This is the shape we're interested in extracting\n    x1 = first(x0)\n\n    # Extract the subgrid containing only the selected object\n    # This effectively crops the input grid to the bounding box of the shape\n    x2 = subgrid(x1, I)\n\n    # Duplicate the extracted subgrid horizontally\n    # This creates a new grid with two copies of the shape side by side\n    x3 = hconcat(x2, x2)\n\n    # Return the horizontally concatenated grid as the output\n    return x3\n"
  },
  "28e73c20": {
    "original": "def verify_28e73c20(I: Grid) -> Grid:\n    x0 = astuple(RIGHT, DOWN)\n    x1 = astuple(DOWN, LEFT)\n    x2 = astuple(x0, x1)\n    x3 = astuple(LEFT, UP)\n    x4 = astuple(UP, RIGHT)\n    x5 = astuple(x3, x4)\n    x6 = combine(x2, x5)\n    x7 = height(I)\n    x8 = astuple(x7, ONE)\n    x9 = canvas(THREE, x8)\n    x10 = hconcat(x9, I)\n    x11 = height(x10)\n    x12 = width(x10)\n    x13 = decrement(x12)\n    x14 = tojvec(x13)\n    x15 = identity(DOWN)\n    x16 = connect(ORIGIN, x14)\n    x17 = fill(x10, THREE, x16)\n    x18 = identity(x12)\n    x19 = identity(x11)\n    x20 = identity(x11)\n    x21 = identity(F)\n    x22 = identity(ZERO)\n    x23 = compose(first, first)\n    x24 = chain(first, last, x23)\n    x25 = compose(first, first)\n    x26 = chain(last, last, x25)\n    x27 = chain(first, first, first)\n    x28 = chain(first, last, last)\n    x29 = chain(first, first, last)\n    x30 = chain(last, first, last)\n    x31 = compose(decrement, x24)\n    x32 = compose(decrement, x26)\n    x33 = fork(astuple, x31, x32)\n    x34 = compose(decrement, x26)\n    x35 = fork(multiply, x29, x34)\n    x36 = fork(add, x28, x35)\n    x37 = compose(decrement, x27)\n    x38 = fork(multiply, x29, x37)\n    x39 = fork(add, x28, x38)\n    x40 = fork(astuple, x39, x36)\n    x41 = lbind(extract, x6)\n    x42 = lbind(matcher, first)\n    x43 = compose(x42, x29)\n    x44 = chain(last, x41, x43)\n    x45 = compose(last, first)\n    x46 = lbind(recolor, THREE)\n    x47 = compose(decrement, x27)\n    x48 = fork(multiply, x29, x47)\n    x49 = fork(add, x28, x48)\n    x50 = fork(connect, x28, x49)\n    x51 = compose(x46, x50)\n    x52 = fork(paint, x45, x51)\n    x53 = compose(decrement, x26)\n    x54 = fork(multiply, x30, x53)\n    x55 = compose(flip, x30)\n    x56 = compose(decrement, x24)\n    x57 = fork(multiply, x55, x56)\n    x58 = fork(add, x54, x57)\n    x59 = power(first, THREE)\n    x60 = chain(flip, positive, x59)\n    x61 = fork(astuple, x58, x33)\n    x62 = compose(flip, x30)\n    x63 = fork(astuple, x44, x62)\n    x64 = fork(astuple, x61, x52)\n    x65 = fork(astuple, x63, x40)\n    x66 = fork(astuple, x64, x65)\n    x67 = rbind(branch, x66)\n    x68 = rbind(x67, identity)\n    x69 = chain(initset, x68, x60)\n    x70 = fork(rapply, x69, identity)\n    x71 = compose(first, x70)\n    x72 = multiply(TEN, THREE)\n    x73 = power(x71, x72)\n    x74 = astuple(x18, x19)\n    x75 = astuple(x15, x21)\n    x76 = astuple(x14, x22)\n    x77 = astuple(x20, x74)\n    x78 = astuple(x75, x76)\n    x79 = astuple(x77, x17)\n    x80 = astuple(x79, x78)\n    x81 = x73(x80)\n    x82 = first(x81)\n    x83 = last(x82)\n    x84 = dmirror(x83)\n    x85 = shape(x84)\n    x86 = add(x85, UP)\n    x87 = crop(x84, DOWN, x86)\n    x88 = dmirror(x87)\n    return x88\n\n",
    "annotated": "def verify_28e73c20(I: Grid) -> Grid:\n    x0 = astuple(RIGHT, DOWN)  # Create a tuple of RIGHT and DOWN directions\n    x1 = astuple(DOWN, LEFT)  # Create a tuple of DOWN and LEFT directions\n    x2 = astuple(x0, x1)  # Combine the above two tuples\n    x3 = astuple(LEFT, UP)  # Create a tuple of LEFT and UP directions\n    x4 = astuple(UP, RIGHT)  # Create a tuple of UP and RIGHT directions\n    x5 = astuple(x3, x4)  # Combine the above two tuples\n    x6 = combine(x2, x5)  # Combine all direction tuples into one container\n    x7 = height(I)  # Get the height of the input grid\n    x8 = astuple(x7, ONE)  # Create a tuple of the height and 1\n    x9 = canvas(THREE, x8)  # Create a new grid filled with 3s of height x7 and width 1\n    x10 = hconcat(x9, I)  # Concatenate the new grid horizontally with the input grid\n    x11 = height(x10)  # Get the height of the concatenated grid\n    x12 = width(x10)  # Get the width of the concatenated grid\n    x13 = decrement(x12)  # Decrease the width by 1\n    x14 = tojvec(x13)  # Convert the decremented width to a horizontal vector\n    x15 = identity(DOWN)  # Get the DOWN direction\n    x16 = connect(ORIGIN, x14)  # Create a line from origin to the right edge\n    x17 = fill(x10, THREE, x16)  # Fill the top row of the grid with 3s\n    x18 = identity(x12)  # Store the width\n    x19 = identity(x11)  # Store the height\n    x20 = identity(x11)  # Store the height again\n    x21 = identity(F)  # Store False\n    x22 = identity(ZERO)  # Store 0\n    x23 = compose(first, first)  # Compose functions to get the first element twice\n    x24 = chain(first, last, x23)  # Chain functions to get specific elements\n    x25 = compose(first, first)  # Compose functions to get the first element twice\n    x26 = chain(last, last, x25)  # Chain functions to get specific elements\n    x27 = chain(first, first, first)  # Chain functions to get the first element three times\n    x28 = chain(first, last, last)  # Chain functions to get specific elements\n    x29 = chain(first, first, last)  # Chain functions to get specific elements\n    x30 = chain(last, first, last)  # Chain functions to get specific elements\n    x31 = compose(decrement, x24)  # Compose functions to decrease a specific value\n    x32 = compose(decrement, x26)  # Compose functions to decrease a specific value\n    x33 = fork(astuple, x31, x32)  # Create a tuple of two decremented values\n    x34 = compose(decrement, x26)  # Compose functions to decrease a specific value\n    x35 = fork(multiply, x29, x34)  # Multiply two specific values\n    x36 = fork(add, x28, x35)  # Add two values\n    x37 = compose(decrement, x27)  # Compose functions to decrease a specific value\n    x38 = fork(multiply, x29, x37)  # Multiply two specific values\n    x39 = fork(add, x28, x38)  # Add two values\n    x40 = fork(astuple, x39, x36)  # Create a tuple of two calculated values\n    x41 = lbind(extract, x6)  # Bind the extract function with the direction container\n    x42 = lbind(matcher, first)  # Bind the matcher function with the first function\n    x43 = compose(x42, x29)  # Compose functions to create a specific matcher\n    x44 = chain(last, x41, x43)  # Chain functions to extract a specific direction\n    x45 = compose(last, first)  # Compose functions to get a specific element\n    x46 = lbind(recolor, THREE)  # Bind the recolor function with color 3\n    x47 = compose(decrement, x27)  # Compose functions to decrease a specific value\n    x48 = fork(multiply, x29, x47)  # Multiply two specific values\n    x49 = fork(add, x28, x48)  # Add two values\n    x50 = fork(connect, x28, x49)  # Connect two points\n    x51 = compose(x46, x50)  # Compose functions to recolor a connected line\n    x52 = fork(paint, x45, x51)  # Paint the recolored line on the grid\n    x53 = compose(decrement, x26)  # Compose functions to decrease a specific value\n    x54 = fork(multiply, x30, x53)  # Multiply two specific values\n    x55 = compose(flip, x30)  # Compose functions to flip a boolean value\n    x56 = compose(decrement, x24)  # Compose functions to decrease a specific value\n    x57 = fork(multiply, x55, x56)  # Multiply two specific values\n    x58 = fork(add, x54, x57)  # Add two values\n    x59 = power(first, THREE)  # Apply the first function three times\n    x60 = chain(flip, positive, x59)  # Chain functions to check if a value is positive\n    x61 = fork(astuple, x58, x33)  # Create a tuple of two calculated values\n    x62 = compose(flip, x30)  # Compose functions to flip a boolean value\n    x63 = fork(astuple, x44, x62)  # Create a tuple of a direction and a flipped boolean\n    x64 = fork(astuple, x61, x52)  # Create a tuple of calculated values and a painting function\n    x65 = fork(astuple, x63, x40)  # Create a tuple of direction-related values\n    x66 = fork(astuple, x64, x65)  # Combine all calculated values and functions\n    x67 = rbind(branch, x66)  # Bind the branch function with the combined values\n    x68 = rbind(x67, identity)  # Bind the previous result with the identity function\n    x69 = chain(initset, x68, x60)  # Chain functions to initialize a set based on a condition\n    x70 = fork(rapply, x69, identity)  # Apply functions to the initialized set\n    x71 = compose(first, x70)  # Compose functions to get the first element of the result\n    x72 = multiply(TEN, THREE)  # Calculate 30\n    x73 = power(x71, x72)  # Apply the resulting function 30 times\n    x74 = astuple(x18, x19)  # Create a tuple of width and height\n    x75 = astuple(x15, x21)  # Create a tuple of DOWN direction and False\n    x76 = astuple(x14, x22)  # Create a tuple of the right edge vector and 0\n    x77 = astuple(x20, x74)  # Create a tuple of height and (width, height)\n    x78 = astuple(x75, x76)  # Create a tuple of (DOWN, False) and (right edge, 0)\n    x79 = astuple(x77, x17)  # Create a tuple of previous tuple and the filled grid\n    x80 = astuple(x79, x78)  # Combine all tuples into one\n    x81 = x73(x80)  # Apply the function 30 times to draw the spiral\n    x82 = first(x81)  # Get the first element (the resulting grid)\n    x83 = last(x82)  # Get the last element of the resulting grid\n    x84 = dmirror(x83)  # Mirror the grid diagonally\n    x85 = shape(x84)  # Get the shape of the mirrored grid\n    x86 = add(x85, UP)  # Add UP direction to the shape\n    x87 = crop(x84, DOWN, x86)  # Crop the grid from the bottom\n    x88 = dmirror(x87)  # Mirror the cropped grid diagonally again\n    return x88  # Return the final transformed grid\n"
  },
  "29623171": {
    "original": "def verify_29623171(I: Grid) -> Grid:\n    x0 = compress(I)\n    x1 = leastcolor(x0)\n    x2 = mostcolor(x0)\n    x3 = frontiers(I)\n    x4 = sfilter(x3, hline)\n    x5 = size(x4)\n    x6 = increment(x5)\n    x7 = sfilter(x3, vline)\n    x8 = size(x7)\n    x9 = increment(x8)\n    x10 = height(I)\n    x11 = decrement(x6)\n    x12 = subtract(x10, x11)\n    x13 = divide(x12, x6)\n    x14 = width(I)\n    x15 = decrement(x9)\n    x16 = subtract(x14, x15)\n    x17 = divide(x16, x9)\n    x18 = astuple(x13, x17)\n    x19 = canvas(ZERO, x18)\n    x20 = asindices(x19)\n    x21 = astuple(x6, x9)\n    x22 = canvas(ZERO, x21)\n    x23 = asindices(x22)\n    x24 = astuple(x13, x17)\n    x25 = increment(x24)\n    x26 = rbind(multiply, x25)\n    x27 = apply(x26, x23)\n    x28 = rbind(toobject, I)\n    x29 = lbind(shift, x20)\n    x30 = compose(x28, x29)\n    x31 = apply(x30, x27)\n    x32 = rbind(colorcount, x1)\n    x33 = valmax(x31, x32)\n    x34 = rbind(colorcount, x1)\n    x35 = matcher(x34, x33)\n    x36 = mfilter(x31, x35)\n    x37 = replace(I, x1, x2)\n    x38 = fill(x37, x1, x36)\n    return x38\n\n",
    "annotated": "def verify_29623171(I: Grid) -> Grid:\n    # Remove frontiers from the input grid\n    x0 = compress(I)\n    # Find the least common color in the compressed grid (background color)\n    x1 = leastcolor(x0)\n    # Find the most common color in the compressed grid (foreground color)\n    x2 = mostcolor(x0)\n    # Identify all frontiers in the original input grid\n    x3 = frontiers(I)\n    # Filter out horizontal frontiers\n    x4 = sfilter(x3, hline)\n    # Count the number of horizontal frontiers\n    x5 = size(x4)\n    # Add 1 to get the number of rows in the grid\n    x6 = increment(x5)\n    # Filter out vertical frontiers\n    x7 = sfilter(x3, vline)\n    # Count the number of vertical frontiers\n    x8 = size(x7)\n    # Add 1 to get the number of columns in the grid\n    x9 = increment(x8)\n    # Get the total height of the input grid\n    x10 = height(I)\n    # Subtract 1 from the number of rows\n    x11 = decrement(x6)\n    # Calculate the total height of all horizontal frontiers\n    x12 = subtract(x10, x11)\n    # Calculate the height of each small grid\n    x13 = divide(x12, x6)\n    # Get the total width of the input grid\n    x14 = width(I)\n    # Subtract 1 from the number of columns\n    x15 = decrement(x9)\n    # Calculate the total width of all vertical frontiers\n    x16 = subtract(x14, x15)\n    # Calculate the width of each small grid\n    x17 = divide(x16, x9)\n    # Create a tuple of the small grid dimensions\n    x18 = astuple(x13, x17)\n    # Create a canvas of zeros with the small grid dimensions\n    x19 = canvas(ZERO, x18)\n    # Get all indices of the small grid canvas\n    x20 = asindices(x19)\n    # Create a tuple of the number of rows and columns in the grid\n    x21 = astuple(x6, x9)\n    # Create a canvas of zeros with the grid dimensions\n    x22 = canvas(ZERO, x21)\n    # Get all indices of the grid canvas\n    x23 = asindices(x22)\n    # Create a tuple of the small grid dimensions\n    x24 = astuple(x13, x17)\n    # Add 1 to each dimension to account for frontiers\n    x25 = increment(x24)\n    # Create a function to multiply by the incremented dimensions\n    x26 = rbind(multiply, x25)\n    # Apply the multiplication function to all grid indices\n    x27 = apply(x26, x23)\n    # Create a function to convert grid cells to objects\n    x28 = rbind(toobject, I)\n    # Create a function to shift objects by the small grid indices\n    x29 = lbind(shift, x20)\n    # Compose the object conversion and shifting functions\n    x30 = compose(x28, x29)\n    # Apply the composed function to all multiplied grid indices\n    x31 = apply(x30, x27)\n    # Create a function to count the background color in each object\n    x32 = rbind(colorcount, x1)\n    # Find the maximum count of background color among all objects\n    x33 = valmax(x31, x32)\n    # Create a function to count the background color in each object\n    x34 = rbind(colorcount, x1)\n    # Create a function to match objects with the maximum background color count\n    x35 = matcher(x34, x33)\n    # Filter and merge objects with the maximum background color count\n    x36 = mfilter(x31, x35)\n    # Replace the background color with the foreground color in the input grid\n    x37 = replace(I, x1, x2)\n    # Fill the areas of the filtered objects with the background color\n    x38 = fill(x37, x1, x36)\n    # Return the final modified grid\n    return x38\n"
  },
  "29c11459": {
    "original": "def verify_29c11459(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = product(x0, x0)\n    x2 = fork(hmatching, first, last)\n    x3 = fork(vmatching, first, last)\n    x4 = fork(either, x2, x3)\n    x5 = sfilter(x1, x4)\n    x6 = mostcolor(I)\n    x7 = rbind(toobject, I)\n    x8 = compose(delta, merge)\n    x9 = chain(palette, x7, x8)\n    x10 = initset(x6)\n    x11 = matcher(x9, x10)\n    x12 = sfilter(x5, x11)\n    x13 = shape(I)\n    x14 = subtract(x13, TWO_BY_ZERO)\n    x15 = crop(I, DOWN, x14)\n    x16 = numcolors(x15)\n    x17 = equality(ONE, x16)\n    x18 = branch(x17, vline, hline)\n    x19 = compose(center, first)\n    x20 = compose(center, last)\n    x21 = fork(add, x19, x20)\n    x22 = compose(halve, x21)\n    x23 = compose(color, first)\n    x24 = compose(color, last)\n    x25 = fork(connect, x19, x22)\n    x26 = fork(remove, x22, x25)\n    x27 = fork(recolor, x23, x26)\n    x28 = fork(connect, x20, x22)\n    x29 = fork(remove, x22, x28)\n    x30 = fork(recolor, x24, x29)\n    x31 = lbind(recolor, FIVE)\n    x32 = chain(x31, initset, x22)\n    x33 = fork(combine, x27, x30)\n    x34 = fork(combine, x33, x32)\n    x35 = apply(x34, x12)\n    x36 = mfilter(x35, x18)\n    x37 = paint(I, x36)\n    x38 = merge(x0)\n    x39 = paint(x37, x38)\n    return x39\n\n",
    "annotated": "def verify_29c11459(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    # Create all possible pairs of objects\n    x1 = product(x0, x0)\n    # Create a function to check if two objects are horizontally aligned\n    x2 = fork(hmatching, first, last)\n    # Create a function to check if two objects are vertically aligned\n    x3 = fork(vmatching, first, last)\n    # Create a function to check if two objects are either horizontally or vertically aligned\n    x4 = fork(either, x2, x3)\n    # Filter object pairs to keep only those that are aligned\n    x5 = sfilter(x1, x4)\n    # Get the most common color in the input grid (background color)\n    x6 = mostcolor(I)\n    # Create a function to convert a patch to an object in the context of the input grid\n    x7 = rbind(toobject, I)\n    # Create a function to get the delta (non-object cells) of merged objects\n    x8 = compose(delta, merge)\n    # Create a function to get the palette of colors in the delta of merged objects\n    x9 = chain(palette, x7, x8)\n    # Create a set containing only the background color\n    x10 = initset(x6)\n    # Create a function to check if the delta palette matches the background color set\n    x11 = matcher(x9, x10)\n    # Filter aligned object pairs to keep only those with matching delta palettes\n    x12 = sfilter(x5, x11)\n    # Get the shape (dimensions) of the input grid\n    x13 = shape(I)\n    # Calculate the shape of the grid excluding the top two rows\n    x14 = subtract(x13, TWO_BY_ZERO)\n    # Crop the input grid to exclude the top two rows\n    x15 = crop(I, DOWN, x14)\n    # Count the number of colors in the cropped grid\n    x16 = numcolors(x15)\n    # Check if there's only one color in the cropped grid\n    x17 = equality(ONE, x16)\n    # Choose between vertical and horizontal line based on the color count\n    x18 = branch(x17, vline, hline)\n    # Create a function to get the center of the first object in a pair\n    x19 = compose(center, first)\n    # Create a function to get the center of the second object in a pair\n    x20 = compose(center, last)\n    # Create a function to add the centers of both objects in a pair\n    x21 = fork(add, x19, x20)\n    # Create a function to get the midpoint between the two objects\n    x22 = compose(halve, x21)\n    # Create a function to get the color of the first object in a pair\n    x23 = compose(color, first)\n    # Create a function to get the color of the second object in a pair\n    x24 = compose(color, last)\n    # Create a function to get the line from the first object's center to the midpoint\n    x25 = fork(connect, x19, x22)\n    # Create a function to get the line from the first object's center to the midpoint, excluding the midpoint\n    x26 = fork(remove, x22, x25)\n    # Create a function to recolor the line from the first object with its color\n    x27 = fork(recolor, x23, x26)\n    # Create a function to get the line from the second object's center to the midpoint\n    x28 = fork(connect, x20, x22)\n    # Create a function to get the line from the second object's center to the midpoint, excluding the midpoint\n    x29 = fork(remove, x22, x28)\n    # Create a function to recolor the line from the second object with its color\n    x30 = fork(recolor, x24, x29)\n    # Create a function to recolor a cell with color 5\n    x31 = lbind(recolor, FIVE)\n    # Create a function to recolor the midpoint with color 5\n    x32 = chain(x31, initset, x22)\n    # Create a function to combine the recolored lines from both objects\n    x33 = fork(combine, x27, x30)\n    # Create a function to combine the recolored lines and the midpoint\n    x34 = fork(combine, x33, x32)\n    # Apply the recoloring function to all aligned object pairs\n    x35 = apply(x34, x12)\n    # Filter and merge the recolored lines based on their orientation (vertical or horizontal)\n    x36 = mfilter(x35, x18)\n    # Paint the recolored lines onto the input grid\n    x37 = paint(I, x36)\n    # Merge all objects from the input grid\n    x38 = merge(x0)\n    # Paint the merged objects onto the grid with recolored lines\n    x39 = paint(x37, x38)\n    # Return the final transformed grid\n    return x39\n"
  },
  "29ec7d0e": {
    "original": "def verify_29ec7d0e(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = objects(I, T, F, F)\n    x2 = lbind(colorfilter, x1)\n    x3 = compose(size, x2)\n    x4 = valmin(x0, x3)\n    x5 = matcher(x3, x4)\n    x6 = sfilter(x0, x5)\n    x7 = lbind(colorcount, I)\n    x8 = argmin(x6, x7)\n    x9 = asobject(I)\n    x10 = matcher(first, x8)\n    x11 = compose(flip, x10)\n    x12 = sfilter(x9, x11)\n    x13 = lbind(contained, x8)\n    x14 = compose(flip, x13)\n    x15 = sfilter(I, x14)\n    x16 = asobject(x15)\n    x17 = hperiod(x16)\n    x18 = dmirror(I)\n    x19 = sfilter(x18, x14)\n    x20 = asobject(x19)\n    x21 = hperiod(x20)\n    x22 = (x21, x17)\n    x23 = lbind(multiply, x22)\n    x24 = neighbors(ORIGIN)\n    x25 = mapply(neighbors, x24)\n    x26 = apply(x23, x25)\n    x27 = lbind(shift, x12)\n    x28 = mapply(x27, x26)\n    x29 = paint(I, x28)\n    return x29\n\n",
    "annotated": "def verify_29ec7d0e(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Find all objects in the grid, allowing diagonal connections and including the background\n    x1 = objects(I, T, F, F)\n    \n    # Create a function to filter objects by color\n    x2 = lbind(colorfilter, x1)\n    \n    # Create a function to get the size of color-filtered objects\n    x3 = compose(size, x2)\n    \n    # Find the color with the smallest object size\n    x4 = valmin(x0, x3)\n    \n    # Create a function to match objects with the smallest size\n    x5 = matcher(x3, x4)\n    \n    # Filter colors to get those with the smallest object size\n    x6 = sfilter(x0, x5)\n    \n    # Create a function to count occurrences of a color in the input grid\n    x7 = lbind(colorcount, I)\n    \n    # Find the least common color among those with the smallest object size\n    x8 = argmin(x6, x7)\n    \n    # Convert the input grid to an object representation\n    x9 = asobject(I)\n    \n    # Create a function to match cells with the identified color\n    x10 = matcher(first, x8)\n    \n    # Create a function to match cells that are not of the identified color\n    x11 = compose(flip, x10)\n    \n    # Filter the grid object to keep only cells not of the identified color\n    x12 = sfilter(x9, x11)\n    \n    # Create a function to check if a cell contains the identified color\n    x13 = lbind(contained, x8)\n    \n    # Create a function to check if a cell does not contain the identified color\n    x14 = compose(flip, x13)\n    \n    # Filter the input grid to keep only cells not of the identified color\n    x15 = sfilter(I, x14)\n    \n    # Convert the filtered grid to an object representation\n    x16 = asobject(x15)\n    \n    # Find the horizontal periodicity of the filtered grid object\n    x17 = hperiod(x16)\n    \n    # Create a diagonally mirrored version of the input grid\n    x18 = dmirror(I)\n    \n    # Filter the mirrored grid to keep only cells not of the identified color\n    x19 = sfilter(x18, x14)\n    \n    # Convert the filtered mirrored grid to an object representation\n    x20 = asobject(x19)\n    \n    # Find the horizontal periodicity of the filtered mirrored grid object\n    x21 = hperiod(x20)\n    \n    # Create a tuple of the two periodicities (vertical, horizontal)\n    x22 = (x21, x17)\n    \n    # Create a function to multiply a vector by the periodicity tuple\n    x23 = lbind(multiply, x22)\n    \n    # Get the neighboring cells of the origin\n    x24 = neighbors(ORIGIN)\n    \n    # Get the neighbors of the neighboring cells\n    x25 = mapply(neighbors, x24)\n    \n    # Apply the periodicity multiplication to the extended neighborhood\n    x26 = apply(x23, x25)\n    \n    # Create a function to shift the non-identified color cells\n    x27 = lbind(shift, x12)\n    \n    # Apply the shift function to the periodicity-adjusted positions\n    x28 = mapply(x27, x26)\n    \n    # Paint the shifted non-identified color cells onto the input grid\n    x29 = paint(I, x28)\n    \n    # Return the final modified grid\n    return x29\n"
  },
  "2bcee788": {
    "original": "def verify_2bcee788(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = remove(x2, x0)\n    x4 = argmin(x3, size)\n    x5 = argmax(x3, size)\n    x6 = hmatching(x4, x5)\n    x7 = branch(x6, vmirror, hmirror)\n    x8 = x7(x5)\n    x9 = branch(x6, leftmost, uppermost)\n    x10 = branch(x6, tojvec, toivec)\n    x11 = x9(x4)\n    x12 = x9(x5)\n    x13 = greater(x11, x12)\n    x14 = double(x13)\n    x15 = decrement(x14)\n    x16 = x10(x15)\n    x17 = shape(x5)\n    x18 = multiply(x16, x17)\n    x19 = shift(x8, x18)\n    x20 = fill(I, THREE, x2)\n    x21 = paint(x20, x19)\n    return x21\n\n",
    "annotated": "def verify_2bcee788(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Find the largest object (background) based on area\n    x2 = argmax(x0, x1)\n    \n    # Remove the background object from the set of objects\n    x3 = remove(x2, x0)\n    \n    # Find the smallest non-background object (separator)\n    x4 = argmin(x3, size)\n    \n    # Find the largest non-background object (main shape)\n    x5 = argmax(x3, size)\n    \n    # Check if the separator and main shape are horizontally aligned\n    x6 = hmatching(x4, x5)\n    \n    # Choose vertical or horizontal mirroring based on alignment\n    x7 = branch(x6, vmirror, hmirror)\n    \n    # Mirror the main shape\n    x8 = x7(x5)\n    \n    # Choose leftmost or uppermost function based on alignment\n    x9 = branch(x6, leftmost, uppermost)\n    \n    # Choose horizontal or vertical vector creation based on alignment\n    x10 = branch(x6, tojvec, toivec)\n    \n    # Get the leftmost/uppermost coordinate of the separator\n    x11 = x9(x4)\n    \n    # Get the leftmost/uppermost coordinate of the main shape\n    x12 = x9(x5)\n    \n    # Check if the separator is to the right/below the main shape\n    x13 = greater(x11, x12)\n    \n    # Double the boolean result (0 -> 0, 1 -> 2)\n    x14 = double(x13)\n    \n    # Decrement the result (0 -> -1, 2 -> 1)\n    x15 = decrement(x14)\n    \n    # Create a vector for shifting based on alignment and position\n    x16 = x10(x15)\n    \n    # Get the shape (dimensions) of the main object\n    x17 = shape(x5)\n    \n    # Calculate the shift amount by multiplying the vector with the shape\n    x18 = multiply(x16, x17)\n    \n    # Shift the mirrored main shape to its new position\n    x19 = shift(x8, x18)\n    \n    # Fill the background with color 3\n    x20 = fill(I, THREE, x2)\n    \n    # Paint the shifted mirrored shape onto the new background\n    x21 = paint(x20, x19)\n    \n    # Return the final grid\n    return x21\n"
  },
  "2bee17df": {
    "original": "def verify_2bee17df(I: Grid) -> Grid:\n    x0 = trim(I)\n    x1 = mostcolor(x0)\n    x2 = repeat(x1, ONE)\n    x3 = lbind(repeat, THREE)\n    x4 = compose(x3, size)\n    x5 = matcher(dedupe, x2)\n    x6 = rbind(branch, identity)\n    x7 = rbind(x6, x4)\n    x8 = compose(x7, x5)\n    x9 = compose(initset, x8)\n    x10 = fork(rapply, x9, identity)\n    x11 = compose(first, x10)\n    x12 = apply(x11, x0)\n    x13 = dmirror(x0)\n    x14 = apply(x11, x13)\n    x15 = dmirror(x14)\n    x16 = ofcolor(x12, THREE)\n    x17 = ofcolor(x15, THREE)\n    x18 = combine(x16, x17)\n    x19 = shift(x18, UNITY)\n    x20 = fill(I, THREE, x19)\n    return x20\n\n",
    "annotated": "def verify_2bee17df(I: Grid) -> Grid:\n    # Remove any empty rows/columns from the input grid\n    x0 = trim(I)\n    # Find the most common color in the trimmed grid (background color)\n    x1 = mostcolor(x0)\n    # Create a tuple with the background color repeated once\n    x2 = repeat(x1, ONE)\n    # Create a function that repeats the color 3 a given number of times\n    x3 = lbind(repeat, THREE)\n    # Create a function that determines the size of input and repeats color 3 that many times\n    x4 = compose(x3, size)\n    # Create a function that checks if the input matches the background color tuple\n    x5 = matcher(dedupe, x2)\n    # Create a function that branches based on a condition, returning the identity if false\n    x6 = rbind(branch, identity)\n    # Combine the branching function with the color 3 repetition function\n    x7 = rbind(x6, x4)\n    # Create a function that applies the branching logic based on background color matching\n    x8 = compose(x7, x5)\n    # Wrap the result of the previous function in a set\n    x9 = compose(initset, x8)\n    # Create a function that applies x9 and the identity function to an input\n    x10 = fork(rapply, x9, identity)\n    # Extract the first element from the result of x10\n    x11 = compose(first, x10)\n    # Apply x11 to each row of the trimmed input grid\n    x12 = apply(x11, x0)\n    # Create a diagonal mirror of the trimmed input grid\n    x13 = dmirror(x0)\n    # Apply x11 to each row of the diagonally mirrored grid\n    x14 = apply(x11, x13)\n    # Diagonally mirror the result back to the original orientation\n    x15 = dmirror(x14)\n    # Find all cells with color 3 in x12 (horizontal frontiers)\n    x16 = ofcolor(x12, THREE)\n    # Find all cells with color 3 in x15 (vertical frontiers)\n    x17 = ofcolor(x15, THREE)\n    # Combine the horizontal and vertical frontiers\n    x18 = combine(x16, x17)\n    # Shift the combined frontiers by (1, 1) to account for trimming\n    x19 = shift(x18, UNITY)\n    # Fill the cells in the original input grid corresponding to the frontiers with color 3\n    x20 = fill(I, THREE, x19)\n    # Return the modified grid with frontiers highlighted in color 3\n    return x20\n"
  },
  "2c608aff": {
    "original": "def verify_2c608aff(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = sfilter(x0, x1)\n    x3 = argmax(x2, size)\n    x4 = color(x3)\n    x5 = palette(I)\n    x6 = remove(x4, x5)\n    x7 = lbind(colorcount, I)\n    x8 = argmin(x6, x7)\n    x9 = toindices(x3)\n    x10 = apply(first, x9)\n    x11 = toindices(x3)\n    x12 = apply(last, x11)\n    x13 = rbind(contained, x10)\n    x14 = compose(x13, first)\n    x15 = rbind(contained, x12)\n    x16 = compose(x15, last)\n    x17 = fork(either, x14, x16)\n    x18 = ofcolor(I, x8)\n    x19 = sfilter(x18, x17)\n    x20 = rbind(gravitate, x3)\n    x21 = compose(x20, initset)\n    x22 = fork(add, identity, x21)\n    x23 = fork(connect, identity, x22)\n    x24 = mapply(x23, x19)\n    x25 = fill(I, x8, x24)\n    return x25\n\n",
    "annotated": "def verify_2c608aff(I: Grid) -> Grid:\n    x0 = partition(I)  # Divide the input grid into objects based on color\n    x1 = fork(equality, toindices, backdrop)  # Create a function to check if an object's indices match its bounding box\n    x2 = sfilter(x0, x1)  # Filter objects to keep only those that form solid rectangles\n    x3 = argmax(x2, size)  # Find the largest solid rectangle (the main box)\n    x4 = color(x3)  # Get the color of the main box\n    x5 = palette(I)  # Get all colors used in the input grid\n    x6 = remove(x4, x5)  # Remove the box color from the palette (leaving background and noise colors)\n    x7 = lbind(colorcount, I)  # Create a function to count occurrences of a color in the input grid\n    x8 = argmin(x6, x7)  # Find the least common color among non-box colors (likely the noise color)\n    x9 = toindices(x3)  # Get the indices of all cells in the main box\n    x10 = apply(first, x9)  # Get the top-left corner of the box\n    x11 = toindices(x3)  # Get the indices of all cells in the main box (again)\n    x12 = apply(last, x11)  # Get the bottom-right corner of the box\n    x13 = rbind(contained, x10)  # Create a function to check if a point's row is within the box's rows\n    x14 = compose(x13, first)  # Create a function to check if a point's row is within the box's rows (using only the row coordinate)\n    x15 = rbind(contained, x12)  # Create a function to check if a point's column is within the box's columns\n    x16 = compose(x15, last)  # Create a function to check if a point's column is within the box's columns (using only the column coordinate)\n    x17 = fork(either, x14, x16)  # Create a function to check if a point aligns horizontally or vertically with the box\n    x18 = ofcolor(I, x8)  # Find all cells with the noise color\n    x19 = sfilter(x18, x17)  # Keep only noise cells that align horizontally or vertically with the box\n    x20 = rbind(gravitate, x3)  # Create a function to find the direction from a point to the nearest edge of the box\n    x21 = compose(x20, initset)  # Create a function to find the direction from a single-element set to the box\n    x22 = fork(add, identity, x21)  # Create a function to find the endpoint on the box for a line from a noise point\n    x23 = fork(connect, identity, x22)  # Create a function to generate a line from a noise point to the box\n    x24 = mapply(x23, x19)  # Generate lines from all aligned noise points to the box\n    x25 = fill(I, x8, x24)  # Draw the generated lines on the input grid using the noise color\n    return x25  # Return the modified grid with lines connecting noise points to the box\n\n# This function identifies the main box and noise points in the input grid,\n# then draws lines from noise points to the box if they align horizontally or vertically.\n"
  },
  "2dc579da": {
    "original": "def verify_2dc579da(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = mfilter(x0, hline)\n    x2 = mfilter(x0, vline)\n    x3 = uppermost(x1)\n    x4 = leftmost(x2)\n    x5 = astuple(x3, x4)\n    x6 = add(x5, NEG_UNITY)\n    x7 = uppermost(x1)\n    x8 = rightmost(x2)\n    x9 = astuple(x7, x8)\n    x10 = add(x9, UP_RIGHT)\n    x11 = lowermost(x1)\n    x12 = leftmost(x2)\n    x13 = astuple(x11, x12)\n    x14 = add(x13, DOWN_LEFT)\n    x15 = lowermost(x1)\n    x16 = rightmost(x2)\n    x17 = astuple(x15, x16)\n    x18 = add(x17, UNITY)\n    x19 = initset(ORIGIN)\n    x20 = insert(x6, x19)\n    x21 = width(I)\n    x22 = decrement(x21)\n    x23 = tojvec(x22)\n    x24 = initset(x23)\n    x25 = insert(x10, x24)\n    x26 = height(I)\n    x27 = decrement(x26)\n    x28 = toivec(x27)\n    x29 = initset(x28)\n    x30 = insert(x14, x29)\n    x31 = shape(I)\n    x32 = decrement(x31)\n    x33 = initset(x32)\n    x34 = insert(x18, x33)\n    x35 = astuple(x20, x25)\n    x36 = astuple(x30, x34)\n    x37 = combine(x35, x36)\n    x38 = rbind(toobject, I)\n    x39 = compose(x38, backdrop)\n    x40 = apply(x39, x37)\n    x41 = matcher(numcolors, ONE)\n    x42 = sfilter(x40, x41)\n    x43 = apply(color, x42)\n    x44 = mostcommon(x43)\n    x45 = initset(x44)\n    x46 = matcher(palette, x45)\n    x47 = compose(flip, x46)\n    x48 = extract(x40, x47)\n    x49 = subgrid(x48, I)\n    return x49\n\n",
    "annotated": "def verify_2dc579da(I: Grid) -> Grid:\n    # Get all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out horizontal lines from the frontiers\n    x1 = mfilter(x0, hline)\n    # Filter out vertical lines from the frontiers\n    x2 = mfilter(x0, vline)\n    # Get the topmost row of horizontal lines\n    x3 = uppermost(x1)\n    # Get the leftmost column of vertical lines\n    x4 = leftmost(x2)\n    # Create a tuple of the topmost row and leftmost column\n    x5 = astuple(x3, x4)\n    # Move the point one step up and left (to the corner of the inner rectangle)\n    x6 = add(x5, NEG_UNITY)\n    # Get the topmost row of horizontal lines again\n    x7 = uppermost(x1)\n    # Get the rightmost column of vertical lines\n    x8 = rightmost(x2)\n    # Create a tuple of the topmost row and rightmost column\n    x9 = astuple(x7, x8)\n    # Move the point one step up and right (to the corner of the inner rectangle)\n    x10 = add(x9, UP_RIGHT)\n    # Get the bottommost row of horizontal lines\n    x11 = lowermost(x1)\n    # Get the leftmost column of vertical lines again\n    x12 = leftmost(x2)\n    # Create a tuple of the bottommost row and leftmost column\n    x13 = astuple(x11, x12)\n    # Move the point one step down and left (to the corner of the inner rectangle)\n    x14 = add(x13, DOWN_LEFT)\n    # Get the bottommost row of horizontal lines again\n    x15 = lowermost(x1)\n    # Get the rightmost column of vertical lines again\n    x16 = rightmost(x2)\n    # Create a tuple of the bottommost row and rightmost column\n    x17 = astuple(x15, x16)\n    # Move the point one step down and right (to the corner of the inner rectangle)\n    x18 = add(x17, UNITY)\n    # Create a set with the origin point (0,0)\n    x19 = initset(ORIGIN)\n    # Add the top-left corner of the inner rectangle to the set\n    x20 = insert(x6, x19)\n    # Get the width of the input grid\n    x21 = width(I)\n    # Decrease the width by 1\n    x22 = decrement(x21)\n    # Create a vector pointing to the rightmost column\n    x23 = tojvec(x22)\n    # Create a set with this vector\n    x24 = initset(x23)\n    # Add the top-right corner of the inner rectangle to the set\n    x25 = insert(x10, x24)\n    # Get the height of the input grid\n    x26 = height(I)\n    # Decrease the height by 1\n    x27 = decrement(x26)\n    # Create a vector pointing to the bottommost row\n    x28 = toivec(x27)\n    # Create a set with this vector\n    x29 = initset(x28)\n    # Add the bottom-left corner of the inner rectangle to the set\n    x30 = insert(x14, x29)\n    # Get the shape (height, width) of the input grid\n    x31 = shape(I)\n    # Decrease both dimensions by 1\n    x32 = decrement(x31)\n    # Create a set with this shape\n    x33 = initset(x32)\n    # Add the bottom-right corner of the inner rectangle to the set\n    x34 = insert(x18, x33)\n    # Combine the top corners into a tuple\n    x35 = astuple(x20, x25)\n    # Combine the bottom corners into a tuple\n    x36 = astuple(x30, x34)\n    # Combine all corners into a single container\n    x37 = combine(x35, x36)\n    # Create a function that converts a patch to an object using the input grid\n    x38 = rbind(toobject, I)\n    # Create a function that gets the backdrop of an object\n    x39 = compose(x38, backdrop)\n    # Apply this function to all corners, getting the objects at these locations\n    x40 = apply(x39, x37)\n    # Create a function that checks if an object has only one color\n    x41 = matcher(numcolors, ONE)\n    # Filter the objects to keep only those with one color\n    x42 = sfilter(x40, x41)\n    # Get the color of each remaining object\n    x43 = apply(color, x42)\n    # Find the most common color among these objects (likely the background color)\n    x44 = mostcommon(x43)\n    # Create a set with this color\n    x45 = initset(x44)\n    # Create a function that checks if an object's palette matches this color set\n    x46 = matcher(palette, x45)\n    # Invert this function (to find objects that don't match the background color)\n    x47 = compose(flip, x46)\n    # Find the first object that doesn't match the background color (likely the dot)\n    x48 = extract(x40, x47)\n    # Extract the subgrid containing this object from the input grid\n    x49 = subgrid(x48, I)\n    # Return this subgrid (which should be the top-left quadrant containing the dot)\n    return x49\n"
  },
  "2dd70a9a": {
    "original": "def verify_2dd70a9a(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = vline(x0)\n    x2 = branch(x1, dmirror, identity)\n    x3 = x2(I)\n    x4 = ofcolor(x3, THREE)\n    x5 = ofcolor(x3, TWO)\n    x6 = center(x4)\n    x7 = hfrontier(x6)\n    x8 = center(x5)\n    x9 = hfrontier(x8)\n    x10 = mostcolor(I)\n    x11 = palette(I)\n    x12 = remove(THREE, x11)\n    x13 = remove(TWO, x12)\n    x14 = other(x13, x10)\n    x15 = replace(x3, THREE, x10)\n    x16 = difference(x7, x4)\n    x17 = underfill(x15, THREE, x16)\n    x18 = replace(x3, TWO, x10)\n    x19 = difference(x9, x5)\n    x20 = underfill(x18, TWO, x19)\n    x21 = objects(x17, T, F, F)\n    x22 = colorfilter(x21, THREE)\n    x23 = rbind(adjacent, x4)\n    x24 = sfilter(x22, x23)\n    x25 = objects(x20, T, F, F)\n    x26 = colorfilter(x25, TWO)\n    x27 = rbind(adjacent, x5)\n    x28 = sfilter(x26, x27)\n    x29 = mapply(toindices, x24)\n    x30 = rbind(equality, x14)\n    x31 = lbind(index, x3)\n    x32 = compose(x30, x31)\n    x33 = rbind(add, LEFT)\n    x34 = compose(x32, x33)\n    x35 = rbind(add, RIGHT)\n    x36 = compose(x32, x35)\n    x37 = fork(either, x34, x36)\n    x38 = rbind(add, UP)\n    x39 = compose(x32, x38)\n    x40 = rbind(add, DOWN)\n    x41 = compose(x32, x40)\n    x42 = fork(either, x39, x41)\n    x43 = sfilter(x29, x37)\n    x44 = mapply(toindices, x28)\n    x45 = sfilter(x44, x42)\n    x46 = fork(connect, first, last)\n    x47 = product(x43, x45)\n    x48 = compose(vline, x46)\n    x49 = rbind(toobject, x3)\n    x50 = chain(numcolors, x49, x46)\n    x51 = matcher(x50, ONE)\n    x52 = fork(both, x48, x51)\n    x53 = extract(x47, x52)\n    x54 = x46(x53)\n    x55 = center(x4)\n    x56 = center(x5)\n    x57 = fork(either, hline, vline)\n    x58 = lbind(connect, x55)\n    x59 = corners(x54)\n    x60 = apply(x58, x59)\n    x61 = mfilter(x60, x57)\n    x62 = lbind(connect, x56)\n    x63 = corners(x54)\n    x64 = apply(x62, x63)\n    x65 = mfilter(x64, x57)\n    x66 = combine(x61, x65)\n    x67 = combine(x54, x66)\n    x68 = fill(x3, THREE, x67)\n    x69 = fill(x68, TWO, x5)\n    x70 = x2(x69)\n    return x70\n\n",
    "annotated": "def verify_2dd70a9a(I: Grid) -> Grid:\n    # Find all cells with color 2 in the input grid\n    x0 = ofcolor(I, TWO)\n    # Check if these cells form a vertical line\n    x1 = vline(x0)\n    # If it's a vertical line, apply diagonal mirror, otherwise do nothing\n    x2 = branch(x1, dmirror, identity)\n    # Apply the chosen transformation (mirror or identity) to the input grid\n    x3 = x2(I)\n    # Find all cells with color 3 in the transformed grid\n    x4 = ofcolor(x3, THREE)\n    # Find all cells with color 2 in the transformed grid\n    x5 = ofcolor(x3, TWO)\n    # Find the center of the color 3 cells\n    x6 = center(x4)\n    # Create a horizontal line passing through the center of color 3 cells\n    x7 = hfrontier(x6)\n    # Find the center of the color 2 cells\n    x8 = center(x5)\n    # Create a horizontal line passing through the center of color 2 cells\n    x9 = hfrontier(x8)\n    # Find the most common color in the input grid (background color)\n    x10 = mostcolor(I)\n    # Get all colors used in the input grid\n    x11 = palette(I)\n    # Remove color 3 from the palette\n    x12 = remove(THREE, x11)\n    # Remove color 2 from the palette\n    x13 = remove(TWO, x12)\n    # Find the color that's not the background color (foreground color)\n    x14 = other(x13, x10)\n    # Replace color 3 with the background color in the transformed grid\n    x15 = replace(x3, THREE, x10)\n    # Find cells on the horizontal line through color 3 center that are not color 3\n    x16 = difference(x7, x4)\n    # Fill these cells with color 3, but only if they were background color\n    x17 = underfill(x15, THREE, x16)\n    # Replace color 2 with the background color in the transformed grid\n    x18 = replace(x3, TWO, x10)\n    # Find cells on the horizontal line through color 2 center that are not color 2\n    x19 = difference(x9, x5)\n    # Fill these cells with color 2, but only if they were background color\n    x20 = underfill(x18, TWO, x19)\n    # Find all objects in the grid with color 3 extension\n    x21 = objects(x17, T, F, F)\n    # Filter objects to keep only those of color 3\n    x22 = colorfilter(x21, THREE)\n    # Create a function to check if an object is adjacent to the original color 3 cells\n    x23 = rbind(adjacent, x4)\n    # Filter color 3 objects to keep only those adjacent to original color 3 cells\n    x24 = sfilter(x22, x23)\n    # Find all objects in the grid with color 2 extension\n    x25 = objects(x20, T, F, F)\n    # Filter objects to keep only those of color 2\n    x26 = colorfilter(x25, TWO)\n    # Create a function to check if an object is adjacent to the original color 2 cells\n    x27 = rbind(adjacent, x5)\n    # Filter color 2 objects to keep only those adjacent to original color 2 cells\n    x28 = sfilter(x26, x27)\n    # Convert color 3 objects to indices\n    x29 = mapply(toindices, x24)\n    # Create a function to check if a cell has the foreground color\n    x30 = rbind(equality, x14)\n    # Create a function to get the color of a cell in the transformed grid\n    x31 = lbind(index, x3)\n    # Combine the above two functions\n    x32 = compose(x30, x31)\n    # Create a function to check if the cell to the left has the foreground color\n    x33 = rbind(add, LEFT)\n    x34 = compose(x32, x33)\n    # Create a function to check if the cell to the right has the foreground color\n    x35 = rbind(add, RIGHT)\n    x36 = compose(x32, x35)\n    # Combine left and right checks\n    x37 = fork(either, x34, x36)\n    # Create a function to check if the cell above has the foreground color\n    x38 = rbind(add, UP)\n    x39 = compose(x32, x38)\n    # Create a function to check if the cell below has the foreground color\n    x40 = rbind(add, DOWN)\n    x41 = compose(x32, x40)\n    # Combine up and down checks\n    x42 = fork(either, x39, x41)\n    # Filter color 3 indices to keep only those with foreground color on left or right\n    x43 = sfilter(x29, x37)\n    # Convert color 2 objects to indices\n    x44 = mapply(toindices, x28)\n    # Filter color 2 indices to keep only those with foreground color above or below\n    x45 = sfilter(x44, x42)\n    # Create a function to connect the first and last points of a set\n    x46 = fork(connect, first, last)\n    # Create all possible pairs of color 3 and color 2 indices\n    x47 = product(x43, x45)\n    # Create a function to check if the connection forms a vertical line\n    x48 = compose(vline, x46)\n    # Create a function to convert a connection to an object in the transformed grid\n    x49 = rbind(toobject, x3)\n    # Create a function to count colors in the connection\n    x50 = chain(numcolors, x49, x46)\n    # Create a function to check if the connection has only one color\n    x51 = matcher(x50, ONE)\n    # Combine vertical line and single color checks\n    x52 = fork(both, x48, x51)\n    # Find the first valid connection between color 3 and color 2 indices\n    x53 = extract(x47, x52)\n    # Create the connection line\n    x54 = x46(x53)\n    # Find the center of the color 3 cells\n    x55 = center(x4)\n    # Find the center of the color 2 cells\n    x56 = center(x5)\n    # Create a function to check if a line is horizontal or vertical\n    x57 = fork(either, hline, vline)\n    # Create a function to connect the color 3 center to a point\n    x58 = lbind(connect, x55)\n    # Find the corner points of the connection line\n    x59 = corners(x54)\n    # Connect the color 3 center to all corner points\n    x60 = apply(x58, x59)\n    # Keep only horizontal or vertical lines from color 3 center\n    x61 = mfilter(x60, x57)\n    # Create a function to connect the color 2 center to a point\n    x62 = lbind(connect, x56)\n    # Find the corner points of the connection line (again)\n    x63 = corners(x54)\n    # Connect the color 2 center to all corner points\n    x64 = apply(x62, x63)\n    # Keep only horizontal or vertical lines from color 2 center\n    x65 = mfilter(x64, x57)\n    # Combine all valid lines from both centers\n    x66 = combine(x61, x65)\n    # Add the main connection line to the set of valid lines\n    x67 = combine(x54, x66)\n    # Fill all valid lines with color 3 in the transformed grid\n    x68 = fill(x3, THREE, x67)\n    # Fill the original color 2 cells with color 2\n    x69 = fill(x68, TWO, x5)\n    # Apply the inverse transformation (if any) to get the final output grid\n    x70 = x2(x69)\n    return x70\n"
  },
  "2dee498d": {
    "original": "def verify_2dee498d(I: Grid) -> Grid:\n    x0 = hsplit(I, THREE)\n    x1 = first(x0)\n    return x1\n\n",
    "annotated": "def verify_2dee498d(I: Grid) -> Grid:\n    # Split the input grid horizontally into three equal parts\n    # This reverses the concatenation done in the generator\n    x0 = hsplit(I, THREE)\n    \n    # Select the first part of the split grid\n    # This effectively retrieves the original grid before concatenation\n    x1 = first(x0)\n    \n    # Return the first part as the output\n    # This reconstructs the original grid from the input\n    return x1\n"
  },
  "31aa019c": {
    "original": "def verify_31aa019c(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = first(x1)\n    x3 = neighbors(x2)\n    x4 = mostcolor(I)\n    x5 = shape(I)\n    x6 = canvas(x4, x5)\n    x7 = initset(x2)\n    x8 = fill(x6, x0, x7)\n    x9 = fill(x8, TWO, x3)\n    return x9\n\n",
    "annotated": "def verify_31aa019c(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    x0 = leastcolor(I)\n    \n    # Get the indices of cells with the least common color\n    x1 = ofcolor(I, x0)\n    \n    # Get the first (and only) index of the least common color\n    x2 = first(x1)\n    \n    # Get the neighboring indices of the least common color cell\n    x3 = neighbors(x2)\n    \n    # Find the most common color in the input grid (background color)\n    x4 = mostcolor(I)\n    \n    # Get the dimensions of the input grid\n    x5 = shape(I)\n    \n    # Create a new grid with the same size as input, filled with background color\n    x6 = canvas(x4, x5)\n    \n    # Create a set with only the index of the least common color\n    x7 = initset(x2)\n    \n    # Fill the new grid with the least common color at its original position\n    x8 = fill(x6, x0, x7)\n    \n    # Fill the neighbors of the least common color cell with color 2\n    # This creates a \"halo\" effect around the least common color\n    x9 = fill(x8, TWO, x3)\n    \n    # Return the resulting grid\n    return x9\n"
  },
  "321b1fc6": {
    "original": "def verify_321b1fc6(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = argmax(x0, numcolors)\n    x2 = remove(x1, x0)\n    x3 = normalize(x1)\n    x4 = apply(ulcorner, x2)\n    x5 = lbind(shift, x3)\n    x6 = mapply(x5, x4)\n    x7 = paint(I, x6)\n    x8 = cover(x7, x1)\n    return x8\n\n",
    "annotated": "def verify_321b1fc6(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, F, F, T)\n    \n    # Select the object with the most colors (likely the template shape)\n    x1 = argmax(x0, numcolors)\n    \n    # Remove the template shape from the set of objects\n    x2 = remove(x1, x0)\n    \n    # Normalize the position of the template shape (move it to the origin)\n    x3 = normalize(x1)\n    \n    # Get the upper-left corners of all remaining objects (copies of the template)\n    x4 = apply(ulcorner, x2)\n    \n    # Create a function that shifts the normalized template shape\n    x5 = lbind(shift, x3)\n    \n    # Apply the shift function to all upper-left corners, effectively placing template copies\n    x6 = mapply(x5, x4)\n    \n    # Paint all the shifted template copies onto the input grid\n    x7 = paint(I, x6)\n    \n    # Remove the original template shape from the grid by covering it with the background color\n    x8 = cover(x7, x1)\n    \n    # Return the final grid with the original shape removed and copies painted\n    return x8\n"
  },
  "32597951": {
    "original": "def verify_32597951(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmin(x0, x1)\n    x3 = delta(x2)\n    x4 = fill(I, THREE, x3)\n    return x4\n\n",
    "annotated": "def verify_32597951(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    # This separates the background, noise, and inner rectangle\n    x0 = partition(I)\n\n    # Create a function that multiplies the height and width of an object\n    # This calculates the area of each partitioned object\n    x1 = fork(multiply, height, width)\n\n    # Find the object with the smallest area\n    # This identifies the inner rectangle, as it's typically the smallest partition\n    x2 = argmin(x0, x1)\n\n    # Get the indices of cells in the bounding box of the inner rectangle,\n    # but not part of the inner rectangle itself\n    # This creates a border around the inner rectangle\n    x3 = delta(x2)\n\n    # Fill the border around the inner rectangle with color 3\n    # This adds the required outline to the inner rectangle\n    x4 = fill(I, THREE, x3)\n\n    # Return the modified grid with the outline added\n    return x4\n"
  },
  "3345333e": {
    "original": "def verify_3345333e(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = partition(I)\n    x5 = fork(multiply, height, width)\n    x6 = fork(equality, size, x5)\n    x7 = extract(x4, x6)\n    x8 = color(x7)\n    x9 = palette(I)\n    x10 = remove(x3, x9)\n    x11 = other(x10, x8)\n    x12 = ofcolor(I, x11)\n    x13 = vmirror(x12)\n    x14 = hmirror(x12)\n    x15 = toindices(x7)\n    x16 = combine(x15, x12)\n    x17 = height(x16)\n    x18 = halve(x17)\n    x19 = increment(x18)\n    x20 = width(x16)\n    x21 = halve(x20)\n    x22 = increment(x21)\n    x23 = astuple(x19, x22)\n    x24 = maximum(x23)\n    x25 = invert(x24)\n    x26 = increment(x24)\n    x27 = interval(x25, x26, ONE)\n    x28 = product(x27, x27)\n    x29 = initset(x14)\n    x30 = insert(x13, x29)\n    x31 = product(x28, x30)\n    x32 = ofcolor(I, x3)\n    x33 = rbind(intersection, x32)\n    x34 = fork(shift, last, first)\n    x35 = chain(size, x33, x34)\n    x36 = matcher(x35, ZERO)\n    x37 = sfilter(x31, x36)\n    x38 = rbind(intersection, x12)\n    x39 = fork(shift, last, first)\n    x40 = chain(size, x38, x39)\n    x41 = argmax(x37, x40)\n    x42 = first(x41)\n    x43 = last(x41)\n    x44 = fill(I, x3, x7)\n    x45 = shift(x43, x42)\n    x46 = fill(x44, x11, x45)\n    return x46\n\n",
    "annotated": "def verify_3345333e(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    # Create a box outline around the entire grid\n    x1 = box(x0)\n    # Convert the box outline to an object (with color information)\n    x2 = toobject(x1, I)\n    # Find the most common color in the box outline (likely the background color)\n    x3 = mostcolor(x2)\n    # Partition the input grid into objects based on color\n    x4 = partition(I)\n    # Create a function that multiplies height and width\n    x5 = fork(multiply, height, width)\n    # Create a function that checks if an object's size equals its height * width\n    x6 = fork(equality, size, x5)\n    # Extract the object that satisfies the condition (likely the occluding box)\n    x7 = extract(x4, x6)\n    # Get the color of the extracted object (occluding box color)\n    x8 = color(x7)\n    # Get all colors used in the input grid\n    x9 = palette(I)\n    # Remove the background color from the palette\n    x10 = remove(x3, x9)\n    # Get the color that's neither background nor occluding box (object color)\n    x11 = other(x10, x8)\n    # Get all cells of the object color\n    x12 = ofcolor(I, x11)\n    # Create a vertical mirror of the object\n    x13 = vmirror(x12)\n    # Create a horizontal mirror of the object\n    x14 = hmirror(x12)\n    # Get the indices of the occluding box\n    x15 = toindices(x7)\n    # Combine the occluding box indices with the object indices\n    x16 = combine(x15, x12)\n    # Get the height of the combined shape\n    x17 = height(x16)\n    # Halve the height\n    x18 = halve(x17)\n    # Increment the halved height\n    x19 = increment(x18)\n    # Get the width of the combined shape\n    x20 = width(x16)\n    # Halve the width\n    x21 = halve(x20)\n    # Increment the halved width\n    x22 = increment(x21)\n    # Create a tuple of the incremented half-height and half-width\n    x23 = astuple(x19, x22)\n    # Get the maximum of the two values\n    x24 = maximum(x23)\n    # Invert the maximum value (make it negative)\n    x25 = invert(x24)\n    # Increment the maximum value\n    x26 = increment(x24)\n    # Create an interval from the negative max to positive max+1\n    x27 = interval(x25, x26, ONE)\n    # Create a product of this interval with itself (all possible shifts)\n    x28 = product(x27, x27)\n    # Initialize a set with the horizontal mirror of the object\n    x29 = initset(x14)\n    # Insert the vertical mirror of the object into this set\n    x30 = insert(x13, x29)\n    # Create all possible combinations of shifts and mirrors\n    x31 = product(x28, x30)\n    # Get all cells of the background color\n    x32 = ofcolor(I, x3)\n    # Prepare a function to intersect with background cells\n    x33 = rbind(intersection, x32)\n    # Create a function to shift based on the product elements\n    x34 = fork(shift, last, first)\n    # Chain functions to get size of intersection with background after shift\n    x35 = chain(size, x33, x34)\n    # Create a function to match zero intersection with background\n    x36 = matcher(x35, ZERO)\n    # Filter the products to keep only those that don't intersect with background\n    x37 = sfilter(x31, x36)\n    # Prepare a function to intersect with object cells\n    x38 = rbind(intersection, x12)\n    # Reuse the shift function\n    x39 = fork(shift, last, first)\n    # Chain functions to get size of intersection with object after shift\n    x40 = chain(size, x38, x39)\n    # Find the shift and mirror that maximizes intersection with the object\n    x41 = argmax(x37, x40)\n    # Get the shift from the best match\n    x42 = first(x41)\n    # Get the mirror from the best match\n    x43 = last(x41)\n    # Fill the occluding box with the background color\n    x44 = fill(I, x3, x7)\n    # Apply the best shift to the best mirror of the object\n    x45 = shift(x43, x42)\n    # Fill the shifted mirror with the object color to complete the object\n    x46 = fill(x44, x11, x45)\n    # Return the reconstructed grid with the full object visible\n    return x46\n"
  },
  "3428a4f5": {
    "original": "def verify_3428a4f5(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = halve(x0)\n    x2 = tojvec(x1)\n    x3 = height(I)\n    x4 = decrement(x3)\n    x5 = astuple(x4, x1)\n    x6 = connect(x2, x5)\n    x7 = toobject(x6, I)\n    x8 = numcolors(x7)\n    x9 = equality(x8, ONE)\n    x10 = branch(x9, lefthalf, tophalf)\n    x11 = branch(x9, righthalf, bottomhalf)\n    x12 = x10(I)\n    x13 = x11(I)\n    x14 = palette(x12)\n    x15 = other(x14, ZERO)\n    x16 = palette(x13)\n    x17 = other(x16, ZERO)\n    x18 = shape(x12)\n    x19 = canvas(ZERO, x18)\n    x20 = ofcolor(x12, x15)\n    x21 = ofcolor(x13, x17)\n    x22 = combine(x20, x21)\n    x23 = intersection(x20, x21)\n    x24 = difference(x22, x23)\n    x25 = fill(x19, THREE, x24)\n    return x25\n\n",
    "annotated": "def verify_3428a4f5(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    \n    # Calculate half of the width (to find the middle column)\n    x1 = halve(x0)\n    \n    # Create a vector pointing to the middle column\n    x2 = tojvec(x1)\n    \n    # Get the height of the input grid\n    x3 = height(I)\n    \n    # Subtract 1 from the height (to get the bottom row index)\n    x4 = decrement(x3)\n    \n    # Create a tuple representing the bottom-middle point of the grid\n    x5 = astuple(x4, x1)\n    \n    # Create a line from the top-middle to the bottom-middle of the grid\n    x6 = connect(x2, x5)\n    \n    # Extract the colors along the vertical middle line\n    x7 = toobject(x6, I)\n    \n    # Count the number of unique colors in the middle line\n    x8 = numcolors(x7)\n    \n    # Check if there's only one color in the middle line\n    x9 = equality(x8, ONE)\n    \n    # If there's only one color, use lefthalf function, otherwise use tophalf\n    x10 = branch(x9, lefthalf, tophalf)\n    \n    # If there's only one color, use righthalf function, otherwise use bottomhalf\n    x11 = branch(x9, righthalf, bottomhalf)\n    \n    # Apply the chosen function (left/top half) to the input grid\n    x12 = x10(I)\n    \n    # Apply the chosen function (right/bottom half) to the input grid\n    x13 = x11(I)\n    \n    # Get the set of colors used in the first half\n    x14 = palette(x12)\n    \n    # Find the non-zero color in the first half\n    x15 = other(x14, ZERO)\n    \n    # Get the set of colors used in the second half\n    x16 = palette(x13)\n    \n    # Find the non-zero color in the second half\n    x17 = other(x16, ZERO)\n    \n    # Get the dimensions of the first half\n    x18 = shape(x12)\n    \n    # Create a new grid filled with zeros, same size as the first half\n    x19 = canvas(ZERO, x18)\n    \n    # Get the indices of cells with the non-zero color in the first half\n    x20 = ofcolor(x12, x15)\n    \n    # Get the indices of cells with the non-zero color in the second half\n    x21 = ofcolor(x13, x17)\n    \n    # Combine the indices from both halves\n    x22 = combine(x20, x21)\n    \n    # Find the indices where both halves have non-zero colors\n    x23 = intersection(x20, x21)\n    \n    # Get the indices where only one half has a non-zero color\n    x24 = difference(x22, x23)\n    \n    # Fill the new grid with 3's at the indices where only one half had a non-zero color\n    x25 = fill(x19, THREE, x24)\n    \n    # Return the resulting grid\n    return x25\n"
  },
  "3618c87e": {
    "original": "def verify_3618c87e(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, F, F)\n    x2 = sizefilter(x1, ONE)\n    x3 = totuple(x2)\n    x4 = apply(color, x3)\n    x5 = mostcommon(x4)\n    x6 = palette(I)\n    x7 = remove(x5, x6)\n    x8 = other(x7, x0)\n    x9 = replace(I, x5, x0)\n    x10 = ofcolor(I, x5)\n    x11 = repeat(x8, ONE)\n    x12 = rbind(equality, x11)\n    x13 = first(I)\n    x14 = dedupe(x13)\n    x15 = x12(x14)\n    x16 = last(I)\n    x17 = dedupe(x16)\n    x18 = x12(x17)\n    x19 = dmirror(I)\n    x20 = first(x19)\n    x21 = dedupe(x20)\n    x22 = x12(x21)\n    x23 = dmirror(I)\n    x24 = last(x23)\n    x25 = dedupe(x24)\n    x26 = x12(x25)\n    x27 = apply(last, x10)\n    x28 = apply(first, x10)\n    x29 = either(x15, x18)\n    x30 = branch(x29, x27, x28)\n    x31 = branch(x29, lbind, rbind)\n    x32 = lbind(x31, astuple)\n    x33 = branch(x29, height, width)\n    x34 = x33(I)\n    x35 = decrement(x34)\n    x36 = either(x15, x22)\n    x37 = branch(x36, ZERO, x35)\n    x38 = x32(x37)\n    x39 = apply(x38, x30)\n    x40 = fill(x9, x5, x39)\n    return x40\n\n",
    "annotated": "def verify_3618c87e(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Find all objects in the grid (connected components), allowing diagonal connections\n    x1 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those with size 1 (single pixels)\n    x2 = sizefilter(x1, ONE)\n    \n    # Convert the set of objects to a tuple\n    x3 = totuple(x2)\n    \n    # Get the color of each single-pixel object\n    x4 = apply(color, x3)\n    \n    # Find the most common color among the single-pixel objects (dot color)\n    x5 = mostcommon(x4)\n    \n    # Get all colors used in the input grid\n    x6 = palette(I)\n    \n    # Remove the dot color from the palette\n    x7 = remove(x5, x6)\n    \n    # Find the color that is neither background nor dot color (line color)\n    x8 = other(x7, x0)\n    \n    # Replace all dots with the background color in the grid\n    x9 = replace(I, x5, x0)\n    \n    # Find all positions of dots in the original grid\n    x10 = ofcolor(I, x5)\n    \n    # Create a single-element tuple containing the line color\n    x11 = repeat(x8, ONE)\n    \n    # Create a function that checks if a color equals the line color\n    x12 = rbind(equality, x11)\n    \n    # Get the first row of the input grid\n    x13 = first(I)\n    \n    # Remove duplicates from the first row\n    x14 = dedupe(x13)\n    \n    # Check if the line color is in the first row\n    x15 = x12(x14)\n    \n    # Get the last row of the input grid\n    x16 = last(I)\n    \n    # Remove duplicates from the last row\n    x17 = dedupe(x16)\n    \n    # Check if the line color is in the last row\n    x18 = x12(x17)\n    \n    # Create a diagonally mirrored version of the input grid\n    x19 = dmirror(I)\n    \n    # Get the first row of the mirrored grid (equivalent to first column of original)\n    x20 = first(x19)\n    \n    # Remove duplicates from the first column\n    x21 = dedupe(x20)\n    \n    # Check if the line color is in the first column\n    x22 = x12(x21)\n    \n    # Create another diagonally mirrored version of the input grid\n    x23 = dmirror(I)\n    \n    # Get the last row of the mirrored grid (equivalent to last column of original)\n    x24 = last(x23)\n    \n    # Remove duplicates from the last column\n    x25 = dedupe(x24)\n    \n    # Check if the line color is in the last column\n    x26 = x12(x25)\n    \n    # Get the second coordinate (column) of each dot position\n    x27 = apply(last, x10)\n    \n    # Get the first coordinate (row) of each dot position\n    x28 = apply(first, x10)\n    \n    # Check if the line is on the top or bottom of the grid\n    x29 = either(x15, x18)\n    \n    # If the line is on top/bottom, use column coordinates; otherwise, use row coordinates\n    x30 = branch(x29, x27, x28)\n    \n    # Choose between left-binding and right-binding based on line position\n    x31 = branch(x29, lbind, rbind)\n    \n    # Create a partially applied function to construct tuples\n    x32 = lbind(x31, astuple)\n    \n    # Choose between height and width based on line position\n    x33 = branch(x29, height, width)\n    \n    # Get the height or width of the grid\n    x34 = x33(I)\n    \n    # Decrement the height or width\n    x35 = decrement(x34)\n    \n    # Check if the line is on the top/left or bottom/right\n    x36 = either(x15, x22)\n    \n    # If line is on top/left, use 0; otherwise, use decremented height/width\n    x37 = branch(x36, ZERO, x35)\n    \n    # Create a function to construct coordinate tuples\n    x38 = x32(x37)\n    \n    # Apply the coordinate construction function to each dot position\n    x39 = apply(x38, x30)\n    \n    # Fill the grid with dots at their new positions\n    x40 = fill(x9, x5, x39)\n    \n    # Return the transformed grid\n    return x40\n"
  },
  "3631a71a": {
    "original": "def verify_3631a71a(I: Grid) -> Grid:\n    x0 = lbind(compose, flip)\n    x1 = lbind(matcher, first)\n    x2 = compose(x0, x1)\n    x3 = rbind(compose, asobject)\n    x4 = lbind(rbind, sfilter)\n    x5 = chain(x3, x4, x2)\n    x6 = rbind(shift, ORIGIN)\n    x7 = compose(x6, dmirror)\n    x8 = rbind(shift, TWO_BY_TWO)\n    x9 = compose(x8, cmirror)\n    x10 = rbind(shift, TWO_BY_ZERO)\n    x11 = compose(x10, hmirror)\n    x12 = rbind(shift, ZERO_BY_TWO)\n    x13 = compose(x12, vmirror)\n    x14 = lbind(fork, paint)\n    x15 = lbind(x14, identity)\n    x16 = lbind(compose, x7)\n    x17 = chain(x15, x16, x5)\n    x18 = lbind(compose, x9)\n    x19 = chain(x15, x18, x5)\n    x20 = lbind(compose, x11)\n    x21 = chain(x15, x20, x5)\n    x22 = lbind(compose, x13)\n    x23 = chain(x15, x22, x5)\n    x24 = rbind(rapply, I)\n    x25 = chain(first, x24, initset)\n    x26 = fork(compose, x23, x21)\n    x27 = fork(compose, x19, x17)\n    x28 = fork(compose, x26, x27)\n    x29 = compose(x25, x28)\n    x30 = palette(I)\n    x31 = fork(equality, identity, dmirror)\n    x32 = compose(x31, x29)\n    x33 = argmax(x30, x32)\n    x34 = x29(x33)\n    return x34\n\n",
    "annotated": "def verify_3631a71a(I: Grid) -> Grid:\n    # Create a function that composes a function with the 'flip' function\n    x0 = lbind(compose, flip)\n    \n    # Create a function that matches the first element of a tuple\n    x1 = lbind(matcher, first)\n    \n    # Compose the functions created in x0 and x1\n    x2 = compose(x0, x1)\n    \n    # Create a function that composes a function with 'asobject'\n    x3 = rbind(compose, asobject)\n    \n    # Create a function that binds 'sfilter' as the right argument\n    x4 = lbind(rbind, sfilter)\n    \n    # Chain the functions created in x3, x4, and x2\n    x5 = chain(x3, x4, x2)\n    \n    # Create a function that shifts to the origin\n    x6 = rbind(shift, ORIGIN)\n    \n    # Create a function that applies diagonal mirror and then shifts to origin\n    x7 = compose(x6, dmirror)\n    \n    # Create a function that shifts by (2,2)\n    x8 = rbind(shift, TWO_BY_TWO)\n    \n    # Create a function that applies counter-diagonal mirror and then shifts by (2,2)\n    x9 = compose(x8, cmirror)\n    \n    # Create a function that shifts by (2,0)\n    x10 = rbind(shift, TWO_BY_ZERO)\n    \n    # Create a function that applies horizontal mirror and then shifts by (2,0)\n    x11 = compose(x10, hmirror)\n    \n    # Create a function that shifts by (0,2)\n    x12 = rbind(shift, ZERO_BY_TWO)\n    \n    # Create a function that applies vertical mirror and then shifts by (0,2)\n    x13 = compose(x12, vmirror)\n    \n    # Create a function that forks the 'paint' function\n    x14 = lbind(fork, paint)\n    \n    # Create a function that applies identity function to the result of x14\n    x15 = lbind(x14, identity)\n    \n    # Create a function that composes with the diagonal mirror and shift function\n    x16 = lbind(compose, x7)\n    \n    # Chain the functions created in x15, x16, and x5\n    x17 = chain(x15, x16, x5)\n    \n    # Create a function that composes with the counter-diagonal mirror and shift function\n    x18 = lbind(compose, x9)\n    \n    # Chain the functions created in x15, x18, and x5\n    x19 = chain(x15, x18, x5)\n    \n    # Create a function that composes with the horizontal mirror and shift function\n    x20 = lbind(compose, x11)\n    \n    # Chain the functions created in x15, x20, and x5\n    x21 = chain(x15, x20, x5)\n    \n    # Create a function that composes with the vertical mirror and shift function\n    x22 = lbind(compose, x13)\n    \n    # Chain the functions created in x15, x22, and x5\n    x23 = chain(x15, x22, x5)\n    \n    # Create a function that applies the input grid I to a function\n    x24 = rbind(rapply, I)\n    \n    # Chain functions to initialize a set with the first element after applying x24\n    x25 = chain(first, x24, initset)\n    \n    # Fork the composition of x23 and x21\n    x26 = fork(compose, x23, x21)\n    \n    # Fork the composition of x19 and x17\n    x27 = fork(compose, x19, x17)\n    \n    # Fork the composition of x26 and x27\n    x28 = fork(compose, x26, x27)\n    \n    # Compose x25 and x28\n    x29 = compose(x25, x28)\n    \n    # Get the palette of colors from the input grid\n    x30 = palette(I)\n    \n    # Create a function that checks if a grid is equal to its diagonal mirror\n    x31 = fork(equality, identity, dmirror)\n    \n    # Compose x31 and x29\n    x32 = compose(x31, x29)\n    \n    # Find the color that maximizes the symmetry condition defined by x32\n    x33 = argmax(x30, x32)\n    \n    # Apply the found color to the transformation defined by x29\n    x34 = x29(x33)\n    \n    # Return the final transformed grid\n    return x34\n"
  },
  "363442ee": {
    "original": "def verify_363442ee(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = mostcolor(I)\n    x3 = fill(I, x2, x1)\n    x4 = objects(x3, F, F, T)\n    x5 = argmax(x4, size)\n    x6 = remove(x5, x4)\n    x7 = apply(center, x6)\n    x8 = normalize(x5)\n    x9 = shape(x5)\n    x10 = halve(x9)\n    x11 = invert(x10)\n    x12 = shift(x8, x11)\n    x13 = lbind(shift, x12)\n    x14 = mapply(x13, x7)\n    x15 = paint(I, x14)\n    return x15\n\n",
    "annotated": "def verify_363442ee(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single set of cells\n    x1 = merge(x0)\n    \n    # Determine the most common color in the input grid (background color)\n    x2 = mostcolor(I)\n    \n    # Fill the frontier cells with the background color, effectively removing them\n    x3 = fill(I, x2, x1)\n    \n    # Find all objects in the modified grid, considering 4-connectivity and ignoring the background\n    x4 = objects(x3, F, F, T)\n    \n    # Find the largest object (the right side of the grid)\n    x5 = argmax(x4, size)\n    \n    # Remove the largest object from the set of objects (leaving only the dots)\n    x6 = remove(x5, x4)\n    \n    # Find the center coordinates of each dot\n    x7 = apply(center, x6)\n    \n    # Normalize the largest object (move it to the origin)\n    x8 = normalize(x5)\n    \n    # Get the shape (height, width) of the largest object\n    x9 = shape(x5)\n    \n    # Halve the dimensions of the shape (to find the center of the unit cell)\n    x10 = halve(x9)\n    \n    # Invert the halved dimensions (negative coordinates of the unit cell center)\n    x11 = invert(x10)\n    \n    # Shift the normalized largest object by the inverted half-dimensions\n    # This centers the unit cell around the origin\n    x12 = shift(x8, x11)\n    \n    # Create a new function that shifts by the centered unit cell\n    x13 = lbind(shift, x12)\n    \n    # Apply the shift function to all dot centers, effectively placing a unit cell at each dot\n    x14 = mapply(x13, x7)\n    \n    # Paint the transformed unit cells onto the original input grid\n    x15 = paint(I, x14)\n    \n    # Return the final output grid\n    return x15\n"
  },
  "36d67576": {
    "original": "def verify_36d67576(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = argmax(x0, size)\n    x2 = remove(x1, x0)\n    x3 = merge(x2)\n    x4 = palette(x3)\n    x5 = repeat(identity, ONE)\n    x6 = astuple(cmirror, dmirror)\n    x7 = astuple(vmirror, hmirror)\n    x8 = combine(x6, x7)\n    x9 = combine(x5, x8)\n    x10 = fork(compose, first, last)\n    x11 = product(x9, x9)\n    x12 = apply(x10, x11)\n    x13 = rbind(contained, x4)\n    x14 = compose(x13, first)\n    x15 = rbind(sfilter, x14)\n    x16 = lbind(chain, ulcorner)\n    x17 = lbind(x16, x15)\n    x18 = lbind(fork, shift)\n    x19 = lbind(lbind, shift)\n    x20 = lbind(occurrences, I)\n    x21 = rbind(rapply, x1)\n    x22 = chain(first, x21, initset)\n    x23 = lbind(compose, invert)\n    x24 = compose(x23, x17)\n    x25 = lbind(compose, x15)\n    x26 = fork(x18, x25, x24)\n    x27 = compose(x22, x26)\n    x28 = rbind(rapply, x1)\n    x29 = chain(first, x28, initset)\n    x30 = rbind(rapply, x1)\n    x31 = compose(initset, x17)\n    x32 = chain(first, x30, x31)\n    x33 = compose(invert, x32)\n    x34 = fork(shift, x29, x33)\n    x35 = compose(x19, x34)\n    x36 = compose(x20, x27)\n    x37 = fork(mapply, x35, x36)\n    x38 = rbind(astuple, x37)\n    x39 = compose(last, x38)\n    x40 = rbind(astuple, x12)\n    x41 = compose(last, x40)\n    x42 = fork(mapply, x39, x41)\n    x43 = fork(paint, identity, x42)\n    x44 = rbind(contained, x4)\n    x45 = compose(x44, first)\n    x46 = sfilter(x1, x45)\n    x47 = size(x46)\n    x48 = equality(x47, ZERO)\n    x49 = branch(x48, identity, x43)\n    x50 = x49(I)\n    return x50\n\n",
    "annotated": "def verify_36d67576(I: Grid) -> Grid:\n    # Get all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, F, T, T)\n    # Find the largest object (likely the main object)\n    x1 = argmax(x0, size)\n    # Remove the largest object from the set of objects\n    x2 = remove(x1, x0)\n    # Merge all remaining objects into a single set of cells\n    x3 = merge(x2)\n    # Get the palette (unique colors) of the merged objects\n    x4 = palette(x3)\n    # Create a tuple with the identity function (no transformation)\n    x5 = repeat(identity, ONE)\n    # Create a tuple with diagonal mirror functions\n    x6 = astuple(cmirror, dmirror)\n    # Create a tuple with vertical and horizontal mirror functions\n    x7 = astuple(vmirror, hmirror)\n    # Combine all mirror functions into a single tuple\n    x8 = combine(x6, x7)\n    # Add the identity function to the set of transformations\n    x9 = combine(x5, x8)\n    # Create a function that composes the first and last elements of a tuple\n    x10 = fork(compose, first, last)\n    # Generate all possible pairs of transformations\n    x11 = product(x9, x9)\n    # Apply the composition function to all pairs of transformations\n    x12 = apply(x10, x11)\n    # Create a function that checks if a color is in the palette of smaller objects\n    x13 = rbind(contained, x4)\n    # Compose the color check with getting the first element (color) of a cell\n    x14 = compose(x13, first)\n    # Create a function that filters cells based on their color being in the palette\n    x15 = rbind(sfilter, x14)\n    # Create a function chain that gets the upper-left corner after filtering\n    x16 = lbind(chain, ulcorner)\n    x17 = lbind(x16, x15)\n    # Create a function that shifts an object\n    x18 = lbind(fork, shift)\n    # Create a partial shift function\n    x19 = lbind(lbind, shift)\n    # Create a function that finds occurrences of an object in the input grid\n    x20 = lbind(occurrences, I)\n    # Create a function that applies a function to the largest object and gets the first result\n    x21 = rbind(rapply, x1)\n    x22 = chain(first, x21, initset)\n    # Create a function that inverts the result of the filtering and corner-finding\n    x23 = lbind(compose, invert)\n    x24 = compose(x23, x17)\n    # Create a function that filters an object and finds its corner\n    x25 = lbind(compose, x15)\n    # Create a function that shifts an object based on its filtered corner\n    x26 = fork(x18, x25, x24)\n    # Create a function that normalizes an object's position\n    x27 = compose(x22, x26)\n    # Create functions for finding and shifting objects\n    x28 = rbind(rapply, x1)\n    x29 = chain(first, x28, initset)\n    x30 = rbind(rapply, x1)\n    x31 = compose(initset, x17)\n    x32 = chain(first, x30, x31)\n    x33 = compose(invert, x32)\n    x34 = fork(shift, x29, x33)\n    x35 = compose(x19, x34)\n    # Create a function that finds occurrences of normalized objects\n    x36 = compose(x20, x27)\n    # Create a function that applies transformations to found occurrences\n    x37 = fork(mapply, x35, x36)\n    x38 = rbind(astuple, x37)\n    x39 = compose(last, x38)\n    # Create a function that gets the last (composed) transformation\n    x40 = rbind(astuple, x12)\n    x41 = compose(last, x40)\n    # Create a function that applies transformations to objects\n    x42 = fork(mapply, x39, x41)\n    # Create a function that paints transformed objects onto the grid\n    x43 = fork(paint, identity, x42)\n    # Create a function that checks if a cell's color is in the palette\n    x44 = rbind(contained, x4)\n    x45 = compose(x44, first)\n    # Filter the largest object to keep only cells with colors in the palette\n    x46 = sfilter(x1, x45)\n    # Count the number of cells in the filtered largest object\n    x47 = size(x46)\n    # Check if the filtered largest object is empty\n    x48 = equality(x47, ZERO)\n    # If the filtered largest object is empty, return the input grid unchanged\n    # Otherwise, apply the transformations and paint the objects\n    x49 = branch(x48, identity, x43)\n    # Apply the final transformation to the input grid\n    x50 = x49(I)\n    return x50\n"
  },
  "36fdfd69": {
    "original": "def verify_36fdfd69(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = fork(subtract, first, last)\n    x3 = fork(multiply, sign, identity)\n    x4 = compose(x3, x2)\n    x5 = lbind(greater, THREE)\n    x6 = chain(x5, maximum, x4)\n    x7 = lbind(lbind, astuple)\n    x8 = rbind(chain, x7)\n    x9 = lbind(compose, x6)\n    x10 = rbind(x8, x9)\n    x11 = lbind(lbind, sfilter)\n    x12 = compose(x10, x11)\n    x13 = lbind(mapply, backdrop)\n    x14 = fork(apply, x12, identity)\n    x15 = compose(x13, x14)\n    x16 = power(x15, TWO)\n    x17 = x16(x1)\n    x18 = fill(I, FOUR, x17)\n    x19 = fill(x18, x0, x1)\n    return x19\n\n",
    "annotated": "def verify_36fdfd69(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    x0 = leastcolor(I)\n    \n    # Get all cells with the least common color\n    x1 = ofcolor(I, x0)\n    \n    # Create a function that subtracts the first element from the last element of a tuple\n    x2 = fork(subtract, first, last)\n    \n    # Create a function that multiplies the sign of a number with the number itself\n    x3 = fork(multiply, sign, identity)\n    \n    # Compose x3 and x2 to create a function that calculates the signed difference between first and last elements\n    x4 = compose(x3, x2)\n    \n    # Create a function that checks if a number is greater than 3\n    x5 = lbind(greater, THREE)\n    \n    # Chain x5, maximum, and x4 to create a function that checks if the max signed difference is greater than 3\n    x6 = chain(x5, maximum, x4)\n    \n    # Create a function that turns a function into a tuple-accepting function\n    x7 = lbind(lbind, astuple)\n    \n    # Create a function that chains a function with x7\n    x8 = rbind(chain, x7)\n    \n    # Create a function that composes a function with x6\n    x9 = lbind(compose, x6)\n    \n    # Combine x8 and x9 to create a function composition\n    x10 = rbind(x8, x9)\n    \n    # Create a function that filters a set based on a condition\n    x11 = lbind(lbind, sfilter)\n    \n    # Compose x10 and x11 to create a filtering function based on the previous conditions\n    x12 = compose(x10, x11)\n    \n    # Create a function that applies the backdrop function to a set of indices\n    x13 = lbind(mapply, backdrop)\n    \n    # Create a function that applies x12 and identity to an input\n    x14 = fork(apply, x12, identity)\n    \n    # Compose x13 and x14 to create a function that finds backdrops of filtered objects\n    x15 = compose(x13, x14)\n    \n    # Apply x15 twice to create a function that expands the backdrops\n    x16 = power(x15, TWO)\n    \n    # Apply x16 to x1 to get the expanded backdrops of the least common color objects\n    x17 = x16(x1)\n    \n    # Fill the expanded backdrops with color 4 in the input grid\n    # This marks the areas around the objects\n    x18 = fill(I, FOUR, x17)\n    \n    # Fill the original object cells with their original color (least common color)\n    # This preserves the original objects within the marked areas\n    x19 = fill(x18, x0, x1)\n    \n    # Return the final grid with marked areas (color 4) around the original objects\n    return x19\n"
  },
  "3906de3d": {
    "original": "def verify_3906de3d(I: Grid) -> Grid:\n    x0 = first(I)\n    x1 = dedupe(x0)\n    x2 = size(x1)\n    x3 = equality(ONE, x2)\n    x4 = branch(x3, dmirror, identity)\n    x5 = x4(I)\n    x6 = first(x5)\n    x7 = first(x6)\n    x8 = first(x5)\n    x9 = matcher(identity, x7)\n    x10 = sfilter(x8, x9)\n    x11 = size(x10)\n    x12 = last(x5)\n    x13 = sfilter(x12, x9)\n    x14 = size(x13)\n    x15 = greater(x11, x14)\n    x16 = branch(x15, hmirror, identity)\n    x17 = x16(x5)\n    x18 = partition(x17)\n    x19 = matcher(color, x7)\n    x20 = extract(x18, x19)\n    x21 = remove(x20, x18)\n    x22 = argmin(x21, uppermost)\n    x23 = other(x21, x22)\n    x24 = color(x22)\n    x25 = color(x23)\n    x26 = fill(x17, TWO, x20)\n    x27 = fill(x26, ONE, x23)\n    x28 = fill(x27, ZERO, x22)\n    x29 = rbind(order, identity)\n    x30 = dmirror(x28)\n    x31 = apply(x29, x30)\n    x32 = dmirror(x31)\n    x33 = x16(x32)\n    x34 = x4(x33)\n    x35 = ofcolor(x34, TWO)\n    x36 = fill(x34, x7, x35)\n    x37 = ofcolor(x34, ONE)\n    x38 = fill(x36, x25, x37)\n    x39 = ofcolor(x34, ZERO)\n    x40 = fill(x38, x24, x39)\n    return x40\n\n",
    "annotated": "def verify_3906de3d(I: Grid) -> Grid:\n    # Get the first row of the input grid\n    x0 = first(I)\n    # Remove duplicate colors from the first row\n    x1 = dedupe(x0)\n    # Count the number of unique colors in the first row\n    x2 = size(x1)\n    # Check if there's only one unique color in the first row\n    x3 = equality(ONE, x2)\n    # If there's only one color, apply diagonal mirror; otherwise, do nothing\n    x4 = branch(x3, dmirror, identity)\n    # Apply the chosen transformation (dmirror or identity) to the input grid\n    x5 = x4(I)\n    # Get the first row of the transformed grid\n    x6 = first(x5)\n    # Get the first color in the first row (background color)\n    x7 = first(x6)\n    # Get the first row of the transformed grid again\n    x8 = first(x5)\n    # Create a function to match the background color\n    x9 = matcher(identity, x7)\n    # Filter the first row to keep only background color cells\n    x10 = sfilter(x8, x9)\n    # Count the number of background color cells in the first row\n    x11 = size(x10)\n    # Get the last row of the transformed grid\n    x12 = last(x5)\n    # Filter the last row to keep only background color cells\n    x13 = sfilter(x12, x9)\n    # Count the number of background color cells in the last row\n    x14 = size(x13)\n    # Check if there are more background cells in the first row than in the last row\n    x15 = greater(x11, x14)\n    # If true, apply horizontal mirror; otherwise, do nothing\n    x16 = branch(x15, hmirror, identity)\n    # Apply the chosen transformation (hmirror or identity) to the grid\n    x17 = x16(x5)\n    # Partition the grid into objects based on color\n    x18 = partition(x17)\n    # Create a function to match the background color\n    x19 = matcher(color, x7)\n    # Extract the background object from the partitioned grid\n    x20 = extract(x18, x19)\n    # Remove the background object from the partitioned grid\n    x21 = remove(x20, x18)\n    # Find the object with the topmost position (box)\n    x22 = argmin(x21, uppermost)\n    # Get the other object (lines)\n    x23 = other(x21, x22)\n    # Get the color of the box\n    x24 = color(x22)\n    # Get the color of the lines\n    x25 = color(x23)\n    # Fill the background with color 2\n    x26 = fill(x17, TWO, x20)\n    # Fill the lines with color 1\n    x27 = fill(x26, ONE, x23)\n    # Fill the box with color 0\n    x28 = fill(x27, ZERO, x22)\n    # Create a function to order cells by their position\n    x29 = rbind(order, identity)\n    # Apply diagonal mirror to the grid\n    x30 = dmirror(x28)\n    # Apply the ordering function to each row of the mirrored grid\n    x31 = apply(x29, x30)\n    # Apply diagonal mirror again to restore the original orientation\n    x32 = dmirror(x31)\n    # Apply the horizontal mirror transformation if necessary\n    x33 = x16(x32)\n    # Apply the diagonal mirror transformation if necessary\n    x34 = x4(x33)\n    # Find all cells with color 2 (background)\n    x35 = ofcolor(x34, TWO)\n    # Fill the background cells with the original background color\n    x36 = fill(x34, x7, x35)\n    # Find all cells with color 1 (lines)\n    x37 = ofcolor(x34, ONE)\n    # Fill the line cells with the original line color\n    x38 = fill(x36, x25, x37)\n    # Find all cells with color 0 (box)\n    x39 = ofcolor(x34, ZERO)\n    # Fill the box cells with the original box color\n    x40 = fill(x38, x24, x39)\n    # Return the final transformed grid\n    return x40\n"
  },
  "39a8645d": {
    "original": "def verify_39a8645d(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = totuple(x0)\n    x2 = apply(normalize, x1)\n    x3 = mostcommon(x2)\n    x4 = mostcolor(I)\n    x5 = shape(x3)\n    x6 = canvas(x4, x5)\n    x7 = paint(x6, x3)\n    return x7\n\n",
    "annotated": "def verify_39a8645d(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including background and diagonally connected cells\n    x0 = objects(I, T, T, T)\n    \n    # Convert the set of objects to a tuple for easier manipulation\n    x1 = totuple(x0)\n    \n    # Normalize all objects (move them to the top-left corner)\n    x2 = apply(normalize, x1)\n    \n    # Find the most common normalized object shape\n    # This is likely the main object we're looking for\n    x3 = mostcommon(x2)\n    \n    # Determine the most common color in the input grid\n    # This is likely the background color\n    x4 = mostcolor(I)\n    \n    # Get the dimensions (shape) of the main object\n    x5 = shape(x3)\n    \n    # Create a new canvas with the background color and the size of the main object\n    # This forms the base of our output grid\n    x6 = canvas(x4, x5)\n    \n    # Paint the main object onto the new canvas\n    # This creates the final output grid with the extracted main object\n    x7 = paint(x6, x3)\n    \n    # Return the final output grid\n    return x7\n"
  },
  "39e1d7f9": {
    "original": "def verify_39e1d7f9(I: Grid) -> Grid:\n    x0 = compress(I)\n    x1 = objects(x0, F, F, T)\n    x2 = argmax(x1, numcolors)\n    x3 = remove(x2, x1)\n    x4 = merge(x3)\n    x5 = size(x4)\n    x6 = positive(x5)\n    x7 = astuple(color, x4)\n    x8 = astuple(leastcolor, x2)\n    x9 = branch(x6, x7, x8)\n    x10 = compose(initset, first)\n    x11 = fork(rapply, x10, last)\n    x12 = compose(first, x11)\n    x13 = x12(x9)\n    x14 = normalize(x2)\n    x15 = matcher(first, x13)\n    x16 = sfilter(x14, x15)\n    x17 = ulcorner(x16)\n    x18 = invert(x17)\n    x19 = shift(x14, x18)\n    x20 = lbind(shift, x19)\n    x21 = objects(x0, T, F, T)\n    x22 = colorfilter(x21, x13)\n    x23 = apply(ulcorner, x22)\n    x24 = mapply(x20, x23)\n    x25 = paint(x0, x24)\n    x26 = height(x0)\n    x27 = frontiers(I)\n    x28 = sfilter(x27, hline)\n    x29 = size(x28)\n    x30 = increment(x29)\n    x31 = divide(x26, x30)\n    x32 = width(x0)\n    x33 = frontiers(I)\n    x34 = sfilter(x33, vline)\n    x35 = size(x34)\n    x36 = increment(x35)\n    x37 = divide(x32, x36)\n    x38 = rbind(multiply, x37)\n    x39 = rbind(divide, x37)\n    x40 = compose(x38, x39)\n    x41 = fork(equality, x40, identity)\n    x42 = compose(x41, first)\n    x43 = rbind(multiply, x31)\n    x44 = rbind(divide, x31)\n    x45 = compose(x43, x44)\n    x46 = fork(equality, x45, identity)\n    x47 = compose(x46, first)\n    x48 = lbind(interval, ZERO)\n    x49 = rbind(x48, ONE)\n    x50 = compose(x49, size)\n    x51 = fork(pair, x50, identity)\n    x52 = lbind(apply, last)\n    x53 = rbind(sfilter, x42)\n    x54 = chain(x52, x53, x51)\n    x55 = compose(x54, last)\n    x56 = height(x25)\n    x57 = interval(ZERO, x56, ONE)\n    x58 = pair(x57, x25)\n    x59 = sfilter(x58, x47)\n    x60 = apply(x55, x59)\n    x61 = increment(x37)\n    x62 = hupscale(x60, x61)\n    x63 = increment(x31)\n    x64 = vupscale(x62, x63)\n    x65 = frontiers(I)\n    x66 = merge(x65)\n    x67 = paint(x64, x66)\n    x68 = shape(I)\n    x69 = crop(x67, ORIGIN, x68)\n    return x69\n\n",
    "annotated": "def verify_39e1d7f9(I: Grid) -> Grid:\n    # Remove frontiers from the input grid\n    x0 = compress(I)\n    \n    # Extract objects from the compressed grid (not univalued, not diagonal, without background)\n    x1 = objects(x0, F, F, T)\n    \n    # Find the object with the most colors (likely the template object)\n    x2 = argmax(x1, numcolors)\n    \n    # Remove the template object from the set of objects\n    x3 = remove(x2, x1)\n    \n    # Merge all remaining objects into a single set of cells\n    x4 = merge(x3)\n    \n    # Get the number of cells in the merged objects\n    x5 = size(x4)\n    \n    # Check if there are any cells in the merged objects\n    x6 = positive(x5)\n    \n    # Get the colors of the merged objects as a tuple\n    x7 = astuple(color, x4)\n    \n    # Get the least common color of the template object as a tuple\n    x8 = astuple(leastcolor, x2)\n    \n    # Choose between merged objects' colors and template's least color based on whether merged objects exist\n    x9 = branch(x6, x7, x8)\n    \n    # Create a function to initialize a set with the first element\n    x10 = compose(initset, first)\n    \n    # Create a function to apply x10 to the first and last elements of x9\n    x11 = fork(rapply, x10, last)\n    \n    # Create a function to get the first element of the result of x11\n    x12 = compose(first, x11)\n    \n    # Apply x12 to x9 to get the color to use for new objects\n    x13 = x12(x9)\n    \n    # Normalize the template object (move it to origin)\n    x14 = normalize(x2)\n    \n    # Create a function to match cells with the color x13\n    x15 = matcher(first, x13)\n    \n    # Filter the normalized template to keep only cells with color x13\n    x16 = sfilter(x14, x15)\n    \n    # Get the upper-left corner of the filtered template\n    x17 = ulcorner(x16)\n    \n    # Invert the coordinates of the upper-left corner\n    x18 = invert(x17)\n    \n    # Shift the normalized template by the inverted corner coordinates\n    x19 = shift(x14, x18)\n    \n    # Create a function to shift by x19\n    x20 = lbind(shift, x19)\n    \n    # Extract objects from the compressed grid (univalued, not diagonal, without background)\n    x21 = objects(x0, T, F, T)\n    \n    # Filter objects to keep only those with color x13 (likely the dots)\n    x22 = colorfilter(x21, x13)\n    \n    # Get the upper-left corners of the filtered objects (dot positions)\n    x23 = apply(ulcorner, x22)\n    \n    # Shift the template to each dot position\n    x24 = mapply(x20, x23)\n    \n    # Paint the shifted templates onto the compressed grid\n    x25 = paint(x0, x24)\n    \n    # Get the height of the compressed grid\n    x26 = height(x0)\n    \n    # Get all frontiers of the input grid\n    x27 = frontiers(I)\n    \n    # Filter frontiers to keep only horizontal lines\n    x28 = sfilter(x27, hline)\n    \n    # Count the number of horizontal frontiers\n    x29 = size(x28)\n    \n    # Add 1 to the number of horizontal frontiers\n    x30 = increment(x29)\n    \n    # Calculate the height of each cell in the original grid\n    x31 = divide(x26, x30)\n    \n    # Get the width of the compressed grid\n    x32 = width(x0)\n    \n    # Get all frontiers of the input grid (again)\n    x33 = frontiers(I)\n    \n    # Filter frontiers to keep only vertical lines\n    x34 = sfilter(x33, vline)\n    \n    # Count the number of vertical frontiers\n    x35 = size(x34)\n    \n    # Add 1 to the number of vertical frontiers\n    x36 = increment(x35)\n    \n    # Calculate the width of each cell in the original grid\n    x37 = divide(x32, x36)\n    \n    # Create a function to multiply by x37\n    x38 = rbind(multiply, x37)\n    \n    # Create a function to divide by x37\n    x39 = rbind(divide, x37)\n    \n    # Compose multiplication and division by x37\n    x40 = compose(x38, x39)\n    \n    # Create a function to check if a value is equal to its rounded version when divided and multiplied by x37\n    x41 = fork(equality, x40, identity)\n    \n    # Create a function to apply x41 to the first element of a pair\n    x42 = compose(x41, first)\n    \n    # Create a function to multiply by x31\n    x43 = rbind(multiply, x31)\n    \n    # Create a function to divide by x31\n    x44 = rbind(divide, x31)\n    \n    # Compose multiplication and division by x31\n    x45 = compose(x43, x44)\n    \n    # Create a function to check if a value is equal to its rounded version when divided and multiplied by x31\n    x46 = fork(equality, x45, identity)\n    \n    # Create a function to apply x46 to the first element of a pair\n    x47 = compose(x46, first)\n    \n    # Create a function to generate an interval from 0 to a given value with step 1\n    x48 = lbind(interval, ZERO)\n    x49 = rbind(x48, ONE)\n    \n    # Create a function to generate an interval based on the size of an input\n    x50 = compose(x49, size)\n    \n    # Create a function to pair the interval with the original input\n    x51 = fork(pair, x50, identity)\n    \n    # Create a function to apply a function to the last element of a pair\n    x52 = lbind(apply, last)\n    \n    # Create a function to filter based on x42\n    x53 = rbind(sfilter, x42)\n    \n    # Chain together functions to process rows of the grid\n    x54 = chain(x52, x53, x51)\n    \n    # Create a function to apply x54 to the last element of a pair\n    x55 = compose(x54, last)\n    \n    # Get the height of the painted grid\n    x56 = height(x25)\n    \n    # Generate an interval from 0 to the height of the painted grid\n    x57 = interval(ZERO, x56, ONE)\n    \n    # Pair the interval with the painted grid\n    x58 = pair(x57, x25)\n    \n    # Filter rows based on x47\n    x59 = sfilter(x58, x47)\n    \n    # Apply x55 to the filtered rows\n    x60 = apply(x55, x59)\n    \n    # Increment the cell width\n    x61 = increment(x37)\n    \n    # Upscale the grid horizontally\n    x62 = hupscale(x60, x61)\n    \n    # Increment the cell height\n    x63 = increment(x31)\n    \n    # Upscale the grid vertically\n    x64 = vupscale(x62, x63)\n    \n    # Get all frontiers of the input grid (once more)\n    x65 = frontiers(I)\n    \n    # Merge all frontiers into a single set of cells\n    x66 = merge(x65)\n    \n    # Paint the merged frontiers onto the upscaled grid\n    x67 = paint(x64, x66)\n    \n    # Get the shape (dimensions) of the input grid\n    x68 = shape(I)\n    \n    # Crop the final grid to match the input grid's dimensions\n    x69 = crop(x67, ORIGIN, x68)\n    \n    # Return the final processed grid\n    return x69\n"
  },
  "3aa6fb7a": {
    "original": "def verify_3aa6fb7a(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = mapply(corners, x0)\n    x2 = underfill(I, ONE, x1)\n    return x2\n\n",
    "annotated": "def verify_3aa6fb7a(I: Grid) -> Grid:\n    # Identify all objects in the input grid I\n    # T, F, T parameters mean: univalued=True, diagonal=False, without_bg=True\n    # This extracts all contiguous areas of the same color, excluding the background\n    x0 = objects(I, T, F, T)\n\n    # For each object, find its corner indices\n    # This creates a set of corner points for all shapes in the grid\n    x1 = mapply(corners, x0)\n\n    # Fill the input grid with color 1 (ONE) at the corner positions\n    # This places markers at the corners of all shapes, but only where the original color was background\n    # The 'underfill' function ensures we don't overwrite existing non-background colors\n    x2 = underfill(I, ONE, x1)\n\n    # Return the modified grid with corner markers\n    return x2\n"
  },
  "3ac3eb23": {
    "original": "def verify_3ac3eb23(I: Grid) -> Grid:\n    x0 = astuple(identity, dmirror)\n    x1 = astuple(cmirror, hmirror)\n    x2 = combine(x0, x1)\n    x3 = chain(lowermost, merge, fgpartition)\n    x4 = rbind(rapply, I)\n    x5 = lbind(compose, x3)\n    x6 = compose(initset, x5)\n    x7 = chain(first, x4, x6)\n    x8 = matcher(x7, ZERO)\n    x9 = extract(x2, x8)\n    x10 = x9(I)\n    x11 = objects(x10, T, F, T)\n    x12 = height(x10)\n    x13 = interval(ZERO, x12, TWO)\n    x14 = height(x10)\n    x15 = interval(ONE, x14, TWO)\n    x16 = rbind(apply, x13)\n    x17 = lbind(rbind, astuple)\n    x18 = chain(x16, x17, last)\n    x19 = rbind(apply, x15)\n    x20 = lbind(rbind, astuple)\n    x21 = compose(increment, last)\n    x22 = chain(x19, x20, x21)\n    x23 = rbind(apply, x15)\n    x24 = lbind(rbind, astuple)\n    x25 = compose(decrement, last)\n    x26 = chain(x23, x24, x25)\n    x27 = fork(combine, x18, x22)\n    x28 = fork(combine, x27, x26)\n    x29 = compose(x28, center)\n    x30 = fork(recolor, color, x29)\n    x31 = mapply(x30, x11)\n    x32 = paint(x10, x31)\n    x33 = x9(x32)\n    return x33\n\n",
    "annotated": "def verify_3ac3eb23(I: Grid) -> Grid:\n    # Create a tuple of identity and diagonal mirror functions\n    x0 = astuple(identity, dmirror)\n    \n    # Create a tuple of counter-diagonal mirror and horizontal mirror functions\n    x1 = astuple(cmirror, hmirror)\n    \n    # Combine the two tuples of mirror functions\n    x2 = combine(x0, x1)\n    \n    # Create a chain of functions: partition foreground, merge, then find lowermost\n    x3 = chain(lowermost, merge, fgpartition)\n    \n    # Bind the input grid I to the right side of rapply function\n    x4 = rbind(rapply, I)\n    \n    # Bind the composition function to the left side of x3\n    x5 = lbind(compose, x3)\n    \n    # Compose the initialization of a set with x5\n    x6 = compose(initset, x5)\n    \n    # Chain functions to get the first element after applying x4 and x6\n    x7 = chain(first, x4, x6)\n    \n    # Create a matcher function that checks if x7 equals ZERO\n    x8 = matcher(x7, ZERO)\n    \n    # Extract the first mirror function that satisfies condition x8\n    x9 = extract(x2, x8)\n    \n    # Apply the extracted mirror function to the input grid\n    x10 = x9(I)\n    \n    # Find objects in the mirrored grid, allowing diagonal connections\n    x11 = objects(x10, T, F, T)\n    \n    # Get the height of the mirrored grid\n    x12 = height(x10)\n    \n    # Create an interval of even numbers from 0 to the grid height\n    x13 = interval(ZERO, x12, TWO)\n    \n    # Get the height of the mirrored grid again\n    x14 = height(x10)\n    \n    # Create an interval of odd numbers from 1 to the grid height\n    x15 = interval(ONE, x14, TWO)\n    \n    # Bind the apply function to the right side of x13\n    x16 = rbind(apply, x13)\n    \n    # Bind the astuple function to the right side of rbind\n    x17 = lbind(rbind, astuple)\n    \n    # Chain functions to get the last element after applying x16 and x17\n    x18 = chain(x16, x17, last)\n    \n    # Bind the apply function to the right side of x15\n    x19 = rbind(apply, x15)\n    \n    # Bind the astuple function to the right side of rbind\n    x20 = lbind(rbind, astuple)\n    \n    # Compose the increment function with last\n    x21 = compose(increment, last)\n    \n    # Chain functions to increment the last element after applying x19 and x20\n    x22 = chain(x19, x20, x21)\n    \n    # Bind the apply function to the right side of x15 again\n    x23 = rbind(apply, x15)\n    \n    # Bind the astuple function to the right side of rbind again\n    x24 = lbind(rbind, astuple)\n    \n    # Compose the decrement function with last\n    x25 = compose(decrement, last)\n    \n    # Chain functions to decrement the last element after applying x23 and x24\n    x26 = chain(x23, x24, x25)\n    \n    # Combine the results of x18 and x22\n    x27 = fork(combine, x18, x22)\n    \n    # Combine the results of x27 and x26\n    x28 = fork(combine, x27, x26)\n    \n    # Compose x28 with the center function\n    x29 = compose(x28, center)\n    \n    # Create a function that recolors based on the original color and the new position\n    x30 = fork(recolor, color, x29)\n    \n    # Apply x30 to each object in x11 and merge the results\n    x31 = mapply(x30, x11)\n    \n    # Paint the transformed objects onto the mirrored grid\n    x32 = paint(x10, x31)\n    \n    # Apply the inverse mirror function to get the final output grid\n    x33 = x9(x32)\n    \n    return x33\n"
  },
  "3af2c5a8": {
    "original": "def verify_3af2c5a8(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(I, x0)\n    x2 = hmirror(x1)\n    x3 = vconcat(x1, x2)\n    return x3\n\n",
    "annotated": "def verify_3af2c5a8(I: Grid) -> Grid:\n    # Create a vertical mirror image of the input grid\n    # This flips the grid left to right\n    x0 = vmirror(I)\n    \n    # Horizontally concatenate the original grid with its vertical mirror\n    # This creates a new grid twice as wide, with the mirror image on the right\n    x1 = hconcat(I, x0)\n    \n    # Create a horizontal mirror image of the concatenated grid\n    # This flips the wide grid top to bottom\n    x2 = hmirror(x1)\n    \n    # Vertically concatenate the wide grid with its horizontal mirror\n    # This creates the final grid, four times the size of the original,\n    # with symmetry both horizontally and vertically\n    x3 = vconcat(x1, x2)\n    \n    # Return the final, quadrupled and symmetrical grid\n    return x3\n"
  },
  "3bd67248": {
    "original": "def verify_3bd67248(I: Grid) -> Grid:\n    x0 = astuple(identity, identity)\n    x1 = astuple(rot90, rot270)\n    x2 = astuple(x0, x1)\n    x3 = astuple(rot180, rot180)\n    x4 = astuple(rot270, rot90)\n    x5 = astuple(x3, x4)\n    x6 = combine(x2, x5)\n    x7 = leastcolor(I)\n    x8 = repeat(x7, ONE)\n    x9 = rbind(rapply, I)\n    x10 = chain(x9, initset, first)\n    x11 = compose(first, x10)\n    x12 = chain(dedupe, first, x11)\n    x13 = matcher(x12, x8)\n    x14 = extract(x6, x13)\n    x15 = first(x14)\n    x16 = last(x14)\n    x17 = x15(I)\n    x18 = ofcolor(x17, x7)\n    x19 = height(x18)\n    x20 = interval(ZERO, x19, ONE)\n    x21 = lbind(astuple, x19)\n    x22 = apply(x21, x20)\n    x23 = rbind(shoot, DOWN)\n    x24 = mapply(x23, x22)\n    x25 = fill(x17, FOUR, x24)\n    x26 = astuple(x19, x19)\n    x27 = canvas(ZERO, x26)\n    x28 = asindices(x27)\n    x29 = shift(x28, x26)\n    x30 = shape(I)\n    x31 = maximum(x30)\n    x32 = lbind(shift, x29)\n    x33 = interval(ZERO, x31, x19)\n    x34 = pair(x33, x33)\n    x35 = mapply(x32, x34)\n    x36 = fill(x25, TWO, x35)\n    x37 = x16(x36)\n    return x37\n\n",
    "annotated": "def verify_3bd67248(I: Grid) -> Grid:\n    # Create tuples of identity and rotation functions\n    x0 = astuple(identity, identity)  # No rotation\n    x1 = astuple(rot90, rot270)  # 90 degree clockwise and counterclockwise rotations\n    x2 = astuple(x0, x1)  # Combine no rotation and 90 degree rotations\n    x3 = astuple(rot180, rot180)  # 180 degree rotation\n    x4 = astuple(rot270, rot90)  # 270 degree clockwise and counterclockwise rotations\n    x5 = astuple(x3, x4)  # Combine 180 and 270 degree rotations\n    x6 = combine(x2, x5)  # Combine all rotation possibilities\n\n    # Find the least common color in the input grid (likely the background color)\n    x7 = leastcolor(I)\n    x8 = repeat(x7, ONE)  # Create a tuple with the background color\n\n    # Create a function to apply the input grid to a given function\n    x9 = rbind(rapply, I)\n    # Chain operations to get the first color of the first row after applying rotations\n    x10 = chain(x9, initset, first)\n    x11 = compose(first, x10)\n    x12 = chain(dedupe, first, x11)\n    # Create a matcher function to find the rotation that puts the background color in the top-left\n    x13 = matcher(x12, x8)\n    # Extract the correct rotation functions\n    x14 = extract(x6, x13)\n    x15 = first(x14)  # Get the rotation function for the input\n    x16 = last(x14)   # Get the inverse rotation function for the output\n\n    # Apply the rotation to the input grid\n    x17 = x15(I)\n    # Find all cells with the background color in the rotated grid\n    x18 = ofcolor(x17, x7)\n    # Get the height of the background color area (likely the grid height)\n    x19 = height(x18)\n    # Create an interval from 0 to the grid height\n    x20 = interval(ZERO, x19, ONE)\n    # Create a function to pair each number with the grid height\n    x21 = lbind(astuple, x19)\n    # Apply this function to create coordinate pairs\n    x22 = apply(x21, x20)\n    # Create a function to shoot downwards from each coordinate\n    x23 = rbind(shoot, DOWN)\n    # Apply this function to all coordinates, creating vertical lines\n    x24 = mapply(x23, x22)\n    # Fill these vertical lines with color 4 (creating the bottom horizontal line)\n    x25 = fill(x17, FOUR, x24)\n\n    # Create a square canvas with dimensions equal to the grid height\n    x26 = astuple(x19, x19)\n    x27 = canvas(ZERO, x26)\n    # Get all indices of this canvas\n    x28 = asindices(x27)\n    # Shift these indices by the grid height (moving to bottom-right corner)\n    x29 = shift(x28, x26)\n    # Get the shape of the input grid\n    x30 = shape(I)\n    # Find the maximum dimension of the input grid\n    x31 = maximum(x30)\n    # Create a function to shift the diagonal indices\n    x32 = lbind(shift, x29)\n    # Create an interval from 0 to the maximum dimension, stepping by grid height\n    x33 = interval(ZERO, x31, x19)\n    # Pair this interval with itself\n    x34 = pair(x33, x33)\n    # Apply the shift function to these pairs, creating diagonal line coordinates\n    x35 = mapply(x32, x34)\n    # Fill these diagonal coordinates with color 2\n    x36 = fill(x25, TWO, x35)\n\n    # Apply the inverse rotation to get the final output grid\n    x37 = x16(x36)\n    return x37\n"
  },
  "3bdb4ada": {
    "original": "def verify_3bdb4ada(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = compose(flip, x2)\n    x4 = extract(x0, x3)\n    x5 = remove(x4, x0)\n    x6 = compose(flip, even)\n    x7 = rbind(chain, first)\n    x8 = rbind(chain, last)\n    x9 = lbind(rbind, subtract)\n    x10 = lbind(x7, x6)\n    x11 = lbind(x8, x6)\n    x12 = chain(x10, x9, uppermost)\n    x13 = chain(x11, x9, leftmost)\n    x14 = lbind(fork, both)\n    x15 = fork(x14, x12, x13)\n    x16 = fork(sfilter, toindices, x15)\n    x17 = mapply(x16, x5)\n    x18 = color(x4)\n    x19 = fill(I, x18, x17)\n    return x19\n\n",
    "annotated": "def verify_3bdb4ada(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if the size of an object equals its height * width\n    x2 = fork(equality, size, x1)\n    \n    # Invert the boolean result of x2\n    x3 = compose(flip, x2)\n    \n    # Extract the background object (the one that doesn't fill its bounding box)\n    x4 = extract(x0, x3)\n    \n    # Remove the background object from the set of objects\n    x5 = remove(x4, x0)\n    \n    # Create a function that checks if a number is odd (by inverting the 'even' function)\n    x6 = compose(flip, even)\n    \n    # Create a function that checks if the first coordinate is odd\n    x7 = rbind(chain, first)\n    \n    # Create a function that checks if the last coordinate is odd\n    x8 = rbind(chain, last)\n    \n    # Create a function that subtracts from a fixed value\n    x9 = lbind(rbind, subtract)\n    \n    # Combine x7 and x6 to check if the first coordinate is odd\n    x10 = lbind(x7, x6)\n    \n    # Combine x8 and x6 to check if the last coordinate is odd\n    x11 = lbind(x8, x6)\n    \n    # Create a function that checks if the row is odd relative to the object's top\n    x12 = chain(x10, x9, uppermost)\n    \n    # Create a function that checks if the column is odd relative to the object's left\n    x13 = chain(x11, x9, leftmost)\n    \n    # Create a function that combines two conditions with 'and'\n    x14 = lbind(fork, both)\n    \n    # Combine the row and column odd checks\n    x15 = fork(x14, x12, x13)\n    \n    # Create a function that filters indices based on the combined odd check\n    x16 = fork(sfilter, toindices, x15)\n    \n    # Apply the filter to all non-background objects to get indices to be filled\n    x17 = mapply(x16, x5)\n    \n    # Get the color of the background object\n    x18 = color(x4)\n    \n    # Fill the filtered indices with the background color, creating gaps in objects\n    x19 = fill(I, x18, x17)\n    \n    # Return the modified grid with gaps in objects\n    return x19\n"
  },
  "3befdf3e": {
    "original": "def verify_3befdf3e(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = rbind(compose, last)\n    x2 = lbind(rbind, contained)\n    x3 = chain(x1, x2, box)\n    x4 = fork(sfilter, identity, x3)\n    x5 = compose(color, x4)\n    x6 = fork(other, palette, x5)\n    x7 = chain(decrement, decrement, height)\n    x8 = chain(decrement, decrement, width)\n    x9 = compose(toivec, x7)\n    x10 = fork(shift, toindices, x9)\n    x11 = chain(toivec, invert, x7)\n    x12 = fork(shift, toindices, x11)\n    x13 = compose(tojvec, x8)\n    x14 = fork(shift, toindices, x13)\n    x15 = chain(tojvec, invert, x8)\n    x16 = fork(shift, toindices, x15)\n    x17 = fork(combine, x10, x12)\n    x18 = fork(combine, x14, x16)\n    x19 = fork(combine, x17, x18)\n    x20 = fork(combine, backdrop, x19)\n    x21 = fork(difference, x20, box)\n    x22 = fork(recolor, x5, x21)\n    x23 = fork(recolor, x6, box)\n    x24 = fork(combine, x22, x23)\n    x25 = mapply(x24, x0)\n    x26 = paint(I, x25)\n    return x26\n\n",
    "annotated": "def verify_3befdf3e(I: Grid) -> Grid:\n    # Extract all objects from the input grid, ignoring background\n    x0 = objects(I, F, F, T)\n    \n    # Create a function that composes a function with 'last'\n    x1 = rbind(compose, last)\n    \n    # Create a function that checks if an element is contained in a set\n    x2 = lbind(rbind, contained)\n    \n    # Create a function chain: get box of object, check if element is in box, then get last element\n    x3 = chain(x1, x2, box)\n    \n    # Create a function that filters elements based on whether they're in the object's box\n    x4 = fork(sfilter, identity, x3)\n    \n    # Create a function that gets the color of the filtered object\n    x5 = compose(color, x4)\n    \n    # Create a function that finds the other color in the palette (not the object's color)\n    x6 = fork(other, palette, x5)\n    \n    # Calculate the inner height of the object (full height minus 2)\n    x7 = chain(decrement, decrement, height)\n    \n    # Calculate the inner width of the object (full width minus 2)\n    x8 = chain(decrement, decrement, width)\n    \n    # Create a vertical vector from the inner height\n    x9 = compose(toivec, x7)\n    \n    # Shift the object's indices by the inner height vector (move down)\n    x10 = fork(shift, toindices, x9)\n    \n    # Create an inverted vertical vector from the inner height\n    x11 = chain(toivec, invert, x7)\n    \n    # Shift the object's indices by the inverted inner height vector (move up)\n    x12 = fork(shift, toindices, x11)\n    \n    # Create a horizontal vector from the inner width\n    x13 = compose(tojvec, x8)\n    \n    # Shift the object's indices by the inner width vector (move right)\n    x14 = fork(shift, toindices, x13)\n    \n    # Create an inverted horizontal vector from the inner width\n    x15 = chain(tojvec, invert, x8)\n    \n    # Shift the object's indices by the inverted inner width vector (move left)\n    x16 = fork(shift, toindices, x15)\n    \n    # Combine the up and down shifted indices\n    x17 = fork(combine, x10, x12)\n    \n    # Combine the left and right shifted indices\n    x18 = fork(combine, x14, x16)\n    \n    # Combine all shifted indices (up, down, left, right)\n    x19 = fork(combine, x17, x18)\n    \n    # Combine the object's backdrop with all shifted indices\n    x20 = fork(combine, backdrop, x19)\n    \n    # Remove the object's box from the combined area (get the \"cross\" shape)\n    x21 = fork(difference, x20, box)\n    \n    # Recolor the \"cross\" shape with the object's original color\n    x22 = fork(recolor, x5, x21)\n    \n    # Recolor the object's box with the other color from the palette\n    x23 = fork(recolor, x6, box)\n    \n    # Combine the recolored \"cross\" and the recolored box\n    x24 = fork(combine, x22, x23)\n    \n    # Apply the recoloring to all objects in the grid\n    x25 = mapply(x24, x0)\n    \n    # Paint the recolored objects onto the input grid\n    x26 = paint(I, x25)\n    \n    # Return the modified grid\n    return x26\n"
  },
  "3c9b0459": {
    "original": "def verify_3c9b0459(I: Grid) -> Grid:\n    x0 = rot180(I)\n    return x0\n\n",
    "annotated": "def verify_3c9b0459(I: Grid) -> Grid:\n    # Rotate the input grid 180 degrees (equivalent to flipping both horizontally and vertically)\n    x0 = rot180(I)\n    # Return the rotated grid as the output\n    # This effectively reverses the order of all elements in the grid\n    return x0\n"
  },
  "3de23699": {
    "original": "def verify_3de23699(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = corners(x0)\n    x2 = mapply(dneighbors, x1)\n    x3 = toobject(x2, I)\n    x4 = mostcolor(x3)\n    x5 = palette(I)\n    x6 = remove(x4, x5)\n    x7 = order(x6, identity)\n    x8 = first(x7)\n    x9 = last(x7)\n    x10 = ofcolor(I, x8)\n    x11 = ofcolor(I, x9)\n    x12 = switch(I, x9, x8)\n    x13 = combine(x10, x11)\n    x14 = subgrid(x13, x12)\n    x15 = trim(x14)\n    return x15\n\n",
    "annotated": "def verify_3de23699(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Find the corner indices of the grid\n    x1 = corners(x0)\n    \n    # Get the directly adjacent neighbors of the corner cells\n    x2 = mapply(dneighbors, x1)\n    \n    # Create an object from the neighbor cells using their colors from the input grid\n    x3 = toobject(x2, I)\n    \n    # Find the most common color in the neighbor cells (likely the background color)\n    x4 = mostcolor(x3)\n    \n    # Get all unique colors used in the input grid\n    x5 = palette(I)\n    \n    # Remove the background color from the palette\n    x6 = remove(x4, x5)\n    \n    # Sort the remaining colors\n    x7 = order(x6, identity)\n    \n    # Get the first color (likely the corner color in the input)\n    x8 = first(x7)\n    \n    # Get the last color (likely the noise color in the input)\n    x9 = last(x7)\n    \n    # Find all cells with the corner color\n    x10 = ofcolor(I, x8)\n    \n    # Find all cells with the noise color\n    x11 = ofcolor(I, x9)\n    \n    # Switch the noise color with the corner color in the entire grid\n    x12 = switch(I, x9, x8)\n    \n    # Combine the indices of corner-colored and noise-colored cells\n    x13 = combine(x10, x11)\n    \n    # Extract the subgrid containing the inner rectangle\n    x14 = subgrid(x13, x12)\n    \n    # Remove the outer border of the extracted subgrid\n    x15 = trim(x14)\n    \n    # Return the final processed grid\n    return x15\n"
  },
  "3e980e27": {
    "original": "def verify_3e980e27(I: Grid) -> Grid:\n    x0 = ofcolor(I, THREE)\n    x1 = ofcolor(I, TWO)\n    x2 = matcher(first, THREE)\n    x3 = matcher(first, TWO)\n    x4 = rbind(objects, T)\n    x5 = rbind(x4, T)\n    x6 = rbind(x5, F)\n    x7 = lbind(contained, THREE)\n    x8 = compose(x7, palette)\n    x9 = lbind(contained, TWO)\n    x10 = compose(x9, palette)\n    x11 = rbind(sfilter, x8)\n    x12 = compose(x11, x6)\n    x13 = rbind(sfilter, x10)\n    x14 = compose(x13, x6)\n    x15 = rbind(argmax, numcolors)\n    x16 = chain(normalize, x15, x12)\n    x17 = rbind(argmax, numcolors)\n    x18 = compose(x17, x14)\n    x19 = chain(normalize, vmirror, x18)\n    x20 = rbind(sfilter, x2)\n    x21 = chain(ulcorner, x20, x16)\n    x22 = rbind(sfilter, x3)\n    x23 = chain(ulcorner, x22, x19)\n    x24 = rbind(sfilter, x3)\n    x25 = chain(center, x24, x18)\n    x26 = lbind(lbind, shift)\n    x27 = compose(x26, x16)\n    x28 = lbind(lbind, shift)\n    x29 = compose(x28, x19)\n    x30 = rbind(apply, x0)\n    x31 = lbind(lbind, add)\n    x32 = compose(invert, x21)\n    x33 = chain(x30, x31, x32)\n    x34 = rbind(remove, x1)\n    x35 = compose(x34, x25)\n    x36 = lbind(lbind, add)\n    x37 = chain(x36, invert, x23)\n    x38 = fork(apply, x37, x35)\n    x39 = fork(mapply, x27, x33)\n    x40 = fork(mapply, x29, x38)\n    x41 = fork(paint, identity, x39)\n    x42 = fork(paint, identity, x40)\n    x43 = size(x0)\n    x44 = positive(x43)\n    x45 = size(x1)\n    x46 = positive(x45)\n    x47 = branch(x44, x41, identity)\n    x48 = branch(x46, x42, identity)\n    x49 = compose(x47, x48)\n    x50 = x49(I)\n    return x50\n\n",
    "annotated": "def verify_3e980e27(I: Grid) -> Grid:\n    # Get indices of all cells with color 3 (green)\n    x0 = ofcolor(I, THREE)\n    # Get indices of all cells with color 2 (red)\n    x1 = ofcolor(I, TWO)\n    # Create a function that checks if the first element of a tuple is 3\n    x2 = matcher(first, THREE)\n    # Create a function that checks if the first element of a tuple is 2\n    x3 = matcher(first, TWO)\n    # Partially apply the objects function with True for univalued\n    x4 = rbind(objects, T)\n    # Further partially apply with True for diagonal\n    x5 = rbind(x4, T)\n    # Complete partial application with False for without_bg\n    x6 = rbind(x5, F)\n    # Create a function that checks if 3 is in a container\n    x7 = lbind(contained, THREE)\n    # Create a function that checks if 3 is in the palette of an object\n    x8 = compose(x7, palette)\n    # Create a function that checks if 2 is in a container\n    x9 = lbind(contained, TWO)\n    # Create a function that checks if 2 is in the palette of an object\n    x10 = compose(x9, palette)\n    # Create a function that filters objects containing color 3\n    x11 = rbind(sfilter, x8)\n    # Create a function that finds all objects containing color 3\n    x12 = compose(x11, x6)\n    # Create a function that filters objects containing color 2\n    x13 = rbind(sfilter, x10)\n    # Create a function that finds all objects containing color 2\n    x14 = compose(x13, x6)\n    # Create a function that finds the object with the most colors\n    x15 = rbind(argmax, numcolors)\n    # Find and normalize the green object with the most colors\n    x16 = chain(normalize, x15, x12)\n    # Create another function that finds the object with the most colors\n    x17 = rbind(argmax, numcolors)\n    # Find the red object with the most colors\n    x18 = compose(x17, x14)\n    # Normalize and vertically mirror the red object\n    x19 = chain(normalize, vmirror, x18)\n    # Create a function that filters cells with color 3\n    x20 = rbind(sfilter, x2)\n    # Find the upper-left corner of the green fixed point\n    x21 = chain(ulcorner, x20, x16)\n    # Create a function that filters cells with color 2\n    x22 = rbind(sfilter, x3)\n    # Find the upper-left corner of the red fixed point\n    x23 = chain(ulcorner, x22, x19)\n    # Create another function that filters cells with color 2\n    x24 = rbind(sfilter, x3)\n    # Find the center of the red object\n    x25 = chain(center, x24, x18)\n    # Create a function to shift the green object\n    x26 = lbind(lbind, shift)\n    x27 = compose(x26, x16)\n    # Create a function to shift the red object\n    x28 = lbind(lbind, shift)\n    x29 = compose(x28, x19)\n    # Create a function to apply a transformation to all green cells\n    x30 = rbind(apply, x0)\n    # Create a function to add the inverse of the green fixed point\n    x31 = lbind(lbind, add)\n    x32 = compose(invert, x21)\n    x33 = chain(x30, x31, x32)\n    # Create a function to remove the center of the red object\n    x34 = rbind(remove, x1)\n    x35 = compose(x34, x25)\n    # Create a function to add the inverse of the red fixed point\n    x36 = lbind(lbind, add)\n    x37 = chain(x36, invert, x23)\n    # Apply the transformation to the red cells\n    x38 = fork(apply, x37, x35)\n    # Shift the green object\n    x39 = fork(mapply, x27, x33)\n    # Shift the red object\n    x40 = fork(mapply, x29, x38)\n    # Paint the shifted green object onto the input grid\n    x41 = fork(paint, identity, x39)\n    # Paint the shifted red object onto the input grid\n    x42 = fork(paint, identity, x40)\n    # Count the number of green cells\n    x43 = size(x0)\n    # Check if there are any green cells\n    x44 = positive(x43)\n    # Count the number of red cells\n    x45 = size(x1)\n    # Check if there are any red cells\n    x46 = positive(x45)\n    # If there are green cells, apply the green transformation\n    x47 = branch(x44, x41, identity)\n    # If there are red cells, apply the red transformation\n    x48 = branch(x46, x42, identity)\n    # Compose the green and red transformations\n    x49 = compose(x47, x48)\n    # Apply the final transformation to the input grid\n    x50 = x49(I)\n    # Return the transformed grid\n    return x50\n"
  },
  "3eda0437": {
    "original": "def verify_3eda0437(I: Grid) -> Grid:\n    x0 = matcher(identity, ZERO)\n    x1 = rbind(sfilter, x0)\n    x2 = compose(size, x1)\n    x3 = apply(x2, I)\n    x4 = maximum(x3)\n    x5 = dmirror(I)\n    x6 = apply(x2, x5)\n    x7 = maximum(x6)\n    x8 = increment(x7)\n    x9 = interval(TWO, x8, ONE)\n    x10 = increment(x4)\n    x11 = interval(TWO, x10, ONE)\n    x12 = product(x9, x11)\n    x13 = fork(multiply, first, last)\n    x14 = apply(x13, x12)\n    x15 = lbind(sfilter, x12)\n    x16 = lbind(matcher, x13)\n    x17 = compose(x15, x16)\n    x18 = apply(x17, x14)\n    x19 = lbind(occurrences, I)\n    x20 = lbind(recolor, ZERO)\n    x21 = lbind(canvas, NEG_ONE)\n    x22 = compose(asindices, x21)\n    x23 = chain(x19, x20, x22)\n    x24 = lbind(mapply, x23)\n    x25 = chain(positive, size, x24)\n    x26 = sfilter(x18, x25)\n    x27 = compose(x13, first)\n    x28 = rbind(argmax, x27)\n    x29 = lbind(recolor, ZERO)\n    x30 = lbind(canvas, NEG_ONE)\n    x31 = chain(x29, asindices, x30)\n    x32 = lbind(lbind, shift)\n    x33 = lbind(occurrences, I)\n    x34 = fork(mapply, x32, x33)\n    x35 = compose(x34, x31)\n    x36 = size(x26)\n    x37 = positive(x36)\n    x38 = lbind(recolor, SIX)\n    x39 = lbind(mapply, x35)\n    x40 = chain(x38, x39, x28)\n    x41 = fork(difference, identity, identity)\n    x42 = branch(x37, x40, x41)\n    x43 = x42(x26)\n    x44 = paint(I, x43)\n    return x44\n\n",
    "annotated": "def verify_3eda0437(I: Grid) -> Grid:\n    # Create a function that matches zero\n    x0 = matcher(identity, ZERO)\n    \n    # Create a function that filters elements equal to zero\n    x1 = rbind(sfilter, x0)\n    \n    # Create a function that counts the number of zeros\n    x2 = compose(size, x1)\n    \n    # Apply the zero-counting function to each row of the input grid\n    x3 = apply(x2, I)\n    \n    # Find the maximum number of zeros in any row\n    x4 = maximum(x3)\n    \n    # Transpose the input grid\n    x5 = dmirror(I)\n    \n    # Apply the zero-counting function to each column of the input grid\n    x6 = apply(x2, x5)\n    \n    # Find the maximum number of zeros in any column\n    x7 = maximum(x6)\n    \n    # Increment the maximum column zeros (for range upper bound)\n    x8 = increment(x7)\n    \n    # Create a range from 2 to the incremented max column zeros\n    x9 = interval(TWO, x8, ONE)\n    \n    # Increment the maximum row zeros (for range upper bound)\n    x10 = increment(x4)\n    \n    # Create a range from 2 to the incremented max row zeros\n    x11 = interval(TWO, x10, ONE)\n    \n    # Generate all possible rectangle dimensions (height, width)\n    x12 = product(x9, x11)\n    \n    # Create a function to multiply two numbers\n    x13 = fork(multiply, first, last)\n    \n    # Calculate areas for all possible rectangle dimensions\n    x14 = apply(x13, x12)\n    \n    # Create a function to filter rectangle dimensions\n    x15 = lbind(sfilter, x12)\n    \n    # Create a function to match rectangle areas\n    x16 = lbind(matcher, x13)\n    \n    # Combine the area matching and dimension filtering functions\n    x17 = compose(x15, x16)\n    \n    # Filter rectangle dimensions by their areas\n    x18 = apply(x17, x14)\n    \n    # Create a function to find occurrences of a pattern in the input grid\n    x19 = lbind(occurrences, I)\n    \n    # Create a function to recolor a pattern to zero\n    x20 = lbind(recolor, ZERO)\n    \n    # Create a function to generate a canvas filled with -1\n    x21 = lbind(canvas, NEG_ONE)\n    \n    # Create a function to get indices of a canvas\n    x22 = compose(asindices, x21)\n    \n    # Chain functions to create zero-filled rectangles and find their occurrences\n    x23 = chain(x19, x20, x22)\n    \n    # Create a function to apply the occurrence finding to multiple rectangles\n    x24 = lbind(mapply, x23)\n    \n    # Create a function to check if there are any occurrences of a rectangle\n    x25 = chain(positive, size, x24)\n    \n    # Filter rectangle dimensions to those that actually occur in the grid\n    x26 = sfilter(x18, x25)\n    \n    # Create a function to get the area of a rectangle\n    x27 = compose(x13, first)\n    \n    # Create a function to find the rectangle with the largest area\n    x28 = rbind(argmax, x27)\n    \n    # Create functions to generate zero-filled rectangles\n    x29 = lbind(recolor, ZERO)\n    x30 = lbind(canvas, NEG_ONE)\n    x31 = chain(x29, asindices, x30)\n    \n    # Create a function to shift a pattern\n    x32 = lbind(lbind, shift)\n    \n    # Create a function to find occurrences and shift them\n    x33 = lbind(occurrences, I)\n    x34 = fork(mapply, x32, x33)\n    \n    # Combine functions to find and shift occurrences of rectangles\n    x35 = compose(x34, x31)\n    \n    # Check if any valid rectangles were found\n    x36 = size(x26)\n    x37 = positive(x36)\n    \n    # Create a function to recolor patterns to 6 (the target color)\n    x38 = lbind(recolor, SIX)\n    \n    # Create a function to apply the occurrence finding and shifting\n    x39 = lbind(mapply, x35)\n    \n    # Chain functions to find largest rectangle, its occurrences, and recolor them\n    x40 = chain(x38, x39, x28)\n    \n    # Create a function that returns an empty set (used when no rectangles found)\n    x41 = fork(difference, identity, identity)\n    \n    # Choose between recoloring rectangles or returning empty set based on whether rectangles were found\n    x42 = branch(x37, x40, x41)\n    \n    # Apply the chosen function to the valid rectangle dimensions\n    x43 = x42(x26)\n    \n    # Paint the recolored rectangles (or nothing) onto the input grid\n    x44 = paint(I, x43)\n    \n    # Return the modified grid\n    return x44\n"
  },
  "3f7978a0": {
    "original": "def verify_3f7978a0(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = objects(I, T, F, F)\n    x2 = compose(double, height)\n    x3 = fork(equality, x2, size)\n    x4 = compose(double, width)\n    x5 = fork(equality, x4, size)\n    x6 = fork(either, x3, x5)\n    x7 = rbind(equality, TWO)\n    x8 = lbind(colorfilter, x1)\n    x9 = rbind(sfilter, vline)\n    x10 = rbind(sfilter, hline)\n    x11 = chain(x9, x8, color)\n    x12 = chain(x7, size, x11)\n    x13 = chain(x10, x8, color)\n    x14 = chain(x7, size, x13)\n    x15 = fork(either, x12, x14)\n    x16 = fork(both, x6, x15)\n    x17 = extract(x0, x16)\n    x18 = color(x17)\n    x19 = colorfilter(x1, x18)\n    x20 = first(x19)\n    x21 = vline(x20)\n    x22 = ulcorner(x17)\n    x23 = lrcorner(x17)\n    x24 = branch(x21, UP, LEFT)\n    x25 = add(x22, x24)\n    x26 = branch(x21, DOWN, RIGHT)\n    x27 = add(x23, x26)\n    x28 = initset(x27)\n    x29 = insert(x25, x28)\n    x30 = subgrid(x29, I)\n    return x30\n\n",
    "annotated": "def verify_3f7978a0(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    # Extract objects from the input grid, considering diagonal connections\n    x1 = objects(I, T, F, F)\n    # Create a function that doubles the height of an object\n    x2 = compose(double, height)\n    # Create a function that checks if an object's doubled height equals its size\n    x3 = fork(equality, x2, size)\n    # Create a function that doubles the width of an object\n    x4 = compose(double, width)\n    # Create a function that checks if an object's doubled width equals its size\n    x5 = fork(equality, x4, size)\n    # Combine the height and width checks with a logical OR\n    x6 = fork(either, x3, x5)\n    # Create a function that checks if a value equals 2\n    x7 = rbind(equality, TWO)\n    # Create a function that filters objects by color\n    x8 = lbind(colorfilter, x1)\n    # Create a function that filters for vertical lines\n    x9 = rbind(sfilter, vline)\n    # Create a function that filters for horizontal lines\n    x10 = rbind(sfilter, hline)\n    # Chain functions to find vertical lines of a specific color\n    x11 = chain(x9, x8, color)\n    # Check if there are exactly two vertical lines of the same color\n    x12 = chain(x7, size, x11)\n    # Chain functions to find horizontal lines of a specific color\n    x13 = chain(x10, x8, color)\n    # Check if there are exactly two horizontal lines of the same color\n    x14 = chain(x7, size, x13)\n    # Combine vertical and horizontal line checks with a logical OR\n    x15 = fork(either, x12, x14)\n    # Combine all checks to identify the rectangle object\n    x16 = fork(both, x6, x15)\n    # Extract the rectangle object from the partitioned grid\n    x17 = extract(x0, x16)\n    # Get the color of the rectangle\n    x18 = color(x17)\n    # Filter objects to find those with the same color as the rectangle\n    x19 = colorfilter(x1, x18)\n    # Get the first object (line) of the same color as the rectangle\n    x20 = first(x19)\n    # Check if the line is vertical\n    x21 = vline(x20)\n    # Get the upper-left corner of the rectangle\n    x22 = ulcorner(x17)\n    # Get the lower-right corner of the rectangle\n    x23 = lrcorner(x17)\n    # Choose direction based on whether the line is vertical or horizontal\n    x24 = branch(x21, UP, LEFT)\n    # Calculate one corner of the output subgrid\n    x25 = add(x22, x24)\n    # Choose opposite direction based on whether the line is vertical or horizontal\n    x26 = branch(x21, DOWN, RIGHT)\n    # Calculate the other corner of the output subgrid\n    x27 = add(x23, x26)\n    # Initialize a set with one corner of the output subgrid\n    x28 = initset(x27)\n    # Add the other corner to the set\n    x29 = insert(x25, x28)\n    # Extract the subgrid defined by the two corners\n    x30 = subgrid(x29, I)\n    # Return the extracted subgrid as the output\n    return x30\n"
  },
  "40853293": {
    "original": "def verify_40853293(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(recolor, color, backdrop)\n    x2 = apply(x1, x0)\n    x3 = mfilter(x2, hline)\n    x4 = mfilter(x2, vline)\n    x5 = paint(I, x3)\n    x6 = paint(x5, x4)\n    return x6\n\n",
    "annotated": "def verify_40853293(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that combines recoloring and finding the backdrop for each object\n    x1 = fork(recolor, color, backdrop)\n    \n    # Apply the combined function to each partitioned object\n    x2 = apply(x1, x0)\n    \n    # Filter out and merge all horizontal lines from the processed objects\n    # This effectively identifies all horizontal lines in the input\n    x3 = mfilter(x2, hline)\n    \n    # Filter out and merge all vertical lines from the processed objects\n    # This effectively identifies all vertical lines in the input\n    x4 = mfilter(x2, vline)\n    \n    # Paint the horizontal lines onto the input grid\n    # This extends the horizontal line endpoints to full lines\n    x5 = paint(I, x3)\n    \n    # Paint the vertical lines onto the grid with horizontal lines\n    # This extends the vertical line endpoints to full lines\n    x6 = paint(x5, x4)\n    \n    # Return the final grid with all lines fully drawn\n    return x6\n"
  },
  "4093f84a": {
    "original": "def verify_4093f84a(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = palette(x1)\n    x3 = fork(multiply, height, width)\n    x4 = lbind(ofcolor, I)\n    x5 = compose(x3, x4)\n    x6 = argmin(x2, x5)\n    x7 = palette(I)\n    x8 = remove(x6, x7)\n    x9 = lbind(colorcount, I)\n    x10 = argmin(x8, x9)\n    x11 = ofcolor(I, x6)\n    x12 = leftmost(x11)\n    x13 = positive(x12)\n    x14 = branch(x13, identity, dmirror)\n    x15 = x14(I)\n    x16 = ofcolor(x15, x6)\n    x17 = subgrid(x16, x15)\n    x18 = leftmost(x16)\n    x19 = rightmost(x16)\n    x20 = lbind(greater, x18)\n    x21 = compose(x20, last)\n    x22 = rbind(greater, x19)\n    x23 = compose(x22, last)\n    x24 = asindices(x15)\n    x25 = sfilter(x24, x21)\n    x26 = subgrid(x25, x15)\n    x27 = asindices(x15)\n    x28 = sfilter(x27, x23)\n    x29 = subgrid(x28, x15)\n    x30 = rbind(equality, x10)\n    x31 = rbind(order, x30)\n    x32 = apply(x31, x26)\n    x33 = vmirror(x29)\n    x34 = apply(x31, x33)\n    x35 = vmirror(x34)\n    x36 = hconcat(x32, x17)\n    x37 = hconcat(x36, x35)\n    x38 = x14(x37)\n    x39 = replace(x38, x10, x6)\n    return x39\n\n",
    "annotated": "def verify_4093f84a(I: Grid) -> Grid:\n    # Get the set of frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    # Get the palette (unique colors) of the merged frontiers\n    x2 = palette(x1)\n    # Create a function that multiplies the height and width of a color region\n    x3 = fork(multiply, height, width)\n    # Create a function that finds all cells of a specific color in the input grid\n    x4 = lbind(ofcolor, I)\n    # Compose the area calculation function with the color finding function\n    x5 = compose(x3, x4)\n    # Find the color with the minimum area (likely the background color)\n    x6 = argmin(x2, x5)\n    # Get the palette of the entire input grid\n    x7 = palette(I)\n    # Remove the background color from the palette\n    x8 = remove(x6, x7)\n    # Create a function that counts the occurrences of a color in the input grid\n    x9 = lbind(colorcount, I)\n    # Find the least common non-background color (likely the dot color)\n    x10 = argmin(x8, x9)\n    # Get all cells with the background color\n    x11 = ofcolor(I, x6)\n    # Find the leftmost column of the background color region\n    x12 = leftmost(x11)\n    # Check if the leftmost background column is not at the left edge\n    x13 = positive(x12)\n    # Create a function to mirror the grid diagonally if needed\n    x14 = branch(x13, identity, dmirror)\n    # Apply the mirroring function to the input grid\n    x15 = x14(I)\n    # Get all cells with the background color in the possibly mirrored grid\n    x16 = ofcolor(x15, x6)\n    # Extract the subgrid containing the background color region\n    x17 = subgrid(x16, x15)\n    # Find the leftmost column of the background region\n    x18 = leftmost(x16)\n    # Find the rightmost column of the background region\n    x19 = rightmost(x16)\n    # Create a function to check if a column is to the left of the background region\n    x20 = lbind(greater, x18)\n    # Compose the left check with getting the last element (for vertical lines)\n    x21 = compose(x20, last)\n    # Create a function to check if a column is to the right of the background region\n    x22 = rbind(greater, x19)\n    # Compose the right check with getting the last element (for vertical lines)\n    x23 = compose(x22, last)\n    # Get all cell indices in the grid\n    x24 = asindices(x15)\n    # Filter indices to get only those to the left of the background region\n    x25 = sfilter(x24, x21)\n    # Extract the subgrid to the left of the background region\n    x26 = subgrid(x25, x15)\n    # Get all cell indices in the grid again\n    x27 = asindices(x15)\n    # Filter indices to get only those to the right of the background region\n    x28 = sfilter(x27, x23)\n    # Extract the subgrid to the right of the background region\n    x29 = subgrid(x28, x15)\n    # Create a function to check if a color matches the dot color\n    x30 = rbind(equality, x10)\n    # Create a function to order cells based on whether they match the dot color\n    x31 = rbind(order, x30)\n    # Apply the ordering function to the left subgrid (connect dots vertically)\n    x32 = apply(x31, x26)\n    # Mirror the right subgrid vertically\n    x33 = vmirror(x29)\n    # Apply the ordering function to the mirrored right subgrid\n    x34 = apply(x31, x33)\n    # Mirror the result back vertically\n    x35 = vmirror(x34)\n    # Concatenate the left subgrid, background region, and right subgrid horizontally\n    x36 = hconcat(x32, x17)\n    x37 = hconcat(x36, x35)\n    # Apply the initial mirroring function to the result (if needed)\n    x38 = x14(x37)\n    # Replace the dot color with the background color in the final grid\n    x39 = replace(x38, x10, x6)\n    return x39\n"
  },
  "41e4d17e": {
    "original": "def verify_41e4d17e(I: Grid) -> Grid:\n    x0 = lbind(equality, NINE)\n    x1 = compose(x0, size)\n    x2 = fork(equality, height, width)\n    x3 = fork(both, x1, x2)\n    x4 = objects(I, T, F, F)\n    x5 = sfilter(x4, x3)\n    x6 = fork(combine, vfrontier, hfrontier)\n    x7 = compose(x6, center)\n    x8 = mapply(x7, x5)\n    x9 = underfill(I, SIX, x8)\n    return x9\n\n",
    "annotated": "def verify_41e4d17e(I: Grid) -> Grid:\n    # Create a function that checks if a value is equal to 9\n    x0 = lbind(equality, NINE)\n    \n    # Create a function that checks if the size of an object is 9\n    x1 = compose(x0, size)\n    \n    # Create a function that checks if the height and width of an object are equal\n    x2 = fork(equality, height, width)\n    \n    # Create a function that checks if an object has size 9 AND is square\n    x3 = fork(both, x1, x2)\n    \n    # Find all objects in the input grid, including diagonally connected cells\n    x4 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those that are 3x3 squares\n    x5 = sfilter(x4, x3)\n    \n    # Create a function that combines vertical and horizontal frontiers\n    x6 = fork(combine, vfrontier, hfrontier)\n    \n    # Create a function that finds the center of an object and gets its frontiers\n    x7 = compose(x6, center)\n    \n    # Apply the frontier function to all 3x3 squares and merge results\n    x8 = mapply(x7, x5)\n    \n    # Fill the input grid with color 6 along the frontiers, but only where the original color isn't 6\n    # This creates cross-like patterns through the centers of the 3x3 squares\n    x9 = underfill(I, SIX, x8)\n    \n    # Return the modified grid\n    return x9\n"
  },
  "4258a5f9": {
    "original": "def verify_4258a5f9(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = mapply(neighbors, x1)\n    x3 = difference(x2, x1)\n    x4 = fill(I, ONE, x3)\n    return x4\n\n",
    "annotated": "def verify_4258a5f9(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all positions of the least common color (dot positions)\n    x1 = ofcolor(I, x0)\n    \n    # Find all neighboring positions of the dots\n    x2 = mapply(neighbors, x1)\n    \n    # Get positions that are neighbors of dots but not dots themselves\n    x3 = difference(x2, x1)\n    \n    # Fill these positions with color 1 (creating a halo around each dot)\n    x4 = fill(I, ONE, x3)\n    \n    # Return the modified grid with halos around the dots\n    return x4\n"
  },
  "4290ef0e": {
    "original": "def verify_4290ef0e(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = fgpartition(I)\n    x2 = objects(I, T, F, T)\n    x3 = rbind(valmax, width)\n    x4 = lbind(colorfilter, x2)\n    x5 = chain(x3, x4, color)\n    x6 = compose(maximum, shape)\n    x7 = fork(add, x6, x5)\n    x8 = compose(invert, x7)\n    x9 = order(x1, x8)\n    x10 = rbind(add, DOWN)\n    x11 = compose(x10, ulcorner)\n    x12 = fork(contained, x11, toindices)\n    x13 = rbind(add, RIGHT)\n    x14 = compose(x13, ulcorner)\n    x15 = fork(contained, x14, toindices)\n    x16 = fork(add, x12, x15)\n    x17 = rbind(argmax, x16)\n    x18 = compose(initset, identity)\n    x19 = fork(insert, vmirror, x18)\n    x20 = fork(insert, cmirror, x19)\n    x21 = fork(insert, hmirror, x20)\n    x22 = compose(x17, x21)\n    x23 = apply(x22, x9)\n    x24 = size(x1)\n    x25 = apply(size, x1)\n    x26 = contained(ONE, x25)\n    x27 = increment(x24)\n    x28 = branch(x26, x24, x27)\n    x29 = double(x28)\n    x30 = decrement(x29)\n    x31 = apply(normalize, x23)\n    x32 = interval(ZERO, x28, ONE)\n    x33 = pair(x32, x32)\n    x34 = mpapply(shift, x31, x33)\n    x35 = astuple(x30, x30)\n    x36 = canvas(x0, x35)\n    x37 = paint(x36, x34)\n    x38 = rot90(x37)\n    x39 = paint(x38, x34)\n    x40 = rot90(x39)\n    x41 = paint(x40, x34)\n    x42 = rot90(x41)\n    x43 = paint(x42, x34)\n    return x43\n\n",
    "annotated": "def verify_4290ef0e(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Partition the foreground objects in the input grid\n    x1 = fgpartition(I)\n    # Get all objects in the input grid, considering diagonal connections and ignoring the background\n    x2 = objects(I, T, F, T)\n    # Create a function that finds the maximum width of an object\n    x3 = rbind(valmax, width)\n    # Create a function that filters objects by color\n    x4 = lbind(colorfilter, x2)\n    # Create a function that finds the color with the maximum width\n    x5 = chain(x3, x4, color)\n    # Create a function that finds the maximum dimension (height or width) of an object\n    x6 = compose(maximum, shape)\n    # Create a function that adds the maximum dimension and the maximum width of the color\n    x7 = fork(add, x6, x5)\n    # Invert the result of x7 (to be used for sorting in descending order)\n    x8 = compose(invert, x7)\n    # Sort the partitioned objects based on the inverted size+width metric\n    x9 = order(x1, x8)\n    # Create a function that adds the DOWN vector to a point\n    x10 = rbind(add, DOWN)\n    # Create a function that gets the point below the upper-left corner\n    x11 = compose(x10, ulcorner)\n    # Check if the point below the upper-left corner is in the object\n    x12 = fork(contained, x11, toindices)\n    # Create a function that adds the RIGHT vector to a point\n    x13 = rbind(add, RIGHT)\n    # Create a function that gets the point to the right of the upper-left corner\n    x14 = compose(x13, ulcorner)\n    # Check if the point to the right of the upper-left corner is in the object\n    x15 = fork(contained, x14, toindices)\n    # Combine the checks for points below and to the right of the upper-left corner\n    x16 = fork(add, x12, x15)\n    # Create a function that finds the object with the maximum score from x16\n    x17 = rbind(argmax, x16)\n    # Create a function that initializes a set with an identity function\n    x18 = compose(initset, identity)\n    # Add vertical mirror of the object to the set\n    x19 = fork(insert, vmirror, x18)\n    # Add counter-diagonal mirror of the object to the set\n    x20 = fork(insert, cmirror, x19)\n    # Add horizontal mirror of the object to the set\n    x21 = fork(insert, hmirror, x20)\n    # Create a function that selects the best orientation of an object\n    x22 = compose(x17, x21)\n    # Apply the best orientation selection to all sorted objects\n    x23 = apply(x22, x9)\n    # Get the number of partitioned objects\n    x24 = size(x1)\n    # Get the sizes of all partitioned objects\n    x25 = apply(size, x1)\n    # Check if there's an object of size 1\n    x26 = contained(ONE, x25)\n    # Increment the number of objects\n    x27 = increment(x24)\n    # If there's an object of size 1, use x24; otherwise use x27\n    x28 = branch(x26, x24, x27)\n    # Double the number of objects (for symmetric placement)\n    x29 = double(x28)\n    # Decrement the doubled number (for grid size)\n    x30 = decrement(x29)\n    # Normalize all selected objects\n    x31 = apply(normalize, x23)\n    # Create a range from 0 to x28\n    x32 = interval(ZERO, x28, ONE)\n    # Create pairs of coordinates for object placement\n    x33 = pair(x32, x32)\n    # Shift all normalized objects to their placement positions\n    x34 = mpapply(shift, x31, x33)\n    # Create a tuple representing the dimensions of the output grid\n    x35 = astuple(x30, x30)\n    # Create a canvas with the background color and calculated dimensions\n    x36 = canvas(x0, x35)\n    # Paint the shifted objects onto the canvas\n    x37 = paint(x36, x34)\n    # Rotate the grid 90 degrees\n    x38 = rot90(x37)\n    # Paint the objects again on the rotated grid\n    x39 = paint(x38, x34)\n    # Rotate 90 degrees again\n    x40 = rot90(x39)\n    # Paint the objects on the twice-rotated grid\n    x41 = paint(x40, x34)\n    # Rotate 90 degrees one last time\n    x42 = rot90(x41)\n    # Paint the objects on the thrice-rotated grid, completing the symmetry\n    x43 = paint(x42, x34)\n    # Return the final symmetric grid\n    return x43\n"
  },
  "42a50994": {
    "original": "def verify_42a50994(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = sizefilter(x0, ONE)\n    x2 = merge(x1)\n    x3 = cover(I, x2)\n    return x3\n\n",
    "annotated": "def verify_42a50994(I: Grid) -> Grid:\n    # Identify all objects (connected components) in the input grid I\n    # Objects can have different colors and can be diagonally connected\n    x0 = objects(I, F, T, T)\n\n    # Filter out objects that consist of only one cell\n    # This effectively selects all single-cell objects\n    x1 = sizefilter(x0, ONE)\n\n    # Merge all single-cell objects into one set\n    # This combines all individual cells into a single object\n    x2 = merge(x1)\n\n    # Remove (cover) all cells in x2 from the input grid I\n    # This effectively removes all single-cell objects from the grid\n    # by replacing them with the background color\n    x3 = cover(I, x2)\n\n    # Return the modified grid\n    # The output is the input grid with all single-cell objects removed\n    return x3\n"
  },
  "4347f46a": {
    "original": "def verify_4347f46a(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = fork(difference, toindices, box)\n    x2 = mapply(x1, x0)\n    x3 = mostcolor(I)\n    x4 = fill(I, x3, x2)\n    return x4\n\n",
    "annotated": "def verify_4347f46a(I: Grid) -> Grid:\n    # Identify all objects in the input grid I\n    # T: objects are univalued, F: diagonal connections not allowed, T: exclude background\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that finds the difference between an object's indices and its outline\n    # This effectively creates a function to get the interior of an object\n    x1 = fork(difference, toindices, box)\n    \n    # Apply the interior-finding function to all objects\n    # This gives us the interior cells of all objects\n    x2 = mapply(x1, x0)\n    \n    # Find the most common color in the input grid (background color)\n    x3 = mostcolor(I)\n    \n    # Fill the interior of all objects with the background color\n    # This effectively outlines all objects, leaving only their borders\n    x4 = fill(I, x3, x2)\n    \n    # Return the modified grid with only object outlines remaining\n    return x4\n"
  },
  "444801d8": {
    "original": "def verify_444801d8(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = sizefilter(x0, ONE)\n    x2 = difference(x0, x1)\n    x3 = rbind(toobject, I)\n    x4 = chain(leastcolor, x3, delta)\n    x5 = rbind(shift, UP)\n    x6 = fork(connect, ulcorner, urcorner)\n    x7 = compose(x5, x6)\n    x8 = rbind(shift, DOWN)\n    x9 = fork(connect, llcorner, lrcorner)\n    x10 = compose(x8, x9)\n    x11 = fork(astuple, x7, x10)\n    x12 = lbind(rbind, manhattan)\n    x13 = compose(x12, delta)\n    x14 = fork(argmin, x11, x13)\n    x15 = fork(combine, delta, x14)\n    x16 = fork(recolor, x4, x15)\n    x17 = mapply(x16, x2)\n    x18 = paint(I, x17)\n    return x18\n\n",
    "annotated": "def verify_444801d8(I: Grid) -> Grid:\n    # Find all objects in the input grid, including diagonal connections and excluding the background\n    x0 = objects(I, T, F, T)\n    \n    # Filter out single-cell objects (dots)\n    x1 = sizefilter(x0, ONE)\n    \n    # Get all objects except the dots\n    x2 = difference(x0, x1)\n    \n    # Create a function that converts a patch to an object using the input grid\n    x3 = rbind(toobject, I)\n    \n    # Create a function chain that finds the least common color in the delta (inside) of an object\n    x4 = chain(leastcolor, x3, delta)\n    \n    # Create a function that shifts a patch upwards\n    x5 = rbind(shift, UP)\n    \n    # Create a function that connects the upper left and upper right corners of a patch\n    x6 = fork(connect, ulcorner, urcorner)\n    \n    # Combine the above two functions to get the upper edge of a patch, shifted up\n    x7 = compose(x5, x6)\n    \n    # Create a function that shifts a patch downwards\n    x8 = rbind(shift, DOWN)\n    \n    # Create a function that connects the lower left and lower right corners of a patch\n    x9 = fork(connect, llcorner, lrcorner)\n    \n    # Combine the above two functions to get the lower edge of a patch, shifted down\n    x10 = compose(x8, x9)\n    \n    # Create a function that returns both the upper and lower edges of a patch\n    x11 = fork(astuple, x7, x10)\n    \n    # Create a function that calculates the Manhattan distance to the delta of an object\n    x12 = lbind(rbind, manhattan)\n    x13 = compose(x12, delta)\n    \n    # Find the edge (upper or lower) closest to the delta of the object\n    x14 = fork(argmin, x11, x13)\n    \n    # Combine the delta of the object with the closest edge\n    x15 = fork(combine, delta, x14)\n    \n    # Create a function that recolors the combined area with the least common color\n    x16 = fork(recolor, x4, x15)\n    \n    # Apply the recoloring function to all non-dot objects\n    x17 = mapply(x16, x2)\n    \n    # Paint the recolored objects onto the input grid\n    x18 = paint(I, x17)\n    \n    # Return the modified grid\n    return x18\n"
  },
  "445eab21": {
    "original": "def verify_445eab21(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = color(x2)\n    x4 = canvas(x3, TWO_BY_TWO)\n    return x4\n\n",
    "annotated": "def verify_445eab21(I: Grid) -> Grid:\n    # Extract all objects from the input grid I\n    # Objects are considered connected components of the same color, ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that multiplies the height and width of an object\n    # This effectively calculates the area of the object\n    x1 = fork(multiply, height, width)\n    \n    # Find the object with the largest area\n    # This is done by applying the area calculation function (x1) to each object in x0\n    # and selecting the one that gives the maximum result\n    x2 = argmax(x0, x1)\n    \n    # Extract the color of the largest object\n    x3 = color(x2)\n    \n    # Create a 2x2 grid filled with the color of the largest object\n    # This is the final output of the verifier\n    x4 = canvas(x3, TWO_BY_TWO)\n    \n    # Return the 2x2 grid as the solution\n    return x4\n"
  },
  "447fd412": {
    "original": "def verify_447fd412(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = shape(I)\n    x2 = shift(x0, x1)\n    x3 = mostcolor(I)\n    x4 = shape(I)\n    x5 = multiply(x4, THREE)\n    x6 = canvas(x3, x5)\n    x7 = paint(x6, x2)\n    x8 = objects(x7, F, T, T)\n    x9 = argmax(x8, numcolors)\n    x10 = normalize(x9)\n    x11 = remove(x10, x8)\n    x12 = merge(x11)\n    x13 = mostcolor(x12)\n    x14 = palette(x10)\n    x15 = matcher(identity, x13)\n    x16 = argmin(x14, x15)\n    x17 = matcher(first, x13)\n    x18 = sfilter(x10, x17)\n    x19 = matcher(first, x16)\n    x20 = sfilter(x10, x19)\n    x21 = recolor(x3, x20)\n    x22 = combine(x18, x21)\n    x23 = lbind(mfilter, x8)\n    x24 = lbind(occurrences, x7)\n    x25 = lbind(upscale, x22)\n    x26 = compose(x24, x25)\n    x27 = lbind(lbind, shift)\n    x28 = lbind(upscale, x10)\n    x29 = compose(x27, x28)\n    x30 = fork(apply, x29, x26)\n    x31 = compose(positive, size)\n    x32 = lbind(chain, x31)\n    x33 = rbind(x32, toindices)\n    x34 = lbind(rbind, intersection)\n    x35 = chain(x23, x33, x34)\n    x36 = chain(size, x35, toindices)\n    x37 = rbind(colorcount, x13)\n    x38 = fork(equality, x36, x37)\n    x39 = rbind(sfilter, x38)\n    x40 = chain(merge, x39, x30)\n    x41 = interval(ONE, SIX, ONE)\n    x42 = mapply(x40, x41)\n    x43 = paint(x7, x42)\n    x44 = subgrid(x2, x43)\n    return x44\n\n",
    "annotated": "def verify_447fd412(I: Grid) -> Grid:\n    # Convert input grid to an object representation\n    x0 = asobject(I)\n    # Get the dimensions of the input grid\n    x1 = shape(I)\n    # Shift the object representation by the grid dimensions (effectively doubling its position)\n    x2 = shift(x0, x1)\n    # Find the most common color in the input grid (background color)\n    x3 = mostcolor(I)\n    # Get the dimensions of the input grid again\n    x4 = shape(I)\n    # Multiply the grid dimensions by 3 (creating a larger canvas)\n    x5 = multiply(x4, THREE)\n    # Create a new canvas with the background color and tripled dimensions\n    x6 = canvas(x3, x5)\n    # Paint the shifted object onto the larger canvas\n    x7 = paint(x6, x2)\n    # Find all objects in the larger canvas, allowing diagonal connections and ignoring background\n    x8 = objects(x7, F, T, T)\n    # Find the object with the most colors (likely the original pattern)\n    x9 = argmax(x8, numcolors)\n    # Normalize the position of the found object (move to origin)\n    x10 = normalize(x9)\n    # Remove the found object from the set of all objects\n    x11 = remove(x10, x8)\n    # Merge all remaining objects\n    x12 = merge(x11)\n    # Find the most common color in the merged objects (likely the indicator color)\n    x13 = mostcolor(x12)\n    # Get the palette of colors used in the normalized object\n    x14 = palette(x10)\n    # Create a function to match the indicator color\n    x15 = matcher(identity, x13)\n    # Find the color in the palette that's not the indicator color (main color)\n    x16 = argmin(x14, x15)\n    # Create a function to match the indicator color\n    x17 = matcher(first, x13)\n    # Filter the normalized object to get only the indicator parts\n    x18 = sfilter(x10, x17)\n    # Create a function to match the main color\n    x19 = matcher(first, x16)\n    # Filter the normalized object to get only the main parts\n    x20 = sfilter(x10, x19)\n    # Recolor the main parts to the background color\n    x21 = recolor(x3, x20)\n    # Combine the indicator parts and recolored main parts\n    x22 = combine(x18, x21)\n    # Create a function to filter objects based on a condition\n    x23 = lbind(mfilter, x8)\n    # Create a function to find occurrences of an object in the larger canvas\n    x24 = lbind(occurrences, x7)\n    # Create a function to upscale the combined object\n    x25 = lbind(upscale, x22)\n    # Compose functions to find occurrences of upscaled combined object\n    x26 = compose(x24, x25)\n    # Create a function to bind the shift function\n    x27 = lbind(lbind, shift)\n    # Create a function to upscale the normalized object\n    x28 = lbind(upscale, x10)\n    # Compose functions to create shifted and upscaled versions of the normalized object\n    x29 = compose(x27, x28)\n    # Create a function to apply both x29 and x26 to an input\n    x30 = fork(apply, x29, x26)\n    # Create a function to check if size is positive\n    x31 = compose(positive, size)\n    # Create a function to chain operations\n    x32 = lbind(chain, x31)\n    # Create a function to check if size of indices is positive\n    x33 = rbind(x32, toindices)\n    # Create a function to bind the intersection operation\n    x34 = lbind(rbind, intersection)\n    # Chain operations to filter objects based on intersection and positive size\n    x35 = chain(x23, x33, x34)\n    # Create a function to get the size of the filtered and intersected objects\n    x36 = chain(size, x35, toindices)\n    # Create a function to count occurrences of the indicator color\n    x37 = rbind(colorcount, x13)\n    # Create a function to check if the sizes are equal\n    x38 = fork(equality, x36, x37)\n    # Create a function to filter based on the equality check\n    x39 = rbind(sfilter, x38)\n    # Chain operations to merge filtered and upscaled objects\n    x40 = chain(merge, x39, x30)\n    # Create a range of scaling factors from 1 to 5\n    x41 = interval(ONE, SIX, ONE)\n    # Apply the merging and filtering operations for each scaling factor\n    x42 = mapply(x40, x41)\n    # Paint the resulting objects onto the larger canvas\n    x43 = paint(x7, x42)\n    # Extract the relevant subgrid from the final result\n    x44 = subgrid(x2, x43)\n    # Return the extracted subgrid as the output\n    return x44\n"
  },
  "44d8ac46": {
    "original": "def verify_44d8ac46(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = apply(delta, x0)\n    x2 = mfilter(x1, square)\n    x3 = fill(I, TWO, x2)\n    return x3\n\n",
    "annotated": "def verify_44d8ac46(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and excluding the background\n    x0 = objects(I, T, F, T)\n    \n    # For each object, get the indices in its bounding box that are not part of the object itself\n    x1 = apply(delta, x0)\n    \n    # Filter out only the square-shaped regions from the previous step\n    # This effectively finds all square \"holes\" within the objects\n    x2 = mfilter(x1, square)\n    \n    # Fill all the square \"holes\" with color 2 (representing the inner squares)\n    # This transforms the input grid by filling in the detected square regions\n    x3 = fill(I, TWO, x2)\n    \n    # Return the modified grid, which now has square holes filled with color 2\n    return x3\n"
  },
  "44f52bb0": {
    "original": "def verify_44f52bb0(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = equality(x0, I)\n    x2 = hmirror(I)\n    x3 = equality(x2, I)\n    x4 = either(x1, x3)\n    x5 = branch(x4, ONE, SEVEN)\n    x6 = canvas(x5, UNITY)\n    return x6\n\n",
    "annotated": "def verify_44f52bb0(I: Grid) -> Grid:\n    # Mirror the input grid vertically\n    x0 = vmirror(I)\n    \n    # Check if the vertically mirrored grid is equal to the original input\n    # This tests for vertical symmetry\n    x1 = equality(x0, I)\n    \n    # Mirror the input grid horizontally\n    x2 = hmirror(I)\n    \n    # Check if the horizontally mirrored grid is equal to the original input\n    # This tests for horizontal symmetry\n    x3 = equality(x2, I)\n    \n    # Check if the grid has either vertical or horizontal symmetry\n    # Returns True if the grid is symmetric in either direction\n    x4 = either(x1, x3)\n    \n    # If the grid is symmetric (x4 is True), return 1; otherwise, return 7\n    # This determines the color of the output grid\n    x5 = branch(x4, ONE, SEVEN)\n    \n    # Create a 1x1 grid (canvas) with the color determined in the previous step\n    # This is the final output: 1 for symmetric, 7 for asymmetric\n    x6 = canvas(x5, UNITY)\n    \n    # Return the final 1x1 grid indicating symmetry (1) or asymmetry (7)\n    return x6\n"
  },
  "4522001f": {
    "original": "def verify_4522001f(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = multiply(THREE, x0)\n    x2 = mostcolor(I)\n    x3 = canvas(x2, x1)\n    x4 = objects(I, F, F, T)\n    x5 = merge(x4)\n    x6 = mostcolor(x5)\n    x7 = first(x4)\n    x8 = matcher(first, x6)\n    x9 = sfilter(x7, x8)\n    x10 = normalize(x9)\n    x11 = delta(x10)\n    x12 = first(x11)\n    x13 = subtract(ONE, x12)\n    x14 = asobject(I)\n    x15 = shape(I)\n    x16 = double(x15)\n    x17 = multiply(x13, x16)\n    x18 = shift(x14, x17)\n    x19 = paint(x3, x18)\n    x20 = objects(x19, F, F, T)\n    x21 = lbind(mapply, dneighbors)\n    x22 = matcher(first, x6)\n    x23 = rbind(sfilter, x22)\n    x24 = chain(x21, delta, x23)\n    x25 = ineighbors(ORIGIN)\n    x26 = apply(double, x25)\n    x27 = rbind(apply, x26)\n    x28 = lbind(lbind, shift)\n    x29 = compose(x27, x28)\n    x30 = lbind(rbind, adjacent)\n    x31 = compose(x30, x24)\n    x32 = fork(extract, x29, x31)\n    x33 = fork(combine, identity, x32)\n    x34 = compose(backdrop, x33)\n    x35 = double(x12)\n    x36 = decrement(x35)\n    x37 = multiply(x36, FOUR)\n    x38 = rbind(shift, x37)\n    x39 = compose(x38, x34)\n    x40 = fork(combine, x34, x39)\n    x41 = mapply(x40, x20)\n    x42 = fill(x19, x6, x41)\n    return x42\n\n",
    "annotated": "def verify_4522001f(I: Grid) -> Grid:\n    # Get the shape (dimensions) of the input grid\n    x0 = shape(I)\n    # Multiply the dimensions by 3 to get the output grid size\n    x1 = multiply(THREE, x0)\n    # Find the most common color in the input grid (background color)\n    x2 = mostcolor(I)\n    # Create a canvas of the output size with the background color\n    x3 = canvas(x2, x1)\n    # Find all objects in the input grid, considering diagonals and ignoring background\n    x4 = objects(I, F, F, T)\n    # Merge all objects into a single object\n    x5 = merge(x4)\n    # Find the most common color in the merged object (likely the square color)\n    x6 = mostcolor(x5)\n    # Get the first object from the list of objects\n    x7 = first(x4)\n    # Create a function to match the most common color\n    x8 = matcher(first, x6)\n    # Filter the first object to keep only cells with the most common color\n    x9 = sfilter(x7, x8)\n    # Normalize the filtered object (move to origin)\n    x10 = normalize(x9)\n    # Get the cells in the bounding box that are not part of the object\n    x11 = delta(x10)\n    # Get the first cell from the delta (likely (0,1) or (1,0))\n    x12 = first(x11)\n    # Subtract this cell from (1,1) to get the offset to the dot\n    x13 = subtract(ONE, x12)\n    # Convert the entire input grid to an object\n    x14 = asobject(I)\n    # Get the shape of the input grid again\n    x15 = shape(I)\n    # Double the input grid dimensions\n    x16 = double(x15)\n    # Multiply the dot offset by the doubled dimensions\n    x17 = multiply(x13, x16)\n    # Shift the input grid object by this calculated offset\n    x18 = shift(x14, x17)\n    # Paint the shifted input onto the output canvas\n    x19 = paint(x3, x18)\n    # Find all objects in the new painted grid\n    x20 = objects(x19, F, F, T)\n    # Prepare a function to get direct neighbors\n    x21 = lbind(mapply, dneighbors)\n    # Prepare a function to match the square color\n    x22 = matcher(first, x6)\n    # Prepare a function to filter by square color\n    x23 = rbind(sfilter, x22)\n    # Chain functions to get neighbors of square-colored cells\n    x24 = chain(x21, delta, x23)\n    # Get the diagonal neighbors of the origin\n    x25 = ineighbors(ORIGIN)\n    # Double each diagonal neighbor coordinate\n    x26 = apply(double, x25)\n    # Prepare a function to apply the doubled coordinates\n    x27 = rbind(apply, x26)\n    # Prepare a function to bind shift function\n    x28 = lbind(lbind, shift)\n    # Compose functions to shift by doubled coordinates\n    x29 = compose(x27, x28)\n    # Prepare a function to check adjacency\n    x30 = lbind(rbind, adjacent)\n    # Compose functions to check adjacency of neighbors\n    x31 = compose(x30, x24)\n    # Create a function to extract based on shift and adjacency\n    x32 = fork(extract, x29, x31)\n    # Create a function to combine identity and extraction\n    x33 = fork(combine, identity, x32)\n    # Compose functions to get backdrop of combined cells\n    x34 = compose(backdrop, x33)\n    # Double the first delta cell and decrement\n    x35 = double(x12)\n    x36 = decrement(x35)\n    # Multiply by 4 to get the shift for the second square\n    x37 = multiply(x36, FOUR)\n    # Prepare a function to shift by this amount\n    x38 = rbind(shift, x37)\n    # Compose functions to shift the backdrop\n    x39 = compose(x38, x34)\n    # Create a function to combine original and shifted backdrops\n    x40 = fork(combine, x34, x39)\n    # Apply this combination function to all objects\n    x41 = mapply(x40, x20)\n    # Fill the output grid with the square color in the calculated areas\n    x42 = fill(x19, x6, x41)\n    # Return the final output grid\n    return x42\n"
  },
  "4612dd53": {
    "original": "def verify_4612dd53(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = box(x1)\n    x3 = fill(I, TWO, x2)\n    x4 = subgrid(x1, x3)\n    x5 = ofcolor(x4, x0)\n    x6 = mapply(vfrontier, x5)\n    x7 = mapply(hfrontier, x5)\n    x8 = size(x6)\n    x9 = size(x7)\n    x10 = greater(x8, x9)\n    x11 = branch(x10, x7, x6)\n    x12 = fill(x4, TWO, x11)\n    x13 = ofcolor(x12, TWO)\n    x14 = ulcorner(x1)\n    x15 = shift(x13, x14)\n    x16 = underfill(I, TWO, x15)\n    return x16\n\n",
    "annotated": "def verify_4612dd53(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all cells with the background color (outline of the box)\n    x1 = ofcolor(I, x0)\n    \n    # Create a box outline from the background color cells\n    x2 = box(x1)\n    \n    # Fill the box outline with color 2 (highlighting the box)\n    x3 = fill(I, TWO, x2)\n    \n    # Extract the subgrid containing only the box area\n    x4 = subgrid(x1, x3)\n    \n    # Find background color cells within the box (potential bar locations)\n    x5 = ofcolor(x4, x0)\n    \n    # Create vertical frontiers from the background cells in the box\n    x6 = mapply(vfrontier, x5)\n    \n    # Create horizontal frontiers from the background cells in the box\n    x7 = mapply(hfrontier, x5)\n    \n    # Count the number of vertical frontiers\n    x8 = size(x6)\n    \n    # Count the number of horizontal frontiers\n    x9 = size(x7)\n    \n    # Check if there are more vertical frontiers than horizontal\n    x10 = greater(x8, x9)\n    \n    # Choose horizontal frontiers if more vertical, else choose vertical\n    # (This determines whether the bar is horizontal or vertical)\n    x11 = branch(x10, x7, x6)\n    \n    # Fill the chosen frontier (bar) with color 2\n    x12 = fill(x4, TWO, x11)\n    \n    # Get all cells with color 2 in the box subgrid (box outline and bar)\n    x13 = ofcolor(x12, TWO)\n    \n    # Find the upper-left corner of the original box\n    x14 = ulcorner(x1)\n    \n    # Shift the color 2 cells back to their original position in the input grid\n    x15 = shift(x13, x14)\n    \n    # Fill the input grid with color 2 where the box outline and bar should be,\n    # but only in cells that weren't already filled (reveals occluded parts)\n    x16 = underfill(I, TWO, x15)\n    \n    # Return the final grid with the box outline and bar revealed\n    return x16\n"
  },
  "46442a0e": {
    "original": "def verify_46442a0e(I: Grid) -> Grid:\n    x0 = rot90(I)\n    x1 = rot180(I)\n    x2 = rot270(I)\n    x3 = hconcat(I, x0)\n    x4 = hconcat(x2, x1)\n    x5 = vconcat(x3, x4)\n    return x5\n\n",
    "annotated": "def verify_46442a0e(I: Grid) -> Grid:\n    # Rotate the input grid 90 degrees clockwise\n    x0 = rot90(I)\n    \n    # Rotate the input grid 180 degrees (flip upside down)\n    x1 = rot180(I)\n    \n    # Rotate the input grid 270 degrees clockwise (or 90 degrees counterclockwise)\n    x2 = rot270(I)\n    \n    # Concatenate the original grid and the 90-degree rotated grid horizontally\n    # This forms the top half of the final output\n    x3 = hconcat(I, x0)\n    \n    # Concatenate the 270-degree and 180-degree rotated grids horizontally\n    # This forms the bottom half of the final output\n    x4 = hconcat(x2, x1)\n    \n    # Concatenate the top and bottom halves vertically to create the final output\n    # This results in a 2x2 grid of rotated versions of the input\n    x5 = vconcat(x3, x4)\n    \n    # Return the final composite grid\n    return x5\n"
  },
  "469497ad": {
    "original": "def verify_469497ad(I: Grid) -> Grid:\n    x0 = numcolors(I)\n    x1 = decrement(x0)\n    x2 = upscale(I, x1)\n    x3 = rbind(toobject, I)\n    x4 = lbind(ofcolor, I)\n    x5 = compose(outbox, x4)\n    x6 = chain(numcolors, x3, x5)\n    x7 = matcher(x6, ONE)\n    x8 = palette(I)\n    x9 = sfilter(x8, x7)\n    x10 = fork(multiply, height, width)\n    x11 = lbind(ofcolor, I)\n    x12 = compose(x10, x11)\n    x13 = argmin(x9, x12)\n    x14 = ofcolor(x2, x13)\n    x15 = outbox(x14)\n    x16 = toobject(x15, x2)\n    x17 = mostcolor(x16)\n    x18 = ulcorner(x14)\n    x19 = shoot(x18, NEG_UNITY)\n    x20 = lrcorner(x14)\n    x21 = shoot(x20, UNITY)\n    x22 = urcorner(x14)\n    x23 = shoot(x22, UP_RIGHT)\n    x24 = llcorner(x14)\n    x25 = shoot(x24, DOWN_LEFT)\n    x26 = combine(x19, x21)\n    x27 = combine(x23, x25)\n    x28 = combine(x26, x27)\n    x29 = ofcolor(x2, x17)\n    x30 = intersection(x28, x29)\n    x31 = fill(x2, TWO, x30)\n    return x31\n\n",
    "annotated": "def verify_469497ad(I: Grid) -> Grid:\n    # Count the number of unique colors in the input grid\n    x0 = numcolors(I)\n    # Decrease the color count by 1 (this will be used as the upscale factor)\n    x1 = decrement(x0)\n    # Upscale the input grid by the factor calculated above\n    x2 = upscale(I, x1)\n    # Create a function that converts a patch to an object using the input grid\n    x3 = rbind(toobject, I)\n    # Create a function that finds cells of a specific color in the input grid\n    x4 = lbind(ofcolor, I)\n    # Create a function that finds the outbox of cells of a specific color\n    x5 = compose(outbox, x4)\n    # Create a function that counts colors in the outbox of colored cells\n    x6 = chain(numcolors, x3, x5)\n    # Create a function that checks if the color count in the outbox is 1\n    x7 = matcher(x6, ONE)\n    # Get the set of all colors used in the input grid\n    x8 = palette(I)\n    # Filter the colors to find those with only one color in their outbox\n    x9 = sfilter(x8, x7)\n    # Create a function that multiplies height and width\n    x10 = fork(multiply, height, width)\n    # Create a function that finds cells of a specific color in the input grid\n    x11 = lbind(ofcolor, I)\n    # Create a function that calculates the area of colored cells\n    x12 = compose(x10, x11)\n    # Find the color with the smallest area among the filtered colors\n    x13 = argmin(x9, x12)\n    # Find all cells of the smallest area color in the upscaled grid\n    x14 = ofcolor(x2, x13)\n    # Get the outbox of the smallest area color cells\n    x15 = outbox(x14)\n    # Convert the outbox to an object using the upscaled grid\n    x16 = toobject(x15, x2)\n    # Find the most common color in the outbox object\n    x17 = mostcolor(x16)\n    # Get the upper-left corner of the smallest area color cells\n    x18 = ulcorner(x14)\n    # Create a diagonal line from upper-left corner towards upper-left\n    x19 = shoot(x18, NEG_UNITY)\n    # Get the lower-right corner of the smallest area color cells\n    x20 = lrcorner(x14)\n    # Create a diagonal line from lower-right corner towards lower-right\n    x21 = shoot(x20, UNITY)\n    # Get the upper-right corner of the smallest area color cells\n    x22 = urcorner(x14)\n    # Create a diagonal line from upper-right corner towards upper-right\n    x23 = shoot(x22, UP_RIGHT)\n    # Get the lower-left corner of the smallest area color cells\n    x24 = llcorner(x14)\n    # Create a diagonal line from lower-left corner towards lower-left\n    x25 = shoot(x24, DOWN_LEFT)\n    # Combine the first two diagonal lines\n    x26 = combine(x19, x21)\n    # Combine the other two diagonal lines\n    x27 = combine(x23, x25)\n    # Combine all four diagonal lines\n    x28 = combine(x26, x27)\n    # Find all cells of the most common outbox color in the upscaled grid\n    x29 = ofcolor(x2, x17)\n    # Find the intersection of diagonal lines and cells of the most common outbox color\n    x30 = intersection(x28, x29)\n    # Fill the intersecting cells with color 2 (drawing diagonal lines)\n    x31 = fill(x2, TWO, x30)\n    # Return the final grid with diagonal lines drawn\n    return x31\n"
  },
  "46f33fce": {
    "original": "def verify_46f33fce(I: Grid) -> Grid:\n    x0 = rot180(I)\n    x1 = downscale(x0, TWO)\n    x2 = rot180(x1)\n    x3 = upscale(x2, FOUR)\n    return x3\n\n",
    "annotated": "def verify_46f33fce(I: Grid) -> Grid:\n    # Rotate the input grid 180 degrees (effectively flipping it both horizontally and vertically)\n    x0 = rot180(I)\n    \n    # Downscale the rotated grid by a factor of 2, reducing its size to half in both dimensions\n    x1 = downscale(x0, TWO)\n    \n    # Rotate the downscaled grid 180 degrees again, returning it to its original orientation but at half size\n    x2 = rot180(x1)\n    \n    # Upscale the grid by a factor of 4, increasing its size to twice the original input dimensions\n    # This step effectively zooms in on the center of the original input, magnifying it by 2x\n    x3 = upscale(x2, FOUR)\n    \n    # Return the final processed grid\n    return x3\n"
  },
  "47c1f68c": {
    "original": "def verify_47c1f68c(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = compress(I)\n    x4 = mostcolor(x3)\n    x5 = tophalf(I)\n    x6 = lefthalf(x5)\n    x7 = vmirror(x6)\n    x8 = hconcat(x6, x7)\n    x9 = hmirror(x8)\n    x10 = vconcat(x8, x9)\n    x11 = tophalf(I)\n    x12 = righthalf(x11)\n    x13 = vmirror(x12)\n    x14 = hconcat(x13, x12)\n    x15 = hmirror(x14)\n    x16 = vconcat(x14, x15)\n    x17 = bottomhalf(I)\n    x18 = lefthalf(x17)\n    x19 = vmirror(x18)\n    x20 = hconcat(x18, x19)\n    x21 = hmirror(x20)\n    x22 = vconcat(x21, x20)\n    x23 = bottomhalf(I)\n    x24 = righthalf(x23)\n    x25 = vmirror(x24)\n    x26 = hconcat(x25, x24)\n    x27 = hmirror(x26)\n    x28 = vconcat(x27, x26)\n    x29 = astuple(x10, x16)\n    x30 = astuple(x22, x28)\n    x31 = combine(x29, x30)\n    x32 = argmax(x31, numcolors)\n    x33 = asindices(x32)\n    x34 = ofcolor(x32, x4)\n    x35 = difference(x33, x34)\n    x36 = fill(x32, x2, x35)\n    return x36\n\n",
    "annotated": "def verify_47c1f68c(I: Grid) -> Grid:\n    # Find all frontiers (continuous lines) in the input grid\n    x0 = frontiers(I)\n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    # Get the color of the merged frontier object (this is the line color)\n    x2 = color(x1)\n    # Remove all frontiers from the input grid\n    x3 = compress(I)\n    # Find the most common color in the compressed grid (this is the background color)\n    x4 = mostcolor(x3)\n    # Get the top half of the input grid\n    x5 = tophalf(I)\n    # Get the left half of the top half\n    x6 = lefthalf(x5)\n    # Mirror the top-left quadrant vertically\n    x7 = vmirror(x6)\n    # Concatenate the original and mirrored top-left quadrants horizontally\n    x8 = hconcat(x6, x7)\n    # Mirror the top half horizontally\n    x9 = hmirror(x8)\n    # Concatenate the original and mirrored top halves vertically\n    x10 = vconcat(x8, x9)\n    # Get the top half of the input grid again\n    x11 = tophalf(I)\n    # Get the right half of the top half\n    x12 = righthalf(x11)\n    # Mirror the top-right quadrant vertically\n    x13 = vmirror(x12)\n    # Concatenate the mirrored and original top-right quadrants horizontally\n    x14 = hconcat(x13, x12)\n    # Mirror the top-right half horizontally\n    x15 = hmirror(x14)\n    # Concatenate the original and mirrored top-right halves vertically\n    x16 = vconcat(x14, x15)\n    # Get the bottom half of the input grid\n    x17 = bottomhalf(I)\n    # Get the left half of the bottom half\n    x18 = lefthalf(x17)\n    # Mirror the bottom-left quadrant vertically\n    x19 = vmirror(x18)\n    # Concatenate the original and mirrored bottom-left quadrants horizontally\n    x20 = hconcat(x18, x19)\n    # Mirror the bottom-left half horizontally\n    x21 = hmirror(x20)\n    # Concatenate the mirrored and original bottom-left halves vertically\n    x22 = vconcat(x21, x20)\n    # Get the bottom half of the input grid again\n    x23 = bottomhalf(I)\n    # Get the right half of the bottom half\n    x24 = righthalf(x23)\n    # Mirror the bottom-right quadrant vertically\n    x25 = vmirror(x24)\n    # Concatenate the mirrored and original bottom-right quadrants horizontally\n    x26 = hconcat(x25, x24)\n    # Mirror the bottom-right half horizontally\n    x27 = hmirror(x26)\n    # Concatenate the mirrored and original bottom-right halves vertically\n    x28 = vconcat(x27, x26)\n    # Combine the top-left and top-right quadrants into a tuple\n    x29 = astuple(x10, x16)\n    # Combine the bottom-left and bottom-right quadrants into a tuple\n    x30 = astuple(x22, x28)\n    # Combine all four quadrants into a single container\n    x31 = combine(x29, x30)\n    # Find the quadrant with the most colors (this should be the one with the object)\n    x32 = argmax(x31, numcolors)\n    # Get all indices of the chosen quadrant\n    x33 = asindices(x32)\n    # Find all cells in the chosen quadrant that have the background color\n    x34 = ofcolor(x32, x4)\n    # Get all indices that are not background color (i.e., the object)\n    x35 = difference(x33, x34)\n    # Fill the object with the line color, effectively outlining it\n    x36 = fill(x32, x2, x35)\n    # Return the final grid with the outlined object\n    return x36\n"
  },
  "484b58aa": {
    "original": "def verify_484b58aa(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = objects(I, T, F, F)\n    x2 = lbind(colorfilter, x1)\n    x3 = compose(size, x2)\n    x4 = valmin(x0, x3)\n    x5 = matcher(x3, x4)\n    x6 = sfilter(x0, x5)\n    x7 = lbind(colorcount, I)\n    x8 = argmin(x6, x7)\n    x9 = asobject(I)\n    x10 = matcher(first, x8)\n    x11 = compose(flip, x10)\n    x12 = sfilter(x9, x11)\n    x13 = lbind(contained, x8)\n    x14 = compose(flip, x13)\n    x15 = sfilter(I, x14)\n    x16 = asobject(x15)\n    x17 = hperiod(x16)\n    x18 = dmirror(I)\n    x19 = sfilter(x18, x14)\n    x20 = asobject(x19)\n    x21 = hperiod(x20)\n    x22 = (x21, x17)\n    x23 = lbind(multiply, x22)\n    x24 = neighbors(ORIGIN)\n    x25 = mapply(neighbors, x24)\n    x26 = apply(x23, x25)\n    x27 = lbind(shift, x12)\n    x28 = mapply(x27, x26)\n    x29 = paint(I, x28)\n    return x29\n\n",
    "annotated": "def verify_484b58aa(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Identify all objects in the grid, including diagonally connected cells\n    x1 = objects(I, T, F, F)\n    \n    # Create a function to filter objects by color\n    x2 = lbind(colorfilter, x1)\n    \n    # Create a function to get the size of color-filtered objects\n    x3 = compose(size, x2)\n    \n    # Find the color with the smallest object size\n    x4 = valmin(x0, x3)\n    \n    # Create a function to match objects with the smallest size\n    x5 = matcher(x3, x4)\n    \n    # Filter colors to get only those with the smallest object size\n    x6 = sfilter(x0, x5)\n    \n    # Create a function to count occurrences of a color in the grid\n    x7 = lbind(colorcount, I)\n    \n    # Find the least common color among those with the smallest object size\n    x8 = argmin(x6, x7)\n    \n    # Convert the entire grid to an object representation\n    x9 = asobject(I)\n    \n    # Create a function to match cells with the identified color\n    x10 = matcher(first, x8)\n    \n    # Create a function to identify cells that are not of the identified color\n    x11 = compose(flip, x10)\n    \n    # Filter the grid object to keep only cells not of the identified color\n    x12 = sfilter(x9, x11)\n    \n    # Create a function to check if a cell contains the identified color\n    x13 = lbind(contained, x8)\n    \n    # Create a function to identify cells that don't contain the identified color\n    x14 = compose(flip, x13)\n    \n    # Filter the input grid to keep only cells not of the identified color\n    x15 = sfilter(I, x14)\n    \n    # Convert the filtered grid to an object representation\n    x16 = asobject(x15)\n    \n    # Calculate the horizontal periodicity of the pattern\n    x17 = hperiod(x16)\n    \n    # Mirror the input grid diagonally\n    x18 = dmirror(I)\n    \n    # Filter the mirrored grid to keep only cells not of the identified color\n    x19 = sfilter(x18, x14)\n    \n    # Convert the filtered mirrored grid to an object representation\n    x20 = asobject(x19)\n    \n    # Calculate the horizontal periodicity of the mirrored pattern (vertical periodicity of original)\n    x21 = hperiod(x20)\n    \n    # Combine horizontal and vertical periodicities into a tuple\n    x22 = (x21, x17)\n    \n    # Create a function to multiply a tuple by the periodicity\n    x23 = lbind(multiply, x22)\n    \n    # Get the neighboring cells of the origin\n    x24 = neighbors(ORIGIN)\n    \n    # Get the neighbors of the neighbors (extended neighborhood)\n    x25 = mapply(neighbors, x24)\n    \n    # Apply the periodicity multiplication to the extended neighborhood\n    x26 = apply(x23, x25)\n    \n    # Create a function to shift the pattern cells\n    x27 = lbind(shift, x12)\n    \n    # Apply the shift to all positions in the extended periodic neighborhood\n    x28 = mapply(x27, x26)\n    \n    # Paint the shifted pattern onto the input grid, effectively removing noise\n    x29 = paint(I, x28)\n    \n    # Return the cleaned grid with the noise removed\n    return x29\n"
  },
  "48d8fb45": {
    "original": "def verify_48d8fb45(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = argmax(x0, numcolors)\n    x2 = mostcolor(x1)\n    x3 = matcher(first, x2)\n    x4 = sfilter(x1, x3)\n    x5 = shape(x4)\n    x6 = normalize(x4)\n    x7 = mostcolor(I)\n    x8 = canvas(x7, x5)\n    x9 = paint(x8, x6)\n    return x9\n\n",
    "annotated": "def verify_48d8fb45(I: Grid) -> Grid:\n    # Extract all objects from the input grid, allowing diagonal connections and ignoring the background\n    x0 = objects(I, F, T, T)\n    \n    # Find the object with the most colors\n    x1 = argmax(x0, numcolors)\n    \n    # Determine the most common color in the object with the most colors\n    x2 = mostcolor(x1)\n    \n    # Create a function that checks if the first element of a tuple equals x2\n    x3 = matcher(first, x2)\n    \n    # Filter x1 to keep only the cells with the most common color\n    # This effectively removes the special differently colored cell\n    x4 = sfilter(x1, x3)\n    \n    # Get the dimensions (shape) of the filtered object\n    x5 = shape(x4)\n    \n    # Normalize the position of the filtered object (move it to the origin)\n    x6 = normalize(x4)\n    \n    # Find the most common color in the input grid (background color)\n    x7 = mostcolor(I)\n    \n    # Create a new grid with the background color and the same size as the filtered object\n    x8 = canvas(x7, x5)\n    \n    # Paint the normalized object onto the new background\n    # This creates the output grid with only the filtered object\n    x9 = paint(x8, x6)\n    \n    # Return the final output grid\n    return x9\n"
  },
  "4938f0c2": {
    "original": "def verify_4938f0c2(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = matcher(size, FOUR)\n    x2 = fork(both, square, x1)\n    x3 = extract(x0, x2)\n    x4 = color(x3)\n    x5 = merge(x0)\n    x6 = compose(hmirror, vmirror)\n    x7 = initset(x6)\n    x8 = insert(vmirror, x7)\n    x9 = insert(hmirror, x8)\n    x10 = rapply(x9, x5)\n    x11 = ulcorner(x3)\n    x12 = lbind(subtract, x11)\n    x13 = matcher(first, x4)\n    x14 = rbind(sfilter, x13)\n    x15 = chain(x12, ulcorner, x14)\n    x16 = fork(shift, identity, x15)\n    x17 = mapply(x16, x10)\n    x18 = paint(I, x17)\n    return x18\n\n",
    "annotated": "def verify_4938f0c2(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that checks if an object has exactly 4 cells\n    x1 = matcher(size, FOUR)\n    \n    # Create a function that checks if an object is both square and has 4 cells\n    x2 = fork(both, square, x1)\n    \n    # Extract the object that is square and has 4 cells (the center point)\n    x3 = extract(x0, x2)\n    \n    # Get the color of the center point\n    x4 = color(x3)\n    \n    # Merge all foreground objects into a single object\n    x5 = merge(x0)\n    \n    # Create a function that applies both horizontal and vertical mirroring\n    x6 = compose(hmirror, vmirror)\n    \n    # Initialize a set with the double mirror function\n    x7 = initset(x6)\n    \n    # Add vertical mirroring function to the set\n    x8 = insert(vmirror, x7)\n    \n    # Add horizontal mirroring function to the set\n    x9 = insert(hmirror, x8)\n    \n    # Apply all mirroring functions to the merged object, creating 4 variations\n    x10 = rapply(x9, x5)\n    \n    # Get the upper-left corner of the center point\n    x11 = ulcorner(x3)\n    \n    # Create a function to subtract the center point's position from other positions\n    x12 = lbind(subtract, x11)\n    \n    # Create a function to filter objects by the color of the center point\n    x13 = matcher(first, x4)\n    \n    # Bind the color filter function as the second argument of sfilter\n    x14 = rbind(sfilter, x13)\n    \n    # Chain functions to get the relative position of the center point in each quadrant\n    x15 = chain(x12, ulcorner, x14)\n    \n    # Create a function to shift objects based on their relative position\n    x16 = fork(shift, identity, x15)\n    \n    # Apply the shift function to all mirrored variations of the object\n    x17 = mapply(x16, x10)\n    \n    # Paint the shifted objects onto the input grid, creating the output\n    x18 = paint(I, x17)\n    \n    # Return the final output grid\n    return x18\n"
  },
  "496994bd": {
    "original": "def verify_496994bd(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = vsplit(I, TWO)\n    x2 = apply(numcolors, x1)\n    x3 = contained(ONE, x2)\n    x4 = branch(x3, hmirror, vmirror)\n    x5 = x4(I)\n    x6 = asobject(x5)\n    x7 = matcher(first, x0)\n    x8 = compose(flip, x7)\n    x9 = sfilter(x6, x8)\n    x10 = paint(I, x9)\n    return x10\n\n",
    "annotated": "def verify_496994bd(I: Grid) -> Grid:\n    # Find the most common color in the input grid (likely the background color)\n    x0 = mostcolor(I)\n    \n    # Split the input grid vertically into two halves\n    x1 = vsplit(I, TWO)\n    \n    # Count the number of unique colors in each half\n    x2 = apply(numcolors, x1)\n    \n    # Check if one of the halves contains only one color (the background color)\n    x3 = contained(ONE, x2)\n    \n    # If one half is all background, use hmirror; otherwise, use vmirror\n    # This determines whether to mirror horizontally or vertically\n    x4 = branch(x3, hmirror, vmirror)\n    \n    # Apply the chosen mirroring function to the input grid\n    x5 = x4(I)\n    \n    # Convert the mirrored grid to an object representation\n    x6 = asobject(x5)\n    \n    # Create a function that checks if a cell's color matches the background color\n    x7 = matcher(first, x0)\n    \n    # Invert the background color matching function\n    # This will now return True for non-background colors\n    x8 = compose(flip, x7)\n    \n    # Filter the object to keep only non-background colored cells\n    x9 = sfilter(x6, x8)\n    \n    # Paint the filtered non-background cells onto the original input grid\n    # This effectively mirrors only the colored pattern, leaving the background unchanged\n    x10 = paint(I, x9)\n    \n    # Return the final transformed grid\n    return x10\n"
  },
  "49d1d64f": {
    "original": "def verify_49d1d64f(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = increment(x0)\n    x2 = increment(x1)\n    x3 = canvas(ZERO, x2)\n    x4 = asobject(I)\n    x5 = shift(x4, UNITY)\n    x6 = shift(x5, LEFT)\n    x7 = paint(x3, x6)\n    x8 = shift(x5, RIGHT)\n    x9 = paint(x7, x8)\n    x10 = shift(x5, UP)\n    x11 = paint(x9, x10)\n    x12 = shift(x5, DOWN)\n    x13 = paint(x11, x12)\n    x14 = paint(x13, x5)\n    return x14\n\n",
    "annotated": "def verify_49d1d64f(I: Grid) -> Grid:\n    # Get the dimensions (height, width) of the input grid\n    x0 = shape(I)\n    \n    # Increase both dimensions by 1\n    x1 = increment(x0)\n    \n    # Increase dimensions again by 1 (now 2 larger than input in both directions)\n    x2 = increment(x1)\n    \n    # Create a new canvas filled with zeros, 2 units larger in each dimension than the input\n    x3 = canvas(ZERO, x2)\n    \n    # Convert the input grid to an object representation\n    x4 = asobject(I)\n    \n    # Shift the input object one unit down and right (to center it in the larger grid)\n    x5 = shift(x4, UNITY)\n    \n    # Shift the centered object one unit left (to create left border)\n    x6 = shift(x5, LEFT)\n    \n    # Paint the left border onto the canvas\n    x7 = paint(x3, x6)\n    \n    # Shift the centered object one unit right (to create right border)\n    x8 = shift(x5, RIGHT)\n    \n    # Paint the right border onto the canvas\n    x9 = paint(x7, x8)\n    \n    # Shift the centered object one unit up (to create top border)\n    x10 = shift(x5, UP)\n    \n    # Paint the top border onto the canvas\n    x11 = paint(x9, x10)\n    \n    # Shift the centered object one unit down (to create bottom border)\n    x12 = shift(x5, DOWN)\n    \n    # Paint the bottom border onto the canvas\n    x13 = paint(x11, x12)\n    \n    # Paint the centered input object onto the canvas (filling the center)\n    x14 = paint(x13, x5)\n    \n    # Return the final grid with the input centered and surrounded by a border\n    return x14\n"
  },
  "4be741c5": {
    "original": "def verify_4be741c5(I: Grid) -> Grid:\n    x0 = first(I)\n    x1 = dedupe(x0)\n    x2 = size(x1)\n    x3 = equality(x2, ONE)\n    x4 = branch(x3, dmirror, identity)\n    x5 = branch(x3, height, width)\n    x6 = x5(I)\n    x7 = astuple(ONE, x6)\n    x8 = x4(I)\n    x9 = crop(x8, ORIGIN, x7)\n    x10 = apply(dedupe, x9)\n    x11 = x4(x10)\n    return x11\n\n",
    "annotated": "def verify_4be741c5(I: Grid) -> Grid:\n    # Get the first row of the input grid\n    x0 = first(I)\n    \n    # Remove duplicate colors from the first row\n    x1 = dedupe(x0)\n    \n    # Count the number of unique colors\n    x2 = size(x1)\n    \n    # Check if there's only one row in the deduplicated first row\n    x3 = equality(x2, ONE)\n    \n    # If x3 is True, use dmirror function; otherwise, use identity function\n    # This determines whether to transpose the grid or not\n    x4 = branch(x3, dmirror, identity)\n    \n    # If x3 is True, use height function; otherwise, use width function\n    # This selects whether to use the height or width of the input grid\n    x5 = branch(x3, height, width)\n    \n    # Apply the selected function (height or width) to the input grid\n    x6 = x5(I)\n    \n    # Create a tuple (1, x6) representing dimensions (1 row, x6 columns)\n    x7 = astuple(ONE, x6)\n    \n    # Apply the selected transformation (dmirror or identity) to the input grid\n    x8 = x4(I)\n    \n    # Crop the transformed grid to get the first row (or column if transposed)\n    x9 = crop(x8, ORIGIN, x7)\n    \n    # Remove duplicate colors from each row of the cropped grid\n    x10 = apply(dedupe, x9)\n    \n    # Apply the inverse transformation (dmirror or identity) to get the final result\n    x11 = x4(x10)\n    \n    # Return the final processed grid\n    return x11\n"
  },
  "4c4377d9": {
    "original": "def verify_4c4377d9(I: Grid) -> Grid:\n    x0 = hmirror(I)\n    x1 = vconcat(x0, I)\n    return x1\n\n",
    "annotated": "def verify_4c4377d9(I: Grid) -> Grid:\n    # Create a horizontally mirrored version of the input grid\n    # This flips the grid left to right, creating a mirror image\n    x0 = hmirror(I)\n    \n    # Vertically concatenate the mirrored grid (x0) on top of the original input grid (I)\n    # This effectively doubles the height of the grid, with the top half being the mirror image\n    # of the bottom half\n    x1 = vconcat(x0, I)\n    \n    # Return the final grid, which is the original input with its mirror image stacked on top\n    return x1\n"
  },
  "4c5c2cf0": {
    "original": "def verify_4c5c2cf0(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = compose(dneighbors, center)\n    x2 = fork(difference, backdrop, x1)\n    x3 = fork(equality, toindices, x2)\n    x4 = matcher(size, FIVE)\n    x5 = fork(both, x3, x4)\n    x6 = extract(x0, x5)\n    x7 = color(x6)\n    x8 = merge(x0)\n    x9 = compose(hmirror, vmirror)\n    x10 = initset(x9)\n    x11 = insert(vmirror, x10)\n    x12 = insert(hmirror, x11)\n    x13 = rapply(x12, x8)\n    x14 = ulcorner(x6)\n    x15 = lbind(subtract, x14)\n    x16 = matcher(first, x7)\n    x17 = rbind(sfilter, x16)\n    x18 = chain(x15, ulcorner, x17)\n    x19 = fork(shift, identity, x18)\n    x20 = mapply(x19, x13)\n    x21 = paint(I, x20)\n    return x21\n\n",
    "annotated": "def verify_4c5c2cf0(I: Grid) -> Grid:\n    # Partition the input grid into foreground objects (excluding the background color)\n    x0 = fgpartition(I)\n    \n    # Create a function that finds the directly adjacent neighbors of the center of an object\n    x1 = compose(dneighbors, center)\n    \n    # Create a function that finds the difference between an object's backdrop and its center's neighbors\n    x2 = fork(difference, backdrop, x1)\n    \n    # Create a function that checks if an object's indices are equal to the result of x2\n    x3 = fork(equality, toindices, x2)\n    \n    # Create a function that checks if an object has exactly 5 cells\n    x4 = matcher(size, FIVE)\n    \n    # Combine x3 and x4 to check if an object meets both conditions\n    x5 = fork(both, x3, x4)\n    \n    # Extract the object from x0 that satisfies the conditions in x5 (this is the small grid)\n    x6 = extract(x0, x5)\n    \n    # Get the color of the small grid (object color)\n    x7 = color(x6)\n    \n    # Merge all foreground objects into a single set of cells\n    x8 = merge(x0)\n    \n    # Create a function that applies both horizontal and vertical mirroring\n    x9 = compose(hmirror, vmirror)\n    \n    # Initialize a set with the double mirror function\n    x10 = initset(x9)\n    \n    # Add vertical mirroring to the set of transformations\n    x11 = insert(vmirror, x10)\n    \n    # Add horizontal mirroring to the set of transformations\n    x12 = insert(hmirror, x11)\n    \n    # Apply all transformations to the merged foreground objects\n    x13 = rapply(x12, x8)\n    \n    # Get the upper-left corner of the small grid\n    x14 = ulcorner(x6)\n    \n    # Create a function to subtract the small grid's corner from a point\n    x15 = lbind(subtract, x14)\n    \n    # Create a function to filter objects by the object color\n    x16 = matcher(first, x7)\n    \n    # Bind x16 as the condition for sfilter\n    x17 = rbind(sfilter, x16)\n    \n    # Create a function to find the relative position of other objects with the same color\n    x18 = chain(x15, ulcorner, x17)\n    \n    # Create a function to shift objects based on their relative position\n    x19 = fork(shift, identity, x18)\n    \n    # Apply the shifting to all transformed objects\n    x20 = mapply(x19, x13)\n    \n    # Paint the shifted and transformed objects onto the input grid\n    x21 = paint(I, x20)\n    \n    # Return the final grid with all transformations applied\n    return x21\n"
  },
  "50846271": {
    "original": "def verify_50846271(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = interval(TWO, FIVE, ONE)\n    x3 = rbind(shift, RIGHT)\n    x4 = rbind(shift, LEFT)\n    x5 = rbind(shift, UP)\n    x6 = rbind(shift, DOWN)\n    x7 = lbind(fork, intersection)\n    x8 = lbind(x7, identity)\n    x9 = lbind(rbind, shift)\n    x10 = compose(x8, x9)\n    x11 = compose(x10, tojvec)\n    x12 = chain(x10, tojvec, invert)\n    x13 = compose(x10, toivec)\n    x14 = chain(x10, toivec, invert)\n    x15 = lbind(compose, initset)\n    x16 = lbind(rbind, rapply)\n    x17 = lbind(chain, first)\n    x18 = lbind(compose, x4)\n    x19 = x15(x11)\n    x20 = rbind(x17, x19)\n    x21 = chain(x18, x20, x16)\n    x22 = lbind(compose, x3)\n    x23 = x15(x12)\n    x24 = rbind(x17, x23)\n    x25 = chain(x22, x24, x16)\n    x26 = lbind(compose, x5)\n    x27 = x15(x13)\n    x28 = rbind(x17, x27)\n    x29 = chain(x26, x28, x16)\n    x30 = lbind(compose, x6)\n    x31 = x15(x14)\n    x32 = rbind(x17, x31)\n    x33 = chain(x30, x32, x16)\n    x34 = rbind(ofcolor, x0)\n    x35 = compose(x21, x34)\n    x36 = compose(x25, x34)\n    x37 = compose(x29, x34)\n    x38 = compose(x33, x34)\n    x39 = lbind(fork, combine)\n    x40 = fork(x39, x35, x36)\n    x41 = fork(x39, x37, x38)\n    x42 = fork(x39, x40, x41)\n    x43 = lbind(recolor, x0)\n    x44 = rbind(mapply, x2)\n    x45 = chain(x43, x44, x42)\n    x46 = fork(paint, identity, x45)\n    x47 = power(x46, FOUR)\n    x48 = x47(I)\n    x49 = objects(x48, T, T, T)\n    x50 = colorfilter(x49, x0)\n    x51 = compose(maximum, shape)\n    x52 = apply(x51, x50)\n    x53 = maximum(x52)\n    x54 = ofcolor(x48, x0)\n    x55 = rbind(contained, x54)\n    x56 = rbind(add, RIGHT)\n    x57 = compose(x55, x56)\n    x58 = rbind(add, LEFT)\n    x59 = compose(x55, x58)\n    x60 = fork(either, x57, x59)\n    x61 = rbind(add, DOWN)\n    x62 = compose(x55, x61)\n    x63 = rbind(add, UP)\n    x64 = compose(x55, x63)\n    x65 = fork(either, x62, x64)\n    x66 = fork(both, x60, x65)\n    x67 = matcher(size, x53)\n    x68 = fork(either, vline, hline)\n    x69 = fork(both, x67, x68)\n    x70 = sfilter(x50, x69)\n    x71 = apply(center, x70)\n    x72 = sfilter(x54, x66)\n    x73 = combine(x72, x71)\n    x74 = halve(x53)\n    x75 = invert(x74)\n    x76 = toivec(x75)\n    x77 = rbind(add, x76)\n    x78 = toivec(x74)\n    x79 = rbind(add, x78)\n    x80 = fork(connect, x77, x79)\n    x81 = invert(x74)\n    x82 = tojvec(x81)\n    x83 = rbind(add, x82)\n    x84 = tojvec(x74)\n    x85 = rbind(add, x84)\n    x86 = fork(connect, x83, x85)\n    x87 = fork(combine, x80, x86)\n    x88 = mapply(x87, x73)\n    x89 = fill(x48, x0, x88)\n    x90 = replace(x89, x0, EIGHT)\n    x91 = fill(x90, x0, x1)\n    return x91\n\n",
    "annotated": "def verify_50846271(I: Grid) -> Grid:\n    # Get the least common color in the input grid\n    x0 = leastcolor(I)\n    # Get all indices of cells with the least common color\n    x1 = ofcolor(I, x0)\n    # Create a range of integers from 2 to 4 (2, 3, 4)\n    x2 = interval(TWO, FIVE, ONE)\n    # Create a function that shifts right\n    x3 = rbind(shift, RIGHT)\n    # Create a function that shifts left\n    x4 = rbind(shift, LEFT)\n    # Create a function that shifts up\n    x5 = rbind(shift, UP)\n    # Create a function that shifts down\n    x6 = rbind(shift, DOWN)\n    # Create a function that finds the intersection of two sets\n    x7 = lbind(fork, intersection)\n    # Create a function that finds the intersection with itself\n    x8 = lbind(x7, identity)\n    # Create a function that binds shift to a direction\n    x9 = lbind(rbind, shift)\n    # Compose x8 and x9\n    x10 = compose(x8, x9)\n    # Create a function that shifts horizontally and finds intersection\n    x11 = compose(x10, tojvec)\n    # Create a function that shifts horizontally in opposite direction and finds intersection\n    x12 = chain(x10, tojvec, invert)\n    # Create a function that shifts vertically and finds intersection\n    x13 = compose(x10, toivec)\n    # Create a function that shifts vertically in opposite direction and finds intersection\n    x14 = chain(x10, toivec, invert)\n    # Create a function that initializes a set\n    x15 = lbind(compose, initset)\n    # Create a function that applies a list of functions to a value\n    x16 = lbind(rbind, rapply)\n    # Create a function that gets the first element\n    x17 = lbind(chain, first)\n    # Create a function that shifts left\n    x18 = lbind(compose, x4)\n    # Initialize a set with horizontal shift and intersection\n    x19 = x15(x11)\n    # Create a function that gets the first element of x19\n    x20 = rbind(x17, x19)\n    # Chain functions to shift left and apply x20\n    x21 = chain(x18, x20, x16)\n    # Create a function that shifts right\n    x22 = lbind(compose, x3)\n    # Initialize a set with horizontal shift in opposite direction and intersection\n    x23 = x15(x12)\n    # Create a function that gets the first element of x23\n    x24 = rbind(x17, x23)\n    # Chain functions to shift right and apply x24\n    x25 = chain(x22, x24, x16)\n    # Create a function that shifts up\n    x26 = lbind(compose, x5)\n    # Initialize a set with vertical shift and intersection\n    x27 = x15(x13)\n    # Create a function that gets the first element of x27\n    x28 = rbind(x17, x27)\n    # Chain functions to shift up and apply x28\n    x29 = chain(x26, x28, x16)\n    # Create a function that shifts down\n    x30 = lbind(compose, x6)\n    # Initialize a set with vertical shift in opposite direction and intersection\n    x31 = x15(x14)\n    # Create a function that gets the first element of x31\n    x32 = rbind(x17, x31)\n    # Chain functions to shift down and apply x32\n    x33 = chain(x30, x32, x16)\n    # Create a function that gets cells of the least common color\n    x34 = rbind(ofcolor, x0)\n    # Compose x21 and x34 to shift left and get cells of least common color\n    x35 = compose(x21, x34)\n    # Compose x25 and x34 to shift right and get cells of least common color\n    x36 = compose(x25, x34)\n    # Compose x29 and x34 to shift up and get cells of least common color\n    x37 = compose(x29, x34)\n    # Compose x33 and x34 to shift down and get cells of least common color\n    x38 = compose(x33, x34)\n    # Create a function that combines two sets\n    x39 = lbind(fork, combine)\n    # Combine results of shifting left and right\n    x40 = fork(x39, x35, x36)\n    # Combine results of shifting up and down\n    x41 = fork(x39, x37, x38)\n    # Combine all shift results\n    x42 = fork(x39, x40, x41)\n    # Create a function that recolors with the least common color\n    x43 = lbind(recolor, x0)\n    # Create a function that applies to the range 2-4\n    x44 = rbind(mapply, x2)\n    # Chain functions to recolor, apply to range, and combine shift results\n    x45 = chain(x43, x44, x42)\n    # Create a function that paints the grid with the results\n    x46 = fork(paint, identity, x45)\n    # Apply the painting function 4 times\n    x47 = power(x46, FOUR)\n    # Apply the 4-time painting to the input grid\n    x48 = x47(I)\n    # Get all objects in the painted grid\n    x49 = objects(x48, T, T, T)\n    # Filter objects by the least common color\n    x50 = colorfilter(x49, x0)\n    # Create a function that gets the maximum dimension of an object\n    x51 = compose(maximum, shape)\n    # Apply the max dimension function to all filtered objects\n    x52 = apply(x51, x50)\n    # Get the maximum dimension among all objects\n    x53 = maximum(x52)\n    # Get all cells of the least common color in the painted grid\n    x54 = ofcolor(x48, x0)\n    # Create a function that checks if a cell is in x54\n    x55 = rbind(contained, x54)\n    # Create a function that adds the RIGHT vector\n    x56 = rbind(add, RIGHT)\n    # Compose x55 and x56 to check right neighbor\n    x57 = compose(x55, x56)\n    # Create a function that adds the LEFT vector\n    x58 = rbind(add, LEFT)\n    # Compose x55 and x58 to check left neighbor\n    x59 = compose(x55, x58)\n    # Create a function that checks if either left or right neighbor is in x54\n    x60 = fork(either, x57, x59)\n    # Create a function that adds the DOWN vector\n    x61 = rbind(add, DOWN)\n    # Compose x55 and x61 to check down neighbor\n    x62 = compose(x55, x61)\n    # Create a function that adds the UP vector\n    x63 = rbind(add, UP)\n    # Compose x55 and x63 to check up neighbor\n    x64 = compose(x55, x63)\n    # Create a function that checks if either up or down neighbor is in x54\n    x65 = fork(either, x62, x64)\n    # Create a function that checks if both horizontal and vertical neighbors are in x54\n    x66 = fork(both, x60, x65)\n    # Create a function that checks if an object has the maximum size\n    x67 = matcher(size, x53)\n    # Create a function that checks if an object is a vertical or horizontal line\n    x68 = fork(either, vline, hline)\n    # Create a function that checks if an object is a max-size line\n    x69 = fork(both, x67, x68)\n    # Filter objects that are max-size lines\n    x70 = sfilter(x50, x69)\n    # Get the centers of the filtered objects\n    x71 = apply(center, x70)\n    # Filter cells that have neighbors in all directions\n    x72 = sfilter(x54, x66)\n    # Combine the filtered cells and object centers\n    x73 = combine(x72, x71)\n    # Get half of the maximum dimension\n    x74 = halve(x53)\n    # Invert half of the maximum dimension\n    x75 = invert(x74)\n    # Convert inverted half to vertical vector\n    x76 = toivec(x75)\n    # Create a function that adds the inverted half vector\n    x77 = rbind(add, x76)\n    # Convert half to vertical vector\n    x78 = toivec(x74)\n    # Create a function that adds the half vector\n    x79 = rbind(add, x78)\n    # Create a function that connects points with vertical offset\n    x80 = fork(connect, x77, x79)\n    # Invert half of the maximum dimension\n    x81 = invert(x74)\n    # Convert inverted half to horizontal vector\n    x82 = tojvec(x81)\n    # Create a function that adds the inverted half horizontal vector\n    x83 = rbind(add, x82)\n    # Convert half to horizontal vector\n    x84 = tojvec(x74)\n    # Create a function that adds the half horizontal vector\n    x85 = rbind(add, x84)\n    # Create a function that connects points with horizontal offset\n    x86 = fork(connect, x83, x85)\n    # Create a function that combines vertical and horizontal connections\n    x87 = fork(combine, x80, x86)\n    # Apply the connection function to all points in x73\n    x88 = mapply(x87, x73)\n    # Fill the painted grid with the least common color at the connected points\n    x89 = fill(x48, x0, x88)\n    # Replace the least common color with 8 (completing the crosses)\n    x90 = replace(x89, x0, EIGHT)\n    # Fill the remaining cells with the original least common color\n    x91 = fill(x90, x0, x1)\n    # Return the final grid\n    return x91\n"
  },
  "508bd3b6": {
    "original": "def verify_508bd3b6(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = palette(I)\n    x2 = compose(maximum, shape)\n    x3 = lbind(apply, x2)\n    x4 = lbind(colorfilter, x0)\n    x5 = chain(maximum, x3, x4)\n    x6 = matcher(x5, ONE)\n    x7 = extract(x1, x6)\n    x8 = lbind(ofcolor, I)\n    x9 = compose(backdrop, x8)\n    x10 = fork(equality, x8, x9)\n    x11 = extract(x1, x10)\n    x12 = ofcolor(I, x11)\n    x13 = ofcolor(I, x7)\n    x14 = rbind(manhattan, x12)\n    x15 = compose(x14, initset)\n    x16 = argmin(x13, x15)\n    x17 = ulcorner(x13)\n    x18 = contained(x17, x13)\n    x19 = shoot(x16, UNITY)\n    x20 = shoot(x16, NEG_UNITY)\n    x21 = combine(x19, x20)\n    x22 = shoot(x16, UP_RIGHT)\n    x23 = shoot(x16, DOWN_LEFT)\n    x24 = combine(x22, x23)\n    x25 = branch(x18, x21, x24)\n    x26 = asindices(I)\n    x27 = outbox(x12)\n    x28 = intersection(x26, x27)\n    x29 = intersection(x28, x25)\n    x30 = initset(x16)\n    x31 = rbind(manhattan, x30)\n    x32 = compose(x31, initset)\n    x33 = argmin(x29, x32)\n    x34 = height(x12)\n    x35 = height(I)\n    x36 = equality(x34, x35)\n    x37 = leftmost(x13)\n    x38 = leftmost(x12)\n    x39 = greater(x37, x38)\n    x40 = uppermost(x13)\n    x41 = uppermost(x12)\n    x42 = greater(x40, x41)\n    x43 = lbind(shoot, x33)\n    x44 = branch(x39, UNITY, NEG_UNITY)\n    x45 = branch(x39, UP_RIGHT, DOWN_LEFT)\n    x46 = branch(x42, UNITY, NEG_UNITY)\n    x47 = branch(x42, DOWN_LEFT, UP_RIGHT)\n    x48 = branch(x36, x44, x46)\n    x49 = branch(x36, x45, x47)\n    x50 = x43(x48)\n    x51 = x43(x49)\n    x52 = combine(x50, x51)\n    x53 = difference(x52, x13)\n    x54 = fill(I, THREE, x53)\n    return x54\n\n",
    "annotated": "def verify_508bd3b6(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    # Get the palette (unique colors) of the input grid\n    x1 = palette(I)\n    # Create a function that gets the maximum dimension of an object\n    x2 = compose(maximum, shape)\n    # Create a function that applies x2 to a collection of objects\n    x3 = lbind(apply, x2)\n    # Create a function that filters objects by color\n    x4 = lbind(colorfilter, x0)\n    # Create a function that gets the maximum dimension of objects of a specific color\n    x5 = chain(maximum, x3, x4)\n    # Create a function that checks if the maximum dimension is 1\n    x6 = matcher(x5, ONE)\n    # Find the color of the line (the color with maximum dimension 1)\n    x7 = extract(x1, x6)\n    # Create a function that gets cells of a specific color from the input grid\n    x8 = lbind(ofcolor, I)\n    # Create a function that gets the backdrop of cells of a specific color\n    x9 = compose(backdrop, x8)\n    # Create a function that checks if a color's cells are equal to its backdrop\n    x10 = fork(equality, x8, x9)\n    # Find the background color (the color that fills its backdrop)\n    x11 = extract(x1, x10)\n    # Get the background cells\n    x12 = ofcolor(I, x11)\n    # Get the line cells\n    x13 = ofcolor(I, x7)\n    # Create a function that calculates Manhattan distance to background cells\n    x14 = rbind(manhattan, x12)\n    # Create a function that initializes a set and calculates Manhattan distance\n    x15 = compose(x14, initset)\n    # Find the line cell closest to the background (start of the line)\n    x16 = argmin(x13, x15)\n    # Get the upper-left corner of the line\n    x17 = ulcorner(x13)\n    # Check if the upper-left corner is part of the line\n    x18 = contained(x17, x13)\n    # Create potential line paths in different directions\n    x19 = shoot(x16, UNITY)\n    x20 = shoot(x16, NEG_UNITY)\n    x21 = combine(x19, x20)\n    x22 = shoot(x16, UP_RIGHT)\n    x23 = shoot(x16, DOWN_LEFT)\n    x24 = combine(x22, x23)\n    # Choose the correct line path based on the upper-left corner check\n    x25 = branch(x18, x21, x24)\n    # Get all indices of the input grid\n    x26 = asindices(I)\n    # Get the outbox of the background cells\n    x27 = outbox(x12)\n    # Get the indices that are both in the grid and in the background outbox\n    x28 = intersection(x26, x27)\n    # Get the potential line indices\n    x29 = intersection(x28, x25)\n    # Create a set with the start of the line\n    x30 = initset(x16)\n    # Create a function that calculates Manhattan distance to the start of the line\n    x31 = rbind(manhattan, x30)\n    # Create a function that initializes a set and calculates Manhattan distance\n    x32 = compose(x31, initset)\n    # Find the end of the visible part of the line\n    x33 = argmin(x29, x32)\n    # Get the height of the background\n    x34 = height(x12)\n    # Get the height of the input grid\n    x35 = height(I)\n    # Check if the background height is equal to the grid height\n    x36 = equality(x34, x35)\n    # Check if the line starts to the right of the background\n    x37 = leftmost(x13)\n    x38 = leftmost(x12)\n    x39 = greater(x37, x38)\n    # Check if the line starts below the top of the background\n    x40 = uppermost(x13)\n    x41 = uppermost(x12)\n    x42 = greater(x40, x41)\n    # Create a function to shoot a line from the end of the visible part\n    x43 = lbind(shoot, x33)\n    # Determine the direction of the hidden part of the line\n    x44 = branch(x39, UNITY, NEG_UNITY)\n    x45 = branch(x39, UP_RIGHT, DOWN_LEFT)\n    x46 = branch(x42, UNITY, NEG_UNITY)\n    x47 = branch(x42, DOWN_LEFT, UP_RIGHT)\n    x48 = branch(x36, x44, x46)\n    x49 = branch(x36, x45, x47)\n    # Create the hidden part of the line\n    x50 = x43(x48)\n    x51 = x43(x49)\n    x52 = combine(x50, x51)\n    # Get the part of the hidden line that's not already visible\n    x53 = difference(x52, x13)\n    # Fill the hidden part of the line with color 3 (completing the line)\n    x54 = fill(I, THREE, x53)\n    # Return the completed grid with the full line\n    return x54\n"
  },
  "50cb2852": {
    "original": "def verify_50cb2852(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = compose(backdrop, inbox)\n    x2 = mapply(x1, x0)\n    x3 = fill(I, EIGHT, x2)\n    return x3\n\n",
    "annotated": "def verify_50cb2852(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonally adjacent cells as part of the object\n    # and excluding the background color\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that finds the inner box (inbox) of an object and then gets all cells within that box (backdrop)\n    x1 = compose(backdrop, inbox)\n    \n    # Apply the composed function to all objects, getting the full area of each object\n    x2 = mapply(x1, x0)\n    \n    # Fill all areas occupied by objects with color 8 (outline color)\n    # This effectively creates outlines for all objects in the grid\n    x3 = fill(I, EIGHT, x2)\n    \n    # Return the modified grid with object outlines\n    return x3\n"
  },
  "5117e062": {
    "original": "def verify_5117e062(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = argmax(x0, numcolors)\n    x2 = mostcolor(x1)\n    x3 = normalize(x1)\n    x4 = mostcolor(I)\n    x5 = shape(x1)\n    x6 = canvas(x4, x5)\n    x7 = fill(x6, x2, x3)\n    return x7\n\n",
    "annotated": "def verify_5117e062(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing diagonal connections and ignoring the background\n    x0 = objects(I, F, T, T)\n    \n    # Find the object with the most colors (likely the special object)\n    x1 = argmax(x0, numcolors)\n    \n    # Determine the most common color in the special object (the main color)\n    x2 = mostcolor(x1)\n    \n    # Normalize the special object (move it to the top-left corner)\n    x3 = normalize(x1)\n    \n    # Find the most common color in the input grid (background color)\n    x4 = mostcolor(I)\n    \n    # Get the dimensions of the special object\n    x5 = shape(x1)\n    \n    # Create a new canvas with the background color and the size of the special object\n    x6 = canvas(x4, x5)\n    \n    # Fill the new canvas with the special object, using its main color\n    # This effectively isolates and recreates the special object on a background-colored canvas\n    x7 = fill(x6, x2, x3)\n    \n    # Return the isolated special object as the output\n    return x7\n"
  },
  "5168d44c": {
    "original": "def verify_5168d44c(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = valmax(x0, x1)\n    x3 = matcher(x1, x2)\n    x4 = sfilter(x0, x3)\n    x5 = argmax(x4, size)\n    x6 = color(x5)\n    x7 = remove(x5, x0)\n    x8 = objects(I, T, F, F)\n    x9 = lbind(colorfilter, x8)\n    x10 = chain(size, x9, color)\n    x11 = argmin(x7, x10)\n    x12 = other(x7, x11)\n    x13 = color(x12)\n    x14 = colorfilter(x8, x13)\n    x15 = apply(leftmost, x14)\n    x16 = size(x15)\n    x17 = equality(ONE, x16)\n    x18 = apply(uppermost, x14)\n    x19 = size(x18)\n    x20 = equality(ONE, x19)\n    x21 = fork(add, first, last)\n    x22 = compose(x21, ulcorner)\n    x23 = argmin(x14, x22)\n    x24 = remove(x23, x14)\n    x25 = lbind(manhattan, x23)\n    x26 = argmin(x24, x25)\n    x27 = lowermost(x26)\n    x28 = lowermost(x23)\n    x29 = subtract(x27, x28)\n    x30 = uppermost(x26)\n    x31 = uppermost(x23)\n    x32 = subtract(x30, x31)\n    x33 = astuple(x29, x32)\n    x34 = maximum(x33)\n    x35 = branch(x20, ZERO, x34)\n    x36 = rightmost(x26)\n    x37 = rightmost(x23)\n    x38 = subtract(x36, x37)\n    x39 = leftmost(x26)\n    x40 = leftmost(x23)\n    x41 = subtract(x39, x40)\n    x42 = astuple(x38, x41)\n    x43 = maximum(x42)\n    x44 = branch(x17, ZERO, x43)\n    x45 = astuple(x35, x44)\n    x46 = shift(x11, x45)\n    x47 = delta(x46)\n    x48 = hmirror(x46)\n    x49 = ulcorner(x47)\n    x50 = delta(x48)\n    x51 = ulcorner(x50)\n    x52 = subtract(x49, x51)\n    x53 = shift(x48, x52)\n    x54 = combine(x46, x53)\n    x55 = vmirror(x54)\n    x56 = ulcorner(x47)\n    x57 = delta(x55)\n    x58 = ulcorner(x57)\n    x59 = subtract(x56, x58)\n    x60 = shift(x55, x59)\n    x61 = combine(x60, x54)\n    x62 = color(x11)\n    x63 = replace(I, x62, x6)\n    x64 = paint(x63, x61)\n    return x64\n\n",
    "annotated": "def verify_5168d44c(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Find the maximum area (height * width) among all partitioned objects\n    x2 = valmax(x0, x1)\n    \n    # Create a function that checks if an object's area matches the maximum area\n    x3 = matcher(x1, x2)\n    \n    # Filter the partitioned objects to keep only those with the maximum area\n    x4 = sfilter(x0, x3)\n    \n    # Find the largest object among those with the maximum area (likely the background)\n    x5 = argmax(x4, size)\n    \n    # Get the color of the largest object (background color)\n    x6 = color(x5)\n    \n    # Remove the background object from the set of partitioned objects\n    x7 = remove(x5, x0)\n    \n    # Find all objects in the input grid, including those that touch diagonally\n    x8 = objects(I, T, F, F)\n    \n    # Create a function that filters objects by color\n    x9 = lbind(colorfilter, x8)\n    \n    # Create a function that returns the size of objects of a specific color\n    x10 = chain(size, x9, color)\n    \n    # Find the object with the smallest size among non-background objects (likely the dot)\n    x11 = argmin(x7, x10)\n    \n    # Find the other non-background object (likely the box)\n    x12 = other(x7, x11)\n    \n    # Get the color of the box\n    x13 = color(x12)\n    \n    # Filter objects to keep only those with the box color\n    x14 = colorfilter(x8, x13)\n    \n    # Get the leftmost positions of all box-colored objects\n    x15 = apply(leftmost, x14)\n    \n    # Count the number of unique leftmost positions\n    x16 = size(x15)\n    \n    # Check if there's only one unique leftmost position (box doesn't touch left edge)\n    x17 = equality(ONE, x16)\n    \n    # Get the uppermost positions of all box-colored objects\n    x18 = apply(uppermost, x14)\n    \n    # Count the number of unique uppermost positions\n    x19 = size(x18)\n    \n    # Check if there's only one unique uppermost position (box doesn't touch top edge)\n    x20 = equality(ONE, x19)\n    \n    # Create a function that adds the first and last elements of a tuple\n    x21 = fork(add, first, last)\n    \n    # Create a function that sums the coordinates of the upper-left corner\n    x22 = compose(x21, ulcorner)\n    \n    # Find the box-colored object with the minimum sum of upper-left corner coordinates\n    x23 = argmin(x14, x22)\n    \n    # Remove this object (likely the original box) from the set of box-colored objects\n    x24 = remove(x23, x14)\n    \n    # Create a function that calculates the Manhattan distance from the original box\n    x25 = lbind(manhattan, x23)\n    \n    # Find the box-colored object closest to the original box (likely the moved box)\n    x26 = argmin(x24, x25)\n    \n    # Get the lowermost position of the moved box\n    x27 = lowermost(x26)\n    \n    # Get the lowermost position of the original box\n    x28 = lowermost(x23)\n    \n    # Calculate the vertical distance moved by the box\n    x29 = subtract(x27, x28)\n    \n    # Get the uppermost position of the moved box\n    x30 = uppermost(x26)\n    \n    # Get the uppermost position of the original box\n    x31 = uppermost(x23)\n    \n    # Calculate the vertical distance moved by the box (alternative method)\n    x32 = subtract(x30, x31)\n    \n    # Create a tuple of the two vertical distance calculations\n    x33 = astuple(x29, x32)\n    \n    # Get the maximum of the two vertical distance calculations\n    x34 = maximum(x33)\n    \n    # If the box doesn't touch the top edge, use 0 as vertical movement, otherwise use calculated value\n    x35 = branch(x20, ZERO, x34)\n    \n    # Get the rightmost position of the moved box\n    x36 = rightmost(x26)\n    \n    # Get the rightmost position of the original box\n    x37 = rightmost(x23)\n    \n    # Calculate the horizontal distance moved by the box\n    x38 = subtract(x36, x37)\n    \n    # Get the leftmost position of the moved box\n    x39 = leftmost(x26)\n    \n    # Get the leftmost position of the original box\n    x40 = leftmost(x23)\n    \n    # Calculate the horizontal distance moved by the box (alternative method)\n    x41 = subtract(x39, x40)\n    \n    # Create a tuple of the two horizontal distance calculations\n    x42 = astuple(x38, x41)\n    \n    # Get the maximum of the two horizontal distance calculations\n    x43 = maximum(x42)\n    \n    # If the box doesn't touch the left edge, use 0 as horizontal movement, otherwise use calculated value\n    x44 = branch(x17, ZERO, x43)\n    \n    # Create a tuple of the vertical and horizontal movement\n    x45 = astuple(x35, x44)\n    \n    # Shift the dot by the same amount as the box moved\n    x46 = shift(x11, x45)\n    \n    # Get the area around the shifted dot\n    x47 = delta(x46)\n    \n    # Create a horizontally mirrored version of the shifted dot\n    x48 = hmirror(x46)\n    \n    # Get the upper-left corner of the area around the shifted dot\n    x49 = ulcorner(x47)\n    \n    # Get the area around the horizontally mirrored dot\n    x50 = delta(x48)\n    \n    # Get the upper-left corner of the area around the mirrored dot\n    x51 = ulcorner(x50)\n    \n    # Calculate the shift needed to align the mirrored dot with the original\n    x52 = subtract(x49, x51)\n    \n    # Shift the mirrored dot to align with the original\n    x53 = shift(x48, x52)\n    \n    # Combine the original shifted dot with its horizontal mirror\n    x54 = combine(x46, x53)\n    \n    # Create a vertically mirrored version of the combined dot\n    x55 = vmirror(x54)\n    \n    # Get the upper-left corner of the area around the shifted dot (again)\n    x56 = ulcorner(x47)\n    \n    # Get the area around the vertically mirrored combined dot\n    x57 = delta(x55)\n    \n    # Get the upper-left corner of the area around the vertically mirrored dot\n    x58 = ulcorner(x57)\n    \n    # Calculate the shift needed to align the vertically mirrored dot with the original\n    x59 = subtract(x56, x58)\n    \n    # Shift the vertically mirrored dot to align with the original\n    x60 = shift(x55, x59)\n    \n    # Combine all versions of the dot (original, horizontal mirror, vertical mirror)\n    x61 = combine(x60, x54)\n    \n    # Get the color of the dot\n    x62 = color(x11)\n    \n    # Replace the dot color in the input grid with the background color\n    x63 = replace(I, x62, x6)\n    \n    # Paint the combined dot shape onto the modified input grid\n    x64 = paint(x63, x61)\n    \n    # Return the final grid with the dot moved and expanded\n    return x64\n"
  },
  "539a4f51": {
    "original": "def verify_539a4f51(I: Grid) -> Grid:\n    x0 = astuple(identity, cmirror)\n    x1 = astuple(hmirror, vmirror)\n    x2 = combine(x0, x1)\n    x3 = fork(multiply, height, width)\n    x4 = rbind(objects, F)\n    x5 = rbind(x4, F)\n    x6 = rbind(x5, T)\n    x7 = rbind(argmin, x3)\n    x8 = lbind(contained, ORIGIN)\n    x9 = chain(x8, toindices, x7)\n    x10 = compose(x9, x6)\n    x11 = lbind(compose, x10)\n    x12 = rbind(rapply, I)\n    x13 = compose(initset, x11)\n    x14 = chain(first, x12, x13)\n    x15 = extract(x2, x14)\n    x16 = x15(I)\n    x17 = height(I)\n    x18 = first(x16)\n    x19 = matcher(identity, ZERO)\n    x20 = compose(flip, x19)\n    x21 = sfilter(x18, x20)\n    x22 = size(x21)\n    x23 = divide(x17, x22)\n    x24 = increment(x23)\n    x25 = double(x24)\n    x26 = repeat(x21, x25)\n    x27 = merge(x26)\n    x28 = double(x17)\n    x29 = repeat(x27, x28)\n    x30 = asobject(x29)\n    x31 = chain(increment, last, last)\n    x32 = compose(first, last)\n    x33 = fork(greater, x31, x32)\n    x34 = sfilter(x30, x33)\n    x35 = upscale(x16, TWO)\n    x36 = dmirror(x34)\n    x37 = combine(x34, x36)\n    x38 = paint(x35, x37)\n    x39 = x15(x38)\n    return x39\n\n",
    "annotated": "def verify_539a4f51(I: Grid) -> Grid:\n    # Create a tuple of identity and counter-diagonal mirror functions\n    x0 = astuple(identity, cmirror)\n    # Create a tuple of horizontal and vertical mirror functions\n    x1 = astuple(hmirror, vmirror)\n    # Combine all mirror functions into a single tuple\n    x2 = combine(x0, x1)\n    # Create a function that multiplies the height and width of an object\n    x3 = fork(multiply, height, width)\n    # Partially apply the objects function with False for univalued parameter\n    x4 = rbind(objects, F)\n    # Further partially apply with False for diagonal parameter\n    x5 = rbind(x4, F)\n    # Finally, partially apply with True for without_bg parameter\n    x6 = rbind(x5, T)\n    # Create a function that finds the object with minimum area\n    x7 = rbind(argmin, x3)\n    # Create a function that checks if ORIGIN is contained in a set of indices\n    x8 = lbind(contained, ORIGIN)\n    # Chain functions to find if the smallest object contains the origin\n    x9 = chain(x8, toindices, x7)\n    # Compose the above chain with the object extraction function\n    x10 = compose(x9, x6)\n    # Prepare for partial application of the above composition\n    x11 = lbind(compose, x10)\n    # Create a function to apply a list of functions to the input grid\n    x12 = rbind(rapply, I)\n    # Create a function to initialize a set with the result of x11\n    x13 = compose(initset, x11)\n    # Chain functions to find the correct orientation of the input grid\n    x14 = chain(first, x12, x13)\n    # Extract the correct orientation function\n    x15 = extract(x2, x14)\n    # Apply the orientation function to the input grid\n    x16 = x15(I)\n    # Get the height of the input grid\n    x17 = height(I)\n    # Get the first row of the oriented grid\n    x18 = first(x16)\n    # Create a function that checks if a value is zero\n    x19 = matcher(identity, ZERO)\n    # Create a function that checks if a value is non-zero\n    x20 = compose(flip, x19)\n    # Filter the first row to keep only non-zero elements\n    x21 = sfilter(x18, x20)\n    # Count the number of non-zero elements in the first row\n    x22 = size(x21)\n    # Calculate the ratio of grid height to pattern length\n    x23 = divide(x17, x22)\n    # Increment the ratio (to account for the diagonal)\n    x24 = increment(x23)\n    # Double the incremented ratio\n    x25 = double(x24)\n    # Repeat the pattern to fill the width of the output grid\n    x26 = repeat(x21, x25)\n    # Merge the repeated patterns into a single row\n    x27 = merge(x26)\n    # Calculate the height of the output grid\n    x28 = double(x17)\n    # Repeat the merged row to fill the height of the output grid\n    x29 = repeat(x27, x28)\n    # Convert the 2D list to an object representation\n    x30 = asobject(x29)\n    # Create a function to get the row index of a cell\n    x31 = chain(increment, last, last)\n    # Create a function to get the column index of a cell\n    x32 = compose(first, last)\n    # Create a function to check if row index is greater than column index\n    x33 = fork(greater, x31, x32)\n    # Filter the object to keep only cells below the main diagonal\n    x34 = sfilter(x30, x33)\n    # Double the size of the oriented input grid\n    x35 = upscale(x16, TWO)\n    # Mirror the filtered object along the diagonal\n    x36 = dmirror(x34)\n    # Combine the filtered object and its mirror\n    x37 = combine(x34, x36)\n    # Paint the combined object onto the upscaled input grid\n    x38 = paint(x35, x37)\n    # Apply the inverse orientation function to get the final output\n    x39 = x15(x38)\n    return x39\n"
  },
  "53b68214": {
    "original": "def verify_53b68214(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = mostcolor(I)\n    x3 = width(I)\n    x4 = astuple(TEN, x3)\n    x5 = canvas(x2, x4)\n    x6 = interval(ONE, SIX, ONE)\n    x7 = invert(TEN)\n    x8 = interval(x7, TEN, ONE)\n    x9 = product(x6, x8)\n    x10 = remove(ORIGIN, x9)\n    x11 = lbind(intersection, x1)\n    x12 = lbind(shift, x1)\n    x13 = compose(x11, x12)\n    x14 = toindices(x1)\n    x15 = lbind(intersection, x14)\n    x16 = lbind(shift, x14)\n    x17 = compose(x15, x16)\n    x18 = compose(size, x13)\n    x19 = compose(size, x17)\n    x20 = fork(equality, x18, x19)\n    x21 = chain(positive, size, x13)\n    x22 = fork(both, x20, x21)\n    x23 = sfilter(x10, x22)\n    x24 = compose(size, x13)\n    x25 = valmax(x23, x24)\n    x26 = compose(size, x13)\n    x27 = matcher(x26, x25)\n    x28 = sfilter(x23, x27)\n    x29 = fork(multiply, first, last)\n    x30 = argmax(x28, x29)\n    x31 = interval(ZERO, TEN, ONE)\n    x32 = lbind(shift, x1)\n    x33 = lbind(multiply, x30)\n    x34 = compose(x32, x33)\n    x35 = mapply(x34, x31)\n    x36 = paint(x5, x35)\n    return x36\n\n",
    "annotated": "def verify_53b68214(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    # Find the most common color in the input grid (background color)\n    x2 = mostcolor(I)\n    # Get the width of the input grid\n    x3 = width(I)\n    # Create a tuple (10, width) for the output grid dimensions\n    x4 = astuple(TEN, x3)\n    # Create a canvas with the background color and output dimensions\n    x5 = canvas(x2, x4)\n    # Create a range of integers from 1 to 5 (possible vertical shifts)\n    x6 = interval(ONE, SIX, ONE)\n    # Get the negative of 10 (-10)\n    x7 = invert(TEN)\n    # Create a range of integers from -10 to 9 (possible horizontal shifts)\n    x8 = interval(x7, TEN, ONE)\n    # Generate all possible combinations of vertical and horizontal shifts\n    x9 = product(x6, x8)\n    # Remove the origin (0, 0) from the shift combinations\n    x10 = remove(ORIGIN, x9)\n    # Prepare a function to find the intersection of x1 with a shifted version of itself\n    x11 = lbind(intersection, x1)\n    x12 = lbind(shift, x1)\n    x13 = compose(x11, x12)\n    # Prepare a similar function for the indices of x1\n    x14 = toindices(x1)\n    x15 = lbind(intersection, x14)\n    x16 = lbind(shift, x14)\n    x17 = compose(x15, x16)\n    # Create functions to compare the sizes of the intersections\n    x18 = compose(size, x13)\n    x19 = compose(size, x17)\n    x20 = fork(equality, x18, x19)\n    # Create a function to check if the intersection is non-empty\n    x21 = chain(positive, size, x13)\n    # Combine the size comparison and non-empty check\n    x22 = fork(both, x20, x21)\n    # Filter the shift combinations based on the above conditions\n    x23 = sfilter(x10, x22)\n    # Find the maximum size of intersection among valid shifts\n    x24 = compose(size, x13)\n    x25 = valmax(x23, x24)\n    # Create a function to match shifts with the maximum intersection size\n    x26 = compose(size, x13)\n    x27 = matcher(x26, x25)\n    # Filter shifts to keep only those with maximum intersection size\n    x28 = sfilter(x23, x27)\n    # Create a function to multiply the components of a shift vector\n    x29 = fork(multiply, first, last)\n    # Find the shift with the largest product of its components\n    x30 = argmax(x28, x29)\n    # Create a range of integers from 0 to 9 (for repeating the pattern)\n    x31 = interval(ZERO, TEN, ONE)\n    # Prepare functions to shift the merged object\n    x32 = lbind(shift, x1)\n    x33 = lbind(multiply, x30)\n    x34 = compose(x32, x33)\n    # Apply the shift to create multiple copies of the object\n    x35 = mapply(x34, x31)\n    # Paint the shifted objects onto the output canvas\n    x36 = paint(x5, x35)\n    # Return the final output grid\n    return x36\n"
  },
  "543a7ed5": {
    "original": "def verify_543a7ed5(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = mapply(outbox, x0)\n    x2 = fill(I, THREE, x1)\n    x3 = mapply(delta, x0)\n    x4 = fill(x2, FOUR, x3)\n    return x4\n\n",
    "annotated": "def verify_543a7ed5(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # For each object, find its outbox (the surrounding border)\n    x1 = mapply(outbox, x0)\n    \n    # Fill the input grid with color 3 (border color) at the locations of all outboxes\n    # This draws borders around all objects\n    x2 = fill(I, THREE, x1)\n    \n    # For each object, find its delta (the area inside the object, excluding its border)\n    x3 = mapply(delta, x0)\n    \n    # Fill the grid (which now has borders) with color 4 in the delta areas\n    # This adds inner rectangles to all objects that didn't already have them\n    x4 = fill(x2, FOUR, x3)\n    \n    # Return the final grid with borders (color 3) and inner rectangles (color 4) added to all objects\n    return x4\n"
  },
  "54d82841": {
    "original": "def verify_54d82841(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = mapply(delta, x0)\n    x2 = first(x0)\n    x3 = toindices(x2)\n    x4 = rbind(contained, x3)\n    x5 = portrait(x2)\n    x6 = apply(first, x1)\n    x7 = apply(last, x1)\n    x8 = branch(x5, x6, x7)\n    x9 = branch(x5, RIGHT, DOWN)\n    x10 = delta(x2)\n    x11 = center(x10)\n    x12 = add(x11, x9)\n    x13 = x4(x12)\n    x14 = branch(x5, width, height)\n    x15 = branch(x5, rbind, lbind)\n    x16 = x14(I)\n    x17 = decrement(x16)\n    x18 = x15(astuple, x17)\n    x19 = branch(x5, toivec, tojvec)\n    x20 = branch(x13, x19, x18)\n    x21 = apply(x20, x8)\n    x22 = fill(I, FOUR, x21)\n    return x22\n\n",
    "annotated": "def verify_54d82841(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    \n    # Get the delta (surrounding empty cells) for each object\n    x1 = mapply(delta, x0)\n    \n    # Get the first object from the set of objects\n    x2 = first(x0)\n    \n    # Convert the object to a set of indices\n    x3 = toindices(x2)\n    \n    # Create a function that checks if a point is contained in the object\n    x4 = rbind(contained, x3)\n    \n    # Check if the object is taller than it is wide\n    x5 = portrait(x2)\n    \n    # Get the first (top) point of each object's delta\n    x6 = apply(first, x1)\n    \n    # Get the last (bottom) point of each object's delta\n    x7 = apply(last, x1)\n    \n    # Choose top or bottom point based on whether the object is portrait or landscape\n    x8 = branch(x5, x6, x7)\n    \n    # Choose RIGHT or DOWN direction based on whether the object is portrait or landscape\n    x9 = branch(x5, RIGHT, DOWN)\n    \n    # Get the delta (surrounding empty cells) of the first object\n    x10 = delta(x2)\n    \n    # Find the center of the object's delta\n    x11 = center(x10)\n    \n    # Add the direction vector to the center point\n    x12 = add(x11, x9)\n    \n    # Check if the new point is contained in the object\n    x13 = x4(x12)\n    \n    # Choose width or height function based on whether the object is portrait or landscape\n    x14 = branch(x5, width, height)\n    \n    # Choose right or left bind for the astuple function based on object orientation\n    x15 = branch(x5, rbind, lbind)\n    \n    # Get the width or height of the input grid based on object orientation\n    x16 = x14(I)\n    \n    # Decrement the width or height by 1\n    x17 = decrement(x16)\n    \n    # Create a tuple function with the decremented dimension as a fixed argument\n    x18 = x15(astuple, x17)\n    \n    # Choose between creating a vertical or horizontal vector based on object orientation\n    x19 = branch(x5, toivec, tojvec)\n    \n    # Choose between the vector creation function or the tuple function based on containment check\n    x20 = branch(x13, x19, x18)\n    \n    # Apply the chosen function to each point in x8\n    x21 = apply(x20, x8)\n    \n    # Fill the input grid with color 4 (FOUR) at the calculated positions\n    # This effectively adds a dot below each object in the grid\n    x22 = fill(I, FOUR, x21)\n    \n    # Return the modified grid\n    return x22\n"
  },
  "54d9e175": {
    "original": "def verify_54d9e175(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = leastcolor(x1)\n    x3 = shape(I)\n    x4 = canvas(x2, x3)\n    x5 = hconcat(I, x4)\n    x6 = objects(x5, F, F, T)\n    x7 = power(increment, FIVE)\n    x8 = lbind(remove, FIVE)\n    x9 = lbind(remove, ZERO)\n    x10 = chain(x8, x9, palette)\n    x11 = chain(x7, first, x10)\n    x12 = fork(recolor, x11, toindices)\n    x13 = mapply(x12, x6)\n    x14 = paint(I, x13)\n    return x14\n\n",
    "annotated": "def verify_54d9e175(I: Grid) -> Grid:\n    # Identify all frontiers (rows/columns with same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single set of cells\n    x1 = merge(x0)\n    \n    # Find the least common color in the merged frontiers (likely the background color)\n    x2 = leastcolor(x1)\n    \n    # Get the dimensions of the input grid\n    x3 = shape(I)\n    \n    # Create a new grid with the same dimensions as input, filled with the background color\n    x4 = canvas(x2, x3)\n    \n    # Concatenate the input grid with the background grid horizontally\n    x5 = hconcat(I, x4)\n    \n    # Identify objects in the concatenated grid, ignoring diagonals and background\n    x6 = objects(x5, F, F, T)\n    \n    # Create a function that increments a value 5 times\n    x7 = power(increment, FIVE)\n    \n    # Create a function that removes color 5 from a set\n    x8 = lbind(remove, FIVE)\n    \n    # Create a function that removes color 0 from a set\n    x9 = lbind(remove, ZERO)\n    \n    # Chain functions to get palette, remove 0 and 5, then take first color\n    x10 = chain(x8, x9, palette)\n    \n    # Chain functions to get first non-0/5 color and increment it by 5\n    x11 = chain(x7, first, x10)\n    \n    # Create a function that recolors an object with the incremented color\n    x12 = fork(recolor, x11, toindices)\n    \n    # Apply the recoloring function to all objects\n    x13 = mapply(x12, x6)\n    \n    # Paint the recolored objects onto the input grid\n    x14 = paint(I, x13)\n    \n    # Return the final transformed grid\n    return x14\n"
  },
  "5521c0d9": {
    "original": "def verify_5521c0d9(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = rbind(objects, T)\n    x5 = rbind(x4, F)\n    x6 = rbind(x5, T)\n    x7 = lbind(canvas, x3)\n    x8 = compose(x7, shape)\n    x9 = fork(hconcat, identity, x8)\n    x10 = compose(x6, x9)\n    x11 = lbind(apply, uppermost)\n    x12 = chain(maximum, x11, x10)\n    x13 = matcher(x12, ZERO)\n    x14 = astuple(identity, dmirror)\n    x15 = astuple(cmirror, hmirror)\n    x16 = combine(x14, x15)\n    x17 = rbind(rapply, I)\n    x18 = chain(first, x17, initset)\n    x19 = compose(x13, x18)\n    x20 = extract(x16, x19)\n    x21 = x20(I)\n    x22 = shape(x21)\n    x23 = canvas(x3, x22)\n    x24 = hconcat(x21, x23)\n    x25 = objects(x24, T, F, T)\n    x26 = compose(toivec, height)\n    x27 = fork(shift, identity, x26)\n    x28 = mapply(x27, x25)\n    x29 = mostcolor(I)\n    x30 = merge(x25)\n    x31 = fill(x21, x29, x30)\n    x32 = paint(x31, x28)\n    x33 = x20(x32)\n    return x33\n\n",
    "annotated": "def verify_5521c0d9(I: Grid) -> Grid:\n    x0 = asindices(I)  # Get all indices of the input grid\n    x1 = box(x0)  # Create a box outline around the entire grid\n    x2 = toobject(x1, I)  # Convert the box outline to an object, preserving colors from input grid\n    x3 = mostcolor(x2)  # Find the most common color in the box outline (likely the background color)\n    x4 = rbind(objects, T)  # Partially apply 'objects' function, setting univalued=True\n    x5 = rbind(x4, F)  # Further partially apply, setting diagonal=False\n    x6 = rbind(x5, T)  # Finally, partially apply, setting without_bg=True\n    x7 = lbind(canvas, x3)  # Partially apply 'canvas' function with the background color\n    x8 = compose(x7, shape)  # Compose canvas creation with shape detection\n    x9 = fork(hconcat, identity, x8)  # Create a function that concatenates input with a canvas of same shape\n    x10 = compose(x6, x9)  # Compose object detection with grid concatenation\n    x11 = lbind(apply, uppermost)  # Partially apply 'apply' function with 'uppermost'\n    x12 = chain(maximum, x11, x10)  # Chain maximum, uppermost application, and object detection\n    x13 = matcher(x12, ZERO)  # Create a function that checks if the result of x12 is zero\n    x14 = astuple(identity, dmirror)  # Create a tuple of identity and diagonal mirror functions\n    x15 = astuple(cmirror, hmirror)  # Create a tuple of counter-diagonal and horizontal mirror functions\n    x16 = combine(x14, x15)  # Combine all mirror functions into a single container\n    x17 = rbind(rapply, I)  # Partially apply 'rapply' with the input grid\n    x18 = chain(first, x17, initset)  # Chain first, rapply, and initset functions\n    x19 = compose(x13, x18)  # Compose the zero-checking function with x18\n    x20 = extract(x16, x19)  # Extract the correct mirror function based on x19\n    x21 = x20(I)  # Apply the extracted mirror function to the input grid\n    x22 = shape(x21)  # Get the shape of the mirrored grid\n    x23 = canvas(x3, x22)  # Create a canvas with background color and same shape as mirrored grid\n    x24 = hconcat(x21, x23)  # Horizontally concatenate mirrored grid with the canvas\n    x25 = objects(x24, T, F, T)  # Detect objects in the concatenated grid\n    x26 = compose(toivec, height)  # Compose toivec and height functions\n    x27 = fork(shift, identity, x26)  # Create a function that shifts objects based on their height\n    x28 = mapply(x27, x25)  # Apply the shift function to all detected objects\n    x29 = mostcolor(I)  # Find the most common color in the original input grid\n    x30 = merge(x25)  # Merge all detected objects into a single set of indices\n    x31 = fill(x21, x29, x30)  # Fill the merged object area with the most common color\n    x32 = paint(x31, x28)  # Paint the shifted objects onto the filled grid\n    x33 = x20(x32)  # Apply the same mirror function to the result\n    return x33  # Return the final transformed grid\n\n# This verifier function appears to mirror the input grid, detect objects,\n# shift them vertically based on their height, and then mirror the result back.\n# It effectively \"drops\" the objects to the bottom of the grid.\n"
  },
  "5582e5ca": {
    "original": "def verify_5582e5ca(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = shape(I)\n    x2 = canvas(x0, x1)\n    return x2\n\n",
    "annotated": "def verify_5582e5ca(I: Grid) -> Grid:\n    # Find the most common color in the input grid\n    # This color will be used to fill the entire output grid\n    x0 = mostcolor(I)\n    \n    # Get the dimensions (shape) of the input grid\n    # This ensures the output grid will have the same size as the input\n    x1 = shape(I)\n    \n    # Create a new grid with the same dimensions as the input grid\n    # Fill this new grid entirely with the most common color from the input\n    # This effectively \"floods\" the grid with the dominant color\n    x2 = canvas(x0, x1)\n    \n    # Return the newly created grid as the output\n    # The output is a uniform grid where all cells have the same color\n    # (the most common color from the input)\n    return x2\n"
  },
  "5614dbcf": {
    "original": "def verify_5614dbcf(I: Grid) -> Grid:\n    x0 = canvas(ZERO, THREE_BY_THREE)\n    x1 = asindices(x0)\n    x2 = shape(I)\n    x3 = divide(x2, THREE)\n    x4 = first(x3)\n    x5 = last(x3)\n    x6 = interval(ZERO, x4, ONE)\n    x7 = interval(ZERO, x5, ONE)\n    x8 = product(x6, x7)\n    x9 = rbind(multiply, THREE)\n    x10 = apply(x9, x8)\n    x11 = matcher(first, FIVE)\n    x12 = compose(flip, x11)\n    x13 = rbind(sfilter, x12)\n    x14 = rbind(toobject, I)\n    x15 = lbind(shift, x1)\n    x16 = chain(x13, x14, x15)\n    x17 = compose(color, x16)\n    x18 = lbind(shift, x1)\n    x19 = fork(recolor, x17, x18)\n    x20 = mapply(x19, x10)\n    x21 = paint(I, x20)\n    x22 = downscale(x21, THREE)\n    return x22\n\n",
    "annotated": "def verify_5614dbcf(I: Grid) -> Grid:\n    # Create a 3x3 grid filled with zeros\n    x0 = canvas(ZERO, THREE_BY_THREE)\n    # Get all indices of the 3x3 grid\n    x1 = asindices(x0)\n    # Get the dimensions of the input grid\n    x2 = shape(I)\n    # Divide the dimensions by 3 to get the size of the output grid\n    x3 = divide(x2, THREE)\n    # Get the height of the output grid\n    x4 = first(x3)\n    # Get the width of the output grid\n    x5 = last(x3)\n    # Create a range from 0 to the height of the output grid\n    x6 = interval(ZERO, x4, ONE)\n    # Create a range from 0 to the width of the output grid\n    x7 = interval(ZERO, x5, ONE)\n    # Generate all possible coordinates for the output grid\n    x8 = product(x6, x7)\n    # Create a function that multiplies by 3\n    x9 = rbind(multiply, THREE)\n    # Apply the multiply-by-3 function to all output grid coordinates\n    # This gives us the top-left coordinates of each 3x3 block in the input grid\n    x10 = apply(x9, x8)\n    # Create a function that checks if a color is not 5\n    x11 = matcher(first, FIVE)\n    x12 = compose(flip, x11)\n    # Create a function that filters out cells with color 5\n    x13 = rbind(sfilter, x12)\n    # Create a function that converts a patch to an object using the input grid\n    x14 = rbind(toobject, I)\n    # Create a function that shifts the 3x3 indices\n    x15 = lbind(shift, x1)\n    # Chain functions to get non-5 colored cells in each 3x3 block\n    x16 = chain(x13, x14, x15)\n    # Get the color of the non-5 cells in each 3x3 block\n    x17 = compose(color, x16)\n    # Create a function to shift the 3x3 indices\n    x18 = lbind(shift, x1)\n    # Create a function to recolor the shifted indices with the determined color\n    x19 = fork(recolor, x17, x18)\n    # Apply the recoloring function to all 3x3 blocks\n    x20 = mapply(x19, x10)\n    # Paint the recolored objects onto the input grid\n    x21 = paint(I, x20)\n    # Downscale the resulting grid by a factor of 3 to get the final output\n    x22 = downscale(x21, THREE)\n    return x22\n"
  },
  "56dc2b01": {
    "original": "def verify_56dc2b01(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = hline(x0)\n    x2 = branch(x1, dmirror, identity)\n    x3 = x2(I)\n    x4 = fgpartition(x3)\n    x5 = matcher(color, TWO)\n    x6 = compose(flip, x5)\n    x7 = extract(x4, x6)\n    x8 = ofcolor(x3, TWO)\n    x9 = leftmost(x8)\n    x10 = leftmost(x7)\n    x11 = greater(x9, x10)\n    x12 = manhattan(x7, x8)\n    x13 = decrement(x12)\n    x14 = branch(x11, identity, invert)\n    x15 = branch(x11, decrement, increment)\n    x16 = branch(x11, leftmost, rightmost)\n    x17 = x14(x13)\n    x18 = tojvec(x17)\n    x19 = shift(x7, x18)\n    x20 = x16(x19)\n    x21 = x15(x20)\n    x22 = tojvec(x21)\n    x23 = vfrontier(x22)\n    x24 = cover(x3, x7)\n    x25 = paint(x24, x19)\n    x26 = fill(x25, EIGHT, x23)\n    x27 = x2(x26)\n    return x27\n\n",
    "annotated": "def verify_56dc2b01(I: Grid) -> Grid:\n    # Find all cells with color 2 (vertical bar) in the input grid\n    x0 = ofcolor(I, TWO)\n    # Check if the cells with color 2 form a horizontal line\n    x1 = hline(x0)\n    # If x1 is True, apply diagonal mirror transformation, otherwise keep the grid as is\n    x2 = branch(x1, dmirror, identity)\n    # Apply the transformation (if any) to the input grid\n    x3 = x2(I)\n    # Partition the transformed grid into objects, excluding the background color\n    x4 = fgpartition(x3)\n    # Create a function that checks if a color is not 2\n    x5 = matcher(color, TWO)\n    x6 = compose(flip, x5)\n    # Extract the object that is not color 2 (the main object to be moved)\n    x7 = extract(x4, x6)\n    # Find all cells with color 2 in the transformed grid (vertical bar)\n    x8 = ofcolor(x3, TWO)\n    # Find the leftmost position of the vertical bar\n    x9 = leftmost(x8)\n    # Find the leftmost position of the main object\n    x10 = leftmost(x7)\n    # Check if the vertical bar is to the right of the main object\n    x11 = greater(x9, x10)\n    # Calculate the horizontal distance between the object and the vertical bar\n    x12 = manhattan(x7, x8)\n    # Decrease the distance by 1 (to place object next to the bar)\n    x13 = decrement(x12)\n    # Choose between identity and invert based on relative positions\n    x14 = branch(x11, identity, invert)\n    # Choose between decrement and increment based on relative positions\n    x15 = branch(x11, decrement, increment)\n    # Choose between leftmost and rightmost based on relative positions\n    x16 = branch(x11, leftmost, rightmost)\n    # Apply the chosen function (identity or invert) to the distance\n    x17 = x14(x13)\n    # Convert the distance to a horizontal vector\n    x18 = tojvec(x17)\n    # Shift the main object by the calculated vector\n    x19 = shift(x7, x18)\n    # Find the new leftmost or rightmost position of the shifted object\n    x20 = x16(x19)\n    # Adjust the position (decrement or increment)\n    x21 = x15(x20)\n    # Convert the adjusted position to a horizontal vector\n    x22 = tojvec(x21)\n    # Create a vertical frontier at the adjusted position\n    x23 = vfrontier(x22)\n    # Remove the original object from the transformed grid\n    x24 = cover(x3, x7)\n    # Paint the shifted object onto the grid\n    x25 = paint(x24, x19)\n    # Fill the vertical frontier with color 8 (new vertical bar)\n    x26 = fill(x25, EIGHT, x23)\n    # Apply the inverse transformation (if any) to return to original orientation\n    x27 = x2(x26)\n    return x27\n"
  },
  "56ff96f3": {
    "original": "def verify_56ff96f3(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = fork(recolor, color, backdrop)\n    x2 = mapply(x1, x0)\n    x3 = paint(I, x2)\n    return x3\n\n",
    "annotated": "def verify_56ff96f3(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that combines recoloring and finding the bounding box of an object\n    # This will be used to fill in the entire area of each object\n    x1 = fork(recolor, color, backdrop)\n    \n    # Apply the combined function to each object in the partition\n    # This creates a set of objects where each is filled with its color\n    x2 = mapply(x1, x0)\n    \n    # Paint the filled objects onto the original input grid\n    # This effectively fills in the diagonals to create solid colored rectangles\n    x3 = paint(I, x2)\n    \n    # Return the modified grid with filled rectangles\n    return x3\n"
  },
  "57aa92db": {
    "original": "def verify_57aa92db(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = palette(I)\n    x2 = lbind(sfilter, x0)\n    x3 = rbind(compose, palette)\n    x4 = lbind(lbind, contained)\n    x5 = chain(x2, x3, x4)\n    x6 = compose(size, x5)\n    x7 = argmax(x1, x6)\n    x8 = rbind(colorcount, x7)\n    x9 = apply(x8, x0)\n    x10 = minimum(x9)\n    x11 = rbind(colorcount, x7)\n    x12 = matcher(x11, x10)\n    x13 = sfilter(x0, x12)\n    x14 = argmax(x13, size)\n    x15 = matcher(first, x7)\n    x16 = rbind(sfilter, x15)\n    x17 = lbind(upscale, x14)\n    x18 = chain(x17, width, x16)\n    x19 = compose(ulcorner, x16)\n    x20 = chain(ulcorner, x16, x18)\n    x21 = fork(subtract, x19, x20)\n    x22 = fork(shift, x18, x21)\n    x23 = rbind(other, x7)\n    x24 = compose(x23, palette)\n    x25 = compose(x16, x22)\n    x26 = fork(difference, x22, x25)\n    x27 = fork(recolor, x24, x26)\n    x28 = compose(x16, x22)\n    x29 = fork(combine, x28, x27)\n    x30 = remove(x14, x0)\n    x31 = mapply(x29, x30)\n    x32 = paint(I, x31)\n    return x32\n\n",
    "annotated": "def verify_57aa92db(I: Grid) -> Grid:\n    # Get all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, F, T, T)\n    \n    # Get the palette (unique colors) of the input grid\n    x1 = palette(I)\n    \n    # Partially apply sfilter function with x0 as the first argument\n    x2 = lbind(sfilter, x0)\n    \n    # Create a function that composes palette with another function\n    x3 = rbind(compose, palette)\n    \n    # Partially apply the 'contained' function twice\n    x4 = lbind(lbind, contained)\n    \n    # Chain x2, x3, and x4 functions together\n    x5 = chain(x2, x3, x4)\n    \n    # Create a function that gets the size of the result of x5\n    x6 = compose(size, x5)\n    \n    # Find the color in x1 that maximizes x6\n    # This is likely the main color of the objects\n    x7 = argmax(x1, x6)\n    \n    # Create a function that counts occurrences of x7 in an object\n    x8 = rbind(colorcount, x7)\n    \n    # Apply x8 to all objects in x0\n    x9 = apply(x8, x0)\n    \n    # Find the minimum count of x7 color in objects\n    x10 = minimum(x9)\n    \n    # Create another function that counts occurrences of x7 in an object\n    x11 = rbind(colorcount, x7)\n    \n    # Create a function that checks if an object has x10 occurrences of x7\n    x12 = matcher(x11, x10)\n    \n    # Filter objects in x0 that satisfy x12\n    # This likely finds the smallest objects of the main color\n    x13 = sfilter(x0, x12)\n    \n    # Find the largest object among the filtered objects\n    # This is probably the original object template\n    x14 = argmax(x13, size)\n    \n    # Create a function that checks if the first color of an object is x7\n    x15 = matcher(first, x7)\n    \n    # Partially apply sfilter with x15\n    x16 = rbind(sfilter, x15)\n    \n    # Create a function that upscales x14\n    x17 = lbind(upscale, x14)\n    \n    # Chain x17, width, and x16 functions\n    # This likely finds the width of an upscaled object after filtering\n    x18 = chain(x17, width, x16)\n    \n    # Get the upper-left corner of the filtered upscaled object\n    x19 = compose(ulcorner, x16)\n    \n    # Get the upper-left corner of the filtered upscaled object (again, but through a different chain)\n    x20 = chain(ulcorner, x16, x18)\n    \n    # Calculate the difference between x19 and x20\n    # This might be used to determine the shift needed\n    x21 = fork(subtract, x19, x20)\n    \n    # Create a function that shifts x18 by x21\n    x22 = fork(shift, x18, x21)\n    \n    # Get the other color (not x7) from the palette\n    x23 = rbind(other, x7)\n    \n    # Compose x23 with palette\n    x24 = compose(x23, palette)\n    \n    # Compose x16 with x22\n    x25 = compose(x16, x22)\n    \n    # Calculate the difference between x22 and x25\n    x26 = fork(difference, x22, x25)\n    \n    # Create a function that recolors x26 with the color from x24\n    x27 = fork(recolor, x24, x26)\n    \n    # Compose x16 with x22 (again)\n    x28 = compose(x16, x22)\n    \n    # Combine x28 and x27\n    x29 = fork(combine, x28, x27)\n    \n    # Remove x14 from x0\n    # This removes the original object template from the set of objects\n    x30 = remove(x14, x0)\n    \n    # Apply x29 to all objects in x30\n    # This likely processes all objects except the template\n    x31 = mapply(x29, x30)\n    \n    # Paint the processed objects onto the input grid\n    # This creates the output grid by modifying the objects\n    x32 = paint(I, x31)\n    \n    # Return the modified grid as the output\n    return x32\n"
  },
  "5ad4f10b": {
    "original": "def verify_5ad4f10b(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = palette(I)\n    x5 = remove(x3, x4)\n    x6 = lbind(chain, size)\n    x7 = rbind(x6, dneighbors)\n    x8 = lbind(lbind, intersection)\n    x9 = lbind(ofcolor, I)\n    x10 = chain(x7, x8, x9)\n    x11 = rbind(matcher, ZERO)\n    x12 = compose(x11, x10)\n    x13 = chain(flip, positive, size)\n    x14 = lbind(ofcolor, I)\n    x15 = fork(sfilter, x14, x12)\n    x16 = compose(x13, x15)\n    x17 = argmax(x5, x16)\n    x18 = other(x5, x17)\n    x19 = ofcolor(I, x17)\n    x20 = subgrid(x19, I)\n    x21 = switch(x20, x17, x18)\n    x22 = replace(x21, x17, x3)\n    x23 = lbind(downscale, x22)\n    x24 = fork(upscale, x23, identity)\n    x25 = matcher(x24, x22)\n    x26 = shape(x22)\n    x27 = maximum(x26)\n    x28 = interval(ONE, x27, ONE)\n    x29 = sfilter(x28, x25)\n    x30 = maximum(x29)\n    x31 = downscale(x22, x30)\n    return x31\n\n",
    "annotated": "def verify_5ad4f10b(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    # Create a box outline around the entire grid\n    x1 = box(x0)\n    # Convert the box outline to an object on the input grid\n    x2 = toobject(x1, I)\n    # Find the most common color in the box outline (likely the background color)\n    x3 = mostcolor(x2)\n    # Get all colors used in the input grid\n    x4 = palette(I)\n    # Remove the background color from the palette, leaving object and noise colors\n    x5 = remove(x3, x4)\n    # Create a function that counts the size of an object's direct neighbors\n    x6 = lbind(chain, size)\n    x7 = rbind(x6, dneighbors)\n    # Create a function that finds the intersection of two sets\n    x8 = lbind(lbind, intersection)\n    # Create a function that finds cells of a specific color in the input grid\n    x9 = lbind(ofcolor, I)\n    # Chain the above functions to count neighbors of a specific color\n    x10 = chain(x7, x8, x9)\n    # Create a function that matches with zero\n    x11 = rbind(matcher, ZERO)\n    # Compose functions to find cells with no neighbors of a specific color\n    x12 = compose(x11, x10)\n    # Create a function that checks if the size of a set is positive\n    x13 = chain(flip, positive, size)\n    # Create a function to find cells of a specific color in the input grid\n    x14 = lbind(ofcolor, I)\n    # Create a function to filter cells based on color and neighbor condition\n    x15 = fork(sfilter, x14, x12)\n    # Compose functions to check if there are cells meeting the above conditions\n    x16 = compose(x13, x15)\n    # Find the color (between object and noise) with the most isolated cells\n    x17 = argmax(x5, x16)\n    # Get the other color (noise if x17 is object color, or vice versa)\n    x18 = other(x5, x17)\n    # Find all cells of the color with most isolated cells (likely the object color)\n    x19 = ofcolor(I, x17)\n    # Extract the subgrid containing only the object\n    x20 = subgrid(x19, I)\n    # Switch the object color and the noise color in the subgrid\n    x21 = switch(x20, x17, x18)\n    # Replace the object color with the background color\n    x22 = replace(x21, x17, x3)\n    # Create a function to downscale the processed subgrid\n    x23 = lbind(downscale, x22)\n    # Create a function to compare upscaled downscaled grid with original\n    x24 = fork(upscale, x23, identity)\n    x25 = matcher(x24, x22)\n    # Get the shape (dimensions) of the processed subgrid\n    x26 = shape(x22)\n    # Find the maximum dimension of the subgrid\n    x27 = maximum(x26)\n    # Create a range of possible downscaling factors\n    x28 = interval(ONE, x27, ONE)\n    # Filter downscaling factors that preserve the grid when upscaled\n    x29 = sfilter(x28, x25)\n    # Find the maximum valid downscaling factor\n    x30 = maximum(x29)\n    # Downscale the processed subgrid using the found factor\n    x31 = downscale(x22, x30)\n    # Return the final downscaled grid, which should be the original small grid\n    return x31\n"
  },
  "5bd6f4ac": {
    "original": "def verify_5bd6f4ac(I: Grid) -> Grid:\n    x0 = rot270(I)\n    x1 = crop(x0, ORIGIN, THREE_BY_THREE)\n    x2 = rot90(x1)\n    return x2\n\n",
    "annotated": "def verify_5bd6f4ac(I: Grid) -> Grid:\n    # Rotate the input grid 270 degrees counterclockwise\n    # This effectively flips the grid upside down and then mirrors it horizontally\n    x0 = rot270(I)\n    \n    # Crop a 3x3 section from the top-left corner of the rotated grid\n    # ORIGIN is (0, 0), and THREE_BY_THREE is (3, 3)\n    # This extracts the top-left 3x3 subgrid from the rotated input\n    x1 = crop(x0, ORIGIN, THREE_BY_THREE)\n    \n    # Rotate the cropped 3x3 section 90 degrees clockwise\n    # This is the final transformation, bringing the extracted subgrid to its output orientation\n    x2 = rot90(x1)\n    \n    # Return the final transformed grid\n    # The output is a 3x3 grid that represents a specific corner of the original input, rotated\n    return x2\n"
  },
  "5c0a986e": {
    "original": "def verify_5c0a986e(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = colorfilter(x0, TWO)\n    x2 = colorfilter(x0, ONE)\n    x3 = lbind(recolor, TWO)\n    x4 = rbind(shoot, UNITY)\n    x5 = chain(x3, x4, lrcorner)\n    x6 = lbind(recolor, ONE)\n    x7 = rbind(shoot, NEG_UNITY)\n    x8 = chain(x6, x7, ulcorner)\n    x9 = mapply(x5, x1)\n    x10 = mapply(x8, x2)\n    x11 = combine(x9, x10)\n    x12 = paint(I, x11)\n    return x12\n\n",
    "annotated": "def verify_5c0a986e(I: Grid) -> Grid:\n    # Identify all objects in the input grid, including those touching the border\n    x0 = objects(I, T, F, T)\n    # Filter objects with color 2 (diagonal extending down-right)\n    x1 = colorfilter(x0, TWO)\n    # Filter objects with color 1 (diagonal extending up-left)\n    x2 = colorfilter(x0, ONE)\n    # Create a function that recolors objects to color 2\n    x3 = lbind(recolor, TWO)\n    # Create a function that shoots a line in the down-right direction\n    x4 = rbind(shoot, UNITY)\n    # Create a function chain: find lower-right corner, shoot down-right, recolor to 2\n    x5 = chain(x3, x4, lrcorner)\n    # Create a function that recolors objects to color 1\n    x6 = lbind(recolor, ONE)\n    # Create a function that shoots a line in the up-left direction\n    x7 = rbind(shoot, NEG_UNITY)\n    # Create a function chain: find upper-left corner, shoot up-left, recolor to 1\n    x8 = chain(x6, x7, ulcorner)\n    # Apply the down-right extension to all color 2 objects\n    x9 = mapply(x5, x1)\n    # Apply the up-left extension to all color 1 objects\n    x10 = mapply(x8, x2)\n    # Combine the extended objects of both colors\n    x11 = combine(x9, x10)\n    # Paint the extended objects onto the input grid\n    x12 = paint(I, x11)\n    # Return the modified grid with extended objects\n    return x12\n"
  },
  "5c2c9af4": {
    "original": "def verify_5c2c9af4(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = height(x1)\n    x3 = halve(x2)\n    x4 = width(x1)\n    x5 = halve(x4)\n    x6 = ulcorner(x1)\n    x7 = lrcorner(x1)\n    x8 = shape(I)\n    x9 = maximum(x8)\n    x10 = multiply(THREE, TEN)\n    x11 = interval(ZERO, x10, ONE)\n    x12 = rbind(multiply, x3)\n    x13 = apply(x12, x11)\n    x14 = rbind(multiply, x5)\n    x15 = apply(x14, x11)\n    x16 = pair(x13, x15)\n    x17 = rbind(add, x6)\n    x18 = apply(invert, x16)\n    x19 = apply(x17, x18)\n    x20 = rbind(add, x7)\n    x21 = apply(x20, x16)\n    x22 = pair(x19, x21)\n    x23 = mapply(box, x22)\n    x24 = fill(I, x0, x23)\n    return x24\n\n",
    "annotated": "def verify_5c2c9af4(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all cells of the background color (effectively the negative space)\n    x1 = ofcolor(I, x0)\n    \n    # Calculate the height of the negative space\n    x2 = height(x1)\n    \n    # Calculate half of the height (used for vertical expansion)\n    x3 = halve(x2)\n    \n    # Calculate the width of the negative space\n    x4 = width(x1)\n    \n    # Calculate half of the width (used for horizontal expansion)\n    x5 = halve(x4)\n    \n    # Find the upper-left corner of the foreground shape\n    x6 = ulcorner(x1)\n    \n    # Find the lower-right corner of the foreground shape\n    x7 = lrcorner(x1)\n    \n    # Get the dimensions of the input grid\n    x8 = shape(I)\n    \n    # Find the maximum dimension of the input grid\n    x9 = maximum(x8)\n    \n    # Calculate 30 (maximum possible grid size)\n    x10 = multiply(THREE, TEN)\n    \n    # Create a range from 0 to 30\n    x11 = interval(ZERO, x10, ONE)\n    \n    # Create a function to multiply by half the height\n    x12 = rbind(multiply, x3)\n    \n    # Apply this function to the range, creating vertical expansion steps\n    x13 = apply(x12, x11)\n    \n    # Create a function to multiply by half the width\n    x14 = rbind(multiply, x5)\n    \n    # Apply this function to the range, creating horizontal expansion steps\n    x15 = apply(x14, x11)\n    \n    # Pair the vertical and horizontal expansion steps\n    x16 = pair(x13, x15)\n    \n    # Create a function to add to the upper-left corner\n    x17 = rbind(add, x6)\n    \n    # Invert the expansion steps (for upper-left corner calculation)\n    x18 = apply(invert, x16)\n    \n    # Calculate all possible upper-left corners during expansion\n    x19 = apply(x17, x18)\n    \n    # Create a function to add to the lower-right corner\n    x20 = rbind(add, x7)\n    \n    # Calculate all possible lower-right corners during expansion\n    x21 = apply(x20, x16)\n    \n    # Pair the upper-left and lower-right corners\n    x22 = pair(x19, x21)\n    \n    # Generate box outlines for all expansion steps\n    x23 = mapply(box, x22)\n    \n    # Fill these box outlines with the background color on the input grid\n    # This effectively creates the expanding box pattern\n    x24 = fill(I, x0, x23)\n    \n    # Return the final grid with the expanding box pattern\n    return x24\n"
  },
  "5daaa586": {
    "original": "def verify_5daaa586(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, F, F)\n    x2 = colorfilter(x1, x0)\n    x3 = rbind(bordering, I)\n    x4 = compose(flip, x3)\n    x5 = mfilter(x2, x4)\n    x6 = outbox(x5)\n    x7 = subgrid(x6, I)\n    x8 = trim(x7)\n    x9 = palette(x8)\n    x10 = matcher(identity, x0)\n    x11 = argmin(x9, x10)\n    x12 = trim(x7)\n    x13 = ofcolor(x12, x11)\n    x14 = shift(x13, UNITY)\n    x15 = ofcolor(x7, x11)\n    x16 = difference(x15, x14)\n    x17 = compose(first, first)\n    x18 = compose(first, last)\n    x19 = fork(equality, x17, x18)\n    x20 = compose(last, first)\n    x21 = compose(last, last)\n    x22 = fork(equality, x20, x21)\n    x23 = fork(either, x19, x22)\n    x24 = product(x14, x16)\n    x25 = sfilter(x24, x23)\n    x26 = fork(connect, first, last)\n    x27 = mapply(x26, x25)\n    x28 = fill(x7, x11, x27)\n    return x28\n\n",
    "annotated": "def verify_5daaa586(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Identify all objects in the grid, considering diagonal connections and ignoring the background\n    x1 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those of the background color\n    x2 = colorfilter(x1, x0)\n    \n    # Create a function that checks if an object is bordering the grid\n    x3 = rbind(bordering, I)\n    \n    # Create a function that checks if an object is NOT bordering the grid\n    x4 = compose(flip, x3)\n    \n    # Filter objects to keep only those not bordering the grid (inner objects)\n    x5 = mfilter(x2, x4)\n    \n    # Get the outbox (bounding box) of the inner objects\n    x6 = outbox(x5)\n    \n    # Extract the subgrid defined by the outbox\n    x7 = subgrid(x6, I)\n    \n    # Remove the outer border of the subgrid\n    x8 = trim(x7)\n    \n    # Get the set of colors used in the trimmed subgrid\n    x9 = palette(x8)\n    \n    # Create a function that checks if a color matches the background color\n    x10 = matcher(identity, x0)\n    \n    # Find the color in the palette that's closest to (but not) the background color\n    x11 = argmin(x9, x10)\n    \n    # Remove the outer border of the subgrid (again, possibly for consistency)\n    x12 = trim(x7)\n    \n    # Find all cells of the closest-to-background color in the trimmed subgrid\n    x13 = ofcolor(x12, x11)\n    \n    # Shift these cells down and right by 1\n    x14 = shift(x13, UNITY)\n    \n    # Find all cells of the closest-to-background color in the original subgrid\n    x15 = ofcolor(x7, x11)\n    \n    # Find cells that are in x15 but not in x14 (potential start points for lines)\n    x16 = difference(x15, x14)\n    \n    # Create functions to compare row indices\n    x17 = compose(first, first)\n    x18 = compose(first, last)\n    x19 = fork(equality, x17, x18)\n    \n    # Create functions to compare column indices\n    x20 = compose(last, first)\n    x21 = compose(last, last)\n    x22 = fork(equality, x20, x21)\n    \n    # Create a function that checks if two points are in the same row or column\n    x23 = fork(either, x19, x22)\n    \n    # Create all possible pairs of points from x14 and x16\n    x24 = product(x14, x16)\n    \n    # Filter pairs to keep only those in the same row or column\n    x25 = sfilter(x24, x23)\n    \n    # Create a function to connect two points\n    x26 = fork(connect, first, last)\n    \n    # Connect all pairs of points, creating lines\n    x27 = mapply(x26, x25)\n    \n    # Fill the subgrid with the closest-to-background color along these lines\n    x28 = fill(x7, x11, x27)\n    \n    # Return the modified subgrid as the output\n    return x28\n"
  },
  "60b61512": {
    "original": "def verify_60b61512(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = mapply(delta, x0)\n    x2 = fill(I, SEVEN, x1)\n    return x2\n\n",
    "annotated": "def verify_60b61512(I: Grid) -> Grid:\n    # Find all objects in the input grid I\n    # T, T, T parameters mean: univalued=True, diagonal=True, without_bg=True\n    # This identifies distinct color regions as separate objects\n    x0 = objects(I, T, T, T)\n\n    # For each object, find the cells in its bounding box that are not part of the object\n    # This effectively finds the 'outline' or 'surrounding' of each object\n    x1 = mapply(delta, x0)\n\n    # Fill these 'outline' cells with the color 7 (SEVEN)\n    # This creates a border around each object in the original input\n    x2 = fill(I, SEVEN, x1)\n\n    # Return the modified grid\n    # The result is the input grid with color 7 borders added around each object\n    return x2\n"
  },
  "6150a2bd": {
    "original": "def verify_6150a2bd(I: Grid) -> Grid:\n    x0 = rot180(I)\n    return x0\n\n",
    "annotated": "def verify_6150a2bd(I: Grid) -> Grid:\n    # Rotate the input grid 180 degrees\n    # This effectively flips the grid both horizontally and vertically\n    x0 = rot180(I)\n    \n    # Return the rotated grid as the output\n    # This completes the transformation by returning the flipped version of the input\n    return x0\n"
  },
  "623ea044": {
    "original": "def verify_623ea044(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = rbind(shoot, UNITY)\n    x3 = rbind(shoot, NEG_UNITY)\n    x4 = fork(combine, x2, x3)\n    x5 = rbind(shoot, UP_RIGHT)\n    x6 = rbind(shoot, DOWN_LEFT)\n    x7 = fork(combine, x5, x6)\n    x8 = fork(combine, x4, x7)\n    x9 = mapply(x8, x1)\n    x10 = fill(I, x0, x9)\n    return x10\n\n",
    "annotated": "def verify_623ea044(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get the indices of all cells with the background color\n    x1 = ofcolor(I, x0)\n    \n    # Create a function that shoots a line in the down-right direction\n    x2 = rbind(shoot, UNITY)\n    \n    # Create a function that shoots a line in the up-left direction\n    x3 = rbind(shoot, NEG_UNITY)\n    \n    # Combine the down-right and up-left shooting functions\n    # This will create lines in both directions from a given point\n    x4 = fork(combine, x2, x3)\n    \n    # Create a function that shoots a line in the up-right direction\n    x5 = rbind(shoot, UP_RIGHT)\n    \n    # Create a function that shoots a line in the down-left direction\n    x6 = rbind(shoot, DOWN_LEFT)\n    \n    # Combine the up-right and down-left shooting functions\n    # This will create lines in both diagonal directions from a given point\n    x7 = fork(combine, x5, x6)\n    \n    # Combine all four shooting functions (up-right, down-left, down-right, up-left)\n    # This will create lines in all four diagonal directions from a given point\n    x8 = fork(combine, x4, x7)\n    \n    # Apply the combined shooting function to all background color cells\n    # This creates lines from all background color cells in all four diagonal directions\n    x9 = mapply(x8, x1)\n    \n    # Fill the input grid with the background color in all cells where lines were drawn\n    # This effectively draws the lines on the grid\n    x10 = fill(I, x0, x9)\n    \n    # Return the modified grid with diagonal lines drawn from all background color cells\n    return x10\n"
  },
  "62c24649": {
    "original": "def verify_62c24649(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(I, x0)\n    x2 = hmirror(x1)\n    x3 = vconcat(x1, x2)\n    return x3\n\n",
    "annotated": "def verify_62c24649(I: Grid) -> Grid:\n    # Create a vertical mirror image of the input grid I\n    # This flips the grid left to right\n    x0 = vmirror(I)\n    \n    # Concatenate the original grid I with its vertical mirror x0 horizontally\n    # This creates the top half of the final grid\n    x1 = hconcat(I, x0)\n    \n    # Create a horizontal mirror image of x1\n    # This flips the top half upside down to create the bottom half\n    x2 = hmirror(x1)\n    \n    # Concatenate the top half (x1) with the bottom half (x2) vertically\n    # This creates the final 2x2 grid where:\n    #   - Top-left is the original input\n    #   - Top-right is the vertical mirror of the input\n    #   - Bottom-left is the horizontal mirror of the input\n    #   - Bottom-right is both vertically and horizontally mirrored\n    x3 = vconcat(x1, x2)\n    \n    # Return the final transformed grid\n    return x3\n"
  },
  "63613498": {
    "original": "def verify_63613498(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = mostcolor(I)\n    x2 = fork(add, height, width)\n    x3 = compose(decrement, x2)\n    x4 = fork(equality, x3, size)\n    x5 = rbind(bordering, I)\n    x6 = fork(both, x4, x5)\n    x7 = rbind(toobject, I)\n    x8 = chain(numcolors, x7, delta)\n    x9 = matcher(x8, TWO)\n    x10 = fork(both, x6, x9)\n    x11 = sfilter(x0, x10)\n    x12 = argmax(x11, size)\n    x13 = delta(x12)\n    x14 = toobject(x13, I)\n    x15 = matcher(first, x1)\n    x16 = compose(flip, x15)\n    x17 = sfilter(x14, x16)\n    x18 = normalize(x17)\n    x19 = toindices(x18)\n    x20 = compose(toindices, normalize)\n    x21 = matcher(x20, x19)\n    x22 = remove(x17, x0)\n    x23 = argmax(x22, x21)\n    x24 = color(x12)\n    x25 = fill(I, x24, x23)\n    return x25\n\n",
    "annotated": "def verify_63613498(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Determine the most common color in the input grid (likely the background color)\n    x1 = mostcolor(I)\n    \n    # Create a function that adds the height and width of an object\n    x2 = fork(add, height, width)\n    \n    # Create a function that decrements the sum of height and width by 1\n    x3 = compose(decrement, x2)\n    \n    # Create a function that checks if an object's size equals its height plus width minus 1\n    # This identifies objects that form an L-shape or similar\n    x4 = fork(equality, x3, size)\n    \n    # Create a function that checks if an object is bordering the edge of the input grid\n    x5 = rbind(bordering, I)\n    \n    # Combine the L-shape check and the bordering check\n    x6 = fork(both, x4, x5)\n    \n    # Create a function that converts a patch to an object based on the input grid\n    x7 = rbind(toobject, I)\n    \n    # Create a function that counts the number of colors in the delta (outline) of an object\n    x8 = chain(numcolors, x7, delta)\n    \n    # Create a function that checks if the delta of an object has exactly two colors\n    x9 = matcher(x8, TWO)\n    \n    # Combine all the checks: L-shape, bordering, and two-color delta\n    x10 = fork(both, x6, x9)\n    \n    # Filter the objects to keep only those that satisfy all the conditions\n    x11 = sfilter(x0, x10)\n    \n    # Find the largest object among the filtered objects (likely the separator)\n    x12 = argmax(x11, size)\n    \n    # Get the delta (outline) of the separator object\n    x13 = delta(x12)\n    \n    # Convert the delta to an object based on the input grid\n    x14 = toobject(x13, I)\n    \n    # Create a function that checks if a cell's color is not the background color\n    x15 = matcher(first, x1)\n    x16 = compose(flip, x15)\n    \n    # Filter the delta object to keep only non-background colored cells\n    x17 = sfilter(x14, x16)\n    \n    # Normalize the filtered delta object (move it to the origin)\n    x18 = normalize(x17)\n    \n    # Get the indices of the normalized delta object\n    x19 = toindices(x18)\n    \n    # Create a function that normalizes an object and returns its indices\n    x20 = compose(toindices, normalize)\n    \n    # Create a function that checks if an object matches the normalized delta shape\n    x21 = matcher(x20, x19)\n    \n    # Remove the separator object from the set of all objects\n    x22 = remove(x17, x0)\n    \n    # Find the object that best matches the normalized delta shape\n    x23 = argmax(x22, x21)\n    \n    # Get the color of the separator object\n    x24 = color(x12)\n    \n    # Fill the matching object with the separator color in the input grid\n    # This effectively replaces one object with the separator pattern\n    x25 = fill(I, x24, x23)\n    \n    # Return the modified grid as the output\n    return x25\n"
  },
  "6430c8c4": {
    "original": "def verify_6430c8c4(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, tophalf, lefthalf)\n    x5 = branch(x3, bottomhalf, righthalf)\n    x6 = x4(I)\n    x7 = x5(I)\n    x8 = shape(x6)\n    x9 = palette(x6)\n    x10 = palette(x7)\n    x11 = intersection(x9, x10)\n    x12 = first(x11)\n    x13 = ofcolor(x6, x12)\n    x14 = ofcolor(x7, x12)\n    x15 = intersection(x13, x14)\n    x16 = canvas(x12, x8)\n    x17 = fill(x16, THREE, x15)\n    return x17\n\n",
    "annotated": "def verify_6430c8c4(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out only the horizontal frontiers\n    x1 = sfilter(x0, hline)\n    # Count the number of horizontal frontiers\n    x2 = size(x1)\n    # Check if there are any horizontal frontiers\n    x3 = positive(x2)\n    # If there are horizontal frontiers, use tophalf function, else use lefthalf\n    # This determines which half of the grid to process first\n    x4 = branch(x3, tophalf, lefthalf)\n    # If there are horizontal frontiers, use bottomhalf function, else use righthalf\n    # This determines which half of the grid to process second\n    x5 = branch(x3, bottomhalf, righthalf)\n    # Apply the chosen function (top/left half) to the input grid\n    x6 = x4(I)\n    # Apply the chosen function (bottom/right half) to the input grid\n    x7 = x5(I)\n    # Get the dimensions of the first half\n    x8 = shape(x6)\n    # Get the set of colors used in the first half\n    x9 = palette(x6)\n    # Get the set of colors used in the second half\n    x10 = palette(x7)\n    # Find the colors that appear in both halves\n    x11 = intersection(x9, x10)\n    # Get the first (and likely only) color that appears in both halves\n    # This is probably the background color\n    x12 = first(x11)\n    # Find all cells in the first half that have the background color\n    x13 = ofcolor(x6, x12)\n    # Find all cells in the second half that have the background color\n    x14 = ofcolor(x7, x12)\n    # Find the cells that have the background color in both halves\n    # These are the cells that weren't changed in either half\n    x15 = intersection(x13, x14)\n    # Create a new grid with the same dimensions as the first half, filled with the background color\n    x16 = canvas(x12, x8)\n    # Fill the cells that weren't changed in either half with color 3\n    # This highlights the cells that remained unchanged across both halves\n    x17 = fill(x16, THREE, x15)\n    # Return the resulting grid, showing unchanged cells in color 3 and the rest in the background color\n    return x17\n"
  },
  "6455b5f5": {
    "original": "def verify_6455b5f5(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = asindices(I)\n    x2 = corners(x1)\n    x3 = toobject(x2, I)\n    x4 = mostcolor(x3)\n    x5 = colorfilter(x0, x4)\n    x6 = valmax(x5, size)\n    x7 = valmin(x5, size)\n    x8 = sizefilter(x5, x6)\n    x9 = sizefilter(x5, x7)\n    x10 = merge(x8)\n    x11 = fill(I, ONE, x10)\n    x12 = merge(x9)\n    x13 = fill(x11, EIGHT, x12)\n    return x13\n\n",
    "annotated": "def verify_6455b5f5(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections but not background\n    x0 = objects(I, T, F, F)\n    \n    # Get all indices of the input grid\n    x1 = asindices(I)\n    \n    # Find the corner indices of the grid\n    x2 = corners(x1)\n    \n    # Create an object from the corner indices, using colors from the input grid\n    x3 = toobject(x2, I)\n    \n    # Find the most common color in the corner object (likely the background color)\n    x4 = mostcolor(x3)\n    \n    # Filter objects to keep only those with the background color\n    x5 = colorfilter(x0, x4)\n    \n    # Find the size of the largest background-colored object\n    x6 = valmax(x5, size)\n    \n    # Find the size of the smallest background-colored object\n    x7 = valmin(x5, size)\n    \n    # Filter objects to keep only the largest background-colored objects\n    x8 = sizefilter(x5, x6)\n    \n    # Filter objects to keep only the smallest background-colored objects\n    x9 = sizefilter(x5, x7)\n    \n    # Merge all largest background-colored objects into a single set of indices\n    x10 = merge(x8)\n    \n    # Fill the largest background-colored areas with color 1 (dark blue)\n    x11 = fill(I, ONE, x10)\n    \n    # Merge all smallest background-colored objects into a single set of indices\n    x12 = merge(x9)\n    \n    # Fill the smallest background-colored areas with color 8 (light blue)\n    # This creates the final output grid\n    x13 = fill(x11, EIGHT, x12)\n    \n    # Return the final transformed grid\n    return x13\n"
  },
  "662c240a": {
    "original": "def verify_662c240a(I: Grid) -> Grid:\n    x0 = portrait(I)\n    x1 = branch(x0, vsplit, hsplit)\n    x2 = shape(I)\n    x3 = maximum(x2)\n    x4 = minimum(x2)\n    x5 = divide(x3, x4)\n    x6 = x1(I, x5)\n    x7 = fork(equality, identity, dmirror)\n    x8 = compose(flip, x7)\n    x9 = extract(x6, x8)\n    return x9\n\n",
    "annotated": "def verify_662c240a(I: Grid) -> Grid:\n    # Check if the input grid is taller than it is wide\n    x0 = portrait(I)\n    \n    # Choose vsplit if the grid is portrait, otherwise hsplit\n    # This determines how we'll split the grid into subgrids\n    x1 = branch(x0, vsplit, hsplit)\n    \n    # Get the dimensions (height, width) of the input grid\n    x2 = shape(I)\n    \n    # Find the larger dimension of the grid\n    x3 = maximum(x2)\n    \n    # Find the smaller dimension of the grid\n    x4 = minimum(x2)\n    \n    # Calculate how many times the larger dimension is bigger than the smaller one\n    # This gives us the number of subgrids\n    x5 = divide(x3, x4)\n    \n    # Split the input grid into subgrids based on orientation and calculated ratio\n    x6 = x1(I, x5)\n    \n    # Create a function that checks if a grid is equal to its diagonal mirror\n    # This identifies symmetric grids\n    x7 = fork(equality, identity, dmirror)\n    \n    # Invert the result of the symmetry check\n    # This identifies asymmetric grids\n    x8 = compose(flip, x7)\n    \n    # Extract the first subgrid that is asymmetric\n    # This is the original grid before concatenation in the generator\n    x9 = extract(x6, x8)\n    \n    # Return the extracted original grid\n    return x9\n"
  },
  "67385a82": {
    "original": "def verify_67385a82(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = palette(I)\n    x2 = other(x1, ZERO)\n    x3 = colorfilter(x0, x2)\n    x4 = sizefilter(x3, ONE)\n    x5 = difference(x3, x4)\n    x6 = merge(x5)\n    x7 = fill(I, EIGHT, x6)\n    return x7\n\n",
    "annotated": "def verify_67385a82(I: Grid) -> Grid:\n    # Identify all objects in the input grid (considering 4-connected cells of the same color)\n    x0 = objects(I, T, F, F)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Find the non-zero color in the grid (assumes there's only one non-zero color)\n    x2 = other(x1, ZERO)\n    \n    # Filter objects to keep only those of the non-zero color\n    x3 = colorfilter(x0, x2)\n    \n    # Find all single-cell objects of the non-zero color\n    x4 = sizefilter(x3, ONE)\n    \n    # Remove single-cell objects from the set of non-zero color objects\n    # This leaves us with multi-cell objects of the non-zero color\n    x5 = difference(x3, x4)\n    \n    # Merge all multi-cell objects into a single set of cells\n    x6 = merge(x5)\n    \n    # Create the output grid by filling the multi-cell object cells with color 8\n    # This effectively \"outlines\" the larger objects while leaving single-cell objects unchanged\n    x7 = fill(I, EIGHT, x6)\n    \n    # Return the modified grid\n    return x7\n"
  },
  "673ef223": {
    "original": "def verify_673ef223(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = merge(x0)\n    x2 = palette(x1)\n    x3 = lbind(colorfilter, x0)\n    x4 = compose(size, x3)\n    x5 = matcher(x4, TWO)\n    x6 = asindices(I)\n    x7 = box(x6)\n    x8 = rbind(difference, x7)\n    x9 = lbind(ofcolor, I)\n    x10 = chain(size, x8, x9)\n    x11 = matcher(x10, ZERO)\n    x12 = rbind(greater, ONE)\n    x13 = lbind(apply, size)\n    x14 = lbind(colorfilter, x0)\n    x15 = compose(x13, x14)\n    x16 = chain(x12, minimum, x15)\n    x17 = fork(both, x11, x16)\n    x18 = fork(both, x5, x17)\n    x19 = extract(x2, x18)\n    x20 = other(x2, x19)\n    x21 = ofcolor(I, x20)\n    x22 = colorfilter(x0, x19)\n    x23 = rbind(vmatching, x21)\n    x24 = rbind(hmatching, x21)\n    x25 = fork(either, x23, x24)\n    x26 = extract(x22, x25)\n    x27 = other(x22, x26)\n    x28 = rbind(gravitate, x26)\n    x29 = compose(x28, initset)\n    x30 = fork(add, identity, x29)\n    x31 = fork(connect, identity, x30)\n    x32 = mapply(x31, x21)\n    x33 = fill(I, x20, x32)\n    x34 = fill(x33, FOUR, x21)\n    x35 = ofcolor(I, x19)\n    x36 = apply(first, x35)\n    x37 = size(x36)\n    x38 = apply(last, x35)\n    x39 = size(x38)\n    x40 = greater(x37, x39)\n    x41 = compose(toivec, first)\n    x42 = compose(tojvec, last)\n    x43 = branch(x40, x41, x42)\n    x44 = branch(x40, hfrontier, vfrontier)\n    x45 = ulcorner(x26)\n    x46 = ulcorner(x27)\n    x47 = subtract(x46, x45)\n    x48 = x43(x47)\n    x49 = shift(x21, x48)\n    x50 = mapply(x44, x49)\n    x51 = fill(x34, x20, x50)\n    x52 = fill(x51, x19, x35)\n    return x52\n\n",
    "annotated": "def verify_673ef223(I: Grid) -> Grid:\n    # Identify all objects in the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    \n    # Merge all identified objects into a single set\n    x1 = merge(x0)\n    \n    # Get the palette (unique colors) of the merged objects\n    x2 = palette(x1)\n    \n    # Create a function to filter objects by color\n    x3 = lbind(colorfilter, x0)\n    \n    # Create a function to get the size of color-filtered objects\n    x4 = compose(size, x3)\n    \n    # Create a function to check if the size of color-filtered objects is TWO\n    x5 = matcher(x4, TWO)\n    \n    # Get all indices of the input grid\n    x6 = asindices(I)\n    \n    # Get the bounding box of the entire grid\n    x7 = box(x6)\n    \n    # Create a function to get the difference between the bounding box and a color's indices\n    x8 = rbind(difference, x7)\n    \n    # Create a function to get indices of a specific color in the input grid\n    x9 = lbind(ofcolor, I)\n    \n    # Create a function to check if a color doesn't touch the grid border\n    x10 = chain(size, x8, x9)\n    \n    # Create a function to check if the result of x10 is ZERO (color touches the border)\n    x11 = matcher(x10, ZERO)\n    \n    # Create a function to check if a value is greater than ONE\n    x12 = rbind(greater, ONE)\n    \n    # Create a function to apply the size function\n    x13 = lbind(apply, size)\n    \n    # Create a function to filter objects by color\n    x14 = lbind(colorfilter, x0)\n    \n    # Create a function to get sizes of color-filtered objects\n    x15 = compose(x13, x14)\n    \n    # Create a function to check if the minimum size of color-filtered objects is greater than ONE\n    x16 = chain(x12, minimum, x15)\n    \n    # Create a function to check if a color touches the border and has objects larger than one cell\n    x17 = fork(both, x11, x16)\n    \n    # Create a function to check if a color has exactly two objects and satisfies x17\n    x18 = fork(both, x5, x17)\n    \n    # Extract the color that satisfies condition x18 (likely the bar color)\n    x19 = extract(x2, x18)\n    \n    # Get the other color from the palette (likely the dot color)\n    x20 = other(x2, x19)\n    \n    # Get indices of the dot color in the input grid\n    x21 = ofcolor(I, x20)\n    \n    # Filter objects to get the two bar objects\n    x22 = colorfilter(x0, x19)\n    \n    # Create a function to check if an object vertically matches the dot positions\n    x23 = rbind(vmatching, x21)\n    \n    # Create a function to check if an object horizontally matches the dot positions\n    x24 = rbind(hmatching, x21)\n    \n    # Create a function to check if an object matches dot positions either vertically or horizontally\n    x25 = fork(either, x23, x24)\n    \n    # Extract the bar object that matches the dot positions (source bar)\n    x26 = extract(x22, x25)\n    \n    # Get the other bar object (target bar)\n    x27 = other(x22, x26)\n    \n    # Create a function to find the gravitation direction from x26 to another object\n    x28 = rbind(gravitate, x26)\n    \n    # Create a function to initialize a set and find its gravitation direction\n    x29 = compose(x28, initset)\n    \n    # Create a function to add the original position and the gravitation direction\n    x30 = fork(add, identity, x29)\n    \n    # Create a function to connect the original position to the new position\n    x31 = fork(connect, identity, x30)\n    \n    # Apply x31 to all dot positions, creating paths for the dots\n    x32 = mapply(x31, x21)\n    \n    # Fill the paths with the dot color, creating trails\n    x33 = fill(I, x20, x32)\n    \n    # Place color 4 dots at the original dot positions\n    x34 = fill(x33, FOUR, x21)\n    \n    # Get the indices of the bar color in the input grid\n    x35 = ofcolor(I, x19)\n    \n    # Get the first row of the bar color indices\n    x36 = apply(first, x35)\n    \n    # Get the size (length) of the first row\n    x37 = size(x36)\n    \n    # Get the last row of the bar color indices\n    x38 = apply(last, x35)\n    \n    # Get the size (length) of the last row\n    x39 = size(x38)\n    \n    # Check if the first row is longer than the last row\n    x40 = greater(x37, x39)\n    \n    # Create a function to get a vertical vector from the first element\n    x41 = compose(toivec, first)\n    \n    # Create a function to get a horizontal vector from the last element\n    x42 = compose(tojvec, last)\n    \n    # Choose between vertical and horizontal vector based on x40\n    x43 = branch(x40, x41, x42)\n    \n    # Choose between horizontal and vertical frontier based on x40\n    x44 = branch(x40, hfrontier, vfrontier)\n    \n    # Get the upper-left corner of the source bar\n    x45 = ulcorner(x26)\n    \n    # Get the upper-left corner of the target bar\n    x46 = ulcorner(x27)\n    \n    # Calculate the offset between the source and target bars\n    x47 = subtract(x46, x45)\n    \n    # Apply x43 to get the movement vector\n    x48 = x43(x47)\n    \n    # Shift the dot positions by the movement vector\n    x49 = shift(x21, x48)\n    \n    # Create frontiers for the shifted dot positions\n    x50 = mapply(x44, x49)\n    \n    # Fill the frontiers with the dot color\n    x51 = fill(x34, x20, x50)\n    \n    # Restore the original bar positions\n    x52 = fill(x51, x19, x35)\n    \n    # Return the final transformed grid\n    return x52\n"
  },
  "6773b310": {
    "original": "def verify_6773b310(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = shape(I)\n    x4 = canvas(x2, x3)\n    x5 = hconcat(I, x4)\n    x6 = palette(I)\n    x7 = remove(x2, x6)\n    x8 = lbind(colorcount, I)\n    x9 = argmin(x7, x8)\n    x10 = other(x7, x9)\n    x11 = objects(x5, F, T, T)\n    x12 = rbind(colorcount, x9)\n    x13 = valmax(x11, x12)\n    x14 = rbind(colorcount, x9)\n    x15 = matcher(x14, x13)\n    x16 = sfilter(x11, x15)\n    x17 = apply(ulcorner, x16)\n    x18 = first(x11)\n    x19 = shape(x18)\n    x20 = increment(x19)\n    x21 = rbind(divide, x20)\n    x22 = apply(x21, x17)\n    x23 = sfilter(x0, hline)\n    x24 = size(x23)\n    x25 = sfilter(x0, vline)\n    x26 = size(x25)\n    x27 = astuple(x24, x26)\n    x28 = increment(x27)\n    x29 = canvas(x10, x28)\n    x30 = fill(x29, ONE, x22)\n    return x30\n\n",
    "annotated": "def verify_6773b310(I: Grid) -> Grid:\n    # Extract all frontiers (horizontal and vertical lines) from the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Get the color of the merged frontiers (line color)\n    x2 = color(x1)\n    \n    # Get the shape (dimensions) of the input grid\n    x3 = shape(I)\n    \n    # Create a canvas with the same size as input, filled with line color\n    x4 = canvas(x2, x3)\n    \n    # Concatenate the input grid and the line-colored canvas horizontally\n    x5 = hconcat(I, x4)\n    \n    # Get the palette (set of colors) used in the input grid\n    x6 = palette(I)\n    \n    # Remove the line color from the palette\n    x7 = remove(x2, x6)\n    \n    # Create a function that counts occurrences of a color in the input grid\n    x8 = lbind(colorcount, I)\n    \n    # Find the color with the least occurrences (background color)\n    x9 = argmin(x7, x8)\n    \n    # Get the other color (foreground color)\n    x10 = other(x7, x9)\n    \n    # Extract objects from the concatenated grid, allowing diagonal connections\n    x11 = objects(x5, F, T, T)\n    \n    # Create a function that counts occurrences of the background color\n    x12 = rbind(colorcount, x9)\n    \n    # Find the maximum count of background color in any object\n    x13 = valmax(x11, x12)\n    \n    # Create another function that counts occurrences of the background color\n    x14 = rbind(colorcount, x9)\n    \n    # Create a function that checks if an object has the maximum background count\n    x15 = matcher(x14, x13)\n    \n    # Filter objects to keep only those with the maximum background count\n    x16 = sfilter(x11, x15)\n    \n    # Get the upper-left corners of the filtered objects\n    x17 = apply(ulcorner, x16)\n    \n    # Get the first object from all objects\n    x18 = first(x11)\n    \n    # Get the shape (dimensions) of this object\n    x19 = shape(x18)\n    \n    # Increment the shape (add 1 to both dimensions)\n    x20 = increment(x19)\n    \n    # Create a function that divides by the incremented shape\n    x21 = rbind(divide, x20)\n    \n    # Apply this division to all upper-left corners\n    x22 = apply(x21, x17)\n    \n    # Filter frontiers to keep only horizontal lines\n    x23 = sfilter(x0, hline)\n    \n    # Count the number of horizontal lines\n    x24 = size(x23)\n    \n    # Filter frontiers to keep only vertical lines\n    x25 = sfilter(x0, vline)\n    \n    # Count the number of vertical lines\n    x26 = size(x25)\n    \n    # Create a tuple of horizontal and vertical line counts\n    x27 = astuple(x24, x26)\n    \n    # Increment both counts (add 1 to both)\n    x28 = increment(x27)\n    \n    # Create a canvas with foreground color and size based on line counts\n    x29 = canvas(x10, x28)\n    \n    # Fill the canvas with 1's at the calculated positions\n    # This creates the final output grid where 1's represent detected patterns\n    x30 = fill(x29, ONE, x22)\n    \n    # Return the final output grid\n    return x30\n"
  },
  "67a3c6ac": {
    "original": "def verify_67a3c6ac(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    return x0\n\n",
    "annotated": "def verify_67a3c6ac(I: Grid) -> Grid:\n    # Mirror the input grid I vertically\n    # This creates a new grid where each row is reversed left-to-right\n    x0 = vmirror(I)\n    \n    # Return the mirrored grid\n    # This is the solution to the ARC task: a vertical mirror image of the input\n    return x0\n"
  },
  "67a423a3": {
    "original": "def verify_67a423a3(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = totuple(x2)\n    x4 = first(x3)\n    x5 = last(x3)\n    x6 = ofcolor(I, x4)\n    x7 = backdrop(x6)\n    x8 = ofcolor(I, x5)\n    x9 = backdrop(x8)\n    x10 = intersection(x7, x9)\n    x11 = outbox(x10)\n    x12 = fill(I, FOUR, x11)\n    return x12\n\n",
    "annotated": "def verify_67a423a3(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Remove the background color from the set of colors, leaving only the line colors\n    x2 = remove(x0, x1)\n    \n    # Convert the set of line colors to a tuple\n    x3 = totuple(x2)\n    \n    # Get the first line color (horizontal lines)\n    x4 = first(x3)\n    \n    # Get the second line color (vertical lines)\n    x5 = last(x3)\n    \n    # Find all cells in the input grid that have the first line color (horizontal lines)\n    x6 = ofcolor(I, x4)\n    \n    # Create a bounding box around the horizontal lines\n    x7 = backdrop(x6)\n    \n    # Find all cells in the input grid that have the second line color (vertical lines)\n    x8 = ofcolor(I, x5)\n    \n    # Create a bounding box around the vertical lines\n    x9 = backdrop(x8)\n    \n    # Find the intersection of the horizontal and vertical line bounding boxes\n    # This represents the area where the lines cross\n    x10 = intersection(x7, x9)\n    \n    # Create an outer box around the intersection area\n    # This forms the border that will be filled with color 4\n    x11 = outbox(x10)\n    \n    # Fill the outer box with color 4 on the input grid\n    # This creates the final output by adding a border around the intersection of lines\n    x12 = fill(I, FOUR, x11)\n    \n    # Return the modified grid as the output\n    return x12\n"
  },
  "67e8384a": {
    "original": "def verify_67e8384a(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(I, x0)\n    x2 = hmirror(x1)\n    x3 = vconcat(x1, x2)\n    return x3\n\n",
    "annotated": "def verify_67e8384a(I: Grid) -> Grid:\n    # Create a vertical mirror image of the input grid\n    # This flips the input grid left to right\n    x0 = vmirror(I)\n\n    # Horizontally concatenate the original input with its vertical mirror\n    # This doubles the width of the grid, creating left-right symmetry\n    x1 = hconcat(I, x0)\n\n    # Create a horizontal mirror image of the concatenated grid\n    # This flips the wider grid top to bottom\n    x2 = hmirror(x1)\n\n    # Vertically concatenate the wide grid with its horizontal mirror\n    # This doubles the height, creating a grid with 4x the area of the input\n    # The result has both horizontal and vertical symmetry\n    x3 = vconcat(x1, x2)\n\n    # Return the final symmetrical grid, which is 4 times larger than the input\n    # and has perfect symmetry in all four quadrants\n    return x3\n"
  },
  "681b3aeb": {
    "original": "def verify_681b3aeb(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = totuple(x0)\n    x2 = first(x1)\n    x3 = normalize(x2)\n    x4 = last(x1)\n    x5 = normalize(x4)\n    x6 = color(x3)\n    x7 = color(x5)\n    x8 = toindices(x3)\n    x9 = toindices(x5)\n    x10 = fork(multiply, height, width)\n    x11 = fork(equality, size, x10)\n    x12 = lbind(shift, x8)\n    x13 = lbind(shift, x9)\n    x14 = compose(x12, first)\n    x15 = compose(x13, last)\n    x16 = fork(intersection, x14, x15)\n    x17 = compose(size, x16)\n    x18 = compose(x12, first)\n    x19 = compose(x13, last)\n    x20 = fork(combine, x18, x19)\n    x21 = compose(x11, x20)\n    x22 = matcher(x17, ZERO)\n    x23 = fork(both, x22, x21)\n    x24 = valmax(x1, height)\n    x25 = valmax(x1, width)\n    x26 = interval(ZERO, x24, ONE)\n    x27 = interval(ZERO, x25, ONE)\n    x28 = product(x26, x27)\n    x29 = product(x28, x28)\n    x30 = argmax(x29, x23)\n    x31 = first(x30)\n    x32 = shift(x8, x31)\n    x33 = last(x30)\n    x34 = shift(x9, x33)\n    x35 = combine(x32, x34)\n    x36 = shape(x35)\n    x37 = canvas(x7, x36)\n    x38 = ulcorner(x35)\n    x39 = invert(x38)\n    x40 = shift(x32, x39)\n    x41 = fill(x37, x6, x40)\n    return x41\n\n",
    "annotated": "def verify_681b3aeb(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring background\n    x0 = objects(I, T, T, T)\n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    # Get the first object (likely shape A)\n    x2 = first(x1)\n    # Normalize the first object (move it to origin)\n    x3 = normalize(x2)\n    # Get the last object (likely shape B)\n    x4 = last(x1)\n    # Normalize the last object (move it to origin)\n    x5 = normalize(x4)\n    # Get the color of the first normalized object (shape A)\n    x6 = color(x3)\n    # Get the color of the second normalized object (shape B)\n    x7 = color(x5)\n    # Get the indices of the first normalized object (shape A)\n    x8 = toindices(x3)\n    # Get the indices of the second normalized object (shape B)\n    x9 = toindices(x5)\n    # Create a function that multiplies height and width\n    x10 = fork(multiply, height, width)\n    # Create a function that checks if size equals height * width (rectangle check)\n    x11 = fork(equality, size, x10)\n    # Create a function to shift shape A\n    x12 = lbind(shift, x8)\n    # Create a function to shift shape B\n    x13 = lbind(shift, x9)\n    # Compose function to shift shape A by first element of a tuple\n    x14 = compose(x12, first)\n    # Compose function to shift shape B by last element of a tuple\n    x15 = compose(x13, last)\n    # Create function to find intersection of shifted shapes A and B\n    x16 = fork(intersection, x14, x15)\n    # Create function to get size of intersection\n    x17 = compose(size, x16)\n    # Compose function to shift shape A by first element of a tuple\n    x18 = compose(x12, first)\n    # Compose function to shift shape B by last element of a tuple\n    x19 = compose(x13, last)\n    # Create function to combine shifted shapes A and B\n    x20 = fork(combine, x18, x19)\n    # Create function to check if combined shape is a rectangle\n    x21 = compose(x11, x20)\n    # Create function to check if intersection size is zero\n    x22 = matcher(x17, ZERO)\n    # Create function to check if shapes don't overlap and form a rectangle\n    x23 = fork(both, x22, x21)\n    # Get maximum height of objects\n    x24 = valmax(x1, height)\n    # Get maximum width of objects\n    x25 = valmax(x1, width)\n    # Create range of integers from 0 to max height\n    x26 = interval(ZERO, x24, ONE)\n    # Create range of integers from 0 to max width\n    x27 = interval(ZERO, x25, ONE)\n    # Create all possible coordinates within the grid\n    x28 = product(x26, x27)\n    # Create all possible pairs of coordinates for both shapes\n    x29 = product(x28, x28)\n    # Find the best placement for both shapes (no overlap, forms rectangle)\n    x30 = argmax(x29, x23)\n    # Get the optimal placement for shape A\n    x31 = first(x30)\n    # Shift shape A to its optimal position\n    x32 = shift(x8, x31)\n    # Get the optimal placement for shape B\n    x33 = last(x30)\n    # Shift shape B to its optimal position\n    x34 = shift(x9, x33)\n    # Combine the optimally placed shapes A and B\n    x35 = combine(x32, x34)\n    # Get the dimensions of the combined shape\n    x36 = shape(x35)\n    # Create a canvas with the background color (color of shape B) and correct dimensions\n    x37 = canvas(x7, x36)\n    # Get the upper-left corner of the combined shape\n    x38 = ulcorner(x35)\n    # Invert the coordinates of the upper-left corner\n    x39 = invert(x38)\n    # Shift shape A to be positioned relative to the upper-left corner\n    x40 = shift(x32, x39)\n    # Fill the canvas with shape A using its color\n    x41 = fill(x37, x6, x40)\n    # Return the final output grid\n    return x41\n"
  },
  "6855a6e4": {
    "original": "def verify_6855a6e4(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(difference, toindices, box)\n    x2 = compose(size, x1)\n    x3 = matcher(x2, ZERO)\n    x4 = rbind(add, FOUR)\n    x5 = chain(x4, double, width)\n    x6 = fork(equality, size, x5)\n    x7 = chain(x4, double, height)\n    x8 = fork(equality, size, x7)\n    x9 = fork(either, x6, x8)\n    x10 = fork(both, x3, x9)\n    x11 = extract(x0, x10)\n    x12 = toindices(x11)\n    x13 = center(x11)\n    x14 = vfrontier(x13)\n    x15 = intersection(x12, x14)\n    x16 = size(x15)\n    x17 = positive(x16)\n    x18 = branch(x17, dmirror, identity)\n    x19 = x18(I)\n    x20 = color(x11)\n    x21 = palette(I)\n    x22 = remove(x20, x21)\n    x23 = lbind(colorcount, I)\n    x24 = argmin(x22, x23)\n    x25 = other(x22, x24)\n    x26 = ofcolor(x19, x24)\n    x27 = ofcolor(x19, x20)\n    x28 = leftmost(x27)\n    x29 = lbind(greater, x28)\n    x30 = compose(x29, last)\n    x31 = sfilter(x26, x30)\n    x32 = difference(x26, x31)\n    x33 = vmirror(x31)\n    x34 = leftmost(x27)\n    x35 = leftmost(x31)\n    x36 = subtract(x34, x35)\n    x37 = add(TWO, x36)\n    x38 = tojvec(x37)\n    x39 = shift(x33, x38)\n    x40 = vmirror(x32)\n    x41 = rightmost(x32)\n    x42 = rightmost(x27)\n    x43 = subtract(x41, x42)\n    x44 = add(TWO, x43)\n    x45 = tojvec(x44)\n    x46 = invert(x45)\n    x47 = shift(x40, x46)\n    x48 = fill(x19, x25, x26)\n    x49 = combine(x39, x47)\n    x50 = fill(x48, x24, x49)\n    x51 = x18(x50)\n    return x51\n\n",
    "annotated": "def verify_6855a6e4(I: Grid) -> Grid:\n    # Partition the input grid into objects\n    x0 = partition(I)\n    \n    # Create a function that finds the difference between all indices and the box outline\n    x1 = fork(difference, toindices, box)\n    \n    # Create a function that counts the number of cells in the difference\n    x2 = compose(size, x1)\n    \n    # Create a function that checks if the difference size is zero (object fills its bounding box)\n    x3 = matcher(x2, ZERO)\n    \n    # Create a function that adds 4 to a value\n    x4 = rbind(add, FOUR)\n    \n    # Create a function that doubles the width and adds 4\n    x5 = chain(x4, double, width)\n    \n    # Create a function that checks if the size equals doubled width plus 4\n    x6 = fork(equality, size, x5)\n    \n    # Create a function that doubles the height and adds 4\n    x7 = chain(x4, double, height)\n    \n    # Create a function that checks if the size equals doubled height plus 4\n    x8 = fork(equality, size, x7)\n    \n    # Create a function that checks if either width or height condition is met\n    x9 = fork(either, x6, x8)\n    \n    # Create a function that checks if both fill and size conditions are met\n    x10 = fork(both, x3, x9)\n    \n    # Extract the object that meets both conditions (the box)\n    x11 = extract(x0, x10)\n    \n    # Get the indices of the box\n    x12 = toindices(x11)\n    \n    # Find the center of the box\n    x13 = center(x11)\n    \n    # Create a vertical frontier at the center of the box\n    x14 = vfrontier(x13)\n    \n    # Find the intersection of the box and the vertical frontier (middle line)\n    x15 = intersection(x12, x14)\n    \n    # Count the number of cells in the middle line\n    x16 = size(x15)\n    \n    # Check if the middle line exists (size > 0)\n    x17 = positive(x16)\n    \n    # If middle line exists, prepare to mirror diagonally, else do nothing\n    x18 = branch(x17, dmirror, identity)\n    \n    # Apply the mirroring function to the input grid if necessary\n    x19 = x18(I)\n    \n    # Get the color of the box\n    x20 = color(x11)\n    \n    # Get all colors used in the input grid\n    x21 = palette(I)\n    \n    # Remove the box color from the palette\n    x22 = remove(x20, x21)\n    \n    # Create a function to count occurrences of a color in the input grid\n    x23 = lbind(colorcount, I)\n    \n    # Find the least common color (background)\n    x24 = argmin(x22, x23)\n    \n    # Find the other color (object color)\n    x25 = other(x22, x24)\n    \n    # Get all cells with background color\n    x26 = ofcolor(x19, x24)\n    \n    # Get all cells with box color\n    x27 = ofcolor(x19, x20)\n    \n    # Find the leftmost column of the box\n    x28 = leftmost(x27)\n    \n    # Create a function to check if a column is to the right of the box's left edge\n    x29 = lbind(greater, x28)\n    \n    # Create a function to get the rightmost column of an object\n    x30 = compose(x29, last)\n    \n    # Filter background cells to the right of the box's left edge\n    x31 = sfilter(x26, x30)\n    \n    # Get background cells to the left of the box's left edge\n    x32 = difference(x26, x31)\n    \n    # Mirror the right side background cells vertically\n    x33 = vmirror(x31)\n    \n    # Find the leftmost column of the box\n    x34 = leftmost(x27)\n    \n    # Find the leftmost column of the right side background\n    x35 = leftmost(x31)\n    \n    # Calculate the horizontal distance between box and right background\n    x36 = subtract(x34, x35)\n    \n    # Add 2 to the horizontal distance (for padding)\n    x37 = add(TWO, x36)\n    \n    # Create a horizontal vector for shifting\n    x38 = tojvec(x37)\n    \n    # Shift the mirrored right background to the left\n    x39 = shift(x33, x38)\n    \n    # Mirror the left side background vertically\n    x40 = vmirror(x32)\n    \n    # Find the rightmost column of the left background\n    x41 = rightmost(x32)\n    \n    # Find the rightmost column of the box\n    x42 = rightmost(x27)\n    \n    # Calculate the horizontal distance between left background and box\n    x43 = subtract(x41, x42)\n    \n    # Add 2 to the horizontal distance (for padding)\n    x44 = add(TWO, x43)\n    \n    # Create a horizontal vector for shifting\n    x45 = tojvec(x44)\n    \n    # Invert the shifting vector (move left instead of right)\n    x46 = invert(x45)\n    \n    # Shift the mirrored left background to the right\n    x47 = shift(x40, x46)\n    \n    # Fill all background cells with the object color\n    x48 = fill(x19, x25, x26)\n    \n    # Combine the shifted left and right backgrounds\n    x49 = combine(x39, x47)\n    \n    # Fill the combined backgrounds with the background color\n    x50 = fill(x48, x24, x49)\n    \n    # Apply the inverse of the initial mirroring if necessary\n    x51 = x18(x50)\n    \n    # Return the transformed grid\n    return x51\n"
  },
  "68b16354": {
    "original": "def verify_68b16354(I: Grid) -> Grid:\n    x0 = hmirror(I)\n    return x0\n\n",
    "annotated": "def verify_68b16354(I: Grid) -> Grid:\n    # Horizontally mirror the input grid I\n    # This creates a new grid where each row is reversed left-to-right\n    x0 = hmirror(I)\n    \n    # Return the horizontally mirrored grid\n    # This is the final output of the function, representing the solution to the ARC task\n    return x0\n"
  },
  "694f12f3": {
    "original": "def verify_694f12f3(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = sfilter(x0, x2)\n    x4 = compose(backdrop, inbox)\n    x5 = argmin(x3, size)\n    x6 = argmax(x3, size)\n    x7 = x4(x5)\n    x8 = x4(x6)\n    x9 = fill(I, ONE, x7)\n    x10 = fill(x9, TWO, x8)\n    return x10\n\n",
    "annotated": "def verify_694f12f3(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its height * width\n    x2 = fork(equality, size, x1)\n    \n    # Filter objects to keep only those that are solid rectangles (no holes)\n    x3 = sfilter(x0, x2)\n    \n    # Create a function that finds the inner box of an object's backdrop\n    x4 = compose(backdrop, inbox)\n    \n    # Find the smallest solid rectangle object\n    x5 = argmin(x3, size)\n    \n    # Find the largest solid rectangle object\n    x6 = argmax(x3, size)\n    \n    # Get the inner box of the smallest rectangle\n    x7 = x4(x5)\n    \n    # Get the inner box of the largest rectangle\n    x8 = x4(x6)\n    \n    # Fill the inner box of the smallest rectangle with color 1\n    x9 = fill(I, ONE, x7)\n    \n    # Fill the inner box of the largest rectangle with color 2\n    x10 = fill(x9, TWO, x8)\n    \n    # Return the modified grid\n    return x10\n"
  },
  "6a1e5592": {
    "original": "def verify_6a1e5592(I: Grid) -> Grid:\n    x0 = astuple(identity, dmirror)\n    x1 = astuple(cmirror, hmirror)\n    x2 = combine(x0, x1)\n    x3 = fork(vsplit, identity, height)\n    x4 = chain(asobject, first, x3)\n    x5 = mostcolor(I)\n    x6 = lbind(chain, numcolors)\n    x7 = lbind(x6, x4)\n    x8 = lbind(chain, color)\n    x9 = lbind(x8, x4)\n    x10 = rbind(rapply, I)\n    x11 = compose(initset, x7)\n    x12 = chain(first, x10, x11)\n    x13 = rbind(rapply, I)\n    x14 = compose(initset, x9)\n    x15 = chain(first, x13, x14)\n    x16 = matcher(x12, ONE)\n    x17 = matcher(x15, x5)\n    x18 = compose(flip, x17)\n    x19 = fork(both, x16, x18)\n    x20 = argmax(x2, x19)\n    x21 = x20(I)\n    x22 = x4(x21)\n    x23 = color(x22)\n    x24 = palette(x21)\n    x25 = remove(x23, x24)\n    x26 = other(x25, x5)\n    x27 = objects(x21, T, T, T)\n    x28 = colorfilter(x27, x26)\n    x29 = ofcolor(x21, x23)\n    x30 = ofcolor(x21, x5)\n    x31 = mapply(neighbors, x30)\n    x32 = mapply(neighbors, x31)\n    x33 = lowermost(x29)\n    x34 = dneighbors(ORIGIN)\n    x35 = remove(DOWN, x34)\n    x36 = rbind(mapply, x35)\n    x37 = lbind(chain, x36)\n    x38 = lbind(lbind, add)\n    x39 = rbind(x37, x38)\n    x40 = lbind(lbind, compose)\n    x41 = lbind(lbind, shift)\n    x42 = chain(x39, x40, x41)\n    x43 = lbind(chain, size)\n    x44 = rbind(intersection, x29)\n    x45 = lbind(x43, x44)\n    x46 = rbind(matcher, ZERO)\n    x47 = lbind(lbind, shift)\n    x48 = chain(x46, x45, x47)\n    x49 = rbind(chain, first)\n    x50 = rbind(x49, decrement)\n    x51 = lbind(greater, x33)\n    x52 = x50(x51)\n    x53 = rbind(sfilter, x52)\n    x54 = lbind(compose, x53)\n    x55 = lbind(chain, size)\n    x56 = rbind(difference, x30)\n    x57 = lbind(x55, x56)\n    x58 = rbind(matcher, ZERO)\n    x59 = lbind(lbind, shift)\n    x60 = chain(x58, x57, x59)\n    x61 = lbind(chain, size)\n    x62 = rbind(intersection, x30)\n    x63 = lbind(x61, x62)\n    x64 = lbind(fork, difference)\n    x65 = compose(x54, x42)\n    x66 = lbind(lbind, shift)\n    x67 = fork(x64, x65, x66)\n    x68 = compose(x63, x67)\n    x69 = rbind(matcher, ZERO)\n    x70 = compose(x69, x68)\n    x71 = lbind(fork, both)\n    x72 = fork(x71, x70, x60)\n    x73 = lbind(fork, both)\n    x74 = fork(x73, x48, x72)\n    x75 = compose(normalize, toindices)\n    x76 = lbind(sfilter, x32)\n    x77 = chain(x76, x74, x75)\n    x78 = rbind(argmin, first)\n    x79 = compose(x78, x77)\n    x80 = fork(shift, x75, x79)\n    x81 = mapply(x80, x28)\n    x82 = merge(x28)\n    x83 = cover(x21, x82)\n    x84 = fill(x83, ONE, x81)\n    x85 = x20(x84)\n    return x85\n\n",
    "annotated": "def verify_6a1e5592(I: Grid) -> Grid:\n    # Create a tuple of transformation functions (identity, diagonal mirror, counter-diagonal mirror, horizontal mirror)\n    x0 = astuple(identity, dmirror)\n    x1 = astuple(cmirror, hmirror)\n    x2 = combine(x0, x1)\n    \n    # Create a function to split the grid vertically and get the first part (the bar)\n    x3 = fork(vsplit, identity, height)\n    x4 = chain(asobject, first, x3)\n    \n    # Get the most common color in the input grid (background color)\n    x5 = mostcolor(I)\n    \n    # Create functions to get the number of colors and color of the bar\n    x6 = lbind(chain, numcolors)\n    x7 = lbind(x6, x4)\n    x8 = lbind(chain, color)\n    x9 = lbind(x8, x4)\n    \n    # Create functions to apply these operations to the input grid\n    x10 = rbind(rapply, I)\n    x11 = compose(initset, x7)\n    x12 = chain(first, x10, x11)\n    x13 = rbind(rapply, I)\n    x14 = compose(initset, x9)\n    x15 = chain(first, x13, x14)\n    \n    # Create matcher functions for bar properties\n    x16 = matcher(x12, ONE)  # Check if bar has only one color\n    x17 = matcher(x15, x5)   # Check if bar color is different from background\n    x18 = compose(flip, x17)\n    x19 = fork(both, x16, x18)\n    \n    # Find the correct orientation of the grid\n    x20 = argmax(x2, x19)\n    x21 = x20(I)  # Apply the correct orientation transformation\n    \n    # Get properties of the correctly oriented grid\n    x22 = x4(x21)  # Get the bar object\n    x23 = color(x22)  # Get the bar color\n    x24 = palette(x21)  # Get all colors in the grid\n    x25 = remove(x23, x24)  # Remove bar color from palette\n    x26 = other(x25, x5)  # Get the object color (not bar or background)\n    \n    # Find objects in the grid\n    x27 = objects(x21, T, T, T)\n    x28 = colorfilter(x27, x26)  # Filter objects by the object color\n    \n    # Get indices of different color areas\n    x29 = ofcolor(x21, x23)  # Bar area\n    x30 = ofcolor(x21, x5)   # Background area\n    \n    # Get neighborhoods of background area\n    x31 = mapply(neighbors, x30)\n    x32 = mapply(neighbors, x31)\n    \n    # Get the bottom of the bar\n    x33 = lowermost(x29)\n    \n    # Create functions for shifting objects\n    x34 = dneighbors(ORIGIN)\n    x35 = remove(DOWN, x34)\n    x36 = rbind(mapply, x35)\n    x37 = lbind(chain, x36)\n    x38 = lbind(lbind, add)\n    x39 = rbind(x37, x38)\n    x40 = lbind(lbind, compose)\n    x41 = lbind(lbind, shift)\n    x42 = chain(x39, x40, x41)\n    \n    # Create functions to check if shift is valid\n    x43 = lbind(chain, size)\n    x44 = rbind(intersection, x29)\n    x45 = lbind(x43, x44)\n    x46 = rbind(matcher, ZERO)\n    x47 = lbind(lbind, shift)\n    x48 = chain(x46, x45, x47)\n    \n    # Create functions to check if object is above bar\n    x49 = rbind(chain, first)\n    x50 = rbind(x49, decrement)\n    x51 = lbind(greater, x33)\n    x52 = x50(x51)\n    x53 = rbind(sfilter, x52)\n    x54 = lbind(compose, x53)\n    \n    # Create functions to check if shift is within grid\n    x55 = lbind(chain, size)\n    x56 = rbind(difference, x30)\n    x57 = lbind(x55, x56)\n    x58 = rbind(matcher, ZERO)\n    x59 = lbind(lbind, shift)\n    x60 = chain(x58, x57, x59)\n    \n    # Create functions to check if shift doesn't overlap with background\n    x61 = lbind(chain, size)\n    x62 = rbind(intersection, x30)\n    x63 = lbind(x61, x62)\n    x64 = lbind(fork, difference)\n    x65 = compose(x54, x42)\n    x66 = lbind(lbind, shift)\n    x67 = fork(x64, x65, x66)\n    x68 = compose(x63, x67)\n    x69 = rbind(matcher, ZERO)\n    x70 = compose(x69, x68)\n    \n    # Combine all shift validity checks\n    x71 = lbind(fork, both)\n    x72 = fork(x71, x70, x60)\n    x73 = lbind(fork, both)\n    x74 = fork(x73, x48, x72)\n    \n    # Create function to find valid shifts for objects\n    x75 = compose(normalize, toindices)\n    x76 = lbind(sfilter, x32)\n    x77 = chain(x76, x74, x75)\n    x78 = rbind(argmin, first)\n    x79 = compose(x78, x77)\n    \n    # Shift objects to their new positions\n    x80 = fork(shift, x75, x79)\n    x81 = mapply(x80, x28)\n    \n    # Create the output grid\n    x82 = merge(x28)\n    x83 = cover(x21, x82)  # Remove original objects\n    x84 = fill(x83, ONE, x81)  # Place objects in new positions\n    \n    # Apply the inverse orientation transformation\n    x85 = x20(x84)\n    return x85\n"
  },
  "6aa20dc0": {
    "original": "def verify_6aa20dc0(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = mostcolor(I)\n    x2 = valmax(x0, numcolors)\n    x3 = matcher(numcolors, x2)\n    x4 = mfilter(x0, x3)\n    x5 = backdrop(x4)\n    x6 = toobject(x5, I)\n    x7 = matcher(first, x1)\n    x8 = compose(flip, x7)\n    x9 = sfilter(x6, x8)\n    x10 = mostcolor(x9)\n    x11 = initset(identity)\n    x12 = insert(dmirror, x11)\n    x13 = insert(cmirror, x12)\n    x14 = insert(hmirror, x13)\n    x15 = insert(vmirror, x14)\n    x16 = shape(I)\n    x17 = add(TWO, x16)\n    x18 = canvas(x1, x17)\n    x19 = asobject(I)\n    x20 = shift(x19, UNITY)\n    x21 = paint(x18, x20)\n    x22 = interval(ONE, FIVE, ONE)\n    x23 = matcher(first, x10)\n    x24 = compose(flip, x23)\n    x25 = rbind(sfilter, x24)\n    x26 = compose(normalize, x25)\n    x27 = chain(normalize, toindices, x26)\n    x28 = lbind(upscale, x9)\n    x29 = compose(initset, last)\n    x30 = compose(x28, first)\n    x31 = fork(rapply, x29, x30)\n    x32 = chain(normalize, first, x31)\n    x33 = compose(normalize, x26)\n    x34 = lbind(recolor, x1)\n    x35 = lbind(mapply, dneighbors)\n    x36 = compose(x35, x27)\n    x37 = fork(difference, x36, x27)\n    x38 = compose(x34, x37)\n    x39 = fork(combine, x33, x38)\n    x40 = compose(x39, x32)\n    x41 = lbind(lbind, shift)\n    x42 = chain(ulcorner, x26, x32)\n    x43 = fork(shift, x32, x42)\n    x44 = compose(x41, x43)\n    x45 = lbind(occurrences, x21)\n    x46 = compose(x45, x40)\n    x47 = fork(mapply, x44, x46)\n    x48 = product(x22, x15)\n    x49 = mapply(x47, x48)\n    x50 = paint(I, x49)\n    return x50\n\n",
    "annotated": "def verify_6aa20dc0(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, F, T, T)\n    \n    # Get the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Find the object with the maximum number of colors\n    x2 = valmax(x0, numcolors)\n    \n    # Create a function that checks if an object has the same number of colors as x2\n    x3 = matcher(numcolors, x2)\n    \n    # Filter objects to keep only those with the maximum number of colors\n    x4 = mfilter(x0, x3)\n    \n    # Get the bounding box of the filtered objects\n    x5 = backdrop(x4)\n    \n    # Create an object from the bounding box using colors from the input grid\n    x6 = toobject(x5, I)\n    \n    # Create a function that checks if a color is not the background color\n    x7 = matcher(first, x1)\n    x8 = compose(flip, x7)\n    \n    # Filter the bounding box object to keep only non-background colors\n    x9 = sfilter(x6, x8)\n    \n    # Get the most common color in the filtered object (foreground color)\n    x10 = mostcolor(x9)\n    \n    # Create a set of transformation functions\n    x11 = initset(identity)\n    x12 = insert(dmirror, x11)\n    x13 = insert(cmirror, x12)\n    x14 = insert(hmirror, x13)\n    x15 = insert(vmirror, x14)\n    \n    # Get the shape of the input grid and add 2 to each dimension\n    x16 = shape(I)\n    x17 = add(TWO, x16)\n    \n    # Create a new canvas with the background color and increased dimensions\n    x18 = canvas(x1, x17)\n    \n    # Convert the input grid to an object and shift it by (1, 1)\n    x19 = asobject(I)\n    x20 = shift(x19, UNITY)\n    \n    # Paint the shifted input grid onto the new canvas\n    x21 = paint(x18, x20)\n    \n    # Create a range of integers from 1 to 4\n    x22 = interval(ONE, FIVE, ONE)\n    \n    # Create a function that checks if a color is not the foreground color\n    x23 = matcher(first, x10)\n    x24 = compose(flip, x23)\n    \n    # Create a function to filter out foreground color and normalize\n    x25 = rbind(sfilter, x24)\n    x26 = compose(normalize, x25)\n    x27 = chain(normalize, toindices, x26)\n    \n    # Create a function to upscale the filtered object\n    x28 = lbind(upscale, x9)\n    \n    # Create functions to process the object with transformations and scaling\n    x29 = compose(initset, last)\n    x30 = compose(x28, first)\n    x31 = fork(rapply, x29, x30)\n    x32 = chain(normalize, first, x31)\n    \n    # Create functions to process the object and add background color to edges\n    x33 = compose(normalize, x26)\n    x34 = lbind(recolor, x1)\n    x35 = lbind(mapply, dneighbors)\n    x36 = compose(x35, x27)\n    x37 = fork(difference, x36, x27)\n    x38 = compose(x34, x37)\n    x39 = fork(combine, x33, x38)\n    x40 = compose(x39, x32)\n    \n    # Create functions to shift the processed object\n    x41 = lbind(lbind, shift)\n    x42 = chain(ulcorner, x26, x32)\n    x43 = fork(shift, x32, x42)\n    x44 = compose(x41, x43)\n    \n    # Create a function to find occurrences of the processed object\n    x45 = lbind(occurrences, x21)\n    x46 = compose(x45, x40)\n    \n    # Create a function to apply shifts to found occurrences\n    x47 = fork(mapply, x44, x46)\n    \n    # Create all combinations of scaling factors and transformations\n    x48 = product(x22, x15)\n    \n    # Apply processing, finding occurrences, and shifting to all combinations\n    x49 = mapply(x47, x48)\n    \n    # Paint the processed and shifted objects onto the input grid\n    x50 = paint(I, x49)\n    \n    # Return the final processed grid\n    return x50\n"
  },
  "6b9890af": {
    "original": "def verify_6b9890af(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = fork(equality, toindices, box)\n    x2 = sfilter(x0, x1)\n    x3 = fork(multiply, height, width)\n    x4 = argmax(x2, x3)\n    x5 = fgpartition(I)\n    x6 = merge(x5)\n    x7 = difference(x6, x4)\n    x8 = subgrid(x4, I)\n    x9 = subgrid(x7, I)\n    x10 = height(x8)\n    x11 = subtract(x10, TWO)\n    x12 = height(x9)\n    x13 = divide(x11, x12)\n    x14 = width(x8)\n    x15 = subtract(x14, TWO)\n    x16 = width(x9)\n    x17 = divide(x15, x16)\n    x18 = hupscale(x9, x17)\n    x19 = vupscale(x18, x13)\n    x20 = asobject(x19)\n    x21 = shift(x20, UNITY)\n    x22 = paint(x8, x21)\n    return x22\n\n",
    "annotated": "def verify_6b9890af(I: Grid) -> Grid:\n    # Find all objects in the input grid, including background and diagonally connected cells\n    x0 = objects(I, T, T, T)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x1 = fork(equality, toindices, box)\n    \n    # Filter objects to keep only those that form a perfect rectangle (the outer square)\n    x2 = sfilter(x0, x1)\n    \n    # Create a function that calculates the area of an object\n    x3 = fork(multiply, height, width)\n    \n    # Find the largest rectangular object (the outer square)\n    x4 = argmax(x2, x3)\n    \n    # Partition the input grid into objects, excluding the background\n    x5 = fgpartition(I)\n    \n    # Merge all foreground objects into a single set\n    x6 = merge(x5)\n    \n    # Find the object inside the square by removing the square from all foreground objects\n    x7 = difference(x6, x4)\n    \n    # Extract the subgrid containing the outer square\n    x8 = subgrid(x4, I)\n    \n    # Extract the subgrid containing the inner object\n    x9 = subgrid(x7, I)\n    \n    # Calculate the height of the outer square\n    x10 = height(x8)\n    \n    # Calculate the height of the inner area (subtract 2 for the border)\n    x11 = subtract(x10, TWO)\n    \n    # Calculate the height of the inner object\n    x12 = height(x9)\n    \n    # Calculate the vertical scaling factor\n    x13 = divide(x11, x12)\n    \n    # Calculate the width of the outer square\n    x14 = width(x8)\n    \n    # Calculate the width of the inner area (subtract 2 for the border)\n    x15 = subtract(x14, TWO)\n    \n    # Calculate the width of the inner object\n    x16 = width(x9)\n    \n    # Calculate the horizontal scaling factor\n    x17 = divide(x15, x16)\n    \n    # Scale the inner object horizontally\n    x18 = hupscale(x9, x17)\n    \n    # Scale the inner object vertically\n    x19 = vupscale(x18, x13)\n    \n    # Convert the scaled grid to an object\n    x20 = asobject(x19)\n    \n    # Shift the scaled object by (1, 1) to center it within the square\n    x21 = shift(x20, UNITY)\n    \n    # Paint the scaled and centered object onto the outer square subgrid\n    x22 = paint(x8, x21)\n    \n    # Return the final grid with the scaled object inside the square\n    return x22\n"
  },
  "6c434453": {
    "original": "def verify_6c434453(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = rbind(greater, TWO)\n    x2 = chain(x1, minimum, shape)\n    x3 = sfilter(x0, x2)\n    x4 = fork(equality, toindices, box)\n    x5 = sfilter(x3, x4)\n    x6 = mostcolor(I)\n    x7 = merge(x5)\n    x8 = fill(I, x6, x7)\n    x9 = compose(hfrontier, center)\n    x10 = compose(vfrontier, center)\n    x11 = fork(combine, x9, x10)\n    x12 = fork(intersection, x11, backdrop)\n    x13 = mapply(x12, x5)\n    x14 = fill(x8, TWO, x13)\n    return x14\n\n",
    "annotated": "def verify_6c434453(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that checks if a value is greater than 2\n    x1 = rbind(greater, TWO)\n    \n    # Create a function chain that checks if the minimum dimension of an object is greater than 2\n    x2 = chain(x1, minimum, shape)\n    \n    # Filter objects to keep only those with both dimensions greater than 2\n    x3 = sfilter(x0, x2)\n    \n    # Create a function that checks if an object's shape is exactly a box (rectangle)\n    x4 = fork(equality, toindices, box)\n    \n    # Filter objects to keep only those that are perfect boxes (rectangles)\n    x5 = sfilter(x3, x4)\n    \n    # Find the most common color in the input grid (background color)\n    x6 = mostcolor(I)\n    \n    # Merge all the box objects into a single set of indices\n    x7 = merge(x5)\n    \n    # Fill the areas of all box objects with the background color\n    # This effectively removes all box objects from the grid\n    x8 = fill(I, x6, x7)\n    \n    # Create a function that finds the horizontal frontier of an object's center\n    x9 = compose(hfrontier, center)\n    \n    # Create a function that finds the vertical frontier of an object's center\n    x10 = compose(vfrontier, center)\n    \n    # Create a function that combines the horizontal and vertical frontiers\n    x11 = fork(combine, x9, x10)\n    \n    # Create a function that finds the intersection of the combined frontiers and the object's backdrop\n    x12 = fork(intersection, x11, backdrop)\n    \n    # Apply the frontier intersection function to all box objects\n    # This creates a cross shape within each box\n    x13 = mapply(x12, x5)\n    \n    # Fill the cross shapes with color 2\n    # This draws a cross of color 2 where each box object was located\n    x14 = fill(x8, TWO, x13)\n    \n    # Return the final grid with boxes replaced by crosses\n    return x14\n"
  },
  "6cdd2623": {
    "original": "def verify_6cdd2623(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = rbind(difference, x1)\n    x3 = chain(size, x2, toindices)\n    x4 = matcher(x3, ZERO)\n    x5 = partition(I)\n    x6 = sfilter(x5, x4)\n    x7 = argmax(x6, size)\n    x8 = color(x7)\n    x9 = toindices(x7)\n    x10 = fork(either, hline, vline)\n    x11 = prapply(connect, x9, x9)\n    x12 = compose(flip, x4)\n    x13 = fork(both, x12, x10)\n    x14 = mfilter(x11, x13)\n    x15 = mostcolor(I)\n    x16 = shape(I)\n    x17 = canvas(x15, x16)\n    x18 = fill(x17, x8, x14)\n    return x18\n\n",
    "annotated": "def verify_6cdd2623(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Get the outline (box) of the grid\n    x1 = box(x0)\n    \n    # Create a function that removes the outline from a given set of indices\n    x2 = rbind(difference, x1)\n    \n    # Create a function that counts the number of indices after removing the outline\n    x3 = chain(size, x2, toindices)\n    \n    # Create a function that checks if the count is zero (i.e., if an object is only on the outline)\n    x4 = matcher(x3, ZERO)\n    \n    # Partition the input grid into objects based on color\n    x5 = partition(I)\n    \n    # Filter objects that are only on the outline\n    x6 = sfilter(x5, x4)\n    \n    # Find the largest object among those on the outline (likely the line color)\n    x7 = argmax(x6, size)\n    \n    # Get the color of this largest outline object (line color)\n    x8 = color(x7)\n    \n    # Get the indices of the largest outline object\n    x9 = toindices(x7)\n    \n    # Create a function that checks if a set of indices forms a horizontal or vertical line\n    x10 = fork(either, hline, vline)\n    \n    # Generate all possible connections between outline indices\n    x11 = prapply(connect, x9, x9)\n    \n    # Create a function that checks if a set of indices is not only on the outline\n    x12 = compose(flip, x4)\n    \n    # Create a function that checks if a set of indices is both not only on the outline and forms a line\n    x13 = fork(both, x12, x10)\n    \n    # Filter the connections to keep only valid lines\n    x14 = mfilter(x11, x13)\n    \n    # Find the most common color in the input grid (background color)\n    x15 = mostcolor(I)\n    \n    # Get the shape (dimensions) of the input grid\n    x16 = shape(I)\n    \n    # Create a new grid with the background color\n    x17 = canvas(x15, x16)\n    \n    # Fill the new grid with the line color at the positions of valid lines\n    x18 = fill(x17, x8, x14)\n    \n    # Return the resulting grid with completed lines\n    return x18\n"
  },
  "6cf79266": {
    "original": "def verify_6cf79266(I: Grid) -> Grid:\n    x0 = canvas(ZERO, THREE_BY_THREE)\n    x1 = asobject(x0)\n    x2 = occurrences(I, x1)\n    x3 = lbind(shift, x1)\n    x4 = mapply(x3, x2)\n    x5 = fill(I, ONE, x4)\n    return x5\n\n",
    "annotated": "def verify_6cf79266(I: Grid) -> Grid:\n    # Create a 3x3 grid filled with zeros\n    x0 = canvas(ZERO, THREE_BY_THREE)\n    \n    # Convert the 3x3 grid to an object representation\n    # This creates a set of (value, position) pairs for each cell in the 3x3 grid\n    x1 = asobject(x0)\n    \n    # Find all occurrences of the 3x3 zero object in the input grid I\n    # This identifies all 3x3 black squares in the input\n    x2 = occurrences(I, x1)\n    \n    # Create a partial function that shifts the 3x3 zero object\n    # This prepares for applying the shift to each occurrence found\n    x3 = lbind(shift, x1)\n    \n    # Apply the shift function to all occurrences\n    # This creates a set of shifted 3x3 objects, one for each occurrence\n    x4 = mapply(x3, x2)\n    \n    # Fill the input grid I with ones (1) at all positions of the shifted 3x3 objects\n    # This effectively outlines all 3x3 black squares with color 1\n    x5 = fill(I, ONE, x4)\n    \n    # Return the modified grid, which now has all 3x3 black squares outlined\n    return x5\n"
  },
  "6d0160f0": {
    "original": "def verify_6d0160f0(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = mostcolor(x1)\n    x3 = shape(I)\n    x4 = canvas(NEG_ONE, x3)\n    x5 = hconcat(I, x4)\n    x6 = fill(x5, NEG_ONE, x1)\n    x7 = objects(x6, F, F, T)\n    x8 = lbind(contained, FOUR)\n    x9 = compose(x8, palette)\n    x10 = extract(x7, x9)\n    x11 = lbind(sfilter, x7)\n    x12 = compose(size, x11)\n    x13 = rbind(compose, palette)\n    x14 = lbind(lbind, contained)\n    x15 = chain(x12, x13, x14)\n    x16 = merge(x7)\n    x17 = palette(I)\n    x18 = remove(x2, x17)\n    x19 = valmax(x18, x15)\n    x20 = matcher(x15, x19)\n    x21 = sfilter(x18, x20)\n    x22 = lbind(colorcount, x16)\n    x23 = argmax(x21, x22)\n    x24 = shape(I)\n    x25 = canvas(x23, x24)\n    x26 = paint(x25, x1)\n    x27 = normalize(x10)\n    x28 = matcher(first, x2)\n    x29 = compose(flip, x28)\n    x30 = sfilter(x27, x29)\n    x31 = shape(x27)\n    x32 = increment(x31)\n    x33 = matcher(first, FOUR)\n    x34 = sfilter(x27, x33)\n    x35 = center(x34)\n    x36 = multiply(x32, x35)\n    x37 = shift(x30, x36)\n    x38 = paint(x26, x37)\n    return x38\n\n",
    "annotated": "def verify_6d0160f0(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single set of cells\n    x1 = merge(x0)\n    \n    # Find the most common color in the merged frontiers (likely the line color)\n    x2 = mostcolor(x1)\n    \n    # Get the shape (dimensions) of the input grid\n    x3 = shape(I)\n    \n    # Create a canvas of the same size as the input grid, filled with -1\n    x4 = canvas(NEG_ONE, x3)\n    \n    # Concatenate the input grid with the negative canvas horizontally\n    # This effectively doubles the width of the grid\n    x5 = hconcat(I, x4)\n    \n    # Fill the frontiers in the concatenated grid with -1\n    # This removes the grid lines, creating separate regions\n    x6 = fill(x5, NEG_ONE, x1)\n    \n    # Find all objects in the modified grid, ignoring background and considering only 4-connected cells\n    x7 = objects(x6, F, F, T)\n    \n    # Create a function that checks if 4 is in a set\n    x8 = lbind(contained, FOUR)\n    \n    # Create a function that checks if 4 is in the palette of an object\n    x9 = compose(x8, palette)\n    \n    # Extract the object that contains the color 4 (the target object)\n    x10 = extract(x7, x9)\n    \n    # Create a function that filters objects based on a condition\n    x11 = lbind(sfilter, x7)\n    \n    # Create a function that gets the size of filtered objects\n    x12 = compose(size, x11)\n    \n    # Create a function that checks if a color is in an object's palette\n    x13 = rbind(compose, palette)\n    x14 = lbind(lbind, contained)\n    x15 = chain(x12, x13, x14)\n    \n    # Merge all objects into a single set of cells\n    x16 = merge(x7)\n    \n    # Get the palette of the input grid\n    x17 = palette(I)\n    \n    # Remove the line color from the palette\n    x18 = remove(x2, x17)\n    \n    # Find the color with the maximum number of cells (excluding the line color)\n    x19 = valmax(x18, x15)\n    \n    # Create a function that matches objects with the maximum color\n    x20 = matcher(x15, x19)\n    \n    # Filter the palette to only include colors with the maximum number of cells\n    x21 = sfilter(x18, x20)\n    \n    # Create a function that counts the occurrences of a color in all objects\n    x22 = lbind(colorcount, x16)\n    \n    # Find the most common color among the filtered colors\n    x23 = argmax(x21, x22)\n    \n    # Create a new grid with the same dimensions as the input, filled with the most common color\n    x24 = shape(I)\n    x25 = canvas(x23, x24)\n    \n    # Paint the grid lines onto the new canvas\n    x26 = paint(x25, x1)\n    \n    # Normalize the position of the target object (with color 4)\n    x27 = normalize(x10)\n    \n    # Create a function that checks if a cell's color is not the line color\n    x28 = matcher(first, x2)\n    x29 = compose(flip, x28)\n    \n    # Filter the normalized target object to exclude line-colored cells\n    x30 = sfilter(x27, x29)\n    \n    # Get the shape of the normalized target object\n    x31 = shape(x27)\n    \n    # Increment the shape (add 1 to both dimensions)\n    x32 = increment(x31)\n    \n    # Create a function that checks if a cell's color is 4\n    x33 = matcher(first, FOUR)\n    \n    # Filter the normalized target object to only include cells with color 4\n    x34 = sfilter(x27, x33)\n    \n    # Find the center of the cells with color 4\n    x35 = center(x34)\n    \n    # Calculate the new position for the target object\n    x36 = multiply(x32, x35)\n    \n    # Shift the filtered target object to its new position\n    x37 = shift(x30, x36)\n    \n    # Paint the shifted target object onto the output grid\n    x38 = paint(x26, x37)\n    \n    # Return the final output grid\n    return x38\n"
  },
  "6d0aefbc": {
    "original": "def verify_6d0aefbc(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(I, x0)\n    return x1\n\n",
    "annotated": "def verify_6d0aefbc(I: Grid) -> Grid:\n    # Create a vertical mirror image of the input grid\n    # This flips the grid left to right, creating a reflection\n    x0 = vmirror(I)\n    \n    # Horizontally concatenate the original input grid with its mirror image\n    # This effectively doubles the width of the grid, with the right half being a mirror of the left\n    x1 = hconcat(I, x0)\n    \n    # Return the concatenated grid as the output\n    # The result is a grid where the right half is a mirror image of the left half\n    return x1\n"
  },
  "6d58a25d": {
    "original": "def verify_6d58a25d(I: Grid) -> Grid:\n    x0 = astuple(ONE, THREE)\n    x1 = astuple(TWO, FOUR)\n    x2 = initset(x1)\n    x3 = insert(TWO_BY_TWO, x2)\n    x4 = insert(x0, x3)\n    x5 = tojvec(THREE)\n    x6 = toivec(THREE)\n    x7 = connect(x5, x6)\n    x8 = astuple(THREE, SIX)\n    x9 = connect(x5, x8)\n    x10 = combine(x7, x9)\n    x11 = combine(x4, x10)\n    x12 = lbind(contained, x11)\n    x13 = compose(normalize, toindices)\n    x14 = lbind(apply, x13)\n    x15 = chain(x12, x14, partition)\n    x16 = astuple(identity, identity)\n    x17 = astuple(rot90, rot270)\n    x18 = astuple(x16, x17)\n    x19 = astuple(rot180, rot180)\n    x20 = astuple(rot270, rot90)\n    x21 = astuple(x19, x20)\n    x22 = combine(x18, x21)\n    x23 = rbind(rapply, I)\n    x24 = compose(initset, first)\n    x25 = chain(first, x23, x24)\n    x26 = compose(x15, x25)\n    x27 = extract(x22, x26)\n    x28 = first(x27)\n    x29 = last(x27)\n    x30 = x28(I)\n    x31 = palette(I)\n    x32 = lbind(ofcolor, x30)\n    x33 = compose(normalize, x32)\n    x34 = matcher(x33, x11)\n    x35 = extract(x31, x34)\n    x36 = remove(x35, x31)\n    x37 = lbind(colorcount, x30)\n    x38 = argmin(x36, x37)\n    x39 = ofcolor(x30, x38)\n    x40 = ofcolor(x30, x35)\n    x41 = compose(positive, size)\n    x42 = rbind(intersection, x40)\n    x43 = rbind(shoot, UP)\n    x44 = chain(x41, x42, x43)\n    x45 = sfilter(x39, x44)\n    x46 = height(x30)\n    x47 = rbind(valmax, first)\n    x48 = lbind(sfilter, x40)\n    x49 = lbind(matcher, last)\n    x50 = chain(x48, x49, last)\n    x51 = chain(increment, x47, x50)\n    x52 = fork(astuple, x51, last)\n    x53 = decrement(x46)\n    x54 = lbind(astuple, x53)\n    x55 = compose(x54, last)\n    x56 = fork(connect, x52, x55)\n    x57 = mapply(x56, x45)\n    x58 = fill(x30, x38, x57)\n    x59 = x29(x58)\n    return x59\n\n",
    "annotated": "def verify_6d58a25d(I: Grid) -> Grid:\n    # Define a tuple representing the point (1, 3)\n    x0 = astuple(ONE, THREE)\n    # Define a tuple representing the point (2, 4)\n    x1 = astuple(TWO, FOUR)\n    # Create a set containing the point (2, 4)\n    x2 = initset(x1)\n    # Add the point (2, 2) to the set\n    x3 = insert(TWO_BY_TWO, x2)\n    # Add the point (1, 3) to the set\n    x4 = insert(x0, x3)\n    # Create a vector pointing horizontally with length 3\n    x5 = tojvec(THREE)\n    # Create a vector pointing vertically with length 3\n    x6 = toivec(THREE)\n    # Create a line from (0, 3) to (3, 3)\n    x7 = connect(x5, x6)\n    # Create a tuple representing the point (3, 6)\n    x8 = astuple(THREE, SIX)\n    # Create a line from (0, 3) to (3, 6)\n    x9 = connect(x5, x8)\n    # Combine the two lines\n    x10 = combine(x7, x9)\n    # Combine the set of points with the lines to create the shape\n    x11 = combine(x4, x10)\n    # Create a function that checks if a point is in the shape\n    x12 = lbind(contained, x11)\n    # Create a function that normalizes indices\n    x13 = compose(normalize, toindices)\n    # Create a function that applies normalization to a set\n    x14 = lbind(apply, x13)\n    # Create a function chain to find objects matching the shape\n    x15 = chain(x12, x14, partition)\n    # Define tuples for different rotation combinations\n    x16 = astuple(identity, identity)\n    x17 = astuple(rot90, rot270)\n    x18 = astuple(x16, x17)\n    x19 = astuple(rot180, rot180)\n    x20 = astuple(rot270, rot90)\n    x21 = astuple(x19, x20)\n    # Combine all rotation combinations\n    x22 = combine(x18, x21)\n    # Create a function to apply rotations to the input grid\n    x23 = rbind(rapply, I)\n    # Create a function to get the first element of a set\n    x24 = compose(initset, first)\n    # Create a function chain to find the first matching rotation\n    x25 = chain(first, x23, x24)\n    # Create a function to find objects matching the shape after rotation\n    x26 = compose(x15, x25)\n    # Find the correct rotation that matches the shape\n    x27 = extract(x22, x26)\n    # Get the rotation function to apply to the input\n    x28 = first(x27)\n    # Get the inverse rotation function to apply to the output\n    x29 = last(x27)\n    # Apply the rotation to the input grid\n    x30 = x28(I)\n    # Get the palette of colors used in the input grid\n    x31 = palette(I)\n    # Create a function to find cells of a specific color in the rotated input\n    x32 = lbind(ofcolor, x30)\n    # Create a function to normalize the cells of a specific color\n    x33 = compose(normalize, x32)\n    # Create a function to match the normalized cells to the shape\n    x34 = matcher(x33, x11)\n    # Find the color of the shape\n    x35 = extract(x31, x34)\n    # Get the remaining colors (excluding the shape color)\n    x36 = remove(x35, x31)\n    # Create a function to count cells of a specific color\n    x37 = lbind(colorcount, x30)\n    # Find the color with the least occurrences (noise color)\n    x38 = argmin(x36, x37)\n    # Get the indices of cells with the noise color\n    x39 = ofcolor(x30, x38)\n    # Get the indices of cells with the shape color\n    x40 = ofcolor(x30, x35)\n    # Create a function to check if a set is non-empty\n    x41 = compose(positive, size)\n    # Create a function to find intersection with shape\n    x42 = rbind(intersection, x40)\n    # Create a function to shoot upwards from a point\n    x43 = rbind(shoot, UP)\n    # Create a function chain to check if a noise point has shape above it\n    x44 = chain(x41, x42, x43)\n    # Filter noise points to only those with shape above them\n    x45 = sfilter(x39, x44)\n    # Get the height of the rotated input grid\n    x46 = height(x30)\n    # Create a function to find the maximum first coordinate\n    x47 = rbind(valmax, first)\n    # Create a function to filter shape cells in a column\n    x48 = lbind(sfilter, x40)\n    # Create a function to match the column\n    x49 = lbind(matcher, last)\n    # Create a function chain to find the bottom of the shape in a column\n    x50 = chain(x48, x49, last)\n    # Create a function chain to find the point just below the shape\n    x51 = chain(increment, x47, x50)\n    # Create a function to get the start point for a vertical line\n    x52 = fork(astuple, x51, last)\n    # Calculate the index of the bottom row\n    x53 = decrement(x46)\n    # Create a function to make a tuple with the bottom row index\n    x54 = lbind(astuple, x53)\n    # Create a function to get the end point for a vertical line\n    x55 = compose(x54, last)\n    # Create a function to connect start and end points\n    x56 = fork(connect, x52, x55)\n    # Create all vertical lines from noise points to bottom\n    x57 = mapply(x56, x45)\n    # Fill the vertical lines with the noise color\n    x58 = fill(x30, x38, x57)\n    # Apply the inverse rotation to get the final output\n    x59 = x29(x58)\n    return x59\n"
  },
  "6d75e8bb": {
    "original": "def verify_6d75e8bb(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = argmin(x0, size)\n    x2 = delta(x1)\n    x3 = fill(I, TWO, x2)\n    return x3\n\n",
    "annotated": "def verify_6d75e8bb(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    # This creates a set of objects, where each object is a set of cells with the same color\n    x0 = partition(I)\n\n    # Find the smallest object (in terms of number of cells) from the partitioned set\n    # This corresponds to the foreground shape in the input grid\n    x1 = argmin(x0, size)\n\n    # Calculate the delta of the smallest object\n    # This gives us the cells in the bounding box of the shape that are not part of the shape itself\n    x2 = delta(x1)\n\n    # Fill the input grid with color 2 (TWO) in the cells determined by x2\n    # This effectively creates a bounding box around the shape with color 2,\n    # while preserving the original shape and background\n    x3 = fill(I, TWO, x2)\n\n    # Return the modified grid\n    # The output is the input grid with a color 2 bounding box around the foreground shape\n    return x3\n"
  },
  "6e02f1e3": {
    "original": "def verify_6e02f1e3(I: Grid) -> Grid:\n    x0 = numcolors(I)\n    x1 = equality(x0, THREE)\n    x2 = height(I)\n    x3 = decrement(x2)\n    x4 = toivec(x3)\n    x5 = branch(x1, x4, ORIGIN)\n    x6 = equality(x0, TWO)\n    x7 = shape(I)\n    x8 = decrement(x7)\n    x9 = width(I)\n    x10 = decrement(x9)\n    x11 = tojvec(x10)\n    x12 = branch(x6, x8, x11)\n    x13 = shape(I)\n    x14 = canvas(ZERO, x13)\n    x15 = connect(x5, x12)\n    x16 = fill(x14, FIVE, x15)\n    return x16\n\n",
    "annotated": "def verify_6e02f1e3(I: Grid) -> Grid:\n    # Count the number of unique colors in the input grid\n    x0 = numcolors(I)\n    \n    # Check if the number of colors is equal to 3\n    x1 = equality(x0, THREE)\n    \n    # Get the height of the input grid\n    x2 = height(I)\n    \n    # Subtract 1 from the height\n    x3 = decrement(x2)\n    \n    # Create a vertical vector with the decremented height\n    x4 = toivec(x3)\n    \n    # If there are 3 colors, use x4 as start point, else use (0,0)\n    # This determines the starting point for the diagonal line\n    x5 = branch(x1, x4, ORIGIN)\n    \n    # Check if the number of colors is equal to 2\n    x6 = equality(x0, TWO)\n    \n    # Get the shape (height, width) of the input grid\n    x7 = shape(I)\n    \n    # Subtract 1 from both dimensions of the shape\n    x8 = decrement(x7)\n    \n    # Get the width of the input grid\n    x9 = width(I)\n    \n    # Subtract 1 from the width\n    x10 = decrement(x9)\n    \n    # Create a horizontal vector with the decremented width\n    x11 = tojvec(x10)\n    \n    # If there are 2 colors, use x8 as end point, else use x11\n    # This determines the ending point for the diagonal line\n    x12 = branch(x6, x8, x11)\n    \n    # Get the shape of the input grid again\n    x13 = shape(I)\n    \n    # Create a new grid filled with zeros, same size as input\n    x14 = canvas(ZERO, x13)\n    \n    # Create a line connecting the start and end points\n    x15 = connect(x5, x12)\n    \n    # Fill the line on the zero canvas with color 5\n    # This creates the final output with a diagonal line\n    x16 = fill(x14, FIVE, x15)\n    \n    # Return the final grid with the diagonal line\n    return x16\n"
  },
  "6e19193c": {
    "original": "def verify_6e19193c(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = rbind(shoot, UNITY)\n    x2 = rbind(add, UNITY)\n    x3 = chain(x1, x2, lrcorner)\n    x4 = fork(recolor, color, x3)\n    x5 = rbind(shoot, UP_RIGHT)\n    x6 = rbind(add, UP_RIGHT)\n    x7 = chain(x5, x6, urcorner)\n    x8 = fork(recolor, color, x7)\n    x9 = rbind(shoot, NEG_UNITY)\n    x10 = rbind(add, NEG_UNITY)\n    x11 = chain(x9, x10, ulcorner)\n    x12 = fork(recolor, color, x11)\n    x13 = rbind(shoot, DOWN_LEFT)\n    x14 = rbind(add, DOWN_LEFT)\n    x15 = chain(x13, x14, llcorner)\n    x16 = fork(recolor, color, x15)\n    x17 = fork(remove, lrcorner, toindices)\n    x18 = fork(equality, toindices, x17)\n    x19 = sfilter(x0, x18)\n    x20 = fork(remove, urcorner, toindices)\n    x21 = fork(equality, toindices, x20)\n    x22 = sfilter(x0, x21)\n    x23 = fork(remove, ulcorner, toindices)\n    x24 = fork(equality, toindices, x23)\n    x25 = sfilter(x0, x24)\n    x26 = fork(remove, llcorner, toindices)\n    x27 = fork(equality, toindices, x26)\n    x28 = sfilter(x0, x27)\n    x29 = mapply(x4, x19)\n    x30 = mapply(x8, x22)\n    x31 = combine(x29, x30)\n    x32 = mapply(x12, x25)\n    x33 = mapply(x16, x28)\n    x34 = combine(x32, x33)\n    x35 = combine(x31, x34)\n    x36 = paint(I, x35)\n    return x36\n\n",
    "annotated": "def verify_6e19193c(I: Grid) -> Grid:\n    # Identify all objects in the input grid, considering diagonals as connected and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that shoots a line in the (1,1) direction\n    x1 = rbind(shoot, UNITY)\n    \n    # Create a function that adds (1,1) to a coordinate\n    x2 = rbind(add, UNITY)\n    \n    # Chain functions to shoot a line from the lower-right corner in the (1,1) direction\n    x3 = chain(x1, x2, lrcorner)\n    \n    # Create a function that recolors the shot line with the color of the original object\n    x4 = fork(recolor, color, x3)\n    \n    # Create a function that shoots a line in the (-1,1) direction (up-right)\n    x5 = rbind(shoot, UP_RIGHT)\n    \n    # Create a function that adds (-1,1) to a coordinate\n    x6 = rbind(add, UP_RIGHT)\n    \n    # Chain functions to shoot a line from the upper-right corner in the (-1,1) direction\n    x7 = chain(x5, x6, urcorner)\n    \n    # Create a function that recolors the shot line with the color of the original object\n    x8 = fork(recolor, color, x7)\n    \n    # Create a function that shoots a line in the (-1,-1) direction\n    x9 = rbind(shoot, NEG_UNITY)\n    \n    # Create a function that adds (-1,-1) to a coordinate\n    x10 = rbind(add, NEG_UNITY)\n    \n    # Chain functions to shoot a line from the upper-left corner in the (-1,-1) direction\n    x11 = chain(x9, x10, ulcorner)\n    \n    # Create a function that recolors the shot line with the color of the original object\n    x12 = fork(recolor, color, x11)\n    \n    # Create a function that shoots a line in the (1,-1) direction (down-left)\n    x13 = rbind(shoot, DOWN_LEFT)\n    \n    # Create a function that adds (1,-1) to a coordinate\n    x14 = rbind(add, DOWN_LEFT)\n    \n    # Chain functions to shoot a line from the lower-left corner in the (1,-1) direction\n    x15 = chain(x13, x14, llcorner)\n    \n    # Create a function that recolors the shot line with the color of the original object\n    x16 = fork(recolor, color, x15)\n    \n    # Create a function that removes the lower-right corner from an object's indices\n    x17 = fork(remove, lrcorner, toindices)\n    \n    # Create a function that checks if an object is missing its lower-right corner\n    x18 = fork(equality, toindices, x17)\n    \n    # Filter objects to keep only those missing their lower-right corner\n    x19 = sfilter(x0, x18)\n    \n    # Create a function that removes the upper-right corner from an object's indices\n    x20 = fork(remove, urcorner, toindices)\n    \n    # Create a function that checks if an object is missing its upper-right corner\n    x21 = fork(equality, toindices, x20)\n    \n    # Filter objects to keep only those missing their upper-right corner\n    x22 = sfilter(x0, x21)\n    \n    # Create a function that removes the upper-left corner from an object's indices\n    x23 = fork(remove, ulcorner, toindices)\n    \n    # Create a function that checks if an object is missing its upper-left corner\n    x24 = fork(equality, toindices, x23)\n    \n    # Filter objects to keep only those missing their upper-left corner\n    x25 = sfilter(x0, x24)\n    \n    # Create a function that removes the lower-left corner from an object's indices\n    x26 = fork(remove, llcorner, toindices)\n    \n    # Create a function that checks if an object is missing its lower-left corner\n    x27 = fork(equality, toindices, x26)\n    \n    # Filter objects to keep only those missing their lower-left corner\n    x28 = sfilter(x0, x27)\n    \n    # Apply the lower-right corner shooting function to objects missing that corner\n    x29 = mapply(x4, x19)\n    \n    # Apply the upper-right corner shooting function to objects missing that corner\n    x30 = mapply(x8, x22)\n    \n    # Combine the results of lower-right and upper-right corner shootings\n    x31 = combine(x29, x30)\n    \n    # Apply the upper-left corner shooting function to objects missing that corner\n    x32 = mapply(x12, x25)\n    \n    # Apply the lower-left corner shooting function to objects missing that corner\n    x33 = mapply(x16, x28)\n    \n    # Combine the results of upper-left and lower-left corner shootings\n    x34 = combine(x32, x33)\n    \n    # Combine all corner shooting results\n    x35 = combine(x31, x34)\n    \n    # Paint the shot lines onto the input grid, creating the output grid\n    x36 = paint(I, x35)\n    \n    # Return the final output grid\n    return x36\n"
  },
  "6e82a1ae": {
    "original": "def verify_6e82a1ae(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = matcher(size, TWO)\n    x2 = mfilter(x0, x1)\n    x3 = matcher(size, THREE)\n    x4 = mfilter(x0, x3)\n    x5 = matcher(size, FOUR)\n    x6 = mfilter(x0, x5)\n    x7 = fill(I, THREE, x2)\n    x8 = fill(x7, TWO, x4)\n    x9 = fill(x8, ONE, x6)\n    return x9\n\n",
    "annotated": "def verify_6e82a1ae(I: Grid) -> Grid:\n    # Extract all objects from the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that checks if an object has size 2\n    x1 = matcher(size, TWO)\n    \n    # Filter objects with size 2 (L-shaped corner pieces)\n    x2 = mfilter(x0, x1)\n    \n    # Create a function that checks if an object has size 3\n    x3 = matcher(size, THREE)\n    \n    # Filter objects with size 3 (T-shaped and line objects)\n    x4 = mfilter(x0, x3)\n    \n    # Create a function that checks if an object has size 4\n    x5 = matcher(size, FOUR)\n    \n    # Filter objects with size 4 (random 4-cell shapes)\n    x6 = mfilter(x0, x5)\n    \n    # Fill the input grid with color 3 where size-2 objects (L-shapes) are located\n    x7 = fill(I, THREE, x2)\n    \n    # Fill the previous grid with color 2 where size-3 objects (T-shapes and lines) are located\n    x8 = fill(x7, TWO, x4)\n    \n    # Fill the previous grid with color 1 where size-4 objects (random shapes) are located\n    x9 = fill(x8, ONE, x6)\n    \n    # Return the final grid where objects are colored based on their size/shape category\n    return x9\n"
  },
  "6ecd11f4": {
    "original": "def verify_6ecd11f4(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = argmax(x0, numcolors)\n    x2 = argmin(x0, numcolors)\n    x3 = mostcolor(I)\n    x4 = shape(x2)\n    x5 = canvas(x3, x4)\n    x6 = normalize(x2)\n    x7 = paint(x5, x6)\n    x8 = height(x1)\n    x9 = width(x1)\n    x10 = height(x2)\n    x11 = width(x2)\n    x12 = normalize(x1)\n    x13 = divide(x10, x8)\n    x14 = divide(x11, x9)\n    x15 = width(x7)\n    x16 = interval(ZERO, x15, ONE)\n    x17 = height(x7)\n    x18 = interval(ZERO, x17, ONE)\n    x19 = rbind(multiply, x14)\n    x20 = rbind(divide, x14)\n    x21 = compose(x19, x20)\n    x22 = fork(equality, identity, x21)\n    x23 = rbind(multiply, x13)\n    x24 = rbind(divide, x13)\n    x25 = compose(x23, x24)\n    x26 = fork(equality, identity, x25)\n    x27 = lbind(apply, last)\n    x28 = compose(x22, first)\n    x29 = rbind(sfilter, x28)\n    x30 = lbind(pair, x16)\n    x31 = chain(x27, x29, x30)\n    x32 = compose(x31, last)\n    x33 = pair(x18, x7)\n    x34 = compose(x26, first)\n    x35 = sfilter(x33, x34)\n    x36 = apply(x32, x35)\n    x37 = color(x2)\n    x38 = ofcolor(x36, x37)\n    x39 = rbind(contained, x38)\n    x40 = compose(x39, last)\n    x41 = sfilter(x12, x40)\n    x42 = paint(x36, x41)\n    return x42\n\n",
    "annotated": "def verify_6ecd11f4(I: Grid) -> Grid:\n    # Extract all objects from the input grid, allowing diagonal connections and excluding the background\n    x0 = objects(I, F, T, T)\n    \n    # Find the object with the most colors\n    x1 = argmax(x0, numcolors)\n    \n    # Find the object with the least colors (likely the scaled object)\n    x2 = argmin(x0, numcolors)\n    \n    # Determine the most common color in the input grid (likely the background color)\n    x3 = mostcolor(I)\n    \n    # Get the dimensions of the object with the least colors\n    x4 = shape(x2)\n    \n    # Create a canvas with the background color and dimensions of the least colorful object\n    x5 = canvas(x3, x4)\n    \n    # Normalize the position of the least colorful object (move it to origin)\n    x6 = normalize(x2)\n    \n    # Paint the normalized least colorful object onto the canvas\n    x7 = paint(x5, x6)\n    \n    # Get the height of the most colorful object\n    x8 = height(x1)\n    \n    # Get the width of the most colorful object\n    x9 = width(x1)\n    \n    # Get the height of the least colorful object\n    x10 = height(x2)\n    \n    # Get the width of the least colorful object\n    x11 = width(x2)\n    \n    # Normalize the position of the most colorful object\n    x12 = normalize(x1)\n    \n    # Calculate the vertical scaling factor\n    x13 = divide(x10, x8)\n    \n    # Calculate the horizontal scaling factor\n    x14 = divide(x11, x9)\n    \n    # Get the width of the painted canvas\n    x15 = width(x7)\n    \n    # Create a range of integers from 0 to the width of the painted canvas\n    x16 = interval(ZERO, x15, ONE)\n    \n    # Get the height of the painted canvas\n    x17 = height(x7)\n    \n    # Create a range of integers from 0 to the height of the painted canvas\n    x18 = interval(ZERO, x17, ONE)\n    \n    # Create a function that multiplies by the horizontal scaling factor\n    x19 = rbind(multiply, x14)\n    \n    # Create a function that divides by the horizontal scaling factor\n    x20 = rbind(divide, x14)\n    \n    # Compose the multiplication and division functions for horizontal scaling\n    x21 = compose(x19, x20)\n    \n    # Create a function that checks if a value is equal to its horizontally scaled version\n    x22 = fork(equality, identity, x21)\n    \n    # Create a function that multiplies by the vertical scaling factor\n    x23 = rbind(multiply, x13)\n    \n    # Create a function that divides by the vertical scaling factor\n    x24 = rbind(divide, x13)\n    \n    # Compose the multiplication and division functions for vertical scaling\n    x25 = compose(x23, x24)\n    \n    # Create a function that checks if a value is equal to its vertically scaled version\n    x26 = fork(equality, identity, x25)\n    \n    # Create a function that applies the 'last' function\n    x27 = lbind(apply, last)\n    \n    # Create a function that applies the horizontal scaling check to the first element of a pair\n    x28 = compose(x22, first)\n    \n    # Create a function that filters based on the horizontal scaling check\n    x29 = rbind(sfilter, x28)\n    \n    # Create a function that pairs the width range with an element\n    x30 = lbind(pair, x16)\n    \n    # Chain together functions to filter and process horizontal coordinates\n    x31 = chain(x27, x29, x30)\n    \n    # Create a function that applies the chained operations to the last element of a pair\n    x32 = compose(x31, last)\n    \n    # Pair the height range with the painted canvas\n    x33 = pair(x18, x7)\n    \n    # Create a function that applies the vertical scaling check to the first element of a pair\n    x34 = compose(x26, first)\n    \n    # Filter the paired height range and canvas based on the vertical scaling check\n    x35 = sfilter(x33, x34)\n    \n    # Apply the horizontal coordinate processing to the filtered vertical coordinates\n    x36 = apply(x32, x35)\n    \n    # Get the color of the least colorful object\n    x37 = color(x2)\n    \n    # Find all cells in the processed grid that match the color of the least colorful object\n    x38 = ofcolor(x36, x37)\n    \n    # Create a function that checks if a coordinate is in the set of matching color cells\n    x39 = rbind(contained, x38)\n    \n    # Create a function that applies the containment check to the last element of a pair\n    x40 = compose(x39, last)\n    \n    # Filter the normalized most colorful object based on the containment check\n    x41 = sfilter(x12, x40)\n    \n    # Paint the filtered most colorful object onto the processed grid\n    x42 = paint(x36, x41)\n    \n    # Return the final processed and painted grid\n    return x42\n"
  },
  "6f8cd79b": {
    "original": "def verify_6f8cd79b(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = fill(I, EIGHT, x1)\n    return x2\n\n",
    "annotated": "def verify_6f8cd79b(I: Grid) -> Grid:\n    # Get all indices of the input grid I\n    # This creates a set of all (row, column) coordinates in the grid\n    x0 = asindices(I)\n    \n    # Create a 'box' around the grid using the indices\n    # This generates the coordinates for the border of the grid\n    x1 = box(x0)\n    \n    # Fill the border of the input grid with the color 8\n    # This creates a new grid where the border is colored with 8, leaving the interior unchanged\n    x2 = fill(I, EIGHT, x1)\n    \n    # Return the modified grid with the border colored 8\n    # This completes the transformation by adding a border to the original input\n    return x2\n"
  },
  "6fa7a44f": {
    "original": "def verify_6fa7a44f(I: Grid) -> Grid:\n    x0 = hmirror(I)\n    x1 = vconcat(I, x0)\n    return x1\n\n",
    "annotated": "def verify_6fa7a44f(I: Grid) -> Grid:\n    # Create a horizontally mirrored version of the input grid\n    # This flips the input grid left to right\n    x0 = hmirror(I)\n    \n    # Vertically concatenate the original input grid with its mirrored version\n    # This effectively doubles the height of the grid, with the bottom half being the mirror image of the top\n    x1 = vconcat(I, x0)\n    \n    # Return the resulting grid\n    # The output is a grid twice the height of the input, with the bottom half being a horizontal mirror of the top\n    return x1\n"
  },
  "72322fa7": {
    "original": "def verify_72322fa7(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = matcher(numcolors, TWO)\n    x2 = sfilter(x0, x1)\n    x3 = apply(normalize, x2)\n    x4 = chain(first, totuple, palette)\n    x5 = chain(last, totuple, palette)\n    x6 = lbind(matcher, first)\n    x7 = compose(x6, x4)\n    x8 = lbind(matcher, first)\n    x9 = compose(x8, x5)\n    x10 = fork(sfilter, identity, x7)\n    x11 = fork(sfilter, identity, x9)\n    x12 = lbind(occurrences, I)\n    x13 = chain(invert, ulcorner, x10)\n    x14 = chain(invert, ulcorner, x11)\n    x15 = lbind(lbind, shift)\n    x16 = fork(shift, identity, x13)\n    x17 = fork(shift, identity, x14)\n    x18 = compose(x15, x16)\n    x19 = compose(x12, x10)\n    x20 = fork(mapply, x18, x19)\n    x21 = compose(x15, x17)\n    x22 = compose(x12, x11)\n    x23 = fork(mapply, x21, x22)\n    x24 = fork(combine, x20, x23)\n    x25 = mapply(x24, x3)\n    x26 = paint(I, x25)\n    return x26\n\n",
    "annotated": "def verify_72322fa7(I: Grid) -> Grid:\n    # Identify all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, F, T, T)\n    \n    # Create a function that checks if an object has exactly two colors\n    x1 = matcher(numcolors, TWO)\n    \n    # Filter objects to keep only those with two colors\n    x2 = sfilter(x0, x1)\n    \n    # Normalize the position of all two-color objects\n    x3 = apply(normalize, x2)\n    \n    # Create a function to get the first color of an object's palette\n    x4 = chain(first, totuple, palette)\n    \n    # Create a function to get the second color of an object's palette\n    x5 = chain(last, totuple, palette)\n    \n    # Create a function to match the first element (color) of a cell\n    x6 = lbind(matcher, first)\n    \n    # Compose functions to match cells with the first color of an object\n    x7 = compose(x6, x4)\n    \n    # Create another function to match the first element (color) of a cell\n    x8 = lbind(matcher, first)\n    \n    # Compose functions to match cells with the second color of an object\n    x9 = compose(x8, x5)\n    \n    # Create a function to filter an object's cells by its first color\n    x10 = fork(sfilter, identity, x7)\n    \n    # Create a function to filter an object's cells by its second color\n    x11 = fork(sfilter, identity, x9)\n    \n    # Create a function to find occurrences of a pattern in the input grid\n    x12 = lbind(occurrences, I)\n    \n    # Get the inverse of the upper-left corner of the first color part\n    x13 = chain(invert, ulcorner, x10)\n    \n    # Get the inverse of the upper-left corner of the second color part\n    x14 = chain(invert, ulcorner, x11)\n    \n    # Prepare a function for shifting\n    x15 = lbind(lbind, shift)\n    \n    # Create a function to shift the first color part\n    x16 = fork(shift, identity, x13)\n    \n    # Create a function to shift the second color part\n    x17 = fork(shift, identity, x14)\n    \n    # Compose functions for shifting the first color part\n    x18 = compose(x15, x16)\n    \n    # Find occurrences of the first color part in the input grid\n    x19 = compose(x12, x10)\n    \n    # Apply shift to all occurrences of the first color part\n    x20 = fork(mapply, x18, x19)\n    \n    # Compose functions for shifting the second color part\n    x21 = compose(x15, x17)\n    \n    # Find occurrences of the second color part in the input grid\n    x22 = compose(x12, x11)\n    \n    # Apply shift to all occurrences of the second color part\n    x23 = fork(mapply, x21, x22)\n    \n    # Combine the shifted first and second color parts\n    x24 = fork(combine, x20, x23)\n    \n    # Apply the combining operation to all normalized objects\n    x25 = mapply(x24, x3)\n    \n    # Paint the combined objects onto the input grid to create the output\n    x26 = paint(I, x25)\n    \n    # Return the final grid with all two-color objects fully revealed\n    return x26\n"
  },
  "72ca375d": {
    "original": "def verify_72ca375d(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = fork(equality, identity, vmirror)\n    x2 = extract(x0, x1)\n    x3 = subgrid(x2, I)\n    return x3\n\n",
    "annotated": "def verify_72ca375d(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including those touching the border\n    x0 = objects(I, T, T, T)\n    \n    # Create a function that checks if an object is equal to its vertical mirror\n    # This identifies symmetrical objects\n    x1 = fork(equality, identity, vmirror)\n    \n    # Find the first object in x0 that is vertically symmetrical\n    # This extracts the unique symmetrical object from the grid\n    x2 = extract(x0, x1)\n    \n    # Extract the subgrid containing only the symmetrical object\n    # This removes all other objects and returns only the target shape\n    x3 = subgrid(x2, I)\n    \n    # Return the extracted subgrid as the solution\n    # This is the output grid containing only the symmetrical object\n    return x3\n"
  },
  "73251a56": {
    "original": "def verify_73251a56(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = asindices(I)\n    x2 = urcorner(x1)\n    x3 = index(I, ORIGIN)\n    x4 = shoot(ORIGIN, UNITY)\n    x5 = recolor(x3, x4)\n    x6 = index(I, x2)\n    x7 = shoot(x2, DOWN_LEFT)\n    x8 = recolor(x6, x7)\n    x9 = astuple(dmirror, x5)\n    x10 = astuple(cmirror, x8)\n    x11 = initset(x10)\n    x12 = insert(x9, x11)\n    x13 = product(x0, x12)\n    x14 = asobject(I)\n    x15 = lbind(sfilter, x14)\n    x16 = lbind(compose, flip)\n    x17 = lbind(matcher, first)\n    x18 = chain(x15, x16, x17)\n    x19 = lbind(paint, I)\n    x20 = compose(last, last)\n    x21 = compose(first, last)\n    x22 = lbind(fork, equality)\n    x23 = rbind(x22, identity)\n    x24 = compose(x18, first)\n    x25 = compose(x23, x21)\n    x26 = compose(initset, x21)\n    x27 = fork(rapply, x26, x24)\n    x28 = compose(first, x27)\n    x29 = compose(x19, x28)\n    x30 = fork(paint, x29, x20)\n    x31 = compose(initset, x25)\n    x32 = fork(rapply, x31, x30)\n    x33 = compose(first, x32)\n    x34 = sfilter(x13, x33)\n    x35 = lbind(colorcount, I)\n    x36 = compose(x35, first)\n    x37 = argmin(x34, x36)\n    x38 = first(x37)\n    x39 = last(x37)\n    x40 = first(x39)\n    x41 = last(x37)\n    x42 = last(x41)\n    x43 = x18(x38)\n    x44 = x40(x43)\n    x45 = paint(I, x44)\n    x46 = paint(x45, x42)\n    x47 = ofcolor(x46, x38)\n    x48 = mapply(dneighbors, x47)\n    x49 = difference(x48, x47)\n    x50 = toobject(x49, x46)\n    x51 = size(x50)\n    x52 = positive(x51)\n    x53 = rbind(astuple, x38)\n    x54 = compose(last, x53)\n    x55 = branch(x52, mostcolor, x54)\n    x56 = x55(x50)\n    x57 = replace(x46, x38, x56)\n    return x57\n\n",
    "annotated": "def verify_73251a56(I: Grid) -> Grid:\n    x0 = palette(I)  # Get the set of unique colors in the input grid\n    x1 = asindices(I)  # Get all indices of the input grid\n    x2 = urcorner(x1)  # Find the upper right corner of the grid\n    x3 = index(I, ORIGIN)  # Get the color at the origin (0,0) of the grid\n    x4 = shoot(ORIGIN, UNITY)  # Create a line from origin to bottom-right corner\n    x5 = recolor(x3, x4)  # Recolor the diagonal line with the color from origin\n    x6 = index(I, x2)  # Get the color at the upper right corner\n    x7 = shoot(x2, DOWN_LEFT)  # Create a line from upper right to bottom-left\n    x8 = recolor(x6, x7)  # Recolor the anti-diagonal line with the color from upper right\n    x9 = astuple(dmirror, x5)  # Create a tuple with the diagonal mirror function and diagonal line\n    x10 = astuple(cmirror, x8)  # Create a tuple with the counter-diagonal mirror function and anti-diagonal line\n    x11 = initset(x10)  # Initialize a set with the anti-diagonal mirror tuple\n    x12 = insert(x9, x11)  # Insert the diagonal mirror tuple into the set\n    x13 = product(x0, x12)  # Create all possible combinations of colors and mirror operations\n    x14 = asobject(I)  # Convert the input grid to an object representation\n    x15 = lbind(sfilter, x14)  # Partially apply sfilter with the grid object\n    x16 = lbind(compose, flip)  # Prepare to compose with the flip function\n    x17 = lbind(matcher, first)  # Prepare to match the first element\n    x18 = chain(x15, x16, x17)  # Chain these operations: filter grid, flip, match first\n    x19 = lbind(paint, I)  # Partially apply paint with the input grid\n    x20 = compose(last, last)  # Compose functions to get the last of the last\n    x21 = compose(first, last)  # Compose functions to get the first of the last\n    x22 = lbind(fork, equality)  # Prepare to fork with the equality function\n    x23 = rbind(x22, identity)  # Bind the identity function as the second argument\n    x24 = compose(x18, first)  # Compose the chain of operations with getting the first element\n    x25 = compose(x23, x21)  # Compose the equality fork with getting the first of the last\n    x26 = compose(initset, x21)  # Compose initializing a set with getting the first of the last\n    x27 = fork(rapply, x26, x24)  # Fork to apply functions from x26 and x24\n    x28 = compose(first, x27)  # Get the first result of the fork operation\n    x29 = compose(x19, x28)  # Compose painting the grid with the result of x28\n    x30 = fork(paint, x29, x20)  # Fork to paint using results from x29 and x20\n    x31 = compose(initset, x25)  # Compose initializing a set with the result of x25\n    x32 = fork(rapply, x31, x30)  # Fork to apply functions from x31 and x30\n    x33 = compose(first, x32)  # Get the first result of the fork operation\n    x34 = sfilter(x13, x33)  # Filter the color-mirror combinations using the condition in x33\n    x35 = lbind(colorcount, I)  # Partially apply colorcount with the input grid\n    x36 = compose(x35, first)  # Compose counting colors with getting the first element\n    x37 = argmin(x34, x36)  # Find the color-mirror combination that minimizes the color count\n    x38 = first(x37)  # Get the color from the chosen combination\n    x39 = last(x37)  # Get the mirror operation from the chosen combination\n    x40 = first(x39)  # Get the mirror function\n    x41 = last(x37)  # Get the mirror operation again (same as x39)\n    x42 = last(x41)  # Get the line to be mirrored\n    x43 = x18(x38)  # Apply the chain of operations to the chosen color\n    x44 = x40(x43)  # Apply the chosen mirror function to the result\n    x45 = paint(I, x44)  # Paint the input grid with the mirrored result\n    x46 = paint(x45, x42)  # Paint the diagonal or anti-diagonal line\n    x47 = ofcolor(x46, x38)  # Find all cells with the chosen color\n    x48 = mapply(dneighbors, x47)  # Get all direct neighbors of the colored cells\n    x49 = difference(x48, x47)  # Find neighbors that are not of the chosen color\n    x50 = toobject(x49, x46)  # Convert these neighbors to an object representation\n    x51 = size(x50)  # Count the number of these neighbor cells\n    x52 = positive(x51)  # Check if there are any such neighbors\n    x53 = rbind(astuple, x38)  # Prepare to create a tuple with the chosen color\n    x54 = compose(last, x53)  # Compose getting the last element with creating the tuple\n    x55 = branch(x52, mostcolor, x54)  # Choose between mostcolor and x54 based on x52\n    x56 = x55(x50)  # Apply the chosen function to the neighbor cells\n    x57 = replace(x46, x38, x56)  # Replace the chosen color with the result in the grid\n    return x57  # Return the final modified grid\n"
  },
  "7447852a": {
    "original": "def verify_7447852a(I: Grid) -> Grid:\n    x0 = index(I, ORIGIN)\n    x1 = shape(I)\n    x2 = canvas(x0, x1)\n    x3 = hconcat(I, x2)\n    x4 = objects(x3, F, F, T)\n    x5 = compose(last, centerofmass)\n    x6 = order(x4, x5)\n    x7 = size(x6)\n    x8 = interval(ZERO, x7, ONE)\n    x9 = pair(x6, x8)\n    x10 = rbind(multiply, THREE)\n    x11 = rbind(divide, THREE)\n    x12 = chain(x10, x11, last)\n    x13 = fork(equality, last, x12)\n    x14 = sfilter(x9, x13)\n    x15 = mapply(first, x14)\n    x16 = fill(I, FOUR, x15)\n    return x16\n\n",
    "annotated": "def verify_7447852a(I: Grid) -> Grid:\n    # Get the color of the top-left cell of the input grid\n    x0 = index(I, ORIGIN)\n    \n    # Get the dimensions (height, width) of the input grid\n    x1 = shape(I)\n    \n    # Create a new grid with the same dimensions as I, filled with the color from the top-left cell\n    x2 = canvas(x0, x1)\n    \n    # Concatenate the input grid I with the new canvas horizontally\n    # This effectively doubles the width of the grid\n    x3 = hconcat(I, x2)\n    \n    # Identify objects in the concatenated grid, ignoring the background color\n    x4 = objects(x3, F, F, T)\n    \n    # Create a function that finds the center of mass of an object and returns its last (rightmost) coordinate\n    x5 = compose(last, centerofmass)\n    \n    # Order the objects based on their rightmost coordinate\n    x6 = order(x4, x5)\n    \n    # Get the number of objects\n    x7 = size(x6)\n    \n    # Create a range of integers from 0 to the number of objects\n    x8 = interval(ZERO, x7, ONE)\n    \n    # Pair each object with its index\n    x9 = pair(x6, x8)\n    \n    # Create a function that multiplies by 3\n    x10 = rbind(multiply, THREE)\n    \n    # Create a function that divides by 3\n    x11 = rbind(divide, THREE)\n    \n    # Chain functions: multiply by 3, divide by 3, and take the last element\n    # This effectively checks if a number is divisible by 3\n    x12 = chain(x10, x11, last)\n    \n    # Create a function that checks if the last element (index) is equal to its multiple of 3 divided by 3\n    # This identifies every third object\n    x13 = fork(equality, last, x12)\n    \n    # Filter the paired objects, keeping only every third object\n    x14 = sfilter(x9, x13)\n    \n    # Extract just the objects (without their indices) from the filtered pairs\n    x15 = mapply(first, x14)\n    \n    # Fill the selected objects (every third one) with color 4 in the original input grid\n    # This is the final transformation: coloring every third object with color 4\n    x16 = fill(I, FOUR, x15)\n    \n    # Return the modified grid\n    return x16\n"
  },
  "7468f01a": {
    "original": "def verify_7468f01a(I: Grid) -> Grid:\n    x0 = compress(I)\n    x1 = vmirror(x0)\n    return x1\n\n",
    "annotated": "def verify_7468f01a(I: Grid) -> Grid:\n    # Remove any uniform rows or columns from the input grid\n    # This effectively crops the grid to the smallest rectangle containing the shape\n    x0 = compress(I)\n    \n    # Mirror the compressed grid vertically\n    # This reverses the vertical mirroring applied in the generator\n    x1 = vmirror(x0)\n    \n    # Return the vertically mirrored grid as the output\n    # This should match the original shape created in the generator\n    return x1\n"
  },
  "746b3537": {
    "original": "def verify_746b3537(I: Grid) -> Grid:\n    x0 = first(I)\n    x1 = dedupe(x0)\n    x2 = size(x1)\n    x3 = equality(ONE, x2)\n    x4 = branch(x3, dmirror, identity)\n    x5 = x4(I)\n    x6 = objects(x5, T, F, F)\n    x7 = order(x6, leftmost)\n    x8 = apply(color, x7)\n    x9 = repeat(x8, ONE)\n    x10 = x4(x9)\n    return x10\n\n",
    "annotated": "def verify_746b3537(I: Grid) -> Grid:\n    # Get the first row of the input grid\n    x0 = first(I)\n    \n    # Remove duplicate colors from the first row\n    x1 = dedupe(x0)\n    \n    # Count the number of unique colors in the first row\n    x2 = size(x1)\n    \n    # Check if there's only one unique color in the first row\n    x3 = equality(ONE, x2)\n    \n    # If there's only one color, use dmirror function; otherwise, use identity function\n    # This determines if we need to diagonally mirror the grid or not\n    x4 = branch(x3, dmirror, identity)\n    \n    # Apply the chosen function (dmirror or identity) to the input grid\n    x5 = x4(I)\n    \n    # Find all objects in the grid, considering adjacent cells of the same color as one object\n    # Allow different colors (T), don't consider diagonal connections (F), don't exclude background (F)\n    x6 = objects(x5, T, F, F)\n    \n    # Sort the objects based on their leftmost position\n    x7 = order(x6, leftmost)\n    \n    # Extract the color of each object\n    x8 = apply(color, x7)\n    \n    # Create a new grid where each row is a single-cell column with the extracted color\n    x9 = repeat(x8, ONE)\n    \n    # Apply the same transformation (dmirror or identity) as used on the input\n    x10 = x4(x9)\n    \n    # Return the final transformed grid\n    return x10\n"
  },
  "74dd1130": {
    "original": "def verify_74dd1130(I: Grid) -> Grid:\n    x0 = dmirror(I)\n    return x0\n\n",
    "annotated": "def verify_74dd1130(I: Grid) -> Grid:\n    # Mirror the input grid I along the diagonal\n    # This operation swaps rows and columns, effectively rotating the grid and flipping it\n    x0 = dmirror(I)\n    \n    # Return the diagonally mirrored grid\n    # This is the final output of the ARC task, transforming the input into its diagonal mirror image\n    return x0\n"
  },
  "75b8110e": {
    "original": "def verify_75b8110e(I: Grid) -> Grid:\n    x0 = tophalf(I)\n    x1 = lefthalf(x0)\n    x2 = tophalf(I)\n    x3 = righthalf(x2)\n    x4 = bottomhalf(I)\n    x5 = righthalf(x4)\n    x6 = bottomhalf(I)\n    x7 = lefthalf(x6)\n    x8 = palette(x1)\n    x9 = palette(x3)\n    x10 = intersection(x8, x9)\n    x11 = palette(x5)\n    x12 = palette(x7)\n    x13 = intersection(x11, x12)\n    x14 = intersection(x10, x13)\n    x15 = first(x14)\n    x16 = shape(x1)\n    x17 = canvas(x15, x16)\n    x18 = matcher(first, x15)\n    x19 = compose(flip, x18)\n    x20 = rbind(sfilter, x19)\n    x21 = compose(x20, asobject)\n    x22 = x21(x1)\n    x23 = x21(x5)\n    x24 = x21(x7)\n    x25 = x21(x3)\n    x26 = paint(x17, x22)\n    x27 = paint(x26, x23)\n    x28 = paint(x27, x24)\n    x29 = paint(x28, x25)\n    return x29\n\n",
    "annotated": "def verify_75b8110e(I: Grid) -> Grid:\n    # Get the top half of the input grid\n    x0 = tophalf(I)\n    # Get the left half of the top half\n    x1 = lefthalf(x0)\n    # Get the top half of the input grid (again)\n    x2 = tophalf(I)\n    # Get the right half of the top half\n    x3 = righthalf(x2)\n    # Get the bottom half of the input grid\n    x4 = bottomhalf(I)\n    # Get the right half of the bottom half\n    x5 = righthalf(x4)\n    # Get the bottom half of the input grid (again)\n    x6 = bottomhalf(I)\n    # Get the left half of the bottom half\n    x7 = lefthalf(x6)\n    # Get the set of colors in the top-left quadrant\n    x8 = palette(x1)\n    # Get the set of colors in the top-right quadrant\n    x9 = palette(x3)\n    # Find colors common to top-left and top-right quadrants\n    x10 = intersection(x8, x9)\n    # Get the set of colors in the bottom-right quadrant\n    x11 = palette(x5)\n    # Get the set of colors in the bottom-left quadrant\n    x12 = palette(x7)\n    # Find colors common to bottom-right and bottom-left quadrants\n    x13 = intersection(x11, x12)\n    # Find colors common to all quadrants\n    x14 = intersection(x10, x13)\n    # Get the first (and likely only) color common to all quadrants\n    x15 = first(x14)\n    # Get the dimensions of the top-left quadrant\n    x16 = shape(x1)\n    # Create a new grid with the common color and size of a quadrant\n    x17 = canvas(x15, x16)\n    # Create a function to match the common color\n    x18 = matcher(first, x15)\n    # Create a function to match colors different from the common color\n    x19 = compose(flip, x18)\n    # Create a function to filter objects based on color difference\n    x20 = rbind(sfilter, x19)\n    # Create a function to convert grid to object and filter by color\n    x21 = compose(x20, asobject)\n    # Apply the filter function to the top-left quadrant\n    x22 = x21(x1)\n    # Apply the filter function to the bottom-right quadrant\n    x23 = x21(x5)\n    # Apply the filter function to the bottom-left quadrant\n    x24 = x21(x7)\n    # Apply the filter function to the top-right quadrant\n    x25 = x21(x3)\n    # Paint the filtered top-left quadrant onto the new grid\n    x26 = paint(x17, x22)\n    # Paint the filtered bottom-right quadrant onto the result\n    x27 = paint(x26, x23)\n    # Paint the filtered bottom-left quadrant onto the result\n    x28 = paint(x27, x24)\n    # Paint the filtered top-right quadrant onto the result\n    x29 = paint(x28, x25)\n    # Return the final painted grid\n    return x29\n"
  },
  "760b3cac": {
    "original": "def verify_760b3cac(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = matcher(shape, THREE_BY_THREE)\n    x2 = matcher(size, FIVE)\n    x3 = fork(intersection, toindices, box)\n    x4 = compose(size, x3)\n    x5 = matcher(x4, FOUR)\n    x6 = fork(intersection, toindices, corners)\n    x7 = compose(size, x6)\n    x8 = matcher(x7, ONE)\n    x9 = fork(both, x1, x2)\n    x10 = fork(both, x5, x8)\n    x11 = fork(both, x9, x10)\n    x12 = extract(x0, x11)\n    x13 = toindices(x12)\n    x14 = lowermost(x12)\n    x15 = matcher(first, x14)\n    x16 = uppermost(x12)\n    x17 = matcher(first, x16)\n    x18 = rightmost(x12)\n    x19 = matcher(last, x18)\n    x20 = leftmost(x12)\n    x21 = matcher(last, x20)\n    x22 = sfilter(x13, x15)\n    x23 = size(x22)\n    x24 = equality(x23, TWO)\n    x25 = sfilter(x13, x17)\n    x26 = size(x25)\n    x27 = equality(x26, TWO)\n    x28 = sfilter(x13, x19)\n    x29 = size(x28)\n    x30 = equality(x29, TWO)\n    x31 = sfilter(x13, x21)\n    x32 = size(x31)\n    x33 = equality(x32, TWO)\n    x34 = either(x24, x27)\n    x35 = branch(x34, hmirror, vmirror)\n    x36 = multiply(x24, DOWN)\n    x37 = multiply(x27, UP)\n    x38 = add(x36, x37)\n    x39 = multiply(x30, RIGHT)\n    x40 = multiply(x33, LEFT)\n    x41 = add(x39, x40)\n    x42 = add(x38, x41)\n    x43 = other(x0, x12)\n    x44 = x35(x43)\n    x45 = shape(x43)\n    x46 = multiply(x45, x42)\n    x47 = shift(x44, x46)\n    x48 = paint(I, x47)\n    return x48\n\n",
    "annotated": "def verify_760b3cac(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    \n    # Create a matcher function for 3x3 shapes\n    x1 = matcher(shape, THREE_BY_THREE)\n    \n    # Create a matcher function for objects with size 5\n    x2 = matcher(size, FIVE)\n    \n    # Create a function to find the intersection of an object's indices and its bounding box\n    x3 = fork(intersection, toindices, box)\n    \n    # Create a function to get the size of the intersection found by x3\n    x4 = compose(size, x3)\n    \n    # Create a matcher function for objects with 4 cells on their border\n    x5 = matcher(x4, FOUR)\n    \n    # Create a function to find the intersection of an object's indices and its corners\n    x6 = fork(intersection, toindices, corners)\n    \n    # Create a function to get the size of the intersection found by x6\n    x7 = compose(size, x6)\n    \n    # Create a matcher function for objects with 1 cell as a corner\n    x8 = matcher(x7, ONE)\n    \n    # Combine matchers for 3x3 shape and size 5\n    x9 = fork(both, x1, x2)\n    \n    # Combine matchers for 4 border cells and 1 corner cell\n    x10 = fork(both, x5, x8)\n    \n    # Combine all matchers to identify the L-shaped indicator\n    x11 = fork(both, x9, x10)\n    \n    # Extract the L-shaped indicator from the partitioned objects\n    x12 = extract(x0, x11)\n    \n    # Get the indices of the L-shaped indicator\n    x13 = toindices(x12)\n    \n    # Get the lowermost row of the L-shaped indicator\n    x14 = lowermost(x12)\n    \n    # Create a matcher for the first element of the lowermost row\n    x15 = matcher(first, x14)\n    \n    # Get the uppermost row of the L-shaped indicator\n    x16 = uppermost(x12)\n    \n    # Create a matcher for the first element of the uppermost row\n    x17 = matcher(first, x16)\n    \n    # Get the rightmost column of the L-shaped indicator\n    x18 = rightmost(x12)\n    \n    # Create a matcher for the last element of the rightmost column\n    x19 = matcher(last, x18)\n    \n    # Get the leftmost column of the L-shaped indicator\n    x20 = leftmost(x12)\n    \n    # Create a matcher for the last element of the leftmost column\n    x21 = matcher(last, x20)\n    \n    # Filter indices in the bottom row of the L-shape\n    x22 = sfilter(x13, x15)\n    \n    # Count the number of cells in the bottom row\n    x23 = size(x22)\n    \n    # Check if there are exactly two cells in the bottom row\n    x24 = equality(x23, TWO)\n    \n    # Filter indices in the top row of the L-shape\n    x25 = sfilter(x13, x17)\n    \n    # Count the number of cells in the top row\n    x26 = size(x25)\n    \n    # Check if there are exactly two cells in the top row\n    x27 = equality(x26, TWO)\n    \n    # Filter indices in the rightmost column of the L-shape\n    x28 = sfilter(x13, x19)\n    \n    # Count the number of cells in the rightmost column\n    x29 = size(x28)\n    \n    # Check if there are exactly two cells in the rightmost column\n    x30 = equality(x29, TWO)\n    \n    # Filter indices in the leftmost column of the L-shape\n    x31 = sfilter(x13, x21)\n    \n    # Count the number of cells in the leftmost column\n    x32 = size(x31)\n    \n    # Check if there are exactly two cells in the leftmost column\n    x33 = equality(x32, TWO)\n    \n    # Check if the L-shape is either pointing down or up\n    x34 = either(x24, x27)\n    \n    # Choose between horizontal or vertical mirroring based on L-shape orientation\n    x35 = branch(x34, hmirror, vmirror)\n    \n    # Calculate vertical offset if L-shape is pointing down\n    x36 = multiply(x24, DOWN)\n    \n    # Calculate vertical offset if L-shape is pointing up\n    x37 = multiply(x27, UP)\n    \n    # Combine vertical offsets\n    x38 = add(x36, x37)\n    \n    # Calculate horizontal offset if L-shape is pointing right\n    x39 = multiply(x30, RIGHT)\n    \n    # Calculate horizontal offset if L-shape is pointing left\n    x40 = multiply(x33, LEFT)\n    \n    # Combine horizontal offsets\n    x41 = add(x39, x40)\n    \n    # Combine all offsets to get the final direction vector\n    x42 = add(x38, x41)\n    \n    # Get the other object (not the L-shape) from the partitioned objects\n    x43 = other(x0, x12)\n    \n    # Mirror the other object based on the L-shape orientation\n    x44 = x35(x43)\n    \n    # Get the shape (dimensions) of the other object\n    x45 = shape(x43)\n    \n    # Calculate the offset for placing the mirrored object\n    x46 = multiply(x45, x42)\n    \n    # Shift the mirrored object to its new position\n    x47 = shift(x44, x46)\n    \n    # Paint the mirrored object onto the input grid to create the output\n    x48 = paint(I, x47)\n    \n    # Return the modified grid as the output\n    return x48\n"
  },
  "776ffc46": {
    "original": "def verify_776ffc46(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = fork(equality, toindices, box)\n    x2 = sfilter(x0, x1)\n    x3 = fork(multiply, height, width)\n    x4 = argmax(x2, x3)\n    x5 = mostcolor(I)\n    x6 = inbox(x4)\n    x7 = backdrop(x6)\n    x8 = toobject(x7, I)\n    x9 = matcher(first, x5)\n    x10 = compose(flip, x9)\n    x11 = sfilter(x8, x10)\n    x12 = normalize(x11)\n    x13 = color(x12)\n    x14 = toindices(x12)\n    x15 = compose(toindices, normalize)\n    x16 = matcher(x15, x14)\n    x17 = mfilter(x0, x16)\n    x18 = fill(I, x13, x17)\n    return x18\n\n",
    "annotated": "def verify_776ffc46(I: Grid) -> Grid:\n    # Find all objects in the input grid, including those touching the border\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x1 = fork(equality, toindices, box)\n    \n    # Filter objects to keep only those that are perfect rectangles (squares)\n    x2 = sfilter(x0, x1)\n    \n    # Create a function that calculates the area of an object\n    x3 = fork(multiply, height, width)\n    \n    # Find the largest rectangular object (the outer square)\n    x4 = argmax(x2, x3)\n    \n    # Determine the most common color in the input grid (background color)\n    x5 = mostcolor(I)\n    \n    # Get the inner boundary of the largest square\n    x6 = inbox(x4)\n    \n    # Get all cells within the inner boundary\n    x7 = backdrop(x6)\n    \n    # Create an object from the cells within the inner boundary\n    x8 = toobject(x7, I)\n    \n    # Create a function that checks if a cell's color is not the background color\n    x9 = matcher(first, x5)\n    x10 = compose(flip, x9)\n    \n    # Filter the inner cells to keep only non-background colored cells (the inner object)\n    x11 = sfilter(x8, x10)\n    \n    # Normalize the position of the inner object\n    x12 = normalize(x11)\n    \n    # Get the color of the inner object\n    x13 = color(x12)\n    \n    # Get the indices of the normalized inner object\n    x14 = toindices(x12)\n    \n    # Create a function that normalizes an object's indices\n    x15 = compose(toindices, normalize)\n    \n    # Create a function that checks if an object matches the inner object's shape\n    x16 = matcher(x15, x14)\n    \n    # Find all objects in the input grid that match the inner object's shape\n    x17 = mfilter(x0, x16)\n    \n    # Fill all matching objects with the color of the inner object\n    x18 = fill(I, x13, x17)\n    \n    # Return the modified grid as the output\n    return x18\n"
  },
  "77fdfe62": {
    "original": "def verify_77fdfe62(I: Grid) -> Grid:\n    x0 = trim(I)\n    x1 = trim(x0)\n    x2 = tophalf(x1)\n    x3 = lefthalf(x2)\n    x4 = tophalf(x1)\n    x5 = righthalf(x4)\n    x6 = bottomhalf(x1)\n    x7 = lefthalf(x6)\n    x8 = bottomhalf(x1)\n    x9 = righthalf(x8)\n    x10 = index(I, ORIGIN)\n    x11 = width(I)\n    x12 = decrement(x11)\n    x13 = tojvec(x12)\n    x14 = index(I, x13)\n    x15 = height(I)\n    x16 = decrement(x15)\n    x17 = toivec(x16)\n    x18 = index(I, x17)\n    x19 = shape(I)\n    x20 = decrement(x19)\n    x21 = index(I, x20)\n    x22 = compress(I)\n    x23 = asindices(x22)\n    x24 = box(x23)\n    x25 = corners(x23)\n    x26 = difference(x24, x25)\n    x27 = toobject(x26, x22)\n    x28 = color(x27)\n    x29 = palette(x1)\n    x30 = other(x29, x28)\n    x31 = replace(x3, x30, x10)\n    x32 = replace(x5, x30, x14)\n    x33 = replace(x7, x30, x18)\n    x34 = replace(x9, x30, x21)\n    x35 = hconcat(x31, x32)\n    x36 = hconcat(x33, x34)\n    x37 = vconcat(x35, x36)\n    return x37\n\n",
    "annotated": "def verify_77fdfe62(I: Grid) -> Grid:\n    # Remove the outermost border of the input grid\n    x0 = trim(I)\n    # Remove the inner border, leaving only the four quadrants\n    x1 = trim(x0)\n    # Extract the top half of the grid (upper two quadrants)\n    x2 = tophalf(x1)\n    # Extract the left half of the top half (top-left quadrant)\n    x3 = lefthalf(x2)\n    # Extract the top half of the grid again (redundant, same as x2)\n    x4 = tophalf(x1)\n    # Extract the right half of the top half (top-right quadrant)\n    x5 = righthalf(x4)\n    # Extract the bottom half of the grid (lower two quadrants)\n    x6 = bottomhalf(x1)\n    # Extract the left half of the bottom half (bottom-left quadrant)\n    x7 = lefthalf(x6)\n    # Extract the bottom half of the grid again (redundant, same as x6)\n    x8 = bottomhalf(x1)\n    # Extract the right half of the bottom half (bottom-right quadrant)\n    x9 = righthalf(x8)\n    # Get the color of the top-left corner of the original input grid\n    x10 = index(I, ORIGIN)\n    # Get the width of the original input grid\n    x11 = width(I)\n    # Subtract 1 from the width\n    x12 = decrement(x11)\n    # Create a vector pointing to the right edge of the grid\n    x13 = tojvec(x12)\n    # Get the color of the top-right corner of the original input grid\n    x14 = index(I, x13)\n    # Get the height of the original input grid\n    x15 = height(I)\n    # Subtract 1 from the height\n    x16 = decrement(x15)\n    # Create a vector pointing to the bottom edge of the grid\n    x17 = toivec(x16)\n    # Get the color of the bottom-left corner of the original input grid\n    x18 = index(I, x17)\n    # Get the shape (height, width) of the original input grid\n    x19 = shape(I)\n    # Subtract 1 from both height and width\n    x20 = decrement(x19)\n    # Get the color of the bottom-right corner of the original input grid\n    x21 = index(I, x20)\n    # Remove all uniform rows and columns from the grid (i.e., the borders)\n    x22 = compress(I)\n    # Get all indices of the compressed grid\n    x23 = asindices(x22)\n    # Get the outline of the compressed grid\n    x24 = box(x23)\n    # Get the corner indices of the compressed grid\n    x25 = corners(x23)\n    # Get the outline indices without the corners\n    x26 = difference(x24, x25)\n    # Create an object from the outline indices (excluding corners) using the compressed grid\n    x27 = toobject(x26, x22)\n    # Get the color of the outline object (which should be the border color)\n    x28 = color(x27)\n    # Get all colors used in the grid (excluding borders)\n    x29 = palette(x1)\n    # Get the color that's not the border color (should be the color used for the pattern)\n    x30 = other(x29, x28)\n    # Replace the pattern color in the top-left quadrant with the top-left corner color\n    x31 = replace(x3, x30, x10)\n    # Replace the pattern color in the top-right quadrant with the top-right corner color\n    x32 = replace(x5, x30, x14)\n    # Replace the pattern color in the bottom-left quadrant with the bottom-left corner color\n    x33 = replace(x7, x30, x18)\n    # Replace the pattern color in the bottom-right quadrant with the bottom-right corner color\n    x34 = replace(x9, x30, x21)\n    # Concatenate the top two quadrants horizontally\n    x35 = hconcat(x31, x32)\n    # Concatenate the bottom two quadrants horizontally\n    x36 = hconcat(x33, x34)\n    # Concatenate the top and bottom halves vertically to form the final output grid\n    x37 = vconcat(x35, x36)\n    # Return the final output grid\n    return x37\n"
  },
  "780d0b14": {
    "original": "def verify_780d0b14(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = merge(x0)\n    x4 = fill(I, NEG_ONE, x3)\n    x5 = shape(I)\n    x6 = canvas(NEG_ONE, x5)\n    x7 = hconcat(x4, x6)\n    x8 = objects(x7, F, F, T)\n    x9 = rbind(other, x2)\n    x10 = compose(x9, palette)\n    x11 = fork(astuple, x10, ulcorner)\n    x12 = apply(x11, x8)\n    x13 = merge(x8)\n    x14 = fill(I, x2, x13)\n    x15 = paint(x14, x12)\n    x16 = compress(x15)\n    return x16\n\n",
    "annotated": "def verify_780d0b14(I: Grid) -> Grid:\n    # Identify all frontiers (rows or columns with same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Get the color of the merged frontiers (background color)\n    x2 = color(x1)\n    \n    # Merge all frontiers again (same as x1)\n    x3 = merge(x0)\n    \n    # Fill all frontier cells with -1, effectively removing the background grid\n    x4 = fill(I, NEG_ONE, x3)\n    \n    # Get the shape (dimensions) of the input grid\n    x5 = shape(I)\n    \n    # Create a new canvas of the same size as the input, filled with -1\n    x6 = canvas(NEG_ONE, x5)\n    \n    # Concatenate the modified input grid (x4) with the new canvas horizontally\n    x7 = hconcat(x4, x6)\n    \n    # Identify all objects in the concatenated grid, ignoring background\n    x8 = objects(x7, F, F, T)\n    \n    # Create a function that returns colors other than the background color\n    x9 = rbind(other, x2)\n    \n    # Create a function that gets the palette of an object, excluding background\n    x10 = compose(x9, palette)\n    \n    # Create a function that returns a tuple of (color, upper-left corner) for each object\n    x11 = fork(astuple, x10, ulcorner)\n    \n    # Apply the function to all objects, getting color and position information\n    x12 = apply(x11, x8)\n    \n    # Merge all objects into a single object\n    x13 = merge(x8)\n    \n    # Fill the input grid with the background color where objects were\n    x14 = fill(I, x2, x13)\n    \n    # Paint the objects back onto the grid using their color and position info\n    x15 = paint(x14, x12)\n    \n    # Remove all background rows and columns, compressing the grid\n    x16 = compress(x15)\n    \n    # Return the compressed grid, which is the solution to the puzzle\n    return x16\n"
  },
  "7837ac64": {
    "original": "def verify_7837ac64(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = sfilter(x0, x1)\n    x3 = fork(multiply, height, width)\n    x4 = argmax(x2, x3)\n    x5 = color(x4)\n    x6 = palette(I)\n    x7 = remove(x5, x6)\n    x8 = lbind(colorcount, I)\n    x9 = argmax(x7, x8)\n    x10 = remove(x9, x7)\n    x11 = lbind(ofcolor, I)\n    x12 = mapply(x11, x10)\n    x13 = subgrid(x12, I)\n    x14 = objects(x13, T, F, F)\n    x15 = colorfilter(x14, x5)\n    x16 = initset(x9)\n    x17 = insert(x5, x16)\n    x18 = lbind(intersection, x17)\n    x19 = chain(positive, size, x18)\n    x20 = chain(positive, decrement, size)\n    x21 = fork(either, x19, x20)\n    x22 = rbind(toobject, x13)\n    x23 = compose(corners, outbox)\n    x24 = chain(palette, x22, x23)\n    x25 = rbind(branch, x5)\n    x26 = chain(flip, x21, x24)\n    x27 = compose(first, x24)\n    x28 = fork(x25, x26, x27)\n    x29 = apply(uppermost, x15)\n    x30 = order(x29, identity)\n    x31 = lbind(apply, x28)\n    x32 = rbind(order, leftmost)\n    x33 = lbind(sfilter, x15)\n    x34 = lbind(matcher, uppermost)\n    x35 = compose(x33, x34)\n    x36 = chain(x31, x32, x35)\n    x37 = apply(x36, x30)\n    return x37\n\n",
    "annotated": "def verify_7837ac64(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that checks if an object's indices match its backdrop\n    x1 = fork(equality, toindices, backdrop)\n    \n    # Filter objects that are perfect rectangles (indices match backdrop)\n    x2 = sfilter(x0, x1)\n    \n    # Create a function to calculate the area of an object\n    x3 = fork(multiply, height, width)\n    \n    # Find the largest rectangular object (likely the background)\n    x4 = argmax(x2, x3)\n    \n    # Get the color of the largest rectangular object (background color)\n    x5 = color(x4)\n    \n    # Get all colors used in the input grid\n    x6 = palette(I)\n    \n    # Remove the background color from the palette\n    x7 = remove(x5, x6)\n    \n    # Create a function to count occurrences of a color in the input grid\n    x8 = lbind(colorcount, I)\n    \n    # Find the most common non-background color (likely the grid line color)\n    x9 = argmax(x7, x8)\n    \n    # Remove the grid line color from the remaining colors\n    x10 = remove(x9, x7)\n    \n    # Create a function to find cells of a specific color in the input grid\n    x11 = lbind(ofcolor, I)\n    \n    # Find all cells that are neither background nor grid line color\n    x12 = mapply(x11, x10)\n    \n    # Extract the subgrid containing only the pattern cells\n    x13 = subgrid(x12, I)\n    \n    # Extract objects from the pattern subgrid\n    x14 = objects(x13, T, F, F)\n    \n    # Filter objects that have the background color (squares in the pattern)\n    x15 = colorfilter(x14, x5)\n    \n    # Create a set with the grid line color\n    x16 = initset(x9)\n    \n    # Add the background color to the set\n    x17 = insert(x5, x16)\n    \n    # Create a function to check intersection with background and grid colors\n    x18 = lbind(intersection, x17)\n    \n    # Create a function to check if an object has any background or grid colors\n    x19 = chain(positive, size, x18)\n    \n    # Create a function to check if an object has only one non-background/grid color\n    x20 = chain(positive, decrement, size)\n    \n    # Combine the two conditions: either has bg/grid color or only one other color\n    x21 = fork(either, x19, x20)\n    \n    # Create a function to convert indices to an object in the pattern subgrid\n    x22 = rbind(toobject, x13)\n    \n    # Create a function to get the corners of an object's outbox\n    x23 = compose(corners, outbox)\n    \n    # Create a function to get colors of the corners of an object's outbox\n    x24 = chain(palette, x22, x23)\n    \n    # Create a function to choose between background color and another value\n    x25 = rbind(branch, x5)\n    \n    # Create a function to determine if an object should keep its color\n    x26 = chain(flip, x21, x24)\n    \n    # Create a function to get the first color of an object's corner palette\n    x27 = compose(first, x24)\n    \n    # Combine functions to determine the final color of an object\n    x28 = fork(x25, x26, x27)\n    \n    # Get the uppermost positions of all squares in the pattern\n    x29 = apply(uppermost, x15)\n    \n    # Sort the squares by their uppermost positions (top to bottom)\n    x30 = order(x29, identity)\n    \n    # Create a function to apply the color determination to a row of squares\n    x31 = lbind(apply, x28)\n    \n    # Create a function to sort a row of squares from left to right\n    x32 = rbind(order, leftmost)\n    \n    # Create a function to filter squares in a specific row\n    x33 = lbind(sfilter, x15)\n    \n    # Create a function to match squares with a specific uppermost position\n    x34 = lbind(matcher, uppermost)\n    \n    # Combine functions to get and sort squares in a specific row\n    x35 = compose(x33, x34)\n    \n    # Create a function to process each row of squares\n    x36 = chain(x31, x32, x35)\n    \n    # Apply the row processing function to all rows, top to bottom\n    x37 = apply(x36, x30)\n    \n    # Return the final processed grid, representing the solution\n    return x37\n"
  },
  "794b24be": {
    "original": "def verify_794b24be(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = remove(ONE, x0)\n    x2 = lbind(colorcount, I)\n    x3 = argmax(x1, x2)\n    x4 = canvas(x3, THREE_BY_THREE)\n    x5 = colorcount(I, ONE)\n    x6 = decrement(x5)\n    x7 = tojvec(x6)\n    x8 = connect(ORIGIN, x7)\n    x9 = fill(x4, TWO, x8)\n    x10 = initset(UNITY)\n    x11 = equality(x5, FOUR)\n    x12 = branch(x11, x10, x8)\n    x13 = fill(x9, TWO, x12)\n    return x13\n\n",
    "annotated": "def verify_794b24be(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Remove color 1 (blue in input) from the color set\n    x1 = remove(ONE, x0)\n    \n    # Create a function that counts occurrences of each color in the input grid\n    x2 = lbind(colorcount, I)\n    \n    # Find the most common color among the remaining colors (background color)\n    x3 = argmax(x1, x2)\n    \n    # Create a 3x3 grid filled with the background color\n    x4 = canvas(x3, THREE_BY_THREE)\n    \n    # Count the number of blue cells (color 1) in the input grid\n    x5 = colorcount(I, ONE)\n    \n    # Decrease the count by 1 (to use as an index)\n    x6 = decrement(x5)\n    \n    # Create a horizontal vector with the decreased count\n    x7 = tojvec(x6)\n    \n    # Create a line from (0,0) to the point defined by the vector\n    # This determines which cells in the 3x3 grid should be filled\n    x8 = connect(ORIGIN, x7)\n    \n    # Fill the determined cells in the 3x3 grid with color 2 (blue in output)\n    x9 = fill(x4, TWO, x8)\n    \n    # Create a set containing only the point (1,1)\n    x10 = initset(UNITY)\n    \n    # Check if there are exactly 4 blue cells in the input\n    x11 = equality(x5, FOUR)\n    \n    # If there are 4 blue cells, use (1,1) as the fill location\n    # Otherwise, use the previously determined line\n    x12 = branch(x11, x10, x8)\n    \n    # Fill the final determined cells with color 2 (blue in output)\n    # This handles the special case for 4 blue cells\n    x13 = fill(x9, TWO, x12)\n    \n    # Return the final 3x3 output grid\n    return x13\n"
  },
  "7b6016b9": {
    "original": "def verify_7b6016b9(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = asindices(I)\n    x2 = box(x1)\n    x3 = toobject(x2, I)\n    x4 = mostcolor(x3)\n    x5 = colorfilter(x0, x4)\n    x6 = rbind(bordering, I)\n    x7 = compose(flip, x6)\n    x8 = mfilter(x5, x7)\n    x9 = fill(I, TWO, x8)\n    x10 = replace(x9, x4, THREE)\n    return x10\n\n",
    "annotated": "def verify_7b6016b9(I: Grid) -> Grid:\n    # Identify all objects in the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Get all indices of the input grid\n    x1 = asindices(I)\n    \n    # Create a box (outline) around the entire grid\n    x2 = box(x1)\n    \n    # Convert the box outline to an object using the input grid's colors\n    x3 = toobject(x2, I)\n    \n    # Find the most common color in the box outline (likely the background color)\n    x4 = mostcolor(x3)\n    \n    # Filter objects to keep only those with the background color\n    x5 = colorfilter(x0, x4)\n    \n    # Create a function that checks if an object is bordering the grid edges\n    x6 = rbind(bordering, I)\n    \n    # Create a function that inverts the bordering check (i.e., not bordering)\n    x7 = compose(flip, x6)\n    \n    # Filter background objects to keep only those not bordering the grid edges\n    x8 = mfilter(x5, x7)\n    \n    # Fill the identified background objects with color 2 (creates the border)\n    x9 = fill(I, TWO, x8)\n    \n    # Replace the remaining background color with 3\n    x10 = replace(x9, x4, THREE)\n    \n    # Return the modified grid as the output\n    return x10\n"
  },
  "7b7f7511": {
    "original": "def verify_7b7f7511(I: Grid) -> Grid:\n    x0 = lefthalf(I)\n    x1 = righthalf(I)\n    x2 = equality(x0, x1)\n    x3 = branch(x2, lefthalf, tophalf)\n    x4 = x3(I)\n    return x4\n\n",
    "annotated": "def verify_7b7f7511(I: Grid) -> Grid:\n    # Extract the left half of the input grid\n    x0 = lefthalf(I)\n    \n    # Extract the right half of the input grid\n    x1 = righthalf(I)\n    \n    # Check if the left half is equal to the right half\n    x2 = equality(x0, x1)\n    \n    # If the halves are equal, use lefthalf function, otherwise use tophalf function\n    # This handles both horizontal and vertical concatenation cases from the generator\n    x3 = branch(x2, lefthalf, tophalf)\n    \n    # Apply the chosen function (lefthalf or tophalf) to the input grid\n    # This effectively reverses the concatenation done in the generator\n    x4 = x3(I)\n    \n    # Return the original grid, which is either the left half or top half of the input\n    return x4\n"
  },
  "7c008303": {
    "original": "def verify_7c008303(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = shape(I)\n    x4 = canvas(x2, x3)\n    x5 = hconcat(I, x4)\n    x6 = objects(x5, F, F, T)\n    x7 = argmin(x6, size)\n    x8 = argmax(x6, size)\n    x9 = remove(x8, x6)\n    x10 = remove(x7, x9)\n    x11 = merge(x10)\n    x12 = color(x11)\n    x13 = subgrid(x8, I)\n    x14 = subgrid(x7, I)\n    x15 = width(x8)\n    x16 = halve(x15)\n    x17 = hupscale(x14, x16)\n    x18 = height(x8)\n    x19 = halve(x18)\n    x20 = vupscale(x17, x19)\n    x21 = asobject(x20)\n    x22 = asindices(x13)\n    x23 = ofcolor(x13, x12)\n    x24 = difference(x22, x23)\n    x25 = rbind(contained, x24)\n    x26 = compose(x25, last)\n    x27 = sfilter(x21, x26)\n    x28 = paint(x13, x27)\n    return x28\n\n",
    "annotated": "def verify_7c008303(I: Grid) -> Grid:\n    # Find all frontiers (continuous lines of the same color) in the input grid\n    x0 = frontiers(I)\n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    # Get the color of the merged frontier object (likely the border color)\n    x2 = color(x1)\n    # Get the dimensions of the input grid\n    x3 = shape(I)\n    # Create a new canvas with the border color and same dimensions as input\n    x4 = canvas(x2, x3)\n    # Concatenate the input grid and the new canvas horizontally\n    x5 = hconcat(I, x4)\n    # Find all objects in the concatenated grid, ignoring background\n    x6 = objects(x5, F, F, T)\n    # Find the smallest object (likely the color key in the corner)\n    x7 = argmin(x6, size)\n    # Find the largest object (likely the main grid area)\n    x8 = argmax(x6, size)\n    # Remove the largest object from the set of objects\n    x9 = remove(x8, x6)\n    # Remove the smallest object from the remaining set\n    x10 = remove(x7, x9)\n    # Merge the remaining objects (likely the border lines)\n    x11 = merge(x10)\n    # Get the color of the merged border lines\n    x12 = color(x11)\n    # Extract the subgrid corresponding to the largest object (main grid area)\n    x13 = subgrid(x8, I)\n    # Extract the subgrid corresponding to the smallest object (color key)\n    x14 = subgrid(x7, I)\n    # Get the width of the main grid area\n    x15 = width(x8)\n    # Halve the width\n    x16 = halve(x15)\n    # Horizontally upscale the color key to half the width of the main grid\n    x17 = hupscale(x14, x16)\n    # Get the height of the main grid area\n    x18 = height(x8)\n    # Halve the height\n    x19 = halve(x18)\n    # Vertically upscale the color key to half the height of the main grid\n    x20 = vupscale(x17, x19)\n    # Convert the upscaled color key to an object\n    x21 = asobject(x20)\n    # Get all indices of the main grid area\n    x22 = asindices(x13)\n    # Find all cells in the main grid with the border color\n    x23 = ofcolor(x13, x12)\n    # Get the indices of cells that are not the border color\n    x24 = difference(x22, x23)\n    # Create a function that checks if a cell is contained in the non-border cells\n    x25 = rbind(contained, x24)\n    # Create a function that checks if the last element of a cell is in non-border cells\n    x26 = compose(x25, last)\n    # Filter the upscaled color key object to keep only cells that match non-border positions\n    x27 = sfilter(x21, x26)\n    # Paint the filtered color key onto the main grid area\n    x28 = paint(x13, x27)\n    # Return the final transformed grid\n    return x28\n"
  },
  "7ddcd7ec": {
    "original": "def verify_7ddcd7ec(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = argmax(x0, size)\n    x2 = remove(x1, x0)\n    x3 = lbind(position, x1)\n    x4 = fork(shoot, center, x3)\n    x5 = fork(recolor, color, x4)\n    x6 = mapply(x5, x2)\n    x7 = paint(I, x6)\n    return x7\n\n",
    "annotated": "def verify_7ddcd7ec(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing multi-colored objects and diagonal connections, excluding the background\n    x0 = objects(I, F, F, T)\n\n    # Find the largest object (background) by size\n    x1 = argmax(x0, size)\n\n    # Remove the background object from the set of objects\n    x2 = remove(x1, x0)\n\n    # Create a function that finds the position of other objects relative to the background\n    x3 = lbind(position, x1)\n\n    # Create a function that shoots a line from the center of an object in the direction relative to the background\n    x4 = fork(shoot, center, x3)\n\n    # Create a function that recolors the shot line with the color of the original object\n    x5 = fork(recolor, color, x4)\n\n    # Apply the shooting and recoloring function to all non-background objects\n    x6 = mapply(x5, x2)\n\n    # Paint the shot lines onto the input grid, creating the output\n    # This extends the corner pixels into lines pointing towards the grid center\n    x7 = paint(I, x6)\n\n    # Return the modified grid as the output\n    return x7\n"
  },
  "7df24a62": {
    "original": "def verify_7df24a62(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = compose(maximum, shape)\n    x2 = argmin(x0, x1)\n    x3 = color(x2)\n    x4 = palette(I)\n    x5 = remove(x3, x4)\n    x6 = lbind(colorcount, I)\n    x7 = argmin(x5, x6)\n    x8 = mostcolor(I)\n    x9 = shape(I)\n    x10 = increment(x9)\n    x11 = increment(x10)\n    x12 = canvas(x8, x11)\n    x13 = asobject(I)\n    x14 = shift(x13, UNITY)\n    x15 = paint(x12, x14)\n    x16 = repeat(identity, ONE)\n    x17 = astuple(cmirror, dmirror)\n    x18 = astuple(hmirror, vmirror)\n    x19 = combine(x17, x18)\n    x20 = combine(x16, x19)\n    x21 = fork(compose, first, last)\n    x22 = product(x20, x20)\n    x23 = apply(x21, x22)\n    x24 = ofcolor(x15, x3)\n    x25 = backdrop(x24)\n    x26 = toobject(x25, x15)\n    x27 = matcher(first, x7)\n    x28 = rbind(sfilter, x27)\n    x29 = matcher(first, x3)\n    x30 = rbind(sfilter, x29)\n    x31 = lbind(recolor, x8)\n    x32 = compose(x31, x30)\n    x33 = fork(combine, x28, x32)\n    x34 = lbind(lbind, shift)\n    x35 = lbind(occurrences, x15)\n    x36 = compose(x35, x33)\n    x37 = fork(mapply, x34, x36)\n    x38 = lbind(chain, x37)\n    x39 = lbind(x38, normalize)\n    x40 = rbind(rapply, x26)\n    x41 = initset(x39)\n    x42 = lbind(rapply, x41)\n    x43 = chain(first, x40, x42)\n    x44 = mapply(x43, x23)\n    x45 = paint(x15, x44)\n    x46 = trim(x45)\n    return x46\n\n",
    "annotated": "def verify_7df24a62(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    # Create a function that finds the maximum dimension (height or width) of an object\n    x1 = compose(maximum, shape)\n    # Find the smallest object based on its maximum dimension\n    x2 = argmin(x0, x1)\n    # Get the color of the smallest object (likely the noise color)\n    x3 = color(x2)\n    # Get all unique colors in the input grid\n    x4 = palette(I)\n    # Remove the noise color from the palette\n    x5 = remove(x3, x4)\n    # Create a function that counts the occurrences of a color in the input grid\n    x6 = lbind(colorcount, I)\n    # Find the least common color among non-noise colors (likely the square color)\n    x7 = argmin(x5, x6)\n    # Get the most common color in the input grid (likely the background color)\n    x8 = mostcolor(I)\n    # Get the dimensions of the input grid\n    x9 = shape(I)\n    # Increase the dimensions by 1\n    x10 = increment(x9)\n    # Increase the dimensions by 1 again (adding a 2-cell border)\n    x11 = increment(x10)\n    # Create a new canvas with the background color and increased dimensions\n    x12 = canvas(x8, x11)\n    # Convert the input grid to an object\n    x13 = asobject(I)\n    # Shift the input object by (1, 1) to center it in the new canvas\n    x14 = shift(x13, UNITY)\n    # Paint the shifted input object onto the new canvas\n    x15 = paint(x12, x14)\n    # Create a tuple containing the identity function\n    x16 = repeat(identity, ONE)\n    # Create a tuple with counterdiagonal and diagonal mirror functions\n    x17 = astuple(cmirror, dmirror)\n    # Create a tuple with horizontal and vertical mirror functions\n    x18 = astuple(hmirror, vmirror)\n    # Combine all mirror functions into a single tuple\n    x19 = combine(x17, x18)\n    # Add the identity function to the mirror functions\n    x20 = combine(x16, x19)\n    # Create a function that composes the first and last elements of a tuple\n    x21 = fork(compose, first, last)\n    # Generate all possible combinations of transformations\n    x22 = product(x20, x20)\n    # Apply the composition function to all transformation combinations\n    x23 = apply(x21, x22)\n    # Find all cells with the noise color in the expanded grid\n    x24 = ofcolor(x15, x3)\n    # Create a backdrop (bounding box) for the noise cells\n    x25 = backdrop(x24)\n    # Convert the backdrop to an object using the expanded grid\n    x26 = toobject(x25, x15)\n    # Create a function that matches the square color\n    x27 = matcher(first, x7)\n    # Create a function that filters objects by the square color\n    x28 = rbind(sfilter, x27)\n    # Create a function that matches the noise color\n    x29 = matcher(first, x3)\n    # Create a function that filters objects by the noise color\n    x30 = rbind(sfilter, x29)\n    # Create a function that recolors objects to the background color\n    x31 = lbind(recolor, x8)\n    # Compose the recolor and noise filter functions\n    x32 = compose(x31, x30)\n    # Create a function that combines square and recolored noise objects\n    x33 = fork(combine, x28, x32)\n    # Prepare a function for shifting objects\n    x34 = lbind(lbind, shift)\n    # Create a function to find occurrences in the expanded grid\n    x35 = lbind(occurrences, x15)\n    # Compose the occurrence finder with the object combiner\n    x36 = compose(x35, x33)\n    # Create a function to apply shifts to occurrences\n    x37 = fork(mapply, x34, x36)\n    # Chain the shift applier function\n    x38 = lbind(chain, x37)\n    # Add normalization to the chained function\n    x39 = lbind(x38, normalize)\n    # Create a function to apply the backdrop object\n    x40 = rbind(rapply, x26)\n    # Initialize a set with the normalized chained function\n    x41 = initset(x39)\n    # Create a function to apply the set of functions\n    x42 = lbind(rapply, x41)\n    # Chain the backdrop application with the set application\n    x43 = chain(first, x40, x42)\n    # Apply the chained function to all transformations\n    x44 = mapply(x43, x23)\n    # Paint the result onto the expanded grid\n    x45 = paint(x15, x44)\n    # Trim the border to get the final output grid\n    x46 = trim(x45)\n    return x46\n"
  },
  "7e0986d6": {
    "original": "def verify_7e0986d6(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, F, T)\n    x2 = lbind(greater, THREE)\n    x3 = compose(x2, size)\n    x4 = sfilter(x1, x3)\n    x5 = mapply(toindices, x4)\n    x6 = fill(I, x0, x5)\n    x7 = objects(x6, T, F, T)\n    x8 = fork(recolor, color, backdrop)\n    x9 = mapply(x8, x7)\n    x10 = paint(x6, x9)\n    return x10\n\n",
    "annotated": "def verify_7e0986d6(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Identify all objects in the grid, including diagonally connected cells, excluding the background\n    x1 = objects(I, T, F, T)\n    \n    # Create a function that checks if a value is greater than 3\n    x2 = lbind(greater, THREE)\n    \n    # Create a function that checks if the size of an object is greater than 3\n    x3 = compose(x2, size)\n    \n    # Filter objects to keep only those with size greater than 3 (likely the squares)\n    x4 = sfilter(x1, x3)\n    \n    # Convert the filtered objects to sets of indices\n    x5 = mapply(toindices, x4)\n    \n    # Fill the areas of the filtered objects with the background color (removing noise within squares)\n    x6 = fill(I, x0, x5)\n    \n    # Identify objects again after filling (should now be clean squares)\n    x7 = objects(x6, T, F, T)\n    \n    # Create a function that recolors an object with its original color and expands it to its bounding box\n    x8 = fork(recolor, color, backdrop)\n    \n    # Apply the recoloring function to all objects\n    x9 = mapply(x8, x7)\n    \n    # Paint the recolored and expanded objects onto the cleaned grid\n    x10 = paint(x6, x9)\n    \n    # Return the final grid with noise removed and squares expanded to their full rectangular shape\n    return x10\n"
  },
  "7f4411dc": {
    "original": "def verify_7f4411dc(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = mostcommon(x2)\n    x4 = canvas(x3, TWO_BY_TWO)\n    x5 = asobject(x4)\n    x6 = palette(I)\n    x7 = matcher(identity, x3)\n    x8 = argmin(x6, x7)\n    x9 = shape(I)\n    x10 = canvas(x8, x9)\n    x11 = lbind(shift, x5)\n    x12 = occurrences(I, x5)\n    x13 = mapply(x11, x12)\n    x14 = paint(x10, x13)\n    return x14\n\n",
    "annotated": "def verify_7f4411dc(I: Grid) -> Grid:\n    # Get all objects from the input grid, considering diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    \n    # Extract the color of each object\n    x2 = apply(color, x1)\n    \n    # Find the most common color among the objects (likely the foreground color)\n    x3 = mostcommon(x2)\n    \n    # Create a 2x2 grid filled with the most common color (represents a square)\n    x4 = canvas(x3, TWO_BY_TWO)\n    \n    # Convert the 2x2 grid to an object representation\n    x5 = asobject(x4)\n    \n    # Get all unique colors used in the input grid\n    x6 = palette(I)\n    \n    # Create a function that checks if a color matches the most common color\n    x7 = matcher(identity, x3)\n    \n    # Find the color in the palette that's different from the most common color (likely the background color)\n    x8 = argmin(x6, x7)\n    \n    # Get the dimensions of the input grid\n    x9 = shape(I)\n    \n    # Create a new grid with the same dimensions as the input, filled with the background color\n    x10 = canvas(x8, x9)\n    \n    # Create a function that shifts the 2x2 square object\n    x11 = lbind(shift, x5)\n    \n    # Find all occurrences of the 2x2 square in the input grid\n    x12 = occurrences(I, x5)\n    \n    # Apply the shift function to all occurrences of the 2x2 square\n    x13 = mapply(x11, x12)\n    \n    # Paint the shifted squares onto the background grid, effectively removing noise\n    x14 = paint(x10, x13)\n    \n    # Return the cleaned grid with noise removed\n    return x14\n"
  },
  "7fe24cdd": {
    "original": "def verify_7fe24cdd(I: Grid) -> Grid:\n    x0 = rot90(I)\n    x1 = rot180(I)\n    x2 = rot270(I)\n    x3 = hconcat(I, x0)\n    x4 = hconcat(x2, x1)\n    x5 = vconcat(x3, x4)\n    return x5\n\n",
    "annotated": "def verify_7fe24cdd(I: Grid) -> Grid:\n    # Rotate the input grid 90 degrees clockwise\n    x0 = rot90(I)\n    \n    # Rotate the input grid 180 degrees (flip it upside down)\n    x1 = rot180(I)\n    \n    # Rotate the input grid 270 degrees clockwise (equivalent to 90 degrees counterclockwise)\n    x2 = rot270(I)\n    \n    # Concatenate the original input grid with its 90-degree rotated version horizontally\n    # This forms the top half of the final output\n    x3 = hconcat(I, x0)\n    \n    # Concatenate the 270-degree rotated grid with the 180-degree rotated grid horizontally\n    # This forms the bottom half of the final output\n    x4 = hconcat(x2, x1)\n    \n    # Concatenate the top and bottom halves vertically to create the final output\n    # The result is a 2x2 grid of rotated versions of the input:\n    # [original, 90\u00b0 rotation]\n    # [270\u00b0 rotation, 180\u00b0 rotation]\n    x5 = vconcat(x3, x4)\n    \n    # Return the final composite grid\n    return x5\n"
  },
  "80af3007": {
    "original": "def verify_80af3007(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmin(x0, x1)\n    x3 = color(x2)\n    x4 = palette(I)\n    x5 = other(x4, x3)\n    x6 = subgrid(x2, I)\n    x7 = fork(multiply, identity, identity)\n    x8 = width(x6)\n    x9 = matcher(x7, x8)\n    x10 = fork(multiply, identity, identity)\n    x11 = height(x6)\n    x12 = matcher(x10, x11)\n    x13 = width(x6)\n    x14 = interval(ONE, x13, ONE)\n    x15 = extract(x14, x9)\n    x16 = height(x6)\n    x17 = interval(ONE, x16, ONE)\n    x18 = extract(x17, x12)\n    x19 = width(x6)\n    x20 = interval(ZERO, x19, ONE)\n    x21 = height(x6)\n    x22 = interval(ZERO, x21, ONE)\n    x23 = rbind(multiply, x15)\n    x24 = rbind(divide, x15)\n    x25 = compose(x23, x24)\n    x26 = fork(equality, identity, x25)\n    x27 = compose(x26, last)\n    x28 = rbind(multiply, x18)\n    x29 = rbind(divide, x18)\n    x30 = compose(x28, x29)\n    x31 = fork(equality, identity, x30)\n    x32 = compose(x31, last)\n    x33 = lbind(apply, first)\n    x34 = rbind(sfilter, x27)\n    x35 = rbind(pair, x20)\n    x36 = chain(x33, x34, x35)\n    x37 = pair(x6, x22)\n    x38 = sfilter(x37, x32)\n    x39 = apply(first, x38)\n    x40 = apply(x36, x39)\n    x41 = shape(x40)\n    x42 = multiply(x41, x41)\n    x43 = canvas(x5, x42)\n    x44 = ofcolor(x40, x3)\n    x45 = rbind(multiply, x41)\n    x46 = apply(x45, x44)\n    x47 = lbind(shift, x44)\n    x48 = mapply(x47, x46)\n    x49 = fill(x43, x3, x48)\n    return x49\n\n",
    "annotated": "def verify_80af3007(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    # Find the object with the smallest area (height * width)\n    x2 = argmin(x0, x1)\n    # Get the color of the smallest object (foreground color)\n    x3 = color(x2)\n    # Get the set of all colors used in the input grid\n    x4 = palette(I)\n    # Find the other color (background color)\n    x5 = other(x4, x3)\n    # Extract the subgrid containing the smallest object\n    x6 = subgrid(x2, I)\n    # Create a function that multiplies a value by itself\n    x7 = fork(multiply, identity, identity)\n    # Get the width of the extracted subgrid\n    x8 = width(x6)\n    # Create a function that checks if a value equals the subgrid width squared\n    x9 = matcher(x7, x8)\n    # Create another function that multiplies a value by itself (for height)\n    x10 = fork(multiply, identity, identity)\n    # Get the height of the extracted subgrid\n    x11 = height(x6)\n    # Create a function that checks if a value equals the subgrid height squared\n    x12 = matcher(x10, x11)\n    # Get the width of the subgrid again (for creating interval)\n    x13 = width(x6)\n    # Create an interval from 1 to the subgrid width\n    x14 = interval(ONE, x13, ONE)\n    # Find the value in the interval that, when squared, equals the subgrid width\n    x15 = extract(x14, x9)\n    # Get the height of the subgrid again (for creating interval)\n    x16 = height(x6)\n    # Create an interval from 1 to the subgrid height\n    x17 = interval(ONE, x16, ONE)\n    # Find the value in the interval that, when squared, equals the subgrid height\n    x18 = extract(x17, x12)\n    # Get the width of the subgrid again (for creating another interval)\n    x19 = width(x6)\n    # Create an interval from 0 to the subgrid width\n    x20 = interval(ZERO, x19, ONE)\n    # Get the height of the subgrid again (for creating another interval)\n    x21 = height(x6)\n    # Create an interval from 0 to the subgrid height\n    x22 = interval(ZERO, x21, ONE)\n    # Create a function that multiplies by x15 (width scaling factor)\n    x23 = rbind(multiply, x15)\n    # Create a function that divides by x15\n    x24 = rbind(divide, x15)\n    # Compose the multiplication and division functions\n    x25 = compose(x23, x24)\n    # Create a function that checks if a value is equal to its scaled and unscaled version\n    x26 = fork(equality, identity, x25)\n    # Create a function that applies the above check to the last element\n    x27 = compose(x26, last)\n    # Create a function that multiplies by x18 (height scaling factor)\n    x28 = rbind(multiply, x18)\n    # Create a function that divides by x18\n    x29 = rbind(divide, x18)\n    # Compose the multiplication and division functions for height\n    x30 = compose(x28, x29)\n    # Create a function that checks if a value is equal to its scaled and unscaled version (for height)\n    x31 = fork(equality, identity, x30)\n    # Create a function that applies the above check to the last element\n    x32 = compose(x31, last)\n    # Create a function that applies 'first' to each element\n    x33 = lbind(apply, first)\n    # Create a function that filters based on the width scaling check\n    x34 = rbind(sfilter, x27)\n    # Create a function that pairs each element with the width interval\n    x35 = rbind(pair, x20)\n    # Chain the above functions to extract and scale the width dimension\n    x36 = chain(x33, x34, x35)\n    # Pair the subgrid with the height interval\n    x37 = pair(x6, x22)\n    # Filter the paired subgrid based on the height scaling check\n    x38 = sfilter(x37, x32)\n    # Extract the first elements (subgrid rows)\n    x39 = apply(first, x38)\n    # Apply the width scaling to the extracted rows\n    x40 = apply(x36, x39)\n    # Get the shape (dimensions) of the scaled subgrid\n    x41 = shape(x40)\n    # Calculate the dimensions of the output grid\n    x42 = multiply(x41, x41)\n    # Create a canvas with the background color and calculated dimensions\n    x43 = canvas(x5, x42)\n    # Find the indices of the foreground color in the scaled subgrid\n    x44 = ofcolor(x40, x3)\n    # Create a function to multiply by the output grid dimensions\n    x45 = rbind(multiply, x41)\n    # Scale up the foreground color indices to match the output grid size\n    x46 = apply(x45, x44)\n    # Create a function to shift the foreground color indices\n    x47 = lbind(shift, x44)\n    # Apply the shift to all scaled indices\n    x48 = mapply(x47, x46)\n    # Fill the output canvas with the foreground color at the calculated positions\n    x49 = fill(x43, x3, x48)\n    # Return the final output grid\n    return x49\n"
  },
  "810b9b61": {
    "original": "def verify_810b9b61(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = rbind(greater, TWO)\n    x2 = chain(x1, minimum, shape)\n    x3 = fork(equality, toindices, box)\n    x4 = fork(both, x2, x3)\n    x5 = mfilter(x0, x4)\n    x6 = fill(I, THREE, x5)\n    return x6\n\n",
    "annotated": "def verify_810b9b61(I: Grid) -> Grid:\n    # Get all objects from the input grid, allowing diagonal connections and excluding background\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that checks if a value is greater than 2\n    x1 = rbind(greater, TWO)\n    \n    # Create a function that checks if the minimum dimension of an object is greater than 2\n    x2 = chain(x1, minimum, shape)\n    \n    # Create a function that checks if an object's indices form a perfect box\n    x3 = fork(equality, toindices, box)\n    \n    # Combine the two conditions: minimum dimension > 2 and perfect box shape\n    x4 = fork(both, x2, x3)\n    \n    # Filter objects that satisfy both conditions (boxes with min dimension > 2)\n    x5 = mfilter(x0, x4)\n    \n    # Fill the identified boxes with color 3 (changing their color in the output)\n    x6 = fill(I, THREE, x5)\n    \n    # Return the modified grid\n    return x6\n"
  },
  "82819916": {
    "original": "def verify_82819916(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, identity, dmirror)\n    x5 = x4(I)\n    x6 = frontiers(I)\n    x7 = merge(x6)\n    x8 = mostcolor(x7)\n    x9 = matcher(identity, x8)\n    x10 = rbind(sfilter, x9)\n    x11 = compose(size, x10)\n    x12 = argmin(x5, x11)\n    x13 = repeat(x12, ONE)\n    x14 = asobject(x13)\n    x15 = palette(x14)\n    x16 = totuple(x15)\n    x17 = first(x16)\n    x18 = last(x16)\n    x19 = fgpartition(x5)\n    x20 = merge(x19)\n    x21 = toindices(x20)\n    x22 = apply(first, x21)\n    x23 = lbind(sfilter, x20)\n    x24 = compose(first, last)\n    x25 = lbind(matcher, x24)\n    x26 = compose(x23, x25)\n    x27 = apply(x26, x22)\n    x28 = lbind(shift, x14)\n    x29 = chain(x28, toivec, uppermost)\n    x30 = matcher(first, x17)\n    x31 = rbind(sfilter, x30)\n    x32 = rbind(compose, last)\n    x33 = lbind(rbind, contained)\n    x34 = chain(toindices, x31, x29)\n    x35 = chain(x32, x33, x34)\n    x36 = fork(sfilter, identity, x35)\n    x37 = compose(color, x36)\n    x38 = compose(x31, x29)\n    x39 = fork(recolor, x37, x38)\n    x40 = fork(other, palette, x37)\n    x41 = compose(x31, x29)\n    x42 = fork(difference, x29, x41)\n    x43 = fork(recolor, x40, x42)\n    x44 = fork(combine, x39, x43)\n    x45 = mapply(x44, x27)\n    x46 = paint(x5, x45)\n    x47 = x4(x46)\n    return x47\n\n",
    "annotated": "def verify_82819916(I: Grid) -> Grid:\n    # Find all frontiers (rows or columns with same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out only horizontal frontiers\n    x1 = sfilter(x0, hline)\n    # Count the number of horizontal frontiers\n    x2 = size(x1)\n    # Check if there are any horizontal frontiers\n    x3 = positive(x2)\n    # If horizontal frontiers exist, use identity function, else use diagonal mirror\n    # This ensures the special line is horizontal for processing\n    x4 = branch(x3, identity, dmirror)\n    # Apply the chosen transformation to the input grid\n    x5 = x4(I)\n    # Find all frontiers in the transformed grid\n    x6 = frontiers(I)\n    # Merge all frontiers into a single set\n    x7 = merge(x6)\n    # Find the most common color in the frontiers (likely the background color)\n    x8 = mostcolor(x7)\n    # Create a function to match the background color\n    x9 = matcher(identity, x8)\n    # Create a function to filter elements by the background color\n    x10 = rbind(sfilter, x9)\n    # Create a function to count elements of background color\n    x11 = compose(size, x10)\n    # Find the row with the least background color (likely the special line)\n    x12 = argmin(x5, x11)\n    # Create a single-element tuple with the special line\n    x13 = repeat(x12, ONE)\n    # Convert the special line to an object\n    x14 = asobject(x13)\n    # Get the palette (unique colors) of the special line\n    x15 = palette(x14)\n    # Convert the palette to a tuple\n    x16 = totuple(x15)\n    # Get the first color in the palette (color A)\n    x17 = first(x16)\n    # Get the last color in the palette (color B)\n    x18 = last(x16)\n    # Partition the grid into objects, excluding the background\n    x19 = fgpartition(x5)\n    # Merge all non-background objects\n    x20 = merge(x19)\n    # Get the indices of all non-background cells\n    x21 = toindices(x20)\n    # Get the row indices of all non-background cells\n    x22 = apply(first, x21)\n    # Create a function to filter objects by row\n    x23 = lbind(sfilter, x20)\n    # Create a function to get the last element's first component\n    x24 = compose(first, last)\n    # Create a function to match the row index\n    x25 = lbind(matcher, x24)\n    # Create a function to filter objects by row index\n    x26 = compose(x23, x25)\n    # Group non-background objects by row\n    x27 = apply(x26, x22)\n    # Create a function to shift the special line\n    x28 = lbind(shift, x14)\n    # Create a function to get the vertical offset to the top of the grid\n    x29 = chain(x28, toivec, uppermost)\n    # Create a function to match color A\n    x30 = matcher(first, x17)\n    # Create a function to filter cells of color A\n    x31 = rbind(sfilter, x30)\n    # Create a function to get the last element\n    x32 = rbind(compose, last)\n    # Create a function to check if an element is contained\n    x33 = lbind(rbind, contained)\n    # Create a function to get indices of color A cells in the special line\n    x34 = chain(toindices, x31, x29)\n    # Create a function to check if a cell is in the color A region\n    x35 = chain(x32, x33, x34)\n    # Create a function to filter cells in the color A region\n    x36 = fork(sfilter, identity, x35)\n    # Create a function to get the color of cells in the color A region\n    x37 = compose(color, x36)\n    # Create a function to get indices of color A cells\n    x38 = compose(x31, x29)\n    # Create a function to recolor cells in the color A region\n    x39 = fork(recolor, x37, x38)\n    # Create a function to get the other color (B) in the special line\n    x40 = fork(other, palette, x37)\n    # Create a function to get indices of color A cells\n    x41 = compose(x31, x29)\n    # Create a function to get indices of color B cells\n    x42 = fork(difference, x29, x41)\n    # Create a function to recolor cells in the color B region\n    x43 = fork(recolor, x40, x42)\n    # Create a function to combine recolored A and B regions\n    x44 = fork(combine, x39, x43)\n    # Apply the recoloring to all rows\n    x45 = mapply(x44, x27)\n    # Paint the recolored objects onto the transformed grid\n    x46 = paint(x5, x45)\n    # Reverse the initial transformation to get the final output\n    x47 = x4(x46)\n    return x47\n"
  },
  "83302e8f": {
    "original": "def verify_83302e8f(I: Grid) -> Grid:\n    x0 = index(I, ORIGIN)\n    x1 = objects(I, T, F, F)\n    x2 = fork(multiply, height, width)\n    x3 = fork(equality, size, x2)\n    x4 = chain(positive, decrement, size)\n    x5 = colorfilter(x1, x0)\n    x6 = fork(both, x3, x4)\n    x7 = sfilter(x5, x6)\n    x8 = merge(x7)\n    x9 = ofcolor(I, x0)\n    x10 = fill(I, FOUR, x9)\n    x11 = fill(x10, THREE, x8)\n    return x11\n\n",
    "annotated": "def verify_83302e8f(I: Grid) -> Grid:\n    # Get the color of the top-left cell (background color)\n    x0 = index(I, ORIGIN)\n    \n    # Find all objects in the input grid, including those touching diagonally\n    x1 = objects(I, T, F, F)\n    \n    # Create a function that multiplies the height and width of an object\n    x2 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its height * width\n    x3 = fork(equality, size, x2)\n    \n    # Create a function that checks if an object's size is greater than 1\n    x4 = chain(positive, decrement, size)\n    \n    # Filter objects to only include those with the background color\n    x5 = colorfilter(x1, x0)\n    \n    # Create a function that combines the size check and the \"greater than 1\" check\n    x6 = fork(both, x3, x4)\n    \n    # Filter background-colored objects to only include those passing both checks\n    # This effectively selects complete cells (not partial due to line breaks)\n    x7 = sfilter(x5, x6)\n    \n    # Merge all selected cells into a single set of indices\n    x8 = merge(x7)\n    \n    # Find all cells in the input grid with the background color\n    x9 = ofcolor(I, x0)\n    \n    # Replace all background-colored cells with color 4\n    x10 = fill(I, FOUR, x9)\n    \n    # Fill the selected complete cells (from x8) with color 3\n    x11 = fill(x10, THREE, x8)\n    \n    # Return the modified grid\n    return x11\n"
  },
  "834ec97d": {
    "original": "def verify_834ec97d(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = argmin(x0, size)\n    x2 = cover(I, x1)\n    x3 = shift(x1, DOWN)\n    x4 = paint(x2, x3)\n    x5 = leftmost(x1)\n    x6 = width(I)\n    x7 = interval(x5, x6, TWO)\n    x8 = leftmost(x1)\n    x9 = interval(x8, NEG_ONE, NEG_TWO)\n    x10 = combine(x7, x9)\n    x11 = rbind(shoot, UP)\n    x12 = uppermost(x1)\n    x13 = lbind(astuple, x12)\n    x14 = apply(x13, x10)\n    x15 = mapply(x11, x14)\n    x16 = fill(x4, FOUR, x15)\n    return x16\n\n",
    "annotated": "def verify_834ec97d(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Find the smallest object (the single pixel of foreground color)\n    x1 = argmin(x0, size)\n    \n    # Create a new grid by covering (removing) the smallest object from the input grid\n    x2 = cover(I, x1)\n    \n    # Shift the smallest object one step down\n    x3 = shift(x1, DOWN)\n    \n    # Paint the shifted object onto the grid where the original object was removed\n    x4 = paint(x2, x3)\n    \n    # Find the leftmost coordinate of the original foreground pixel\n    x5 = leftmost(x1)\n    \n    # Get the width of the input grid\n    x6 = width(I)\n    \n    # Create a range of horizontal positions to the right of the foreground pixel, stepping by 2\n    x7 = interval(x5, x6, TWO)\n    \n    # Create a range of horizontal positions to the left of the foreground pixel, stepping by -2\n    x8 = leftmost(x1)\n    x9 = interval(x8, NEG_ONE, NEG_TWO)\n    \n    # Combine the left and right ranges of horizontal positions\n    x10 = combine(x7, x9)\n    \n    # Create a function that shoots a line upwards\n    x11 = rbind(shoot, UP)\n    \n    # Get the uppermost coordinate of the original foreground pixel\n    x12 = uppermost(x1)\n    \n    # Create a function that pairs the uppermost coordinate with each horizontal position\n    x13 = lbind(astuple, x12)\n    \n    # Apply this pairing function to all horizontal positions\n    x14 = apply(x13, x10)\n    \n    # Shoot lines upwards from each paired position\n    x15 = mapply(x11, x14)\n    \n    # Fill these vertical lines with color 4 (creating a \"curtain\" effect)\n    x16 = fill(x4, FOUR, x15)\n    \n    # Return the final grid with the foreground pixel moved down and vertical lines added\n    return x16\n"
  },
  "8403a5d5": {
    "original": "def verify_8403a5d5(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = argmin(x0, size)\n    x2 = color(x1)\n    x3 = leftmost(x1)\n    x4 = width(I)\n    x5 = interval(x3, x4, TWO)\n    x6 = apply(tojvec, x5)\n    x7 = mapply(vfrontier, x6)\n    x8 = fill(I, x2, x7)\n    x9 = increment(x3)\n    x10 = width(I)\n    x11 = interval(x9, x10, FOUR)\n    x12 = add(x3, THREE)\n    x13 = width(I)\n    x14 = interval(x12, x13, FOUR)\n    x15 = apply(tojvec, x11)\n    x16 = height(I)\n    x17 = decrement(x16)\n    x18 = lbind(astuple, x17)\n    x19 = apply(x18, x14)\n    x20 = combine(x15, x19)\n    x21 = fill(x8, FIVE, x20)\n    return x21\n\n",
    "annotated": "def verify_8403a5d5(I: Grid) -> Grid:\n    # Get all foreground objects (excluding the background color)\n    x0 = fgpartition(I)\n    \n    # Find the smallest object (which should be the single starting point)\n    x1 = argmin(x0, size)\n    \n    # Get the color of the starting point (foreground color)\n    x2 = color(x1)\n    \n    # Find the leftmost coordinate of the starting point\n    x3 = leftmost(x1)\n    \n    # Get the width of the input grid\n    x4 = width(I)\n    \n    # Create a range from the starting point to the grid width, stepping by 2\n    # This will be used to determine the columns for vertical lines\n    x5 = interval(x3, x4, TWO)\n    \n    # Convert the column indices to vertical vectors\n    x6 = apply(tojvec, x5)\n    \n    # Create vertical frontiers (full column lines) for each column index\n    x7 = mapply(vfrontier, x6)\n    \n    # Fill the vertical lines with the foreground color\n    x8 = fill(I, x2, x7)\n    \n    # Increment the starting column (for placing color 5 markers)\n    x9 = increment(x3)\n    \n    # Get the width of the input grid again\n    x10 = width(I)\n    \n    # Create a range for every 4th column starting from x9\n    # This will be used for placing color 5 at the top\n    x11 = interval(x9, x10, FOUR)\n    \n    # Add 3 to the starting column\n    x12 = add(x3, THREE)\n    \n    # Get the width of the input grid once more\n    x13 = width(I)\n    \n    # Create another range for every 4th column starting from x12\n    # This will be used for placing color 5 at the bottom\n    x14 = interval(x12, x13, FOUR)\n    \n    # Convert the top marker column indices to vertical vectors\n    x15 = apply(tojvec, x11)\n    \n    # Get the height of the input grid\n    x16 = height(I)\n    \n    # Decrement the height (to get the bottom row index)\n    x17 = decrement(x16)\n    \n    # Create a function that pairs the bottom row index with a column index\n    x18 = lbind(astuple, x17)\n    \n    # Apply this function to the bottom marker column indices\n    x19 = apply(x18, x14)\n    \n    # Combine the top and bottom marker positions\n    x20 = combine(x15, x19)\n    \n    # Fill the marker positions with color 5\n    x21 = fill(x8, FIVE, x20)\n    \n    # Return the final grid\n    return x21\n"
  },
  "846bdb03": {
    "original": "def verify_846bdb03(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(equality, corners, toindices)\n    x2 = extract(x0, x1)\n    x3 = subgrid(x2, I)\n    x4 = backdrop(x2)\n    x5 = cover(I, x4)\n    x6 = frontiers(x3)\n    x7 = sfilter(x6, hline)\n    x8 = size(x7)\n    x9 = positive(x8)\n    x10 = branch(x9, dmirror, identity)\n    x11 = x10(x3)\n    x12 = x10(x5)\n    x13 = fgpartition(x12)\n    x14 = merge(x13)\n    x15 = normalize(x14)\n    x16 = mostcolor(x12)\n    x17 = color(x2)\n    x18 = palette(x11)\n    x19 = remove(x17, x18)\n    x20 = remove(x16, x19)\n    x21 = first(x20)\n    x22 = last(x20)\n    x23 = ofcolor(x11, x22)\n    x24 = leftmost(x23)\n    x25 = ofcolor(x11, x21)\n    x26 = leftmost(x25)\n    x27 = greater(x24, x26)\n    x28 = ofcolor(x12, x22)\n    x29 = leftmost(x28)\n    x30 = ofcolor(x12, x21)\n    x31 = leftmost(x30)\n    x32 = greater(x29, x31)\n    x33 = equality(x27, x32)\n    x34 = branch(x33, identity, vmirror)\n    x35 = x34(x15)\n    x36 = shift(x35, UNITY)\n    x37 = paint(x11, x36)\n    x38 = x10(x37)\n    return x38\n\n",
    "annotated": "def verify_846bdb03(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that checks if an object's corners match its indices\n    x1 = fork(equality, corners, toindices)\n    \n    # Extract the object from x0 that satisfies the condition in x1 (likely the border object)\n    x2 = extract(x0, x1)\n    \n    # Get the subgrid of I that corresponds to the extracted object (likely the output grid)\n    x3 = subgrid(x2, I)\n    \n    # Get the bounding box of the extracted object\n    x4 = backdrop(x2)\n    \n    # Cover the area of the input grid corresponding to x4 with the background color\n    x5 = cover(I, x4)\n    \n    # Find all frontiers (continuous lines of same color) in the subgrid\n    x6 = frontiers(x3)\n    \n    # Filter out horizontal lines from the frontiers\n    x7 = sfilter(x6, hline)\n    \n    # Count the number of horizontal lines\n    x8 = size(x7)\n    \n    # Check if there are any horizontal lines\n    x9 = positive(x8)\n    \n    # If there are horizontal lines, prepare to mirror diagonally; otherwise, do nothing\n    x10 = branch(x9, dmirror, identity)\n    \n    # Apply the mirroring operation (if any) to the subgrid\n    x11 = x10(x3)\n    \n    # Apply the same mirroring operation (if any) to the covered input grid\n    x12 = x10(x5)\n    \n    # Partition the mirrored covered input grid, excluding the background color\n    x13 = fgpartition(x12)\n    \n    # Merge all partitioned objects into a single object\n    x14 = merge(x13)\n    \n    # Normalize the merged object (move it to the origin)\n    x15 = normalize(x14)\n    \n    # Find the most common color in the mirrored covered input grid (likely background)\n    x16 = mostcolor(x12)\n    \n    # Get the color of the extracted object (likely the border color)\n    x17 = color(x2)\n    \n    # Get all colors used in the mirrored subgrid\n    x18 = palette(x11)\n    \n    # Remove the border color from the subgrid palette\n    x19 = remove(x17, x18)\n    \n    # Remove the background color from the remaining colors\n    x20 = remove(x16, x19)\n    \n    # Get the first of the two remaining colors\n    x21 = first(x20)\n    \n    # Get the second of the two remaining colors\n    x22 = last(x20)\n    \n    # Find all cells in the mirrored subgrid with the second color\n    x23 = ofcolor(x11, x22)\n    \n    # Find the leftmost position of the second color in the subgrid\n    x24 = leftmost(x23)\n    \n    # Find all cells in the mirrored subgrid with the first color\n    x25 = ofcolor(x11, x21)\n    \n    # Find the leftmost position of the first color in the subgrid\n    x26 = leftmost(x25)\n    \n    # Check if the second color is to the right of the first color in the subgrid\n    x27 = greater(x24, x26)\n    \n    # Find all cells in the mirrored covered input grid with the second color\n    x28 = ofcolor(x12, x22)\n    \n    # Find the leftmost position of the second color in the covered input grid\n    x29 = leftmost(x28)\n    \n    # Find all cells in the mirrored covered input grid with the first color\n    x30 = ofcolor(x12, x21)\n    \n    # Find the leftmost position of the first color in the covered input grid\n    x31 = leftmost(x30)\n    \n    # Check if the second color is to the right of the first color in the covered input grid\n    x32 = greater(x29, x31)\n    \n    # Check if the color order is the same in both the subgrid and the covered input grid\n    x33 = equality(x27, x32)\n    \n    # If color order is the same, do nothing; otherwise, mirror vertically\n    x34 = branch(x33, identity, vmirror)\n    \n    # Apply the mirroring operation (if any) to the normalized merged object\n    x35 = x34(x15)\n    \n    # Shift the (possibly mirrored) object one unit down and right\n    x36 = shift(x35, UNITY)\n    \n    # Paint the shifted object onto the mirrored subgrid\n    x37 = paint(x11, x36)\n    \n    # Apply the initial mirroring operation (if any) to the result\n    x38 = x10(x37)\n    \n    # Return the final grid, which should be the correct output\n    return x38\n"
  },
  "855e0971": {
    "original": "def verify_855e0971(I: Grid) -> Grid:\n    x0 = lbind(greater, THREE)\n    x1 = chain(x0, size, dedupe)\n    x2 = apply(x1, I)\n    x3 = contained(F, x2)\n    x4 = flip(x3)\n    x5 = branch(x4, identity, dmirror)\n    x6 = x5(I)\n    x7 = rbind(toobject, I)\n    x8 = chain(palette, x7, neighbors)\n    x9 = lbind(chain, flip)\n    x10 = rbind(x9, x8)\n    x11 = lbind(lbind, contained)\n    x12 = compose(x10, x11)\n    x13 = lbind(ofcolor, I)\n    x14 = fork(sfilter, x13, x12)\n    x15 = compose(size, x14)\n    x16 = palette(I)\n    x17 = argmax(x16, x15)\n    x18 = objects(x6, T, T, F)\n    x19 = colorfilter(x18, x17)\n    x20 = difference(x18, x19)\n    x21 = rbind(subgrid, x6)\n    x22 = order(x20, uppermost)\n    x23 = apply(x21, x22)\n    x24 = lbind(recolor, x17)\n    x25 = lbind(mapply, vfrontier)\n    x26 = rbind(ofcolor, x17)\n    x27 = chain(x24, x25, x26)\n    x28 = fork(paint, identity, x27)\n    x29 = mapply(x28, x23)\n    x30 = x5(x29)\n    return x30\n\n",
    "annotated": "def verify_855e0971(I: Grid) -> Grid:\n    # Create a function that checks if a value is greater than 3\n    x0 = lbind(greater, THREE)\n    \n    # Create a chain of functions: dedupe -> size -> greater than 3\n    x1 = chain(x0, size, dedupe)\n    \n    # Apply the chain to the input grid I, checking if it has more than 3 unique colors\n    x2 = apply(x1, I)\n    \n    # Check if False is in the result (i.e., if any row doesn't have more than 3 colors)\n    x3 = contained(F, x2)\n    \n    # Flip the boolean result\n    x4 = flip(x3)\n    \n    # Create a function that either returns the identity or mirrors diagonally based on x4\n    x5 = branch(x4, identity, dmirror)\n    \n    # Apply the branching function to the input grid I\n    x6 = x5(I)\n    \n    # Create a function that converts the input grid I to an object\n    x7 = rbind(toobject, I)\n    \n    # Create a chain: neighbors -> toobject -> palette\n    x8 = chain(palette, x7, neighbors)\n    \n    # Create a function that flips the result of a chained function\n    x9 = lbind(chain, flip)\n    \n    # Bind x8 as the second argument to x9\n    x10 = rbind(x9, x8)\n    \n    # Create a function that checks if a value is contained in a set\n    x11 = lbind(lbind, contained)\n    \n    # Compose x11 with x10\n    x12 = compose(x10, x11)\n    \n    # Create a function that finds cells of a specific color in the input grid I\n    x13 = lbind(ofcolor, I)\n    \n    # Create a function that filters cells based on color and neighborhood conditions\n    x14 = fork(sfilter, x13, x12)\n    \n    # Create a function that counts the number of cells satisfying the conditions in x14\n    x15 = compose(size, x14)\n    \n    # Get the palette (unique colors) of the input grid I\n    x16 = palette(I)\n    \n    # Find the color with the maximum number of cells satisfying the conditions\n    x17 = argmax(x16, x15)\n    \n    # Find all objects in the grid, including diagonally connected and ignoring background\n    x18 = objects(x6, T, T, F)\n    \n    # Filter objects to keep only those of the color found in x17\n    x19 = colorfilter(x18, x17)\n    \n    # Get all objects that are not of the color found in x17\n    x20 = difference(x18, x19)\n    \n    # Create a function that extracts subgrids from x6\n    x21 = rbind(subgrid, x6)\n    \n    # Order the non-x17 colored objects by their uppermost position\n    x22 = order(x20, uppermost)\n    \n    # Extract subgrids for each ordered object\n    x23 = apply(x21, x22)\n    \n    # Create a function that recolors to the color found in x17\n    x24 = lbind(recolor, x17)\n    \n    # Create a function that applies the vertical frontier to each cell\n    x25 = lbind(mapply, vfrontier)\n    \n    # Create a function that finds cells of the color x17 in a grid\n    x26 = rbind(ofcolor, x17)\n    \n    # Chain functions: find x17 colored cells -> apply vfrontier -> recolor to x17\n    x27 = chain(x24, x25, x26)\n    \n    # Create a function that paints the result of x27 onto the identity grid\n    x28 = fork(paint, identity, x27)\n    \n    # Apply x28 to each subgrid in x23, effectively drawing vertical lines\n    x29 = mapply(x28, x23)\n    \n    # Apply the same mirroring (if any) that was applied to the input grid\n    x30 = x5(x29)\n    \n    # Return the final transformed grid\n    return x30\n"
  },
  "85c4e7cd": {
    "original": "def verify_85c4e7cd(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = shape(I)\n    x3 = minimum(x2)\n    x4 = halve(x3)\n    x5 = interval(ONE, x4, ONE)\n    x6 = lbind(power, inbox)\n    x7 = rbind(rapply, x1)\n    x8 = compose(initset, x6)\n    x9 = chain(first, x7, x8)\n    x10 = apply(x9, x5)\n    x11 = repeat(x1, ONE)\n    x12 = combine(x11, x10)\n    x13 = rbind(toobject, I)\n    x14 = compose(color, x13)\n    x15 = apply(x14, x12)\n    x16 = interval(ZERO, x4, ONE)\n    x17 = pair(x16, x15)\n    x18 = compose(invert, first)\n    x19 = order(x17, x18)\n    x20 = apply(last, x19)\n    x21 = mpapply(recolor, x20, x12)\n    x22 = paint(I, x21)\n    return x22\n\n",
    "annotated": "def verify_85c4e7cd(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Create a box outline using all indices of the input grid\n    # This effectively creates an outline of the entire grid\n    x1 = box(x0)\n    \n    # Get the dimensions (height, width) of the input grid\n    x2 = shape(I)\n    \n    # Find the smaller dimension of the grid (min of height and width)\n    x3 = minimum(x2)\n    \n    # Halve the smaller dimension\n    # This determines the maximum number of nested boxes we can create\n    x4 = halve(x3)\n    \n    # Create a range from 1 to half of the smaller dimension\n    # This will be used to generate the nested boxes\n    x5 = interval(ONE, x4, ONE)\n    \n    # Partially apply the 'power' function to 'inbox'\n    # This creates a function that will generate increasingly nested boxes\n    x6 = lbind(power, inbox)\n    \n    # Partially apply 'rapply' with the outline of the entire grid\n    # This prepares a function to apply other functions to this outline\n    x7 = rbind(rapply, x1)\n    \n    # Compose functions to initialize a set with the nested box function\n    x8 = compose(initset, x6)\n    \n    # Chain functions to get the first element after applying nested box function to the grid outline\n    x9 = chain(first, x7, x8)\n    \n    # Generate all nested boxes within the grid\n    x10 = apply(x9, x5)\n    \n    # Create a list containing just the outline of the entire grid\n    x11 = repeat(x1, ONE)\n    \n    # Combine the entire grid outline with all nested boxes\n    # This creates a list of all box outlines, from outermost to innermost\n    x12 = combine(x11, x10)\n    \n    # Partially apply 'toobject' with the input grid\n    # This prepares a function to convert indices to grid objects\n    x13 = rbind(toobject, I)\n    \n    # Compose functions to get the color of grid objects\n    x14 = compose(color, x13)\n    \n    # Get the colors of all box outlines in the input grid\n    x15 = apply(x14, x12)\n    \n    # Create a range from 0 to half of the smaller dimension\n    # This will be used to pair with colors for sorting\n    x16 = interval(ZERO, x4, ONE)\n    \n    # Pair each index with its corresponding color\n    x17 = pair(x16, x15)\n    \n    # Compose functions to invert the first element of each pair\n    # This prepares for sorting in descending order\n    x18 = compose(invert, first)\n    \n    # Sort the index-color pairs in descending order of index\n    # This effectively reverses the order of colors\n    x19 = order(x17, x18)\n    \n    # Extract the reversed list of colors\n    x20 = apply(last, x19)\n    \n    # Recolor each box outline with the reversed colors\n    x21 = mpapply(recolor, x20, x12)\n    \n    # Paint the recolored box outlines onto the input grid\n    # This creates the output grid with colors reversed from outer to inner\n    x22 = paint(I, x21)\n    \n    # Return the transformed grid\n    return x22\n"
  },
  "868de0fa": {
    "original": "def verify_868de0fa(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = sfilter(x0, square)\n    x2 = compose(even, height)\n    x3 = sfilter(x1, x2)\n    x4 = difference(x1, x3)\n    x5 = merge(x3)\n    x6 = merge(x4)\n    x7 = fill(I, TWO, x5)\n    x8 = fill(x7, SEVEN, x6)\n    return x8\n\n",
    "annotated": "def verify_868de0fa(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, F)\n    \n    # Filter out non-square objects, keeping only square-shaped objects\n    x1 = sfilter(x0, square)\n    \n    # Create a function that checks if the height of an object is even\n    x2 = compose(even, height)\n    \n    # Filter square objects to keep only those with even height/width\n    x3 = sfilter(x1, x2)\n    \n    # Get the set of square objects with odd height/width\n    x4 = difference(x1, x3)\n    \n    # Merge all even-sized square objects into a single set of indices\n    x5 = merge(x3)\n    \n    # Merge all odd-sized square objects into a single set of indices\n    x6 = merge(x4)\n    \n    # Fill the even-sized square objects with color 2 (TWO)\n    x7 = fill(I, TWO, x5)\n    \n    # Fill the odd-sized square objects with color 7 (SEVEN)\n    # This is the final step, creating the output grid\n    x8 = fill(x7, SEVEN, x6)\n    \n    # Return the modified grid as the output\n    return x8\n"
  },
  "8731374e": {
    "original": "def verify_8731374e(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = argmax(x0, size)\n    x2 = color(x1)\n    x3 = subgrid(x1, I)\n    x4 = lbind(insert, DOWN)\n    x5 = compose(lrcorner, asindices)\n    x6 = chain(x4, initset, x5)\n    x7 = fork(subgrid, x6, identity)\n    x8 = matcher(identity, x2)\n    x9 = rbind(subtract, TWO)\n    x10 = rbind(sfilter, x8)\n    x11 = compose(x9, width)\n    x12 = chain(size, x10, first)\n    x13 = fork(greater, x11, x12)\n    x14 = rbind(branch, identity)\n    x15 = rbind(x14, x7)\n    x16 = chain(initset, x15, x13)\n    x17 = fork(rapply, x16, identity)\n    x18 = compose(first, x17)\n    x19 = compose(x18, rot90)\n    x20 = double(EIGHT)\n    x21 = double(x20)\n    x22 = power(x19, x21)\n    x23 = x22(x3)\n    x24 = leastcolor(x23)\n    x25 = ofcolor(x23, x24)\n    x26 = fork(combine, vfrontier, hfrontier)\n    x27 = mapply(x26, x25)\n    x28 = fill(x23, x24, x27)\n    return x28\n\n",
    "annotated": "def verify_8731374e(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    # Find the largest object (likely the main pattern)\n    x1 = argmax(x0, size)\n    # Get the color of the largest object (background color)\n    x2 = color(x1)\n    # Extract the subgrid containing the largest object\n    x3 = subgrid(x1, I)\n    # Create a function that inserts the DOWN direction into a set\n    x4 = lbind(insert, DOWN)\n    # Create a function that finds the lower right corner of a grid\n    x5 = compose(lrcorner, asindices)\n    # Chain functions to create a set with the cell below the lower right corner\n    x6 = chain(x4, initset, x5)\n    # Create a function that extracts a subgrid based on the cell below lower right corner\n    x7 = fork(subgrid, x6, identity)\n    # Create a function that matches the background color\n    x8 = matcher(identity, x2)\n    # Create a function that subtracts 2 from a value\n    x9 = rbind(subtract, TWO)\n    # Create a function that filters elements matching the background color\n    x10 = rbind(sfilter, x8)\n    # Create a function that returns the width minus 2\n    x11 = compose(x9, width)\n    # Create a function that counts the number of background color cells in the first row\n    x12 = chain(size, x10, first)\n    # Create a function that checks if width-2 is greater than the count of background cells\n    x13 = fork(greater, x11, x12)\n    # Create a function for branching based on a condition\n    x14 = rbind(branch, identity)\n    # Bind the subgrid extraction function to the branching function\n    x15 = rbind(x14, x7)\n    # Chain functions to create a set based on the condition and subgrid extraction\n    x16 = chain(initset, x15, x13)\n    # Create a function that applies the set of functions to an input\n    x17 = fork(rapply, x16, identity)\n    # Create a function that gets the first result of the applied functions\n    x18 = compose(first, x17)\n    # Create a function that rotates the grid 90 degrees before applying previous function\n    x19 = compose(x18, rot90)\n    # Calculate 16\n    x20 = double(EIGHT)\n    # Calculate 32\n    x21 = double(x20)\n    # Create a function that applies the rotation and extraction 32 times\n    x22 = power(x19, x21)\n    # Apply the repeated rotation and extraction to the subgrid\n    x23 = x22(x3)\n    # Find the least common color in the resulting grid (likely the line color)\n    x24 = leastcolor(x23)\n    # Get all cells with the line color\n    x25 = ofcolor(x23, x24)\n    # Create a function that combines vertical and horizontal frontiers\n    x26 = fork(combine, vfrontier, hfrontier)\n    # Apply the frontier combination to all line color cells\n    x27 = mapply(x26, x25)\n    # Fill the resulting frontiers with the line color to create the final output\n    x28 = fill(x23, x24, x27)\n    return x28\n"
  },
  "88a10436": {
    "original": "def verify_88a10436(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = argmax(x0, size)\n    x2 = normalize(x1)\n    x3 = shape(x1)\n    x4 = halve(x3)\n    x5 = invert(x4)\n    x6 = shift(x2, x5)\n    x7 = sizefilter(x0, ONE)\n    x8 = apply(center, x7)\n    x9 = lbind(shift, x6)\n    x10 = mapply(x9, x8)\n    x11 = paint(I, x10)\n    return x11\n\n",
    "annotated": "def verify_88a10436(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and excluding the background\n    x0 = objects(I, F, F, T)\n    \n    # Find the largest object (template) among the extracted objects\n    x1 = argmax(x0, size)\n    \n    # Normalize the position of the largest object (move it to the origin)\n    x2 = normalize(x1)\n    \n    # Get the dimensions (height, width) of the largest object\n    x3 = shape(x1)\n    \n    # Halve the dimensions of the object\n    x4 = halve(x3)\n    \n    # Invert the halved dimensions (negate them)\n    # This will be used to center the object later\n    x5 = invert(x4)\n    \n    # Shift the normalized object by the inverted half-dimensions\n    # This centers the object around its middle point\n    x6 = shift(x2, x5)\n    \n    # Filter out all single-cell objects (dots) from the original set of objects\n    x7 = sizefilter(x0, ONE)\n    \n    # Find the center coordinates of all the single-cell objects (dots)\n    x8 = apply(center, x7)\n    \n    # Create a partial function that shifts the centered template object\n    x9 = lbind(shift, x6)\n    \n    # Apply the shifting function to all dot center coordinates\n    # This places a copy of the template object at each dot's position\n    x10 = mapply(x9, x8)\n    \n    # Paint all the newly created objects onto the input grid\n    # This effectively replaces each dot with the template object\n    x11 = paint(I, x10)\n    \n    # Return the modified grid as the output\n    return x11\n"
  },
  "88a62173": {
    "original": "def verify_88a62173(I: Grid) -> Grid:\n    x0 = lefthalf(I)\n    x1 = righthalf(I)\n    x2 = tophalf(x0)\n    x3 = tophalf(x1)\n    x4 = bottomhalf(x0)\n    x5 = bottomhalf(x1)\n    x6 = astuple(x2, x3)\n    x7 = astuple(x4, x5)\n    x8 = combine(x6, x7)\n    x9 = leastcommon(x8)\n    return x9\n\n",
    "annotated": "def verify_88a62173(I: Grid) -> Grid:\n    # Split the input grid vertically into left and right halves\n    x0 = lefthalf(I)\n    x1 = righthalf(I)\n    \n    # Split the left half horizontally into top and bottom quarters\n    x2 = tophalf(x0)\n    # Split the right half horizontally into top and bottom quarters\n    x3 = tophalf(x1)\n    \n    # Get the bottom quarter of the left half\n    x4 = bottomhalf(x0)\n    # Get the bottom quarter of the right half\n    x5 = bottomhalf(x1)\n    \n    # Combine the top quarters into a tuple\n    x6 = astuple(x2, x3)\n    # Combine the bottom quarters into a tuple\n    x7 = astuple(x4, x5)\n    \n    # Merge all four quarters into a single container\n    x8 = combine(x6, x7)\n    \n    # Find the least common grid among the four quarters\n    # This effectively identifies the unique grid (output) among the four copies\n    x9 = leastcommon(x8)\n    \n    # Return the identified unique grid (output)\n    return x9\n"
  },
  "890034e9": {
    "original": "def verify_890034e9(I: Grid) -> Grid:\n    x0 = rbind(greater, TWO)\n    x1 = chain(x0, minimum, shape)\n    x2 = objects(I, T, F, F)\n    x3 = sfilter(x2, x1)\n    x4 = fork(equality, toindices, box)\n    x5 = sfilter(x3, x4)\n    x6 = totuple(x5)\n    x7 = apply(color, x6)\n    x8 = leastcommon(x7)\n    x9 = ofcolor(I, x8)\n    x10 = inbox(x9)\n    x11 = recolor(ZERO, x10)\n    x12 = occurrences(I, x11)\n    x13 = normalize(x9)\n    x14 = shift(x13, NEG_UNITY)\n    x15 = lbind(shift, x14)\n    x16 = mapply(x15, x12)\n    x17 = fill(I, x8, x16)\n    return x17\n\n",
    "annotated": "def verify_890034e9(I: Grid) -> Grid:\n    # Create a function that checks if a value is greater than 2\n    x0 = rbind(greater, TWO)\n    \n    # Create a function that checks if the minimum dimension of a shape is greater than 2\n    x1 = chain(x0, minimum, shape)\n    \n    # Find all objects in the input grid, allowing different colors within objects\n    x2 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those with minimum dimension greater than 2\n    x3 = sfilter(x2, x1)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x4 = fork(equality, toindices, box)\n    \n    # Filter objects to keep only those that are rectangular (indices match bounding box)\n    x5 = sfilter(x3, x4)\n    \n    # Convert the set of filtered objects to a tuple\n    x6 = totuple(x5)\n    \n    # Get the color of each object\n    x7 = apply(color, x6)\n    \n    # Find the least common color among the objects (this is the marker color)\n    x8 = leastcommon(x7)\n    \n    # Find all cells in the input grid that have the marker color\n    x9 = ofcolor(I, x8)\n    \n    # Get the inner box of the marker-colored cells\n    x10 = inbox(x9)\n    \n    # Create a pattern by setting all cells in the inner box to 0 (black)\n    x11 = recolor(ZERO, x10)\n    \n    # Find all occurrences of this pattern in the input grid\n    x12 = occurrences(I, x11)\n    \n    # Normalize the marker-colored cells (move to origin)\n    x13 = normalize(x9)\n    \n    # Shift the normalized cells by (-1, -1) to create the outline\n    x14 = shift(x13, NEG_UNITY)\n    \n    # Create a function that shifts by the outline pattern\n    x15 = lbind(shift, x14)\n    \n    # Apply the shift function to all occurrences of the pattern\n    x16 = mapply(x15, x12)\n    \n    # Fill the input grid with the marker color at all shifted outline positions\n    # This effectively draws the outline around all occurrences of the pattern\n    x17 = fill(I, x8, x16)\n    \n    # Return the modified grid with outlines drawn\n    return x17\n"
  },
  "8a004b2b": {
    "original": "def verify_8a004b2b(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(equality, toindices, corners)\n    x2 = sfilter(x0, x1)\n    x3 = argmax(x2, size)\n    x4 = fgpartition(I)\n    x5 = merge(x4)\n    x6 = backdrop(x3)\n    x7 = toobject(x6, I)\n    x8 = difference(x5, x7)\n    x9 = mostcolor(I)\n    x10 = inbox(x3)\n    x11 = backdrop(x10)\n    x12 = toobject(x11, I)\n    x13 = matcher(first, x9)\n    x14 = compose(flip, x13)\n    x15 = sfilter(x12, x14)\n    x16 = subgrid(x8, I)\n    x17 = palette(x15)\n    x18 = order(x17, identity)\n    x19 = lbind(colorcount, x15)\n    x20 = apply(x19, x18)\n    x21 = lbind(colorcount, x8)\n    x22 = apply(x21, x18)\n    x23 = pair(x20, x22)\n    x24 = fork(divide, first, last)\n    x25 = apply(x24, x23)\n    x26 = mostcommon(x25)\n    x27 = lbind(colorcount, x15)\n    x28 = lbind(colorcount, x8)\n    x29 = fork(divide, x27, x28)\n    x30 = matcher(x29, x26)\n    x31 = palette(x8)\n    x32 = sfilter(x31, x30)\n    x33 = rbind(contained, x32)\n    x34 = compose(x33, first)\n    x35 = sfilter(x15, x34)\n    x36 = sfilter(x8, x34)\n    x37 = height(x35)\n    x38 = height(x36)\n    x39 = divide(x37, x38)\n    x40 = width(x35)\n    x41 = width(x36)\n    x42 = divide(x40, x41)\n    x43 = vupscale(x16, x39)\n    x44 = hupscale(x43, x42)\n    x45 = asobject(x44)\n    x46 = matcher(first, x9)\n    x47 = compose(flip, x46)\n    x48 = sfilter(x45, x47)\n    x49 = ulcorner(x15)\n    x50 = sfilter(x48, x34)\n    x51 = ulcorner(x50)\n    x52 = subtract(x49, x51)\n    x53 = shift(x48, x52)\n    x54 = paint(I, x53)\n    x55 = subgrid(x3, x54)\n    return x55\n\n",
    "annotated": "def verify_8a004b2b(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that checks if an object's indices match its corners\n    x1 = fork(equality, toindices, corners)\n    \n    # Filter objects that have indices matching their corners (likely the bounding box)\n    x2 = sfilter(x0, x1)\n    \n    # Find the largest object among the filtered objects (the bounding box)\n    x3 = argmax(x2, size)\n    \n    # Partition the input grid into foreground objects (excluding background)\n    x4 = fgpartition(I)\n    \n    # Merge all foreground objects into a single set\n    x5 = merge(x4)\n    \n    # Get all indices within the bounding box\n    x6 = backdrop(x3)\n    \n    # Convert the bounding box indices to an object with colors from the input grid\n    x7 = toobject(x6, I)\n    \n    # Find the difference between all foreground objects and the bounding box (the scaled object)\n    x8 = difference(x5, x7)\n    \n    # Determine the most common color in the input grid (likely the background color)\n    x9 = mostcolor(I)\n    \n    # Get the indices of the inner box (one cell inside the bounding box)\n    x10 = inbox(x3)\n    \n    # Get all indices within the inner box\n    x11 = backdrop(x10)\n    \n    # Convert the inner box indices to an object with colors from the input grid\n    x12 = toobject(x11, I)\n    \n    # Create a function that checks if a cell's color is not the background color\n    x13 = matcher(first, x9)\n    x14 = compose(flip, x13)\n    \n    # Filter the inner box to keep only non-background colored cells (the original object)\n    x15 = sfilter(x12, x14)\n    \n    # Extract the subgrid containing the scaled object\n    x16 = subgrid(x8, I)\n    \n    # Get the palette of colors used in the original object\n    x17 = palette(x15)\n    \n    # Order the palette colors\n    x18 = order(x17, identity)\n    \n    # Count occurrences of each color in the original object\n    x19 = lbind(colorcount, x15)\n    x20 = apply(x19, x18)\n    \n    # Count occurrences of each color in the scaled object\n    x21 = lbind(colorcount, x8)\n    x22 = apply(x21, x18)\n    \n    # Pair the color counts of original and scaled objects\n    x23 = pair(x20, x22)\n    \n    # Calculate the ratio of color counts between original and scaled objects\n    x24 = fork(divide, first, last)\n    x25 = apply(x24, x23)\n    \n    # Find the most common ratio (likely the scaling factor)\n    x26 = mostcommon(x25)\n    \n    # Create a function to calculate color count ratios\n    x27 = lbind(colorcount, x15)\n    x28 = lbind(colorcount, x8)\n    x29 = fork(divide, x27, x28)\n    \n    # Create a function to match colors with the scaling factor\n    x30 = matcher(x29, x26)\n    \n    # Get the palette of the scaled object\n    x31 = palette(x8)\n    \n    # Filter colors that match the scaling factor\n    x32 = sfilter(x31, x30)\n    \n    # Create a function to check if a color is in the filtered palette\n    x33 = rbind(contained, x32)\n    x34 = compose(x33, first)\n    \n    # Filter the original and scaled objects to keep only colors matching the scaling factor\n    x35 = sfilter(x15, x34)\n    x36 = sfilter(x8, x34)\n    \n    # Calculate the vertical scaling factor\n    x37 = height(x35)\n    x38 = height(x36)\n    x39 = divide(x37, x38)\n    \n    # Calculate the horizontal scaling factor\n    x40 = width(x35)\n    x41 = width(x36)\n    x42 = divide(x40, x41)\n    \n    # Scale the subgrid vertically and horizontally\n    x43 = vupscale(x16, x39)\n    x44 = hupscale(x43, x42)\n    \n    # Convert the scaled subgrid to an object\n    x45 = asobject(x44)\n    \n    # Create a function to check if a cell's color is not the background color\n    x46 = matcher(first, x9)\n    x47 = compose(flip, x46)\n    \n    # Filter the scaled object to keep only non-background colored cells\n    x48 = sfilter(x45, x47)\n    \n    # Get the upper-left corner of the original object\n    x49 = ulcorner(x15)\n    \n    # Filter the scaled object to keep only colors matching the scaling factor\n    x50 = sfilter(x48, x34)\n    \n    # Get the upper-left corner of the filtered scaled object\n    x51 = ulcorner(x50)\n    \n    # Calculate the offset between the original and scaled object positions\n    x52 = subtract(x49, x51)\n    \n    # Shift the scaled object to align with the original object's position\n    x53 = shift(x48, x52)\n    \n    # Paint the shifted scaled object onto the input grid\n    x54 = paint(I, x53)\n    \n    # Extract the subgrid within the bounding box (the final output)\n    x55 = subgrid(x3, x54)\n    \n    return x55\n"
  },
  "8be77c9e": {
    "original": "def verify_8be77c9e(I: Grid) -> Grid:\n    x0 = hmirror(I)\n    x1 = vconcat(I, x0)\n    return x1\n\n",
    "annotated": "def verify_8be77c9e(I: Grid) -> Grid:\n    # Create a horizontally mirrored version of the input grid I\n    # This effectively flips the input grid left-to-right\n    x0 = hmirror(I)\n    \n    # Vertically concatenate the original input grid I with its horizontal mirror x0\n    # This creates a new grid where the top half is the original input and the bottom half is its mirror image\n    x1 = vconcat(I, x0)\n    \n    # Return the resulting grid, which is twice the height of the original input\n    # The output grid consists of the original input on top and its horizontal mirror on the bottom\n    return x1\n"
  },
  "8d5021e8": {
    "original": "def verify_8d5021e8(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(x0, I)\n    x2 = hmirror(x1)\n    x3 = vconcat(x1, x2)\n    x4 = vconcat(x3, x1)\n    x5 = hmirror(x4)\n    return x5\n\n",
    "annotated": "def verify_8d5021e8(I: Grid) -> Grid:\n    # Mirror the input grid vertically (flip top to bottom)\n    x0 = vmirror(I)\n    \n    # Concatenate the mirrored grid (x0) with the original input (I) horizontally\n    # This creates a grid twice as wide, with the mirrored version on the left\n    x1 = hconcat(x0, I)\n    \n    # Mirror x1 horizontally (flip left to right)\n    # This creates a grid four times the size of the original, mirrored both vertically and horizontally\n    x2 = hmirror(x1)\n    \n    # Concatenate x1 and x2 vertically\n    # This creates a grid four times the height and twice the width of the original\n    x3 = vconcat(x1, x2)\n    \n    # Concatenate x3 with x1 vertically\n    # This adds the top half (x1) to the bottom, creating a grid six times the height and twice the width of the original\n    x4 = vconcat(x3, x1)\n    \n    # Mirror x4 horizontally (flip left to right)\n    # This creates the final output: a grid six times the height and four times the width of the original,\n    # with complex symmetry patterns in all directions\n    x5 = hmirror(x4)\n    \n    # Return the final transformed grid\n    return x5\n"
  },
  "8d510a79": {
    "original": "def verify_8d510a79(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = leastcommon(x2)\n    x4 = frontiers(I)\n    x5 = colorfilter(x4, x3)\n    x6 = size(x5)\n    x7 = positive(x6)\n    x8 = branch(x7, dmirror, identity)\n    x9 = ofcolor(I, x3)\n    x10 = ofcolor(I, TWO)\n    x11 = ofcolor(I, ONE)\n    x12 = rbind(gravitate, x9)\n    x13 = compose(x12, initset)\n    x14 = fork(add, identity, x13)\n    x15 = fork(connect, identity, x14)\n    x16 = shape(I)\n    x17 = maximum(x16)\n    x18 = lbind(multiply, x17)\n    x19 = lbind(gravitate, x9)\n    x20 = chain(x18, sign, x19)\n    x21 = compose(x20, initset)\n    x22 = fork(add, identity, x21)\n    x23 = fork(connect, identity, x22)\n    x24 = mapply(x15, x10)\n    x25 = mapply(x23, x11)\n    x26 = fill(I, TWO, x24)\n    x27 = fill(x26, ONE, x25)\n    return x27\n\n",
    "annotated": "def verify_8d510a79(I: Grid) -> Grid:\n    # Get all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Convert the set of frontiers to a tuple\n    x1 = totuple(x0)\n    # Extract the color of each frontier\n    x2 = apply(color, x1)\n    # Find the least common color among the frontiers (likely the color of the horizontal bar)\n    x3 = leastcommon(x2)\n    # Get all frontiers again (redundant operation)\n    x4 = frontiers(I)\n    # Filter frontiers to keep only those of the least common color\n    x5 = colorfilter(x4, x3)\n    # Count the number of frontiers with the least common color\n    x6 = size(x5)\n    # Check if there are any frontiers of the least common color\n    x7 = positive(x6)\n    # If there are frontiers of the least common color, apply diagonal mirror; otherwise, do nothing\n    # This handles the potential diagonal mirroring in the generator\n    x8 = branch(x7, dmirror, identity)\n    # Get all cells with the least common color (the horizontal bar)\n    x9 = ofcolor(I, x3)\n    # Get all cells with color 2\n    x10 = ofcolor(I, TWO)\n    # Get all cells with color 1\n    x11 = ofcolor(I, ONE)\n    # Create a function that gravitates towards the horizontal bar\n    x12 = rbind(gravitate, x9)\n    # Wrap the gravitate function to work with single-element sets\n    x13 = compose(x12, initset)\n    # Create a function that adds the original position to the gravitated position\n    x14 = fork(add, identity, x13)\n    # Create a function that connects the original position to the gravitated position\n    x15 = fork(connect, identity, x14)\n    # Get the shape (dimensions) of the input grid\n    x16 = shape(I)\n    # Get the maximum dimension of the grid\n    x17 = maximum(x16)\n    # Create a function that multiplies by the maximum dimension\n    x18 = lbind(multiply, x17)\n    # Create a function that gravitates away from the horizontal bar\n    x19 = lbind(gravitate, x9)\n    # Create a function that determines the direction and distance to move away from the bar\n    x20 = chain(x18, sign, x19)\n    # Wrap the direction function to work with single-element sets\n    x21 = compose(x20, initset)\n    # Create a function that adds the original position to the moved position\n    x22 = fork(add, identity, x21)\n    # Create a function that connects the original position to the moved position\n    x23 = fork(connect, identity, x22)\n    # Apply the connect-to-bar function to all color 2 cells\n    x24 = mapply(x15, x10)\n    # Apply the connect-away-from-bar function to all color 1 cells\n    x25 = mapply(x23, x11)\n    # Fill the grid with color 2 lines (connecting to the bar)\n    x26 = fill(I, TWO, x24)\n    # Fill the grid with color 1 lines (connecting away from the bar)\n    x27 = fill(x26, ONE, x25)\n    # Return the final grid with all lines drawn\n    return x27\n"
  },
  "8e1813be": {
    "original": "def verify_8e1813be(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = matcher(height, ONE)\n    x2 = matcher(width, ONE)\n    x3 = fork(either, x1, x2)\n    x4 = sfilter(x0, x3)\n    x5 = matcher(height, ONE)\n    x6 = sfilter(x4, x5)\n    x7 = size(x6)\n    x8 = matcher(width, ONE)\n    x9 = sfilter(x4, x8)\n    x10 = size(x9)\n    x11 = greater(x7, x10)\n    x12 = branch(x11, dmirror, identity)\n    x13 = branch(x11, uppermost, leftmost)\n    x14 = order(x4, x13)\n    x15 = apply(color, x14)\n    x16 = size(x4)\n    x17 = repeat(x15, x16)\n    x18 = x12(x17)\n    return x18\n\n",
    "annotated": "def verify_8e1813be(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that checks if height is 1\n    x1 = matcher(height, ONE)\n    \n    # Create a function that checks if width is 1\n    x2 = matcher(width, ONE)\n    \n    # Create a function that checks if either height or width is 1\n    x3 = fork(either, x1, x2)\n    \n    # Filter objects to keep only those with either height or width equal to 1 (i.e., lines)\n    x4 = sfilter(x0, x3)\n    \n    # Create a function that checks if height is 1\n    x5 = matcher(height, ONE)\n    \n    # Filter objects to keep only horizontal lines\n    x6 = sfilter(x4, x5)\n    \n    # Count the number of horizontal lines\n    x7 = size(x6)\n    \n    # Create a function that checks if width is 1\n    x8 = matcher(width, ONE)\n    \n    # Filter objects to keep only vertical lines\n    x9 = sfilter(x4, x8)\n    \n    # Count the number of vertical lines\n    x10 = size(x9)\n    \n    # Check if there are more horizontal lines than vertical lines\n    x11 = greater(x7, x10)\n    \n    # Create a function that either mirrors diagonally or keeps the identity based on x11\n    x12 = branch(x11, dmirror, identity)\n    \n    # Create a function that either finds uppermost or leftmost based on x11\n    x13 = branch(x11, uppermost, leftmost)\n    \n    # Order the lines based on their position (uppermost or leftmost)\n    x14 = order(x4, x13)\n    \n    # Extract the colors of the ordered lines\n    x15 = apply(color, x14)\n    \n    # Count the total number of lines\n    x16 = size(x4)\n    \n    # Create a grid by repeating the colors of the lines\n    x17 = repeat(x15, x16)\n    \n    # Apply the mirroring function if necessary\n    x18 = x12(x17)\n    \n    # Return the final output grid\n    return x18\n"
  },
  "8e5a5113": {
    "original": "def verify_8e5a5113(I: Grid) -> Grid:\n    x0 = portrait(I)\n    x1 = branch(x0, identity, rot90)\n    x2 = branch(x0, identity, rot270)\n    x3 = x1(I)\n    x4 = width(x3)\n    x5 = toivec(x4)\n    x6 = index(x3, x5)\n    x7 = shape(x3)\n    x8 = canvas(x6, x7)\n    x9 = hconcat(x3, x8)\n    x10 = objects(x9, F, T, T)\n    x11 = argmax(x10, numcolors)\n    x12 = subgrid(x11, x3)\n    x13 = interval(ONE, FOUR, ONE)\n    x14 = lbind(power, rot90)\n    x15 = lbind(power, rot270)\n    x16 = rbind(rapply, x12)\n    x17 = compose(initset, x14)\n    x18 = chain(first, x16, x17)\n    x19 = rbind(rapply, x12)\n    x20 = compose(initset, x15)\n    x21 = chain(first, x19, x20)\n    x22 = compose(asobject, x18)\n    x23 = uppermost(x11)\n    x24 = lbind(add, x23)\n    x25 = height(x11)\n    x26 = increment(x25)\n    x27 = lbind(multiply, x26)\n    x28 = chain(toivec, x24, x27)\n    x29 = fork(shift, x22, x28)\n    x30 = compose(asobject, x21)\n    x31 = uppermost(x11)\n    x32 = lbind(subtract, x31)\n    x33 = height(x11)\n    x34 = increment(x33)\n    x35 = lbind(multiply, x34)\n    x36 = chain(toivec, x32, x35)\n    x37 = fork(shift, x30, x36)\n    x38 = fork(combine, x29, x37)\n    x39 = mapply(x38, x13)\n    x40 = paint(x3, x39)\n    x41 = x2(x40)\n    return x41\n\n",
    "annotated": "def verify_8e5a5113(I: Grid) -> Grid:\n    # Check if the input grid is portrait-oriented\n    x0 = portrait(I)\n    # If portrait, use identity function; if landscape, use rot90\n    x1 = branch(x0, identity, rot90)\n    # If portrait, use identity function; if landscape, use rot270\n    x2 = branch(x0, identity, rot270)\n    # Apply the rotation function to normalize orientation\n    x3 = x1(I)\n    # Get the width of the normalized grid\n    x4 = width(x3)\n    # Convert width to a vertical vector (height, 0)\n    x5 = toivec(x4)\n    # Get the color of the separating bar\n    x6 = index(x3, x5)\n    # Get the shape (dimensions) of the normalized grid\n    x7 = shape(x3)\n    # Create a canvas of the same size as the grid, filled with the bar color\n    x8 = canvas(x6, x7)\n    # Concatenate the normalized grid with the bar-colored canvas horizontally\n    x9 = hconcat(x3, x8)\n    # Identify objects in the concatenated grid, allowing diagonal connections\n    x10 = objects(x9, F, T, T)\n    # Find the object with the most colors (likely the pattern)\n    x11 = argmax(x10, numcolors)\n    # Extract the subgrid containing the identified pattern\n    x12 = subgrid(x11, x3)\n    # Create an interval from 1 to 4 with step 1\n    x13 = interval(ONE, FOUR, ONE)\n    # Prepare a function to apply multiple 90-degree rotations\n    x14 = lbind(power, rot90)\n    # Prepare a function to apply multiple 270-degree rotations\n    x15 = lbind(power, rot270)\n    # Prepare a function to apply rotations to the pattern\n    x16 = rbind(rapply, x12)\n    # Create a function to initialize a set with 90-degree rotations\n    x17 = compose(initset, x14)\n    # Apply 90-degree rotations to the pattern and get the first result\n    x18 = chain(first, x16, x17)\n    # Prepare another function to apply rotations to the pattern\n    x19 = rbind(rapply, x12)\n    # Create a function to initialize a set with 270-degree rotations\n    x20 = compose(initset, x15)\n    # Apply 270-degree rotations to the pattern and get the first result\n    x21 = chain(first, x19, x20)\n    # Convert the 90-degree rotated pattern to an object\n    x22 = compose(asobject, x18)\n    # Get the uppermost row of the original pattern\n    x23 = uppermost(x11)\n    # Prepare a function to add to the uppermost row\n    x24 = lbind(add, x23)\n    # Get the height of the original pattern\n    x25 = height(x11)\n    # Increment the height by 1\n    x26 = increment(x25)\n    # Prepare a function to multiply by the incremented height\n    x27 = lbind(multiply, x26)\n    # Create a function to calculate the vertical shift for 90-degree rotation\n    x28 = chain(toivec, x24, x27)\n    # Create a function to shift the 90-degree rotated pattern\n    x29 = fork(shift, x22, x28)\n    # Convert the 270-degree rotated pattern to an object\n    x30 = compose(asobject, x21)\n    # Get the uppermost row of the original pattern\n    x31 = uppermost(x11)\n    # Prepare a function to subtract from the uppermost row\n    x32 = lbind(subtract, x31)\n    # Get the height of the original pattern\n    x33 = height(x11)\n    # Increment the height by 1\n    x34 = increment(x33)\n    # Prepare a function to multiply by the incremented height\n    x35 = lbind(multiply, x34)\n    # Create a function to calculate the vertical shift for 270-degree rotation\n    x36 = chain(toivec, x32, x35)\n    # Create a function to shift the 270-degree rotated pattern\n    x37 = fork(shift, x30, x36)\n    # Create a function to combine the shifted 90 and 270-degree rotated patterns\n    x38 = fork(combine, x29, x37)\n    # Apply the combining function to create all rotated patterns\n    x39 = mapply(x38, x13)\n    # Paint the rotated patterns onto the normalized grid\n    x40 = paint(x3, x39)\n    # Reverse the initial rotation if necessary\n    x41 = x2(x40)\n    # Return the final grid with all rotations filled in\n    return x41\n"
  },
  "8eb1be9a": {
    "original": "def verify_8eb1be9a(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = height(x1)\n    x3 = height(I)\n    x4 = interval(ZERO, x3, x2)\n    x5 = lbind(shift, x1)\n    x6 = compose(x5, toivec)\n    x7 = compose(x6, invert)\n    x8 = fork(combine, x6, x7)\n    x9 = mapply(x8, x4)\n    x10 = paint(I, x9)\n    return x10\n\n",
    "annotated": "def verify_8eb1be9a(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    \n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Get the height of the merged object\n    x2 = height(x1)\n    \n    # Get the height of the input grid\n    x3 = height(I)\n    \n    # Create a sequence of integers from 0 to grid height, stepping by object height\n    # This sequence represents the vertical offsets for replicating the object\n    x4 = interval(ZERO, x3, x2)\n    \n    # Partially apply the shift function, fixing the object to be shifted\n    x5 = lbind(shift, x1)\n    \n    # Create a function that converts an integer to a vertical offset vector and shifts the object\n    x6 = compose(x5, toivec)\n    \n    # Create a function that does the same as x6, but with inverted offset\n    # This will be used for shifting the object upwards\n    x7 = compose(x6, invert)\n    \n    # Create a function that combines the results of x6 and x7\n    # This function will shift the object both up and down for each offset\n    x8 = fork(combine, x6, x7)\n    \n    # Apply the shifting function to all offsets and merge the results\n    # This creates all vertical repetitions of the object\n    x9 = mapply(x8, x4)\n    \n    # Paint the repeated objects onto the input grid\n    # This creates the final output with the object repeated vertically\n    x10 = paint(I, x9)\n    \n    # Return the final grid with vertically repeated objects\n    return x10\n"
  },
  "8efcae92": {
    "original": "def verify_8efcae92(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = remove(x2, x0)\n    x4 = lbind(chain, positive)\n    x5 = lbind(x4, size)\n    x6 = rbind(compose, backdrop)\n    x7 = lbind(lbind, intersection)\n    x8 = chain(x5, x6, x7)\n    x9 = chain(x8, backdrop, outbox)\n    x10 = lbind(sfilter, x3)\n    x11 = compose(x10, x9)\n    x12 = chain(positive, size, x11)\n    x13 = sfilter(x3, x12)\n    x14 = compose(merge, x11)\n    x15 = apply(x14, x13)\n    x16 = rbind(subgrid, I)\n    x17 = apply(x16, x15)\n    x18 = merge(x15)\n    x19 = palette(x18)\n    x20 = lbind(colorcount, x18)\n    x21 = argmin(x19, x20)\n    x22 = rbind(colorcount, x21)\n    x23 = argmax(x17, x22)\n    return x23\n\n",
    "annotated": "def verify_8efcae92(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonally adjacent cells as part of the same object\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Find the largest object based on area (height * width)\n    x2 = argmax(x0, x1)\n    \n    # Remove the largest object from the set of objects\n    x3 = remove(x2, x0)\n    \n    # Create a chain of functions: check if positive after getting the size\n    x4 = lbind(chain, positive)\n    x5 = lbind(x4, size)\n    \n    # Create a function to get the backdrop of an object\n    x6 = rbind(compose, backdrop)\n    \n    # Create a function to find the intersection with an object's backdrop\n    x7 = lbind(lbind, intersection)\n    \n    # Chain functions to check if there's a positive-sized intersection between an object's backdrop and outbox\n    x8 = chain(x5, x6, x7)\n    x9 = chain(x8, backdrop, outbox)\n    \n    # Create a function to filter objects based on the previous condition\n    x10 = lbind(sfilter, x3)\n    x11 = compose(x10, x9)\n    \n    # Filter objects that have a positive-sized intersection between their backdrop and outbox\n    x12 = chain(positive, size, x11)\n    x13 = sfilter(x3, x12)\n    \n    # Create a function to merge the filtered objects\n    x14 = compose(merge, x11)\n    \n    # Apply the merging function to the filtered objects\n    x15 = apply(x14, x13)\n    \n    # Create a function to extract subgrids from the input grid\n    x16 = rbind(subgrid, I)\n    \n    # Extract subgrids for each merged object\n    x17 = apply(x16, x15)\n    \n    # Merge all the filtered objects into a single object\n    x18 = merge(x15)\n    \n    # Get the palette (unique colors) of the merged object\n    x19 = palette(x18)\n    \n    # Create a function to count occurrences of colors in the merged object\n    x20 = lbind(colorcount, x18)\n    \n    # Find the color with the minimum count in the merged object (likely the dot color)\n    x21 = argmin(x19, x20)\n    \n    # Create a function to count occurrences of the dot color\n    x22 = rbind(colorcount, x21)\n    \n    # Find the subgrid with the maximum number of dots\n    x23 = argmax(x17, x22)\n    \n    # Return the subgrid with the most dots, which is likely the output grid\n    return x23\n"
  },
  "8f2ea7aa": {
    "original": "def verify_8f2ea7aa(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = normalize(x1)\n    x3 = mostcolor(I)\n    x4 = shape(x2)\n    x5 = multiply(x4, x4)\n    x6 = canvas(x3, x5)\n    x7 = shape(x2)\n    x8 = rbind(multiply, x7)\n    x9 = toindices(x2)\n    x10 = apply(x8, x9)\n    x11 = lbind(shift, x2)\n    x12 = mapply(x11, x10)\n    x13 = paint(x6, x12)\n    return x13\n\n",
    "annotated": "def verify_8f2ea7aa(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Normalize the merged object by moving it to the top-left corner\n    x2 = normalize(x1)\n    \n    # Determine the most common color in the input grid (background color)\n    x3 = mostcolor(I)\n    \n    # Get the shape (dimensions) of the normalized object (mini-grid)\n    x4 = shape(x2)\n    \n    # Calculate the dimensions of the full output grid by squaring the mini-grid dimensions\n    x5 = multiply(x4, x4)\n    \n    # Create a canvas for the output grid with the background color and calculated dimensions\n    x6 = canvas(x3, x5)\n    \n    # Get the shape of the normalized object again (redundant, could be optimized)\n    x7 = shape(x2)\n    \n    # Create a function that multiplies a tuple by the shape of the normalized object\n    x8 = rbind(multiply, x7)\n    \n    # Get the indices of all colored cells in the normalized object\n    x9 = toindices(x2)\n    \n    # Calculate the new positions for each colored cell in the full output grid\n    x10 = apply(x8, x9)\n    \n    # Create a function that shifts the normalized object\n    x11 = lbind(shift, x2)\n    \n    # Apply the shift function to each calculated position, creating copies of the mini-grid\n    x12 = mapply(x11, x10)\n    \n    # Paint the shifted objects onto the output canvas, creating the final pattern\n    x13 = paint(x6, x12)\n    \n    # Return the completed output grid\n    return x13\n"
  },
  "90c28cc7": {
    "original": "def verify_90c28cc7(I: Grid) -> Grid:\n    x0 = matcher(identity, ZERO)\n    x1 = compose(flip, x0)\n    x2 = rbind(sfilter, x1)\n    x3 = chain(positive, size, x2)\n    x4 = rbind(sfilter, x3)\n    x5 = compose(dmirror, x4)\n    x6 = power(x5, FOUR)\n    x7 = x6(I)\n    x8 = dedupe(x7)\n    x9 = dmirror(x8)\n    x10 = dedupe(x9)\n    x11 = dmirror(x10)\n    return x11\n\n",
    "annotated": "def verify_90c28cc7(I: Grid) -> Grid:\n    # Create a function that checks if a value is equal to ZERO\n    x0 = matcher(identity, ZERO)\n    \n    # Create a function that checks if a value is NOT equal to ZERO\n    x1 = compose(flip, x0)\n    \n    # Create a function that filters a container, keeping only non-zero elements\n    x2 = rbind(sfilter, x1)\n    \n    # Create a function that checks if the count of non-zero elements is positive\n    x3 = chain(positive, size, x2)\n    \n    # Create a function that filters rows/columns, keeping only those with non-zero elements\n    x4 = rbind(sfilter, x3)\n    \n    # Create a function that applies diagonal mirroring after filtering\n    x5 = compose(dmirror, x4)\n    \n    # Create a function that applies the filtering and mirroring process 4 times\n    x6 = power(x5, FOUR)\n    \n    # Apply the repeated filtering and mirroring process to the input grid\n    x7 = x6(I)\n    \n    # Remove duplicate rows/columns from the processed grid\n    x8 = dedupe(x7)\n    \n    # Apply diagonal mirroring to the de-duplicated grid\n    x9 = dmirror(x8)\n    \n    # Remove duplicate rows/columns again\n    x10 = dedupe(x9)\n    \n    # Apply final diagonal mirroring to get the output grid\n    x11 = dmirror(x10)\n    \n    # Return the final processed grid\n    return x11\n\n# This verifier function essentially removes all-zero rows/columns,\n# applies diagonal mirroring, and removes duplicates multiple times\n# to create a symmetrical pattern from the input grid.\n"
  },
  "90f3ed37": {
    "original": "def verify_90f3ed37(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = apply(first, x1)\n    x3 = asindices(I)\n    x4 = apply(first, x3)\n    x5 = difference(x4, x2)\n    x6 = ofcolor(I, x0)\n    x7 = rbind(interval, ONE)\n    x8 = lbind(rbind, contained)\n    x9 = lbind(sfilter, x5)\n    x10 = rbind(matcher, ZERO)\n    x11 = chain(size, x9, x8)\n    x12 = lbind(sfilter, x6)\n    x13 = lbind(compose, x11)\n    x14 = chain(x12, x10, x13)\n    x15 = lbind(fork, x7)\n    x16 = compose(increment, minimum)\n    x17 = lbind(lbind, astuple)\n    x18 = lbind(chain, x16)\n    x19 = rbind(x18, first)\n    x20 = chain(x19, x17, first)\n    x21 = lbind(chain, maximum)\n    x22 = rbind(x21, first)\n    x23 = chain(x22, x17, first)\n    x24 = fork(x15, x20, x23)\n    x25 = compose(x14, x24)\n    x26 = apply(toivec, x2)\n    x27 = apply(x25, x26)\n    x28 = argmax(x27, width)\n    x29 = remove(x28, x27)\n    x30 = ulcorner(x28)\n    x31 = invert(x30)\n    x32 = shift(x28, x31)\n    x33 = asindices(I)\n    x34 = center(x33)\n    x35 = invert(x34)\n    x36 = shift(x33, x35)\n    x37 = width(I)\n    x38 = double(x37)\n    x39 = tojvec(x38)\n    x40 = rbind(apply, x36)\n    x41 = lbind(rbind, add)\n    x42 = chain(x40, x41, center)\n    x43 = compose(positive, size)\n    x44 = lbind(compose, size)\n    x45 = lbind(shift, x32)\n    x46 = rbind(compose, x45)\n    x47 = lbind(rbind, intersection)\n    x48 = compose(x46, x47)\n    x49 = lbind(compose, x43)\n    x50 = compose(x49, x48)\n    x51 = fork(sfilter, x42, x50)\n    x52 = compose(x44, x48)\n    x53 = fork(valmax, x51, x52)\n    x54 = compose(x44, x48)\n    x55 = fork(matcher, x54, x53)\n    x56 = fork(sfilter, x51, x55)\n    x57 = lbind(shift, x32)\n    x58 = lbind(insert, x39)\n    x59 = lbind(rbind, greater)\n    x60 = compose(x59, rightmost)\n    x61 = compose(leftmost, x58)\n    x62 = rbind(compose, x57)\n    x63 = lbind(rbind, difference)\n    x64 = compose(x62, x63)\n    x65 = lbind(compose, x61)\n    x66 = compose(x65, x64)\n    x67 = fork(compose, x60, x66)\n    x68 = fork(argmax, x56, x67)\n    x69 = lbind(shift, x32)\n    x70 = compose(x69, x68)\n    x71 = fork(difference, x70, identity)\n    x72 = mapply(x71, x29)\n    x73 = fill(I, ONE, x72)\n    return x73\n\n",
    "annotated": "def verify_90f3ed37(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    x0 = leastcolor(I)\n    # Get indices of cells with the least common color\n    x1 = ofcolor(I, x0)\n    # Get the first (topmost, leftmost) cell with the least common color\n    x2 = apply(first, x1)\n    # Get all indices of the input grid\n    x3 = asindices(I)\n    # Get all row indices of the input grid\n    x4 = apply(first, x3)\n    # Get all row indices except the one with the first least common color cell\n    x5 = difference(x4, x2)\n    # Get indices of all cells with the least common color (same as x1)\n    x6 = ofcolor(I, x0)\n    # Partially apply interval function to start from 1\n    x7 = rbind(interval, ONE)\n    # Create a function to check if a value is contained in an interval\n    x8 = lbind(rbind, contained)\n    # Create a function to filter row indices\n    x9 = lbind(sfilter, x5)\n    # Create a function to match with zero\n    x10 = rbind(matcher, ZERO)\n    # Create a function to count rows meeting certain criteria\n    x11 = chain(size, x9, x8)\n    # Create a function to filter cells with least common color\n    x12 = lbind(sfilter, x6)\n    # Compose functions for filtering based on row count\n    x13 = lbind(compose, x11)\n    # Create a function to find cells meeting specific criteria\n    x14 = chain(x12, x10, x13)\n    # Partially apply fork function with interval\n    x15 = lbind(fork, x7)\n    # Create a function to get the next row after the minimum\n    x16 = compose(increment, minimum)\n    # Create a function to convert to tuple\n    x17 = lbind(lbind, astuple)\n    # Create a function to get the next row after the first\n    x18 = lbind(chain, x16)\n    x19 = rbind(x18, first)\n    x20 = chain(x19, x17, first)\n    # Create a function to get the maximum row\n    x21 = lbind(chain, maximum)\n    x22 = rbind(x21, first)\n    x23 = chain(x22, x17, first)\n    # Create a function to get row range\n    x24 = fork(x15, x20, x23)\n    # Compose functions to find cells in specific row range\n    x25 = compose(x14, x24)\n    # Convert row of first least common color cell to vertical vector\n    x26 = apply(toivec, x2)\n    # Find cells in specific row ranges for each column\n    x27 = apply(x25, x26)\n    # Find the widest group of cells\n    x28 = argmax(x27, width)\n    # Remove the widest group from the list\n    x29 = remove(x28, x27)\n    # Get the upper left corner of the widest group\n    x30 = ulcorner(x28)\n    # Invert the corner coordinates\n    x31 = invert(x30)\n    # Shift the widest group to the origin\n    x32 = shift(x28, x31)\n    # Get all indices of the input grid (same as x3)\n    x33 = asindices(I)\n    # Find the center of the grid\n    x34 = center(x33)\n    # Invert the center coordinates\n    x35 = invert(x34)\n    # Shift the grid indices to center at origin\n    x36 = shift(x33, x35)\n    # Get the width of the input grid\n    x37 = width(I)\n    # Double the width\n    x38 = double(x37)\n    # Convert doubled width to horizontal vector\n    x39 = tojvec(x38)\n    # Create a function to apply shift to centered grid indices\n    x40 = rbind(apply, x36)\n    # Create a function to add vectors\n    x41 = lbind(rbind, add)\n    # Create a function to find new center after shift\n    x42 = chain(x40, x41, center)\n    # Create a function to check if size is positive\n    x43 = compose(positive, size)\n    # Create a function to get size\n    x44 = lbind(compose, size)\n    # Create a function to shift the normalized widest group\n    x45 = lbind(shift, x32)\n    # Create a function to compose with shift\n    x46 = rbind(compose, x45)\n    # Create a function for intersection\n    x47 = lbind(rbind, intersection)\n    # Compose functions for shifted intersection\n    x48 = compose(x46, x47)\n    # Create a function to check if intersection is non-empty\n    x49 = lbind(compose, x43)\n    x50 = compose(x49, x48)\n    # Create a function to filter valid shifts\n    x51 = fork(sfilter, x42, x50)\n    # Create a function to get size of intersection\n    x52 = compose(x44, x48)\n    # Create a function to find shift with maximum intersection\n    x53 = fork(valmax, x51, x52)\n    # Create a function to match maximum intersection\n    x54 = compose(x44, x48)\n    x55 = fork(matcher, x54, x53)\n    # Create a function to filter shifts with maximum intersection\n    x56 = fork(sfilter, x51, x55)\n    # Create a function to shift the normalized widest group\n    x57 = lbind(shift, x32)\n    # Create a function to insert doubled width vector\n    x58 = lbind(insert, x39)\n    # Create a function to compare rightmost positions\n    x59 = lbind(rbind, greater)\n    x60 = compose(x59, rightmost)\n    # Create a function to find leftmost position after insertion\n    x61 = compose(leftmost, x58)\n    # Create a function to compose with shift\n    x62 = rbind(compose, x57)\n    # Create a function for set difference\n    x63 = lbind(rbind, difference)\n    # Compose functions for shifted difference\n    x64 = compose(x62, x63)\n    # Create a function to compose with leftmost after insertion\n    x65 = lbind(compose, x61)\n    x66 = compose(x65, x64)\n    # Create a function to compare rightmost and leftmost positions\n    x67 = fork(compose, x60, x66)\n    # Find the optimal shift for the widest group\n    x68 = fork(argmax, x56, x67)\n    # Create a function to apply the optimal shift\n    x69 = lbind(shift, x32)\n    x70 = compose(x69, x68)\n    # Create a function to find the difference between shifted and original\n    x71 = fork(difference, x70, identity)\n    # Apply the difference function to all other groups\n    x72 = mapply(x71, x29)\n    # Fill the input grid with 1 at the calculated positions\n    # This effectively removes the extended parts of the patterns\n    x73 = fill(I, ONE, x72)\n    return x73\n"
  },
  "913fb3ed": {
    "original": "def verify_913fb3ed(I: Grid) -> Grid:\n    x0 = lbind(ofcolor, I)\n    x1 = lbind(mapply, neighbors)\n    x2 = chain(x1, x0, last)\n    x3 = fork(recolor, first, x2)\n    x4 = astuple(SIX, THREE)\n    x5 = astuple(FOUR, EIGHT)\n    x6 = astuple(ONE, TWO)\n    x7 = initset(x4)\n    x8 = insert(x5, x7)\n    x9 = insert(x6, x8)\n    x10 = mapply(x3, x9)\n    x11 = paint(I, x10)\n    return x11\n\n",
    "annotated": "def verify_913fb3ed(I: Grid) -> Grid:\n    # Partially apply ofcolor function with input grid I as the first argument\n    x0 = lbind(ofcolor, I)\n    \n    # Partially apply mapply function with neighbors function as the first argument\n    x1 = lbind(mapply, neighbors)\n    \n    # Chain functions: apply x0 to result of x1, then apply last to that result\n    # This finds the color of the last neighbor cell for each color group\n    x2 = chain(x1, x0, last)\n    \n    # Create a function that recolors cells based on their original color and the color of their neighbors\n    x3 = fork(recolor, first, x2)\n    \n    # Create tuples representing color pairs: (6, 3), (4, 8), and (1, 2)\n    x4 = astuple(SIX, THREE)\n    x5 = astuple(FOUR, EIGHT)\n    x6 = astuple(ONE, TWO)\n    \n    # Initialize a set with the first color pair (6, 3)\n    x7 = initset(x4)\n    \n    # Add the second color pair (4, 8) to the set\n    x8 = insert(x5, x7)\n    \n    # Add the third color pair (1, 2) to the set, completing the set of color transformations\n    x9 = insert(x6, x8)\n    \n    # Apply the recoloring function to each color pair in the set\n    x10 = mapply(x3, x9)\n    \n    # Paint the recolored cells onto the original input grid\n    x11 = paint(I, x10)\n    \n    # Return the final transformed grid\n    return x11\n"
  },
  "91413438": {
    "original": "def verify_91413438(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = other(x0, ZERO)\n    x2 = colorcount(I, x1)\n    x3 = colorcount(I, ZERO)\n    x4 = dmirror(I)\n    x5 = repeat(x4, x2)\n    x6 = dmirror(I)\n    x7 = shape(x6)\n    x8 = canvas(ZERO, x7)\n    x9 = multiply(x3, x3)\n    x10 = subtract(x9, x2)\n    x11 = repeat(x8, x10)\n    x12 = combine(x5, x11)\n    x13 = merge(x12)\n    x14 = dmirror(x13)\n    x15 = hsplit(x14, x3)\n    x16 = merge(x15)\n    return x16\n\n",
    "annotated": "def verify_91413438(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    # Find the non-zero color (foreground color)\n    x1 = other(x0, ZERO)\n    # Count the number of cells with the foreground color\n    x2 = colorcount(I, x1)\n    # Count the number of cells with the background color (zero)\n    x3 = colorcount(I, ZERO)\n    # Mirror the input grid along the diagonal (transpose)\n    x4 = dmirror(I)\n    # Repeat the transposed grid x2 times (number of foreground cells)\n    x5 = repeat(x4, x2)\n    # Mirror the input grid along the diagonal again (back to original orientation)\n    x6 = dmirror(I)\n    # Get the shape (dimensions) of the original input grid\n    x7 = shape(x6)\n    # Create an empty grid with the same dimensions as the input\n    x8 = canvas(ZERO, x7)\n    # Calculate the square of the number of background cells\n    x9 = multiply(x3, x3)\n    # Subtract the number of foreground cells from the square of background cells\n    x10 = subtract(x9, x2)\n    # Repeat the empty grid x10 times\n    x11 = repeat(x8, x10)\n    # Combine the repeated transposed grid and the repeated empty grid\n    x12 = combine(x5, x11)\n    # Merge all the grids in x12 into a single grid\n    x13 = merge(x12)\n    # Mirror the merged grid along the diagonal (transpose)\n    x14 = dmirror(x13)\n    # Split the transposed grid horizontally into x3 parts (number of background cells)\n    x15 = hsplit(x14, x3)\n    # Merge the split grids vertically to form the final output\n    x16 = merge(x15)\n    # Return the final output grid\n    return x16\n"
  },
  "91714a58": {
    "original": "def verify_91714a58(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = asindices(I)\n    x2 = objects(I, T, F, T)\n    x3 = argmax(x2, size)\n    x4 = mostcolor(x3)\n    x5 = mostcolor(I)\n    x6 = canvas(x5, x0)\n    x7 = paint(x6, x3)\n    x8 = mostcolor(I)\n    x9 = color(x3)\n    x10 = astuple(x8, ORIGIN)\n    x11 = astuple(x9, RIGHT)\n    x12 = astuple(x8, ZERO_BY_TWO)\n    x13 = initset(x12)\n    x14 = insert(x11, x13)\n    x15 = insert(x10, x14)\n    x16 = dmirror(x15)\n    x17 = toindices(x15)\n    x18 = lbind(shift, x17)\n    x19 = occurrences(x7, x15)\n    x20 = mapply(x18, x19)\n    x21 = toindices(x16)\n    x22 = lbind(shift, x21)\n    x23 = occurrences(x7, x16)\n    x24 = mapply(x22, x23)\n    x25 = combine(x20, x24)\n    x26 = fill(x7, x8, x25)\n    return x26\n\n",
    "annotated": "def verify_91714a58(I: Grid) -> Grid:\n    # Get the dimensions (height and width) of the input grid\n    x0 = shape(I)\n    \n    # Get all indices of the input grid\n    x1 = asindices(I)\n    \n    # Find all objects in the grid, allowing different colors and considering diagonal connections\n    x2 = objects(I, T, F, T)\n    \n    # Find the largest object (presumably the inner rectangle)\n    x3 = argmax(x2, size)\n    \n    # Get the most common color in the largest object (target color)\n    x4 = mostcolor(x3)\n    \n    # Get the most common color in the entire input grid (background color)\n    x5 = mostcolor(I)\n    \n    # Create a new grid with the background color and same dimensions as input\n    x6 = canvas(x5, x0)\n    \n    # Paint the largest object onto the new background grid\n    x7 = paint(x6, x3)\n    \n    # Get the background color again (same as x5)\n    x8 = mostcolor(I)\n    \n    # Get the color of the largest object (target color, same as x4)\n    x9 = color(x3)\n    \n    # Create a tuple with background color at origin (0,0)\n    x10 = astuple(x8, ORIGIN)\n    \n    # Create a tuple with target color at (0,1)\n    x11 = astuple(x9, RIGHT)\n    \n    # Create a tuple with background color at (0,2)\n    x12 = astuple(x8, ZERO_BY_TWO)\n    \n    # Initialize a set with the (0,2) tuple\n    x13 = initset(x12)\n    \n    # Insert the (0,1) tuple into the set\n    x14 = insert(x11, x13)\n    \n    # Insert the (0,0) tuple into the set\n    x15 = insert(x10, x14)\n    \n    # Create a diagonally mirrored version of the set\n    x16 = dmirror(x15)\n    \n    # Convert the original set to indices\n    x17 = toindices(x15)\n    \n    # Create a partially applied shift function with x17 as the patch to shift\n    x18 = lbind(shift, x17)\n    \n    # Find all occurrences of the original pattern in the cleaned grid\n    x19 = occurrences(x7, x15)\n    \n    # Apply the shift to all occurrences of the original pattern\n    x20 = mapply(x18, x19)\n    \n    # Convert the mirrored set to indices\n    x21 = toindices(x16)\n    \n    # Create a partially applied shift function with x21 as the patch to shift\n    x22 = lbind(shift, x21)\n    \n    # Find all occurrences of the mirrored pattern in the cleaned grid\n    x23 = occurrences(x7, x16)\n    \n    # Apply the shift to all occurrences of the mirrored pattern\n    x24 = mapply(x22, x23)\n    \n    # Combine the shifted indices from both patterns\n    x25 = combine(x20, x24)\n    \n    # Fill the cleaned grid with background color at the combined indices\n    # This effectively removes the corners of the rectangle\n    x26 = fill(x7, x8, x25)\n    \n    # Return the final grid with corners removed\n    return x26\n"
  },
  "9172f3a0": {
    "original": "def verify_9172f3a0(I: Grid) -> Grid:\n    x0 = upscale(I, THREE)\n    return x0\n\n",
    "annotated": "def verify_9172f3a0(I: Grid) -> Grid:\n    # Upscale the input grid 'I' by a factor of 3\n    # This triples the size of the grid in both dimensions\n    # Each cell in the original grid becomes a 3x3 block of the same color in the new grid\n    x0 = upscale(I, THREE)\n    \n    # Return the upscaled grid\n    # The output grid is exactly the same as the input grid, just 3 times larger in each dimension\n    return x0\n"
  },
  "928ad970": {
    "original": "def verify_928ad970(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = leastcolor(I)\n    x3 = palette(I)\n    x4 = remove(x2, x3)\n    x5 = mostcolor(I)\n    x6 = other(x4, x5)\n    x7 = inbox(x1)\n    x8 = fill(I, x6, x7)\n    return x8\n\n",
    "annotated": "def verify_928ad970(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get the indices of all cells with the background color\n    x1 = ofcolor(I, x0)\n    \n    # Find the least common color again (same as x0, redundant operation)\n    x2 = leastcolor(I)\n    \n    # Get the set of all colors used in the input grid\n    x3 = palette(I)\n    \n    # Remove the background color from the palette\n    x4 = remove(x2, x3)\n    \n    # Find the most common color in the input grid (dot color)\n    x5 = mostcolor(I)\n    \n    # Get the other color from x4 (line color)\n    x6 = other(x4, x5)\n    \n    # Find the indices of the cells inside the box formed by the dots\n    x7 = inbox(x1)\n    \n    # Fill the area inside the box with the line color\n    # This creates the output grid by filling the inner area of the dot box\n    x8 = fill(I, x6, x7)\n    \n    # Return the modified grid as the output\n    return x8\n"
  },
  "93b581b8": {
    "original": "def verify_93b581b8(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = apply(toindices, x0)\n    x2 = lbind(index, I)\n    x3 = compose(x2, lrcorner)\n    x4 = astuple(NEG_TWO, NEG_TWO)\n    x5 = rbind(shift, x4)\n    x6 = fork(recolor, x3, x5)\n    x7 = compose(x2, ulcorner)\n    x8 = rbind(shift, TWO_BY_TWO)\n    x9 = fork(recolor, x7, x8)\n    x10 = compose(x2, llcorner)\n    x11 = astuple(NEG_TWO, TWO)\n    x12 = rbind(shift, x11)\n    x13 = fork(recolor, x10, x12)\n    x14 = compose(x2, urcorner)\n    x15 = astuple(TWO, NEG_TWO)\n    x16 = rbind(shift, x15)\n    x17 = fork(recolor, x14, x16)\n    x18 = fork(combine, x6, x9)\n    x19 = fork(combine, x13, x17)\n    x20 = fork(combine, x18, x19)\n    x21 = mapply(x20, x1)\n    x22 = paint(I, x21)\n    return x22\n\n",
    "annotated": "def verify_93b581b8(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonally adjacent cells as part of the same object\n    x0 = objects(I, F, F, T)\n    \n    # Convert each object to its set of indices\n    x1 = apply(toindices, x0)\n    \n    # Create a function that retrieves the color at a given index in the input grid\n    x2 = lbind(index, I)\n    \n    # Create a function that gets the color of the lower right corner of an object\n    x3 = compose(x2, lrcorner)\n    \n    # Create a tuple representing a shift of (-2, -2)\n    x4 = astuple(NEG_TWO, NEG_TWO)\n    \n    # Create a function that shifts indices by (-2, -2)\n    x5 = rbind(shift, x4)\n    \n    # Create a function that recolors cells shifted (-2, -2) with the color of the lower right corner\n    x6 = fork(recolor, x3, x5)\n    \n    # Create a function that gets the color of the upper left corner of an object\n    x7 = compose(x2, ulcorner)\n    \n    # Create a function that shifts indices by (2, 2)\n    x8 = rbind(shift, TWO_BY_TWO)\n    \n    # Create a function that recolors cells shifted (2, 2) with the color of the upper left corner\n    x9 = fork(recolor, x7, x8)\n    \n    # Create a function that gets the color of the lower left corner of an object\n    x10 = compose(x2, llcorner)\n    \n    # Create a tuple representing a shift of (-2, 2)\n    x11 = astuple(NEG_TWO, TWO)\n    \n    # Create a function that shifts indices by (-2, 2)\n    x12 = rbind(shift, x11)\n    \n    # Create a function that recolors cells shifted (-2, 2) with the color of the lower left corner\n    x13 = fork(recolor, x10, x12)\n    \n    # Create a function that gets the color of the upper right corner of an object\n    x14 = compose(x2, urcorner)\n    \n    # Create a tuple representing a shift of (2, -2)\n    x15 = astuple(TWO, NEG_TWO)\n    \n    # Create a function that shifts indices by (2, -2)\n    x16 = rbind(shift, x15)\n    \n    # Create a function that recolors cells shifted (2, -2) with the color of the upper right corner\n    x17 = fork(recolor, x14, x16)\n    \n    # Combine the recoloring functions for the lower right and upper left corners\n    x18 = fork(combine, x6, x9)\n    \n    # Combine the recoloring functions for the lower left and upper right corners\n    x19 = fork(combine, x13, x17)\n    \n    # Combine all recoloring functions into a single function\n    x20 = fork(combine, x18, x19)\n    \n    # Apply the combined recoloring function to all object indices\n    x21 = mapply(x20, x1)\n    \n    # Paint the recolored objects onto the input grid to create the output grid\n    x22 = paint(I, x21)\n    \n    # Return the final output grid\n    return x22\n"
  },
  "941d9a10": {
    "original": "def verify_941d9a10(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = corners(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = objects(I, T, T, F)\n    x5 = colorfilter(x4, x3)\n    x6 = fork(add, leftmost, uppermost)\n    x7 = argmin(x5, x6)\n    x8 = argmax(x5, x6)\n    x9 = lbind(sfilter, x5)\n    x10 = rbind(compose, leftmost)\n    x11 = chain(size, x9, x10)\n    x12 = lbind(sfilter, x5)\n    x13 = rbind(compose, uppermost)\n    x14 = chain(size, x12, x13)\n    x15 = lbind(lbind, greater)\n    x16 = chain(x11, x15, leftmost)\n    x17 = lbind(rbind, greater)\n    x18 = chain(x11, x17, leftmost)\n    x19 = lbind(lbind, greater)\n    x20 = chain(x14, x19, uppermost)\n    x21 = lbind(rbind, greater)\n    x22 = chain(x14, x21, uppermost)\n    x23 = fork(equality, x16, x18)\n    x24 = fork(equality, x20, x22)\n    x25 = fork(both, x23, x24)\n    x26 = extract(x5, x25)\n    x27 = fill(I, ONE, x7)\n    x28 = fill(x27, THREE, x8)\n    x29 = fill(x28, TWO, x26)\n    return x29\n\n",
    "annotated": "def verify_941d9a10(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Find the corner indices of the grid\n    x1 = corners(x0)\n    \n    # Create an object from the corner indices and their colors in the input grid\n    x2 = toobject(x1, I)\n    \n    # Find the most common color in the corner object (likely the background color)\n    x3 = mostcolor(x2)\n    \n    # Identify all objects in the input grid, considering diagonal connections\n    x4 = objects(I, T, T, F)\n    \n    # Filter objects to keep only those with the background color\n    x5 = colorfilter(x4, x3)\n    \n    # Create a function that adds the leftmost and uppermost coordinates of an object\n    x6 = fork(add, leftmost, uppermost)\n    \n    # Find the object with the minimum sum of leftmost and uppermost coordinates (top-left object)\n    x7 = argmin(x5, x6)\n    \n    # Find the object with the maximum sum of leftmost and uppermost coordinates (bottom-right object)\n    x8 = argmax(x5, x6)\n    \n    # Prepare a function to filter objects based on their leftmost coordinate\n    x9 = lbind(sfilter, x5)\n    x10 = rbind(compose, leftmost)\n    x11 = chain(size, x9, x10)\n    \n    # Prepare a function to filter objects based on their uppermost coordinate\n    x12 = lbind(sfilter, x5)\n    x13 = rbind(compose, uppermost)\n    x14 = chain(size, x12, x13)\n    \n    # Create functions to compare leftmost coordinates\n    x15 = lbind(lbind, greater)\n    x16 = chain(x11, x15, leftmost)\n    x17 = lbind(rbind, greater)\n    x18 = chain(x11, x17, leftmost)\n    \n    # Create functions to compare uppermost coordinates\n    x19 = lbind(lbind, greater)\n    x20 = chain(x14, x19, uppermost)\n    x21 = lbind(rbind, greater)\n    x22 = chain(x14, x21, uppermost)\n    \n    # Check if an object is in the middle horizontally\n    x23 = fork(equality, x16, x18)\n    \n    # Check if an object is in the middle vertically\n    x24 = fork(equality, x20, x22)\n    \n    # Combine horizontal and vertical middle checks\n    x25 = fork(both, x23, x24)\n    \n    # Find the object that is in the middle both horizontally and vertically\n    x26 = extract(x5, x25)\n    \n    # Color the top-left object blue (1)\n    x27 = fill(I, ONE, x7)\n    \n    # Color the bottom-right object green (3)\n    x28 = fill(x27, THREE, x8)\n    \n    # Color the middle object red (2)\n    x29 = fill(x28, TWO, x26)\n    \n    # Return the final colored grid\n    return x29\n"
  },
  "94f9d214": {
    "original": "def verify_94f9d214(I: Grid) -> Grid:\n    x0 = astuple(vsplit, hsplit)\n    x1 = rbind(rbind, TWO)\n    x2 = rbind(rapply, I)\n    x3 = initset(x1)\n    x4 = lbind(rapply, x3)\n    x5 = chain(first, x2, x4)\n    x6 = lbind(apply, numcolors)\n    x7 = compose(x6, x5)\n    x8 = matcher(x7, TWO_BY_TWO)\n    x9 = extract(x0, x8)\n    x10 = x9(I, TWO)\n    x11 = first(x10)\n    x12 = last(x10)\n    x13 = palette(x11)\n    x14 = palette(x12)\n    x15 = intersection(x13, x14)\n    x16 = first(x15)\n    x17 = shape(x11)\n    x18 = canvas(x16, x17)\n    x19 = ofcolor(x11, x16)\n    x20 = ofcolor(x12, x16)\n    x21 = intersection(x19, x20)\n    x22 = fill(x18, TWO, x21)\n    return x22\n\n",
    "annotated": "def verify_94f9d214(I: Grid) -> Grid:\n    # Create a tuple of vsplit and hsplit functions\n    x0 = astuple(vsplit, hsplit)\n    \n    # Bind the value 2 as the second argument to the rbind function\n    x1 = rbind(rbind, TWO)\n    \n    # Create a function that applies its argument to I\n    x2 = rbind(rapply, I)\n    \n    # Create a set containing the function x1\n    x3 = initset(x1)\n    \n    # Create a function that applies x3 to its argument\n    x4 = lbind(rapply, x3)\n    \n    # Chain functions: apply x4, then x2, then take the first element\n    x5 = chain(first, x2, x4)\n    \n    # Create a function that applies numcolors to its argument\n    x6 = lbind(apply, numcolors)\n    \n    # Compose x6 with x5\n    x7 = compose(x6, x5)\n    \n    # Create a function that checks if x7's output equals (2,2)\n    x8 = matcher(x7, TWO_BY_TWO)\n    \n    # Extract the first function from x0 that satisfies x8\n    x9 = extract(x0, x8)\n    \n    # Apply x9 to I and 2, splitting I into 2x2 subgrids\n    x10 = x9(I, TWO)\n    \n    # Get the first subgrid (top-left)\n    x11 = first(x10)\n    \n    # Get the last subgrid (bottom-right)\n    x12 = last(x10)\n    \n    # Get the set of colors in the first subgrid\n    x13 = palette(x11)\n    \n    # Get the set of colors in the last subgrid\n    x14 = palette(x12)\n    \n    # Find the common colors between the two subgrids\n    x15 = intersection(x13, x14)\n    \n    # Get the first (and only) common color\n    x16 = first(x15)\n    \n    # Get the shape (dimensions) of the first subgrid\n    x17 = shape(x11)\n    \n    # Create a new grid with the common color and same shape as subgrid\n    x18 = canvas(x16, x17)\n    \n    # Get indices of cells with the common color in the first subgrid\n    x19 = ofcolor(x11, x16)\n    \n    # Get indices of cells with the common color in the last subgrid\n    x20 = ofcolor(x12, x16)\n    \n    # Find common indices between x19 and x20\n    x21 = intersection(x19, x20)\n    \n    # Fill the canvas with color 2 at the common indices\n    x22 = fill(x18, TWO, x21)\n    \n    # Return the resulting grid\n    return x22\n"
  },
  "952a094c": {
    "original": "def verify_952a094c(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = inbox(x1)\n    x3 = cover(I, x2)\n    x4 = ulcorner(x2)\n    x5 = index(I, x4)\n    x6 = lrcorner(x1)\n    x7 = add(UNITY, x6)\n    x8 = initset(x7)\n    x9 = fill(x3, x5, x8)\n    x10 = lrcorner(x2)\n    x11 = index(I, x10)\n    x12 = ulcorner(x1)\n    x13 = add(NEG_UNITY, x12)\n    x14 = initset(x13)\n    x15 = fill(x9, x11, x14)\n    x16 = urcorner(x2)\n    x17 = index(I, x16)\n    x18 = llcorner(x1)\n    x19 = add(DOWN_LEFT, x18)\n    x20 = initset(x19)\n    x21 = fill(x15, x17, x20)\n    x22 = llcorner(x2)\n    x23 = index(I, x22)\n    x24 = urcorner(x1)\n    x25 = add(UP_RIGHT, x24)\n    x26 = initset(x25)\n    x27 = fill(x21, x23, x26)\n    return x27\n\n",
    "annotated": "def verify_952a094c(I: Grid) -> Grid:\n    # Get all non-background objects from the input grid\n    x0 = fgpartition(I)\n    \n    # Merge all non-background objects into a single object\n    x1 = merge(x0)\n    \n    # Get the indices of the inner box (one cell inside the merged object)\n    x2 = inbox(x1)\n    \n    # Remove the inner box from the input grid, effectively leaving only the outer frame\n    x3 = cover(I, x2)\n    \n    # Get the upper-left corner of the inner box\n    x4 = ulcorner(x2)\n    \n    # Get the color of the upper-left corner of the inner box in the input grid\n    x5 = index(I, x4)\n    \n    # Get the lower-right corner of the merged object (outer frame)\n    x6 = lrcorner(x1)\n    \n    # Move one step down and right from the lower-right corner of the outer frame\n    x7 = add(UNITY, x6)\n    \n    # Create a set with this new position (lower-right corner outside the frame)\n    x8 = initset(x7)\n    \n    # Fill this position with the color from the upper-left corner of the inner box\n    x9 = fill(x3, x5, x8)\n    \n    # Get the lower-right corner of the inner box\n    x10 = lrcorner(x2)\n    \n    # Get the color of the lower-right corner of the inner box in the input grid\n    x11 = index(I, x10)\n    \n    # Get the upper-left corner of the merged object (outer frame)\n    x12 = ulcorner(x1)\n    \n    # Move one step up and left from the upper-left corner of the outer frame\n    x13 = add(NEG_UNITY, x12)\n    \n    # Create a set with this new position (upper-left corner outside the frame)\n    x14 = initset(x13)\n    \n    # Fill this position with the color from the lower-right corner of the inner box\n    x15 = fill(x9, x11, x14)\n    \n    # Get the upper-right corner of the inner box\n    x16 = urcorner(x2)\n    \n    # Get the color of the upper-right corner of the inner box in the input grid\n    x17 = index(I, x16)\n    \n    # Get the lower-left corner of the merged object (outer frame)\n    x18 = llcorner(x1)\n    \n    # Move one step down and left from the lower-left corner of the outer frame\n    x19 = add(DOWN_LEFT, x18)\n    \n    # Create a set with this new position (lower-left corner outside the frame)\n    x20 = initset(x19)\n    \n    # Fill this position with the color from the upper-right corner of the inner box\n    x21 = fill(x15, x17, x20)\n    \n    # Get the lower-left corner of the inner box\n    x22 = llcorner(x2)\n    \n    # Get the color of the lower-left corner of the inner box in the input grid\n    x23 = index(I, x22)\n    \n    # Get the upper-right corner of the merged object (outer frame)\n    x24 = urcorner(x1)\n    \n    # Move one step up and right from the upper-right corner of the outer frame\n    x25 = add(UP_RIGHT, x24)\n    \n    # Create a set with this new position (upper-right corner outside the frame)\n    x26 = initset(x25)\n    \n    # Fill this position with the color from the lower-left corner of the inner box\n    x27 = fill(x21, x23, x26)\n    \n    # Return the final grid with all transformations applied\n    return x27\n"
  },
  "9565186b": {
    "original": "def verify_9565186b(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = partition(I)\n    x2 = argmax(x1, size)\n    x3 = canvas(FIVE, x0)\n    x4 = paint(x3, x2)\n    return x4\n\n",
    "annotated": "def verify_9565186b(I: Grid) -> Grid:\n    # Get the dimensions (height and width) of the input grid\n    x0 = shape(I)\n    \n    # Partition the input grid into objects, where each object consists of cells with the same color\n    x1 = partition(I)\n    \n    # Find the largest object (most frequent color) in the partitioned grid\n    x2 = argmax(x1, size)\n    \n    # Create a new canvas filled with color 5 (background color) with the same dimensions as the input grid\n    x3 = canvas(FIVE, x0)\n    \n    # Paint the largest object (most frequent color) onto the new canvas\n    # This effectively removes all colors except the most frequent one and the background\n    x4 = paint(x3, x2)\n    \n    # Return the resulting grid, which contains only the most frequent color and the background color 5\n    return x4\n"
  },
  "95990924": {
    "original": "def verify_95990924(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = apply(ulcorner, x0)\n    x2 = apply(urcorner, x0)\n    x3 = apply(llcorner, x0)\n    x4 = apply(lrcorner, x0)\n    x5 = shift(x1, NEG_UNITY)\n    x6 = shift(x2, UP_RIGHT)\n    x7 = shift(x3, DOWN_LEFT)\n    x8 = shift(x4, UNITY)\n    x9 = fill(I, ONE, x5)\n    x10 = fill(x9, TWO, x6)\n    x11 = fill(x10, THREE, x7)\n    x12 = fill(x11, FOUR, x8)\n    return x12\n\n",
    "annotated": "def verify_95990924(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Get the upper-left corners of all objects\n    x1 = apply(ulcorner, x0)\n    \n    # Get the upper-right corners of all objects\n    x2 = apply(urcorner, x0)\n    \n    # Get the lower-left corners of all objects\n    x3 = apply(llcorner, x0)\n    \n    # Get the lower-right corners of all objects\n    x4 = apply(lrcorner, x0)\n    \n    # Shift the upper-left corners one unit up and left (inside the box)\n    x5 = shift(x1, NEG_UNITY)\n    \n    # Shift the upper-right corners one unit up and right (inside the box)\n    x6 = shift(x2, UP_RIGHT)\n    \n    # Shift the lower-left corners one unit down and left (inside the box)\n    x7 = shift(x3, DOWN_LEFT)\n    \n    # Shift the lower-right corners one unit down and right (inside the box)\n    x8 = shift(x4, UNITY)\n    \n    # Fill the shifted upper-left corners with color 1 (marking top-left of each box)\n    x9 = fill(I, ONE, x5)\n    \n    # Fill the shifted upper-right corners with color 2 (marking top-right of each box)\n    x10 = fill(x9, TWO, x6)\n    \n    # Fill the shifted lower-left corners with color 3 (marking bottom-left of each box)\n    x11 = fill(x10, THREE, x7)\n    \n    # Fill the shifted lower-right corners with color 4 (marking bottom-right of each box)\n    x12 = fill(x11, FOUR, x8)\n    \n    # Return the modified grid with all corners marked\n    return x12\n"
  },
  "963e52fc": {
    "original": "def verify_963e52fc(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = asobject(I)\n    x2 = hperiod(x1)\n    x3 = height(x1)\n    x4 = astuple(x3, x2)\n    x5 = ulcorner(x1)\n    x6 = crop(I, x5, x4)\n    x7 = rot90(x6)\n    x8 = double(x0)\n    x9 = divide(x8, x2)\n    x10 = increment(x9)\n    x11 = repeat(x7, x10)\n    x12 = merge(x11)\n    x13 = rot270(x12)\n    x14 = astuple(x3, x8)\n    x15 = crop(x13, ORIGIN, x14)\n    return x15\n\n",
    "annotated": "def verify_963e52fc(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    \n    # Convert the input grid to an object representation\n    x1 = asobject(I)\n    \n    # Calculate the horizontal period of the pattern in the object\n    x2 = hperiod(x1)\n    \n    # Get the height of the object (which is the same as the input grid height)\n    x3 = height(x1)\n    \n    # Create a tuple of the height and horizontal period\n    x4 = astuple(x3, x2)\n    \n    # Find the upper-left corner coordinates of the object\n    x5 = ulcorner(x1)\n    \n    # Crop the input grid to get one full period of the pattern\n    x6 = crop(I, x5, x4)\n    \n    # Rotate the cropped pattern 90 degrees clockwise\n    x7 = rot90(x6)\n    \n    # Double the width of the input grid (for the output grid)\n    x8 = double(x0)\n    \n    # Calculate how many times the pattern needs to be repeated horizontally\n    x9 = divide(x8, x2)\n    \n    # Add 1 to ensure the pattern covers the entire width, even if there's a remainder\n    x10 = increment(x9)\n    \n    # Create a tuple by repeating the rotated pattern the calculated number of times\n    x11 = repeat(x7, x10)\n    \n    # Merge the repeated patterns into a single object\n    x12 = merge(x11)\n    \n    # Rotate the merged pattern 270 degrees clockwise (effectively 90 degrees counterclockwise)\n    # This restores the original orientation of the pattern\n    x13 = rot270(x12)\n    \n    # Create a tuple of the original height and the doubled width\n    x14 = astuple(x3, x8)\n    \n    # Crop the final pattern to the correct size for the output grid\n    # This removes any excess pattern that went beyond the doubled width\n    x15 = crop(x13, ORIGIN, x14)\n    \n    # Return the final output grid\n    return x15\n"
  },
  "97999447": {
    "original": "def verify_97999447(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = asobject(I)\n    x2 = matcher(first, x0)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x1, x3)\n    x5 = apply(initset, x4)\n    x6 = apply(toindices, x5)\n    x7 = rbind(shoot, RIGHT)\n    x8 = compose(x7, center)\n    x9 = fork(recolor, color, x8)\n    x10 = mapply(x9, x5)\n    x11 = paint(I, x10)\n    x12 = width(I)\n    x13 = interval(ZERO, x12, ONE)\n    x14 = apply(double, x13)\n    x15 = apply(increment, x14)\n    x16 = apply(tojvec, x15)\n    x17 = prapply(shift, x6, x16)\n    x18 = merge(x17)\n    x19 = fill(x11, FIVE, x18)\n    return x19\n\n",
    "annotated": "def verify_97999447(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Convert the input grid to an object representation\n    x1 = asobject(I)\n    \n    # Create a function that checks if the first element of a tuple is equal to the background color\n    x2 = matcher(first, x0)\n    \n    # Create a function that returns True if a cell is not the background color\n    x3 = compose(flip, x2)\n    \n    # Filter the object representation to keep only non-background colored cells\n    x4 = sfilter(x1, x3)\n    \n    # Convert each non-background cell to a single-element set\n    x5 = apply(initset, x4)\n    \n    # Extract the indices of the non-background cells\n    x6 = apply(toindices, x5)\n    \n    # Create a function that shoots a line to the right from a given point\n    x7 = rbind(shoot, RIGHT)\n    \n    # Create a function that finds the center of a patch and then shoots a line to the right\n    x8 = compose(x7, center)\n    \n    # Create a function that recolors a line with the color of the original cell\n    x9 = fork(recolor, color, x8)\n    \n    # Apply the recoloring function to each non-background cell, creating horizontal lines\n    x10 = mapply(x9, x5)\n    \n    # Paint the horizontal lines onto the input grid\n    x11 = paint(I, x10)\n    \n    # Get the width of the input grid\n    x12 = width(I)\n    \n    # Create a range of integers from 0 to the width of the grid\n    x13 = interval(ZERO, x12, ONE)\n    \n    # Double each number in the range\n    x14 = apply(double, x13)\n    \n    # Increment each doubled number by 1\n    x15 = apply(increment, x14)\n    \n    # Convert each number to a horizontal vector (0, j)\n    x16 = apply(tojvec, x15)\n    \n    # Shift each non-background cell by each horizontal vector, creating alternating gaps\n    x17 = prapply(shift, x6, x16)\n    \n    # Merge all the shifted positions into a single set\n    x18 = merge(x17)\n    \n    # Fill the gaps with color 5 (completing the alternating pattern)\n    x19 = fill(x11, FIVE, x18)\n    \n    # Return the final grid with horizontal lines and alternating color 5\n    return x19\n"
  },
  "97a05b5b": {
    "original": "def verify_97a05b5b(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = matcher(numcolors, TWO)\n    x4 = fork(both, x2, x3)\n    x5 = sfilter(x0, x4)\n    x6 = difference(x0, x5)\n    x7 = merge(x6)\n    x8 = color(x7)\n    x9 = mostcolor(I)\n    x10 = subgrid(x7, I)\n    x11 = astuple(hmirror, vmirror)\n    x12 = astuple(cmirror, dmirror)\n    x13 = combine(x11, x12)\n    x14 = astuple(identity, rot180)\n    x15 = astuple(rot90, rot270)\n    x16 = combine(x14, x15)\n    x17 = combine(x16, x13)\n    x18 = lbind(canvas, NEG_ONE)\n    x19 = compose(x18, shape)\n    x20 = fork(paint, x19, normalize)\n    x21 = rbind(other, x8)\n    x22 = compose(x21, palette)\n    x23 = lbind(occurrences, x10)\n    x24 = chain(positive, size, x23)\n    x25 = compose(x24, asobject)\n    x26 = rbind(replace, x8)\n    x27 = rbind(replace, x9)\n    x28 = rbind(x27, x8)\n    x29 = compose(x28, x20)\n    x30 = fork(x26, x29, x22)\n    x31 = rbind(chain, initset)\n    x32 = compose(x25, first)\n    x33 = lbind(x31, x32)\n    x34 = lbind(rbind, rapply)\n    x35 = chain(x33, x34, x30)\n    x36 = lbind(occurrences, x10)\n    x37 = chain(first, x36, asobject)\n    x38 = lbind(argmax, x17)\n    x39 = compose(x38, x35)\n    x40 = compose(initset, x39)\n    x41 = fork(rapply, x40, x20)\n    x42 = compose(first, x41)\n    x43 = compose(initset, x39)\n    x44 = fork(rapply, x43, x30)\n    x45 = compose(first, x44)\n    x46 = compose(asobject, x42)\n    x47 = compose(x37, x45)\n    x48 = fork(shift, x46, x47)\n    x49 = mapply(x48, x5)\n    x50 = paint(x10, x49)\n    return x50\n\n",
    "annotated": "def verify_97a05b5b(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering background and allowing diagonal connections\n    x0 = objects(I, F, F, T)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if the size of an object equals its height * width\n    x2 = fork(equality, size, x1)\n    \n    # Create a function that checks if an object has exactly two colors\n    x3 = matcher(numcolors, TWO)\n    \n    # Combine the two previous checks (rectangular shape and two colors)\n    x4 = fork(both, x2, x3)\n    \n    # Filter objects that satisfy both conditions (rectangular and two colors)\n    x5 = sfilter(x0, x4)\n    \n    # Get all objects that are not rectangular two-colored objects\n    x6 = difference(x0, x5)\n    \n    # Merge all non-rectangular or non-two-colored objects into a single object\n    x7 = merge(x6)\n    \n    # Get the color of the merged object (background color of the subgrid)\n    x8 = color(x7)\n    \n    # Get the most common color in the input grid (overall background color)\n    x9 = mostcolor(I)\n    \n    # Extract the subgrid containing all non-rectangular or non-two-colored objects\n    x10 = subgrid(x7, I)\n    \n    # Create a tuple of horizontal and vertical mirror functions\n    x11 = astuple(hmirror, vmirror)\n    \n    # Create a tuple of diagonal mirror functions\n    x12 = astuple(cmirror, dmirror)\n    \n    # Combine all mirror functions\n    x13 = combine(x11, x12)\n    \n    # Create a tuple of identity and 180-degree rotation functions\n    x14 = astuple(identity, rot180)\n    \n    # Create a tuple of 90-degree and 270-degree rotation functions\n    x15 = astuple(rot90, rot270)\n    \n    # Combine rotation functions\n    x16 = combine(x14, x15)\n    \n    # Combine all transformation functions (mirrors and rotations)\n    x17 = combine(x16, x13)\n    \n    # Create a function to generate a canvas filled with -1\n    x18 = lbind(canvas, NEG_ONE)\n    \n    # Create a function to generate a canvas with the same shape as the input\n    x19 = compose(x18, shape)\n    \n    # Create a function to paint a normalized object on a canvas\n    x20 = fork(paint, x19, normalize)\n    \n    # Create a function to get the other color in the palette (not background)\n    x21 = rbind(other, x8)\n    \n    # Create a function to get the non-background color of an object\n    x22 = compose(x21, palette)\n    \n    # Create a function to find occurrences of objects in the subgrid\n    x23 = lbind(occurrences, x10)\n    \n    # Create a function to check if an object occurs in the subgrid\n    x24 = chain(positive, size, x23)\n    \n    # Create a function to check if an object as a grid occurs in the subgrid\n    x25 = compose(x24, asobject)\n    \n    # Create a function to replace the background color with -1\n    x26 = rbind(replace, x8)\n    \n    # Create a function to replace the overall background color with the subgrid background color\n    x27 = rbind(replace, x9)\n    \n    # Create a function to replace both background colors\n    x28 = rbind(x27, x8)\n    \n    # Create a function to normalize and recolor an object\n    x29 = compose(x28, x20)\n    \n    # Create a function to process an object (normalize, recolor, get non-background color)\n    x30 = fork(x26, x29, x22)\n    \n    # Create a function to initialize a set with the result of checking if an object occurs\n    x31 = rbind(chain, initset)\n    \n    # Create a function to check if the first object occurs in the subgrid\n    x32 = compose(x25, first)\n    \n    # Create a function to initialize a set based on the occurrence check\n    x33 = lbind(x31, x32)\n    \n    # Create a function to apply a function to each element of a set\n    x34 = lbind(rbind, rapply)\n    \n    # Create a function to process and check occurrence for each object\n    x35 = chain(x33, x34, x30)\n    \n    # Create a function to find occurrences of objects in the subgrid\n    x36 = lbind(occurrences, x10)\n    \n    # Create a function to get the position of the first occurrence of an object\n    x37 = chain(first, x36, asobject)\n    \n    # Create a function to find the best transformation for an object\n    x38 = lbind(argmax, x17)\n    \n    # Create a function to find the best transformation for processed objects\n    x39 = compose(x38, x35)\n    \n    # Create a function to initialize a set with the best transformation\n    x40 = compose(initset, x39)\n    \n    # Create a function to apply the best transformation to normalized objects\n    x41 = fork(rapply, x40, x20)\n    \n    # Create a function to get the transformed object\n    x42 = compose(first, x41)\n    \n    # Create a function to initialize a set with the best transformation (duplicate of x40)\n    x43 = compose(initset, x39)\n    \n    # Create a function to apply the best transformation to processed objects\n    x44 = fork(rapply, x43, x30)\n    \n    # Create a function to get the processed and transformed object\n    x45 = compose(first, x44)\n    \n    # Create a function to convert the transformed object to an object representation\n    x46 = compose(asobject, x42)\n    \n    # Create a function to get the position of the transformed object in the subgrid\n    x47 = compose(x37, x45)\n    \n    # Create a function to shift the transformed object to its correct position\n    x48 = fork(shift, x46, x47)\n    \n    # Apply the shifting function to all rectangular two-colored objects\n    x49 = mapply(x48, x5)\n    \n    # Paint the transformed and shifted objects onto the subgrid to create the output\n    x50 = paint(x10, x49)\n    \n    # Return the final output grid\n    return x50\n"
  },
  "98cf29f8": {
    "original": "def verify_98cf29f8(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = shape(I)\n    x5 = add(TWO, x4)\n    x6 = canvas(x3, x5)\n    x7 = asobject(I)\n    x8 = shift(x7, UNITY)\n    x9 = paint(x6, x8)\n    x10 = palette(x9)\n    x11 = remove(x3, x10)\n    x12 = lbind(ofcolor, x9)\n    x13 = fork(recolor, identity, x12)\n    x14 = apply(x13, x11)\n    x15 = fork(equality, toindices, backdrop)\n    x16 = extract(x14, x15)\n    x17 = other(x14, x16)\n    x18 = color(x17)\n    x19 = astuple(x18, RIGHT)\n    x20 = initset(ZERO_BY_TWO)\n    x21 = insert(ORIGIN, x20)\n    x22 = recolor(x3, x21)\n    x23 = insert(x19, x22)\n    x24 = dmirror(x23)\n    x25 = lbind(shift, x23)\n    x26 = occurrences(x9, x23)\n    x27 = mapply(x25, x26)\n    x28 = lbind(shift, x24)\n    x29 = occurrences(x9, x24)\n    x30 = mapply(x28, x29)\n    x31 = combine(x27, x30)\n    x32 = fill(x9, x3, x31)\n    x33 = ofcolor(x32, x18)\n    x34 = gravitate(x33, x16)\n    x35 = replace(x9, x18, x3)\n    x36 = shift(x33, x34)\n    x37 = fill(x35, x18, x36)\n    x38 = trim(x37)\n    return x38\n\n",
    "annotated": "def verify_98cf29f8(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Create a box outline around the entire grid\n    x1 = box(x0)\n    \n    # Convert the box outline to an object using the input grid's colors\n    x2 = toobject(x1, I)\n    \n    # Find the most common color in the box outline (likely the background color)\n    x3 = mostcolor(x2)\n    \n    # Get the dimensions of the input grid\n    x4 = shape(I)\n    \n    # Increase both dimensions by 2 to create a larger canvas\n    x5 = add(TWO, x4)\n    \n    # Create a new canvas with the background color and increased dimensions\n    x6 = canvas(x3, x5)\n    \n    # Convert the entire input grid to an object\n    x7 = asobject(I)\n    \n    # Shift the input grid object by (1, 1), effectively adding a 1-cell border\n    x8 = shift(x7, UNITY)\n    \n    # Paint the shifted input grid onto the new larger canvas\n    x9 = paint(x6, x8)\n    \n    # Get all colors used in the new grid\n    x10 = palette(x9)\n    \n    # Remove the background color from the palette\n    x11 = remove(x3, x10)\n    \n    # Create a function that finds all cells of a specific color in the new grid\n    x12 = lbind(ofcolor, x9)\n    \n    # Create a function that recolors cells of a specific color\n    x13 = fork(recolor, identity, x12)\n    \n    # Apply the recoloring function to all non-background colors\n    x14 = apply(x13, x11)\n    \n    # Create a function to check if an object forms a solid rectangle\n    x15 = fork(equality, toindices, backdrop)\n    \n    # Find the first object that forms a solid rectangle (likely the main object)\n    x16 = extract(x14, x15)\n    \n    # Find the other object (likely the smaller object to be moved)\n    x17 = other(x14, x16)\n    \n    # Get the color of the smaller object\n    x18 = color(x17)\n    \n    # Create a tuple (color, 1) for the smaller object's movement\n    x19 = astuple(x18, RIGHT)\n    \n    # Initialize a set with the point (0, 2)\n    x20 = initset(ZERO_BY_TWO)\n    \n    # Add the origin (0, 0) to the set\n    x21 = insert(ORIGIN, x20)\n    \n    # Create an L-shaped object with the background color\n    x22 = recolor(x3, x21)\n    \n    # Add the movement tuple to the L-shaped object\n    x23 = insert(x19, x22)\n    \n    # Create a mirrored version of the L-shaped object\n    x24 = dmirror(x23)\n    \n    # Create a function to shift the L-shaped object\n    x25 = lbind(shift, x23)\n    \n    # Find all occurrences of the L-shaped object in the grid\n    x26 = occurrences(x9, x23)\n    \n    # Apply the shift function to all occurrences of the L-shaped object\n    x27 = mapply(x25, x26)\n    \n    # Create a function to shift the mirrored L-shaped object\n    x28 = lbind(shift, x24)\n    \n    # Find all occurrences of the mirrored L-shaped object in the grid\n    x29 = occurrences(x9, x24)\n    \n    # Apply the shift function to all occurrences of the mirrored L-shaped object\n    x30 = mapply(x28, x29)\n    \n    # Combine the shifted positions of both L-shaped objects\n    x31 = combine(x27, x30)\n    \n    # Fill the shifted positions with the background color (effectively erasing the L-shapes)\n    x32 = fill(x9, x3, x31)\n    \n    # Find all cells with the color of the smaller object\n    x33 = ofcolor(x32, x18)\n    \n    # Calculate the movement needed to move the smaller object to the main object\n    x34 = gravitate(x33, x16)\n    \n    # Replace the color of the smaller object with the background color\n    x35 = replace(x9, x18, x3)\n    \n    # Shift the smaller object to its new position\n    x36 = shift(x33, x34)\n    \n    # Fill the new position of the smaller object with its original color\n    x37 = fill(x35, x18, x36)\n    \n    # Remove the 1-cell border added earlier\n    x38 = trim(x37)\n    \n    # Return the final grid with the smaller object moved to the main object\n    return x38\n"
  },
  "995c5fa3": {
    "original": "def verify_995c5fa3(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = increment(x0)\n    x2 = divide(x1, FIVE)\n    x3 = astuple(FOUR, FOUR)\n    x4 = canvas(NEG_ONE, x3)\n    x5 = asindices(x4)\n    x6 = rbind(toobject, I)\n    x7 = lbind(shift, x5)\n    x8 = compose(x6, x7)\n    x9 = multiply(x2, FIVE)\n    x10 = interval(ZERO, x9, FIVE)\n    x11 = apply(tojvec, x10)\n    x12 = apply(x8, x11)\n    x13 = matcher(numcolors, ONE)\n    x14 = fork(equality, identity, hmirror)\n    x15 = compose(flip, x14)\n    x16 = lbind(index, I)\n    x17 = compose(x16, ulcorner)\n    x18 = lbind(add, DOWN)\n    x19 = chain(x16, x18, ulcorner)\n    x20 = fork(equality, x17, x19)\n    x21 = compose(flip, x20)\n    x22 = fork(either, x13, x15)\n    x23 = fork(either, x22, x21)\n    x24 = compose(flip, x23)\n    x25 = lbind(multiply, TWO)\n    x26 = compose(x25, x13)\n    x27 = lbind(multiply, FOUR)\n    x28 = compose(x27, x15)\n    x29 = fork(add, x26, x28)\n    x30 = lbind(multiply, THREE)\n    x31 = compose(x30, x21)\n    x32 = lbind(multiply, EIGHT)\n    x33 = compose(x32, x24)\n    x34 = fork(add, x31, x33)\n    x35 = fork(add, x29, x34)\n    x36 = apply(x35, x12)\n    x37 = rbind(repeat, x2)\n    x38 = apply(x37, x36)\n    return x38\n\n",
    "annotated": "def verify_995c5fa3(I: Grid) -> Grid:\n    x0 = width(I)  # Get the width of the input grid\n    x1 = increment(x0)  # Increment the width by 1\n    x2 = divide(x1, FIVE)  # Divide the incremented width by 5 to get the number of objects\n    x3 = astuple(FOUR, FOUR)  # Create a tuple (4, 4) representing the dimensions of each object\n    x4 = canvas(NEG_ONE, x3)  # Create a 4x4 canvas filled with -1\n    x5 = asindices(x4)  # Convert the canvas to a set of indices\n    x6 = rbind(toobject, I)  # Partially apply toobject function with input grid I\n    x7 = lbind(shift, x5)  # Partially apply shift function with the 4x4 indices\n    x8 = compose(x6, x7)  # Compose toobject and shift functions\n    x9 = multiply(x2, FIVE)  # Multiply number of objects by 5 to get the total width\n    x10 = interval(ZERO, x9, FIVE)  # Create an interval from 0 to total width, step 5\n    x11 = apply(tojvec, x10)  # Convert each number in the interval to a horizontal vector\n    x12 = apply(x8, x11)  # Apply the composed function to each horizontal vector, extracting objects\n    x13 = matcher(numcolors, ONE)  # Create a function that checks if an object has exactly one color\n    x14 = fork(equality, identity, hmirror)  # Create a function that checks if an object is horizontally symmetric\n    x15 = compose(flip, x14)  # Flip the result of the symmetry check\n    x16 = lbind(index, I)  # Partially apply index function with input grid I\n    x17 = compose(x16, ulcorner)  # Compose index and ulcorner functions to get the color of the upper-left corner\n    x18 = lbind(add, DOWN)  # Partially apply add function with DOWN vector\n    x19 = chain(x16, x18, ulcorner)  # Chain functions to get the color of the cell below the upper-left corner\n    x20 = fork(equality, x17, x19)  # Create a function that checks if the two corner colors are equal\n    x21 = compose(flip, x20)  # Flip the result of the corner color check\n    x22 = fork(either, x13, x15)  # Combine single color check and symmetry check with OR\n    x23 = fork(either, x22, x21)  # Combine previous result with corner color check using OR\n    x24 = compose(flip, x23)  # Flip the result of the combined checks\n    x25 = lbind(multiply, TWO)  # Partially apply multiply function with 2\n    x26 = compose(x25, x13)  # Compose multiplication by 2 with single color check\n    x27 = lbind(multiply, FOUR)  # Partially apply multiply function with 4\n    x28 = compose(x27, x15)  # Compose multiplication by 4 with symmetry check\n    x29 = fork(add, x26, x28)  # Add results of single color and symmetry checks\n    x30 = lbind(multiply, THREE)  # Partially apply multiply function with 3\n    x31 = compose(x30, x21)  # Compose multiplication by 3 with corner color check\n    x32 = lbind(multiply, EIGHT)  # Partially apply multiply function with 8\n    x33 = compose(x32, x24)  # Compose multiplication by 8 with flipped combined check\n    x34 = fork(add, x31, x33)  # Add results of corner color check and flipped combined check\n    x35 = fork(add, x29, x34)  # Add all check results together\n    x36 = apply(x35, x12)  # Apply the combined check function to each extracted object\n    x37 = rbind(repeat, x2)  # Partially apply repeat function with the number of objects\n    x38 = apply(x37, x36)  # Repeat each result to create the output grid\n    return x38  # Return the final output grid\n"
  },
  "99b1bc43": {
    "original": "def verify_99b1bc43(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, vline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, hsplit, vsplit)\n    x5 = x4(I, TWO)\n    x6 = first(x5)\n    x7 = last(x5)\n    x8 = palette(x6)\n    x9 = palette(x7)\n    x10 = intersection(x8, x9)\n    x11 = first(x10)\n    x12 = shape(x6)\n    x13 = canvas(x11, x12)\n    x14 = ofcolor(x6, x11)\n    x15 = ofcolor(x7, x11)\n    x16 = combine(x14, x15)\n    x17 = intersection(x14, x15)\n    x18 = difference(x16, x17)\n    x19 = fill(x13, THREE, x18)\n    return x19\n\n",
    "annotated": "def verify_99b1bc43(I: Grid) -> Grid:\n    # Find all frontiers (continuous lines of the same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out only the vertical frontiers\n    x1 = sfilter(x0, vline)\n    # Count the number of vertical frontiers\n    x2 = size(x1)\n    # Check if there is at least one vertical frontier\n    x3 = positive(x2)\n    # Choose to split horizontally if there's a vertical frontier, otherwise split vertically\n    x4 = branch(x3, hsplit, vsplit)\n    # Split the input grid into two parts based on the chosen split method\n    x5 = x4(I, TWO)\n    # Get the first part of the split grid (left or top)\n    x6 = first(x5)\n    # Get the second part of the split grid (right or bottom)\n    x7 = last(x5)\n    # Get the set of colors used in the first part\n    x8 = palette(x6)\n    # Get the set of colors used in the second part\n    x9 = palette(x7)\n    # Find the common colors between the two parts (should be the background color)\n    x10 = intersection(x8, x9)\n    # Get the background color (first common color)\n    x11 = first(x10)\n    # Get the dimensions of the first part\n    x12 = shape(x6)\n    # Create a new grid with the background color and same dimensions as the first part\n    x13 = canvas(x11, x12)\n    # Find all cells in the first part that have the background color\n    x14 = ofcolor(x6, x11)\n    # Find all cells in the second part that have the background color\n    x15 = ofcolor(x7, x11)\n    # Combine the background-colored cells from both parts\n    x16 = combine(x14, x15)\n    # Find the cells that are background-colored in both parts\n    x17 = intersection(x14, x15)\n    # Find the cells that are background-colored in only one part (symmetric difference)\n    x18 = difference(x16, x17)\n    # Fill the cells of the symmetric difference with color 3 in the output grid\n    x19 = fill(x13, THREE, x18)\n    # Return the resulting grid, showing the symmetric difference of non-background cells\n    return x19\n"
  },
  "99fa7670": {
    "original": "def verify_99fa7670(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = objects(I, T, F, T)\n    x2 = rbind(shoot, RIGHT)\n    x3 = compose(x2, center)\n    x4 = fork(recolor, color, x3)\n    x5 = mapply(x4, x1)\n    x6 = paint(I, x5)\n    x7 = add(x0, DOWN_LEFT)\n    x8 = initset(x7)\n    x9 = mostcolor(I)\n    x10 = recolor(x9, x8)\n    x11 = objects(x6, T, F, T)\n    x12 = insert(x10, x11)\n    x13 = order(x12, uppermost)\n    x14 = first(x13)\n    x15 = remove(x10, x13)\n    x16 = remove(x14, x13)\n    x17 = compose(lrcorner, first)\n    x18 = compose(lrcorner, last)\n    x19 = fork(connect, x17, x18)\n    x20 = compose(color, first)\n    x21 = fork(recolor, x20, x19)\n    x22 = pair(x15, x16)\n    x23 = mapply(x21, x22)\n    x24 = underpaint(x6, x23)\n    return x24\n\n",
    "annotated": "def verify_99fa7670(I: Grid) -> Grid:\n    # Get the dimensions of the input grid\n    x0 = shape(I)\n    \n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background\n    x1 = objects(I, T, F, T)\n    \n    # Create a function that shoots a line to the right from a given point\n    x2 = rbind(shoot, RIGHT)\n    \n    # Create a function that finds the center of an object and then shoots a line to the right\n    x3 = compose(x2, center)\n    \n    # Create a function that recolors the shot line with the color of the original object\n    x4 = fork(recolor, color, x3)\n    \n    # Apply this recoloring function to all objects, creating horizontal lines\n    x5 = mapply(x4, x1)\n    \n    # Paint these horizontal lines onto the input grid\n    x6 = paint(I, x5)\n    \n    # Calculate the bottom-right corner of the grid\n    x7 = add(x0, DOWN_LEFT)\n    \n    # Create a set containing only the bottom-right corner\n    x8 = initset(x7)\n    \n    # Find the most common color in the input grid (background color)\n    x9 = mostcolor(I)\n    \n    # Create an object of the background color at the bottom-right corner\n    x10 = recolor(x9, x8)\n    \n    # Extract all objects from the grid with horizontal lines, ignoring the background\n    x11 = objects(x6, T, F, T)\n    \n    # Add the bottom-right corner object to the set of objects\n    x12 = insert(x10, x11)\n    \n    # Sort all objects based on their uppermost position\n    x13 = order(x12, uppermost)\n    \n    # Get the topmost object (which should be the first colored pixel)\n    x14 = first(x13)\n    \n    # Remove the bottom-right corner object from the sorted list\n    x15 = remove(x10, x13)\n    \n    # Remove the topmost object from the sorted list\n    x16 = remove(x14, x13)\n    \n    # Create a function to get the lower-right corner of the first object in a list\n    x17 = compose(lrcorner, first)\n    \n    # Create a function to get the lower-right corner of the last object in a list\n    x18 = compose(lrcorner, last)\n    \n    # Create a function that connects the lower-right corners of the first and last objects\n    x19 = fork(connect, x17, x18)\n    \n    # Create a function to get the color of the first object in a list\n    x20 = compose(color, first)\n    \n    # Create a function that recolors the connected line with the color of the first object\n    x21 = fork(recolor, x20, x19)\n    \n    # Pair up the objects (excluding the first and last) to create vertical lines\n    x22 = pair(x15, x16)\n    \n    # Apply the recoloring and connecting function to create vertical lines\n    x23 = mapply(x21, x22)\n    \n    # Paint the vertical lines onto the grid with horizontal lines, completing the L-shapes\n    x24 = underpaint(x6, x23)\n    \n    # Return the final grid with all L-shaped lines drawn\n    return x24\n"
  },
  "9aec4887": {
    "original": "def verify_9aec4887(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = sfilter(x0, x2)\n    x4 = mostcolor(I)\n    x5 = colorfilter(x3, x4)\n    x6 = argmax(x5, size)\n    x7 = outbox(x6)\n    x8 = backdrop(x7)\n    x9 = subgrid(x8, I)\n    x10 = cover(I, x8)\n    x11 = fgpartition(x10)\n    x12 = merge(x11)\n    x13 = normalize(x12)\n    x14 = shift(x13, UNITY)\n    x15 = paint(x9, x14)\n    x16 = toindices(x14)\n    x17 = fgpartition(x9)\n    x18 = rbind(remove, x17)\n    x19 = lbind(lbind, manhattan)\n    x20 = compose(x19, initset)\n    x21 = lbind(fork, greater)\n    x22 = lbind(sfilter, x16)\n    x23 = rbind(compose, x20)\n    x24 = lbind(lbind, valmin)\n    x25 = chain(x23, x24, x18)\n    x26 = rbind(compose, initset)\n    x27 = lbind(rbind, manhattan)\n    x28 = compose(x26, x27)\n    x29 = fork(x21, x25, x28)\n    x30 = compose(x22, x29)\n    x31 = fork(recolor, color, x30)\n    x32 = mapply(x31, x17)\n    x33 = paint(x15, x32)\n    return x33\n\n",
    "annotated": "def verify_9aec4887(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonally adjacent cells as part of the same object\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its height * width (i.e., if it's rectangular)\n    x2 = fork(equality, size, x1)\n    \n    # Filter objects to keep only rectangular ones\n    x3 = sfilter(x0, x2)\n    \n    # Get the most common color in the input grid (background color)\n    x4 = mostcolor(I)\n    \n    # Filter rectangular objects to keep only those with the background color\n    x5 = colorfilter(x3, x4)\n    \n    # Find the largest background-colored rectangular object (the frame)\n    x6 = argmax(x5, size)\n    \n    # Get the outbox of the frame (one cell larger in each direction)\n    x7 = outbox(x6)\n    \n    # Get all cells within the outbox\n    x8 = backdrop(x7)\n    \n    # Extract the subgrid defined by the outbox\n    x9 = subgrid(x8, I)\n    \n    # Remove the outbox area from the input grid\n    x10 = cover(I, x8)\n    \n    # Partition the remaining foreground objects\n    x11 = fgpartition(x10)\n    \n    # Merge all foreground objects into one\n    x12 = merge(x11)\n    \n    # Normalize the merged object (move to origin)\n    x13 = normalize(x12)\n    \n    # Shift the normalized object by (1,1) to fit inside the frame\n    x14 = shift(x13, UNITY)\n    \n    # Paint the shifted object onto the subgrid\n    x15 = paint(x9, x14)\n    \n    # Get the indices of the shifted object\n    x16 = toindices(x14)\n    \n    # Partition the foreground objects in the subgrid (border lines)\n    x17 = fgpartition(x9)\n    \n    # Create a function to remove border objects from a set\n    x18 = rbind(remove, x17)\n    \n    # Create a function to calculate Manhattan distance from a single point\n    x19 = lbind(lbind, manhattan)\n    x20 = compose(x19, initset)\n    \n    # Create a function to filter based on a \"greater than\" condition\n    x21 = lbind(fork, greater)\n    \n    # Create a function to filter the indices of the shifted object\n    x22 = lbind(sfilter, x16)\n    \n    # Create a function to compose with the Manhattan distance function\n    x23 = rbind(compose, x20)\n    \n    # Create a function to find the minimum value\n    x24 = lbind(lbind, valmin)\n    \n    # Chain functions to find the closest border object\n    x25 = chain(x23, x24, x18)\n    \n    # Create functions for Manhattan distance calculation\n    x26 = rbind(compose, initset)\n    x27 = lbind(rbind, manhattan)\n    x28 = compose(x26, x27)\n    \n    # Create a function to determine if a point is closer to one border than others\n    x29 = fork(x21, x25, x28)\n    \n    # Compose functions to filter points based on proximity to borders\n    x30 = compose(x22, x29)\n    \n    # Create a function to recolor points based on the closest border\n    x31 = fork(recolor, color, x30)\n    \n    # Apply the recoloring function to all border objects\n    x32 = mapply(x31, x17)\n    \n    # Paint the recolored objects onto the subgrid\n    x33 = paint(x15, x32)\n    \n    # Return the final grid\n    return x33\n"
  },
  "9af7a82c": {
    "original": "def verify_9af7a82c(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = order(x0, size)\n    x2 = valmax(x0, size)\n    x3 = rbind(astuple, ONE)\n    x4 = lbind(subtract, x2)\n    x5 = compose(x3, size)\n    x6 = chain(x3, x4, size)\n    x7 = fork(canvas, color, x5)\n    x8 = lbind(canvas, ZERO)\n    x9 = compose(x8, x6)\n    x10 = fork(vconcat, x7, x9)\n    x11 = compose(cmirror, x10)\n    x12 = apply(x11, x1)\n    x13 = merge(x12)\n    x14 = cmirror(x13)\n    return x14\n\n",
    "annotated": "def verify_9af7a82c(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Order the partitioned objects by their size (number of cells)\n    x1 = order(x0, size)\n    \n    # Find the size of the largest object\n    x2 = valmax(x0, size)\n    \n    # Create a function that pairs a value with 1\n    x3 = rbind(astuple, ONE)\n    \n    # Create a function that subtracts a value from the largest object size\n    x4 = lbind(subtract, x2)\n    \n    # Create a function that returns (size, 1) for an object\n    x5 = compose(x3, size)\n    \n    # Create a function that returns (largest_size - size + 1, 1) for an object\n    x6 = chain(x3, x4, size)\n    \n    # Create a function that generates a canvas of an object's color with height equal to its size\n    x7 = fork(canvas, color, x5)\n    \n    # Create a function that generates a canvas of zeros\n    x8 = lbind(canvas, ZERO)\n    \n    # Create a function that generates a canvas of zeros with height equal to (largest_size - size + 1)\n    x9 = compose(x8, x6)\n    \n    # Create a function that vertically concatenates the color canvas with the zero canvas\n    x10 = fork(vconcat, x7, x9)\n    \n    # Create a function that mirrors the concatenated canvas along the counter-diagonal\n    x11 = compose(cmirror, x10)\n    \n    # Apply the mirroring and concatenation to each ordered object\n    x12 = apply(x11, x1)\n    \n    # Merge all the resulting canvases into a single grid\n    x13 = merge(x12)\n    \n    # Mirror the final grid along the counter-diagonal to get the correct orientation\n    x14 = cmirror(x13)\n    \n    # Return the final transformed grid\n    return x14\n"
  },
  "9d9215db": {
    "original": "def verify_9d9215db(I: Grid) -> Grid:\n    x0 = hmirror(I)\n    x1 = fgpartition(x0)\n    x2 = merge(x1)\n    x3 = vmirror(I)\n    x4 = fgpartition(x3)\n    x5 = merge(x4)\n    x6 = hmirror(I)\n    x7 = vmirror(x6)\n    x8 = fgpartition(x7)\n    x9 = merge(x8)\n    x10 = mostcolor(I)\n    x11 = combine(x2, x5)\n    x12 = combine(x11, x9)\n    x13 = paint(I, x12)\n    x14 = compose(increment, first)\n    x15 = fork(greater, last, x14)\n    x16 = tojvec(NEG_TWO)\n    x17 = rbind(shift, x16)\n    x18 = compose(x17, vmirror)\n    x19 = rbind(sfilter, x15)\n    x20 = compose(x19, asindices)\n    x21 = compose(x18, x20)\n    x22 = fork(intersection, x20, x21)\n    x23 = rbind(shoot, RIGHT)\n    x24 = compose(x23, last)\n    x25 = matcher(first, x10)\n    x26 = compose(flip, x25)\n    x27 = rbind(sfilter, x26)\n    x28 = compose(double, halve)\n    x29 = fork(equality, x28, identity)\n    x30 = chain(flip, x29, last)\n    x31 = lbind(fork, both)\n    x32 = rbind(x31, x30)\n    x33 = lbind(fork, recolor)\n    x34 = lbind(x33, first)\n    x35 = rbind(compose, x24)\n    x36 = lbind(rbind, contained)\n    x37 = lbind(rbind, sfilter)\n    x38 = chain(x34, x35, x37)\n    x39 = chain(x38, x32, x36)\n    x40 = fork(toobject, x22, identity)\n    x41 = compose(x27, x40)\n    x42 = compose(x39, x22)\n    x43 = fork(mapply, x42, x41)\n    x44 = fork(paint, identity, x43)\n    x45 = compose(rot90, x44)\n    x46 = power(x45, FOUR)\n    x47 = x46(x13)\n    return x47\n\n",
    "annotated": "def verify_9d9215db(I: Grid) -> Grid:\n    # Mirror the input grid horizontally\n    x0 = hmirror(I)\n    # Partition the foreground of the mirrored grid\n    x1 = fgpartition(x0)\n    # Merge the partitioned foreground\n    x2 = merge(x1)\n    # Mirror the input grid vertically\n    x3 = vmirror(I)\n    # Partition the foreground of the vertically mirrored grid\n    x4 = fgpartition(x3)\n    # Merge the partitioned foreground of the vertically mirrored grid\n    x5 = merge(x4)\n    # Mirror the input grid horizontally\n    x6 = hmirror(I)\n    # Mirror the horizontally mirrored grid vertically\n    x7 = vmirror(x6)\n    # Partition the foreground of the double-mirrored grid\n    x8 = fgpartition(x7)\n    # Merge the partitioned foreground of the double-mirrored grid\n    x9 = merge(x8)\n    # Find the most common color in the input grid (background color)\n    x10 = mostcolor(I)\n    # Combine the merged foregrounds from horizontal, vertical, and double mirroring\n    x11 = combine(x2, x5)\n    x12 = combine(x11, x9)\n    # Paint the combined foregrounds onto the input grid\n    x13 = paint(I, x12)\n    # Create a function that increments the first element of a tuple\n    x14 = compose(increment, first)\n    # Create a function that checks if the last element is greater than the incremented first element\n    x15 = fork(greater, last, x14)\n    # Create a vector pointing two steps left\n    x16 = tojvec(NEG_TWO)\n    # Create a function that shifts by two steps left\n    x17 = rbind(shift, x16)\n    # Create a function that mirrors vertically and then shifts left\n    x18 = compose(x17, vmirror)\n    # Create a function that filters indices based on the condition in x15\n    x19 = rbind(sfilter, x15)\n    # Create a function that converts grid to indices and then applies the filter\n    x20 = compose(x19, asindices)\n    # Create a function that applies vertical mirroring, shifting, and filtering to indices\n    x21 = compose(x18, x20)\n    # Create a function that finds the intersection of filtered indices and their transformed version\n    x22 = fork(intersection, x20, x21)\n    # Create a function that shoots to the right from a given point\n    x23 = rbind(shoot, RIGHT)\n    # Create a function that shoots right from the last point of a set\n    x24 = compose(x23, last)\n    # Create a function that checks if a color matches the background color\n    x25 = matcher(first, x10)\n    # Create a function that inverts the background color matching check\n    x26 = compose(flip, x25)\n    # Create a function that filters elements not matching the background color\n    x27 = rbind(sfilter, x26)\n    # Create a function that doubles and then halves a number (used for checking even numbers)\n    x28 = compose(double, halve)\n    # Create a function that checks if a number is even\n    x29 = fork(equality, x28, identity)\n    # Create a function that checks if the last element of a tuple is even\n    x30 = chain(flip, x29, last)\n    # Create a partial function for combining two conditions with 'and'\n    x31 = lbind(fork, both)\n    # Create a function that combines the evenness check with another condition\n    x32 = rbind(x31, x30)\n    # Create a partial function for recoloring\n    x33 = lbind(fork, recolor)\n    # Create a function that recolors using the first element of a tuple\n    x34 = lbind(x33, first)\n    # Create a function that composes shooting right with another function\n    x35 = rbind(compose, x24)\n    # Create a partial function for checking if an element is contained in a set\n    x36 = lbind(rbind, contained)\n    # Create a partial function for filtering a set\n    x37 = lbind(rbind, sfilter)\n    # Create a complex function for recoloring, shooting, and filtering\n    x38 = chain(x34, x35, x37)\n    # Create a function that combines recoloring, shooting, filtering, and condition checking\n    x39 = chain(x38, x32, x36)\n    # Create a function that converts filtered indices to objects\n    x40 = fork(toobject, x22, identity)\n    # Create a function that filters objects not matching the background color\n    x41 = compose(x27, x40)\n    # Create a function that applies the complex recoloring and filtering to filtered indices\n    x42 = compose(x39, x22)\n    # Create a function that applies the recoloring and filtering to non-background objects\n    x43 = fork(mapply, x42, x41)\n    # Create a function that paints the processed objects onto the input grid\n    x44 = fork(paint, identity, x43)\n    # Create a function that rotates the painted grid 90 degrees\n    x45 = compose(rot90, x44)\n    # Create a function that applies the rotation and painting process 4 times\n    x46 = power(x45, FOUR)\n    # Apply the entire transformation process to the input grid with mirrored foregrounds\n    x47 = x46(x13)\n    # Return the final transformed grid\n    return x47\n"
  },
  "9dfd6313": {
    "original": "def verify_9dfd6313(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = decrement(x0)\n    x2 = connect(ORIGIN, x1)\n    x3 = height(I)\n    x4 = decrement(x3)\n    x5 = toivec(x4)\n    x6 = width(I)\n    x7 = decrement(x6)\n    x8 = tojvec(x7)\n    x9 = connect(x5, x8)\n    x10 = height(I)\n    x11 = halve(x10)\n    x12 = toivec(x11)\n    x13 = width(I)\n    x14 = decrement(x13)\n    x15 = astuple(x11, x14)\n    x16 = connect(x12, x15)\n    x17 = width(I)\n    x18 = halve(x17)\n    x19 = tojvec(x18)\n    x20 = height(I)\n    x21 = decrement(x20)\n    x22 = astuple(x21, x18)\n    x23 = connect(x19, x22)\n    x24 = astuple(x2, dmirror)\n    x25 = astuple(x9, cmirror)\n    x26 = astuple(x24, x25)\n    x27 = astuple(x23, vmirror)\n    x28 = astuple(x16, hmirror)\n    x29 = astuple(x27, x28)\n    x30 = combine(x26, x29)\n    x31 = lbind(colorcount, I)\n    x32 = rbind(toobject, I)\n    x33 = compose(x32, first)\n    x34 = chain(x31, color, x33)\n    x35 = compose(size, first)\n    x36 = fork(equality, x34, x35)\n    x37 = rbind(toobject, I)\n    x38 = chain(numcolors, x37, first)\n    x39 = matcher(x38, ONE)\n    x40 = fork(both, x39, x36)\n    x41 = extract(x30, x40)\n    x42 = last(x41)\n    x43 = x42(I)\n    return x43\n\n",
    "annotated": "def verify_9dfd6313(I: Grid) -> Grid:\n    # Get the shape (height, width) of the input grid\n    x0 = shape(I)\n    # Decrement both dimensions of the shape\n    x1 = decrement(x0)\n    # Create a line from (0,0) to the bottom-right corner\n    x2 = connect(ORIGIN, x1)\n    # Get the height of the input grid\n    x3 = height(I)\n    # Decrement the height\n    x4 = decrement(x3)\n    # Create a vertical vector with the decremented height\n    x5 = toivec(x4)\n    # Get the width of the input grid\n    x6 = width(I)\n    # Decrement the width\n    x7 = decrement(x6)\n    # Create a horizontal vector with the decremented width\n    x8 = tojvec(x7)\n    # Create a line from bottom-left to top-right corner\n    x9 = connect(x5, x8)\n    # Get the height of the input grid\n    x10 = height(I)\n    # Calculate half of the height\n    x11 = halve(x10)\n    # Create a vertical vector with half the height\n    x12 = toivec(x11)\n    # Get the width of the input grid\n    x13 = width(I)\n    # Decrement the width\n    x14 = decrement(x13)\n    # Create a tuple with (half height, full width - 1)\n    x15 = astuple(x11, x14)\n    # Create a horizontal line in the middle of the grid\n    x16 = connect(x12, x15)\n    # Get the width of the input grid\n    x17 = width(I)\n    # Calculate half of the width\n    x18 = halve(x17)\n    # Create a horizontal vector with half the width\n    x19 = tojvec(x18)\n    # Get the height of the input grid\n    x20 = height(I)\n    # Decrement the height\n    x21 = decrement(x20)\n    # Create a tuple with (full height - 1, half width)\n    x22 = astuple(x21, x18)\n    # Create a vertical line in the middle of the grid\n    x23 = connect(x19, x22)\n    # Create a tuple with diagonal line and diagonal mirror function\n    x24 = astuple(x2, dmirror)\n    # Create a tuple with anti-diagonal line and counter-diagonal mirror function\n    x25 = astuple(x9, cmirror)\n    # Combine diagonal and anti-diagonal tuples\n    x26 = astuple(x24, x25)\n    # Create a tuple with vertical line and vertical mirror function\n    x27 = astuple(x23, vmirror)\n    # Create a tuple with horizontal line and horizontal mirror function\n    x28 = astuple(x16, hmirror)\n    # Combine vertical and horizontal tuples\n    x29 = astuple(x27, x28)\n    # Combine all line and mirror function tuples\n    x30 = combine(x26, x29)\n    # Partially apply colorcount function with input grid\n    x31 = lbind(colorcount, I)\n    # Partially apply toobject function with input grid\n    x32 = rbind(toobject, I)\n    # Create a function to get the first object from the grid\n    x33 = compose(x32, first)\n    # Create a function to get the color count of the first object\n    x34 = chain(x31, color, x33)\n    # Create a function to get the size of the first object\n    x35 = compose(size, first)\n    # Create a function to check if color count equals object size\n    x36 = fork(equality, x34, x35)\n    # Partially apply toobject function with input grid\n    x37 = rbind(toobject, I)\n    # Create a function to get the number of colors in the first object\n    x38 = chain(numcolors, x37, first)\n    # Create a function to check if number of colors is 1\n    x39 = matcher(x38, ONE)\n    # Combine checks for single color and color count equality\n    x40 = fork(both, x39, x36)\n    # Extract the correct line and mirror function based on conditions\n    x41 = extract(x30, x40)\n    # Get the mirror function\n    x42 = last(x41)\n    # Apply the mirror function to the input grid\n    x43 = x42(I)\n    # Return the mirrored grid\n    return x43\n"
  },
  "9ecd008a": {
    "original": "def verify_9ecd008a(I: Grid) -> Grid:\n    x0 = ofcolor(I, ZERO)\n    x1 = rbind(colorcount, ZERO)\n    x2 = lbind(toobject, x0)\n    x3 = compose(x1, x2)\n    x4 = vmirror(I)\n    x5 = hmirror(I)\n    x6 = astuple(x4, x5)\n    x7 = argmin(x6, x3)\n    x8 = subgrid(x0, x7)\n    return x8\n\n",
    "annotated": "def verify_9ecd008a(I: Grid) -> Grid:\n    # Get the indices of all cells with color 0 (background color) in the input grid\n    x0 = ofcolor(I, ZERO)\n    \n    # Create a function that counts the number of cells with color 0 in a given object\n    x1 = rbind(colorcount, ZERO)\n    \n    # Create a function that converts the background indices to an object\n    x2 = lbind(toobject, x0)\n    \n    # Compose the two functions to count background cells in the object\n    x3 = compose(x1, x2)\n    \n    # Mirror the input grid vertically\n    x4 = vmirror(I)\n    \n    # Mirror the input grid horizontally\n    x5 = hmirror(I)\n    \n    # Create a tuple of the vertically and horizontally mirrored grids\n    x6 = astuple(x4, x5)\n    \n    # Find the mirrored grid with the least number of background cells\n    # This identifies which quadrant of the original grid contains the subgrid\n    x7 = argmin(x6, x3)\n    \n    # Extract the subgrid from the identified quadrant using the background cell indices\n    x8 = subgrid(x0, x7)\n    \n    # Return the extracted subgrid as the output\n    return x8\n"
  },
  "9edfc990": {
    "original": "def verify_9edfc990(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = colorfilter(x0, ZERO)\n    x2 = ofcolor(I, ONE)\n    x3 = rbind(adjacent, x2)\n    x4 = mfilter(x1, x3)\n    x5 = recolor(ONE, x4)\n    x6 = paint(I, x5)\n    return x6\n\n",
    "annotated": "def verify_9edfc990(I: Grid) -> Grid:\n    # Identify all objects (connected components) in the input grid I\n    # T: univalued, F: not considering diagonal connections, F: not ignoring background\n    x0 = objects(I, T, F, F)\n\n    # Filter objects to keep only those of color 0 (background)\n    x1 = colorfilter(x0, ZERO)\n\n    # Find all cells in the input grid I that are colored blue (1)\n    x2 = ofcolor(I, ONE)\n\n    # Create a function that checks if an object is adjacent to any blue cell\n    x3 = rbind(adjacent, x2)\n\n    # Filter background objects to keep only those adjacent to blue cells\n    x4 = mfilter(x1, x3)\n\n    # Recolor the filtered background objects to blue (1)\n    x5 = recolor(ONE, x4)\n\n    # Paint the recolored objects onto the original input grid\n    # This effectively expands the blue regions to adjacent background areas\n    x6 = paint(I, x5)\n\n    # Return the modified grid as the output\n    return x6\n"
  },
  "9f236235": {
    "original": "def verify_9f236235(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = shape(I)\n    x4 = canvas(x2, x3)\n    x5 = hconcat(I, x4)\n    x6 = objects(x5, T, F, T)\n    x7 = apply(uppermost, x6)\n    x8 = order(x7, identity)\n    x9 = lbind(sfilter, x6)\n    x10 = lbind(matcher, uppermost)\n    x11 = compose(x9, x10)\n    x12 = lbind(apply, color)\n    x13 = rbind(order, leftmost)\n    x14 = chain(x12, x13, x11)\n    x15 = apply(x14, x8)\n    x16 = vmirror(x15)\n    return x16\n\n",
    "annotated": "def verify_9f236235(I: Grid) -> Grid:\n    # Identify all frontiers (horizontal and vertical lines) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Get the color of the merged frontiers (grid line color)\n    x2 = color(x1)\n    \n    # Get the dimensions of the input grid\n    x3 = shape(I)\n    \n    # Create a new grid with the same dimensions as I, filled with the grid line color\n    x4 = canvas(x2, x3)\n    \n    # Concatenate the input grid and the grid line color grid horizontally\n    x5 = hconcat(I, x4)\n    \n    # Identify all objects in the concatenated grid, considering diagonal connections and ignoring the background\n    x6 = objects(x5, T, F, T)\n    \n    # Get the uppermost row of each object\n    x7 = apply(uppermost, x6)\n    \n    # Order the objects based on their uppermost row\n    x8 = order(x7, identity)\n    \n    # Prepare a function to filter objects based on their uppermost row\n    x9 = lbind(sfilter, x6)\n    \n    # Prepare a function to match objects based on their uppermost row\n    x10 = lbind(matcher, uppermost)\n    \n    # Compose the filter and matcher functions\n    x11 = compose(x9, x10)\n    \n    # Prepare a function to apply the color function to objects\n    x12 = lbind(apply, color)\n    \n    # Prepare a function to order objects based on their leftmost column\n    x13 = rbind(order, leftmost)\n    \n    # Chain the color application, ordering, and filtering functions\n    x14 = chain(x12, x13, x11)\n    \n    # Apply the chained function to the ordered objects, creating rows of colors\n    x15 = apply(x14, x8)\n    \n    # Mirror the resulting grid vertically to match the output orientation\n    x16 = vmirror(x15)\n    \n    # Return the final grid, which should match the expected output\n    return x16\n"
  },
  "a1570a43": {
    "original": "def verify_a1570a43(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = fork(equality, toindices, corners)\n    x3 = fork(multiply, height, width)\n    x4 = sfilter(x0, x2)\n    x5 = argmax(x4, x3)\n    x6 = difference(x1, x5)\n    x7 = mostcolor(I)\n    x8 = fill(I, x7, x6)\n    x9 = normalize(x6)\n    x10 = ulcorner(x5)\n    x11 = increment(x10)\n    x12 = shift(x9, x11)\n    x13 = paint(x8, x12)\n    return x13\n\n",
    "annotated": "def verify_a1570a43(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all objects into a single set of cells\n    x1 = merge(x0)\n    \n    # Create a function that checks if an object's indices are equal to its corners\n    # This identifies the object that forms the border\n    x2 = fork(equality, toindices, corners)\n    \n    # Create a function that multiplies the height and width of an object\n    # This will be used to find the largest object\n    x3 = fork(multiply, height, width)\n    \n    # Filter objects to keep only those that form a border (corner dots)\n    x4 = sfilter(x0, x2)\n    \n    # Find the largest border object (the one enclosing the shape to be moved)\n    x5 = argmax(x4, x3)\n    \n    # Get all cells that are not part of the border object\n    # This includes the shape to be moved and any background cells\n    x6 = difference(x1, x5)\n    \n    # Find the most common color in the input grid (background color)\n    x7 = mostcolor(I)\n    \n    # Fill all non-border cells with the background color\n    # This removes the original position of the shape\n    x8 = fill(I, x7, x6)\n    \n    # Normalize the position of the non-border cells (move to origin)\n    x9 = normalize(x6)\n    \n    # Get the upper-left corner of the border object\n    x10 = ulcorner(x5)\n    \n    # Increment the upper-left corner coordinates\n    # This gives the position just inside the border\n    x11 = increment(x10)\n    \n    # Shift the normalized shape to the position just inside the border\n    x12 = shift(x9, x11)\n    \n    # Paint the shifted shape onto the grid with the removed original shape\n    # This places the shape in its final position\n    x13 = paint(x8, x12)\n    \n    # Return the final grid with the shape moved to its correct position\n    return x13\n"
  },
  "a2fd1cf0": {
    "original": "def verify_a2fd1cf0(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = ofcolor(I, THREE)\n    x2 = uppermost(x0)\n    x3 = leftmost(x0)\n    x4 = uppermost(x1)\n    x5 = leftmost(x1)\n    x6 = astuple(x2, x4)\n    x7 = minimum(x6)\n    x8 = maximum(x6)\n    x9 = astuple(x7, x5)\n    x10 = astuple(x8, x5)\n    x11 = connect(x9, x10)\n    x12 = astuple(x3, x5)\n    x13 = minimum(x12)\n    x14 = maximum(x12)\n    x15 = astuple(x2, x13)\n    x16 = astuple(x2, x14)\n    x17 = connect(x15, x16)\n    x18 = combine(x11, x17)\n    x19 = underfill(I, EIGHT, x18)\n    return x19\n\n",
    "annotated": "def verify_a2fd1cf0(I: Grid) -> Grid:\n    # Find the indices of all red (color 2) cells in the input grid\n    x0 = ofcolor(I, TWO)\n    # Find the indices of all green (color 3) cells in the input grid\n    x1 = ofcolor(I, THREE)\n    # Get the topmost row index of the red cell(s)\n    x2 = uppermost(x0)\n    # Get the leftmost column index of the red cell(s)\n    x3 = leftmost(x0)\n    # Get the topmost row index of the green cell(s)\n    x4 = uppermost(x1)\n    # Get the leftmost column index of the green cell(s)\n    x5 = leftmost(x1)\n    # Create a tuple of the row indices of red and green cells\n    x6 = astuple(x2, x4)\n    # Get the smaller (upper) of the two row indices\n    x7 = minimum(x6)\n    # Get the larger (lower) of the two row indices\n    x8 = maximum(x6)\n    # Create a tuple for the start point of the vertical line (upper row, green column)\n    x9 = astuple(x7, x5)\n    # Create a tuple for the end point of the vertical line (lower row, green column)\n    x10 = astuple(x8, x5)\n    # Generate the indices for the vertical yellow line\n    x11 = connect(x9, x10)\n    # Create a tuple of the column indices of red and green cells\n    x12 = astuple(x3, x5)\n    # Get the smaller (left) of the two column indices\n    x13 = minimum(x12)\n    # Get the larger (right) of the two column indices\n    x14 = maximum(x12)\n    # Create a tuple for the start point of the horizontal line (red row, left column)\n    x15 = astuple(x2, x13)\n    # Create a tuple for the end point of the horizontal line (red row, right column)\n    x16 = astuple(x2, x14)\n    # Generate the indices for the horizontal yellow line\n    x17 = connect(x15, x16)\n    # Combine the indices of both vertical and horizontal yellow lines\n    x18 = combine(x11, x17)\n    # Fill the combined indices with yellow (color 8) on the input grid, only where there's no existing color\n    x19 = underfill(I, EIGHT, x18)\n    # Return the modified grid with the yellow L-shaped line added\n    return x19\n"
  },
  "a3325580": {
    "original": "def verify_a3325580(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = valmax(x0, size)\n    x2 = sizefilter(x0, x1)\n    x3 = order(x2, leftmost)\n    x4 = apply(color, x3)\n    x5 = astuple(ONE, x1)\n    x6 = rbind(canvas, x5)\n    x7 = apply(x6, x4)\n    x8 = merge(x7)\n    x9 = dmirror(x8)\n    return x9\n\n",
    "annotated": "def verify_a3325580(I: Grid) -> Grid:\n    # Identify all objects in the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    \n    # Find the size of the largest object(s)\n    x1 = valmax(x0, size)\n    \n    # Filter objects to keep only those with the maximum size\n    x2 = sizefilter(x0, x1)\n    \n    # Order the largest objects from left to right based on their leftmost position\n    x3 = order(x2, leftmost)\n    \n    # Extract the color of each ordered object\n    x4 = apply(color, x3)\n    \n    # Create a tuple (1, max_size) to be used as dimensions for each column in the output\n    x5 = astuple(ONE, x1)\n    \n    # Partially apply the canvas function with the dimensions, preparing it for creating columns\n    x6 = rbind(canvas, x5)\n    \n    # Create a vertical line (column) for each object color\n    x7 = apply(x6, x4)\n    \n    # Merge all the vertical lines into a single grid\n    x8 = merge(x7)\n    \n    # Mirror the grid diagonally, effectively transposing it\n    # This turns the vertical lines into horizontal lines, creating the final output\n    x9 = dmirror(x8)\n    \n    # Return the final output grid\n    return x9\n"
  },
  "a3df8b1e": {
    "original": "def verify_a3df8b1e(I: Grid) -> Grid:\n    x0 = portrait(I)\n    x1 = branch(x0, identity, dmirror)\n    x2 = x1(I)\n    x3 = asindices(x2)\n    x4 = shoot(ORIGIN, UNITY)\n    x5 = intersection(x4, x3)\n    x6 = lrcorner(x5)\n    x7 = shoot(x6, DOWN_LEFT)\n    x8 = intersection(x7, x3)\n    x9 = combine(x5, x8)\n    x10 = llcorner(x9)\n    x11 = remove(x10, x9)\n    x12 = lbind(shift, x11)\n    x13 = height(x11)\n    x14 = lbind(multiply, x13)\n    x15 = chain(x12, toivec, x14)\n    x16 = height(x2)\n    x17 = height(x11)\n    x18 = divide(x16, x17)\n    x19 = increment(x18)\n    x20 = interval(ZERO, x19, ONE)\n    x21 = mapply(x15, x20)\n    x22 = rbind(contained, x21)\n    x23 = sfilter(x3, x22)\n    x24 = asindices(I)\n    x25 = corners(x24)\n    x26 = difference(x24, x25)\n    x27 = toobject(x26, I)\n    x28 = mostcolor(x27)\n    x29 = palette(I)\n    x30 = other(x29, x28)\n    x31 = ulcorner(x3)\n    x32 = index(x2, x31)\n    x33 = equality(x32, x30)\n    x34 = urcorner(x3)\n    x35 = index(x2, x34)\n    x36 = equality(x35, x30)\n    x37 = llcorner(x3)\n    x38 = index(x2, x37)\n    x39 = equality(x38, x30)\n    x40 = lrcorner(x3)\n    x41 = index(x2, x40)\n    x42 = equality(x41, x30)\n    x43 = astuple(x33, x36)\n    x44 = astuple(x39, x42)\n    x45 = combine(x43, x44)\n    x46 = vmirror(x23)\n    x47 = astuple(x23, x46)\n    x48 = hmirror(x23)\n    x49 = hmirror(x46)\n    x50 = astuple(x48, x49)\n    x51 = combine(x47, x50)\n    x52 = pair(x45, x51)\n    x53 = sfilter(x52, first)\n    x54 = mapply(last, x53)\n    x55 = fill(x2, x30, x54)\n    x56 = x1(x55)\n    return x56\n\n",
    "annotated": "def verify_a3df8b1e(I: Grid) -> Grid:\n    x0 = portrait(I)  # Check if the input grid is taller than it is wide\n    x1 = branch(x0, identity, dmirror)  # If portrait, use identity function; otherwise, use diagonal mirror\n    x2 = x1(I)  # Apply the chosen transformation (identity or dmirror) to the input grid\n    x3 = asindices(x2)  # Get all indices of the transformed grid\n    x4 = shoot(ORIGIN, UNITY)  # Create a line from (0,0) to (1,1) and extend it\n    x5 = intersection(x4, x3)  # Find the intersection of the diagonal line with the grid indices\n    x6 = lrcorner(x5)  # Get the lower right corner of the intersection\n    x7 = shoot(x6, DOWN_LEFT)  # Create a line from the lower right corner going down and left\n    x8 = intersection(x7, x3)  # Find the intersection of this new line with the grid indices\n    x9 = combine(x5, x8)  # Combine the two intersections to form the complete line\n    x10 = llcorner(x9)  # Get the lower left corner of the complete line\n    x11 = remove(x10, x9)  # Remove the lower left corner from the line\n    x12 = lbind(shift, x11)  # Create a function that shifts by the line's vector\n    x13 = height(x11)  # Get the height of the line\n    x14 = lbind(multiply, x13)  # Create a function that multiplies by the line's height\n    x15 = chain(x12, toivec, x14)  # Chain functions to create shifts for each line\n    x16 = height(x2)  # Get the height of the transformed grid\n    x17 = height(x11)  # Get the height of the line (same as x13)\n    x18 = divide(x16, x17)  # Calculate how many times the line fits in the grid height\n    x19 = increment(x18)  # Add 1 to account for all possible line positions\n    x20 = interval(ZERO, x19, ONE)  # Create a range from 0 to the number of possible line positions\n    x21 = mapply(x15, x20)  # Apply the shift function to each position in the range\n    x22 = rbind(contained, x21)  # Create a function to check if a point is in any of the shifted lines\n    x23 = sfilter(x3, x22)  # Filter the grid indices to only those in the lines\n    x24 = asindices(I)  # Get all indices of the original input grid\n    x25 = corners(x24)  # Get the corner indices of the original grid\n    x26 = difference(x24, x25)  # Remove the corners from all indices (get non-corner indices)\n    x27 = toobject(x26, I)  # Create an object from the non-corner indices and their values\n    x28 = mostcolor(x27)  # Find the most common color in the non-corner cells (background color)\n    x29 = palette(I)  # Get all colors used in the input grid\n    x30 = other(x29, x28)  # Find the other color (line color)\n    x31 = ulcorner(x3)  # Get the upper left corner of the transformed grid\n    x32 = index(x2, x31)  # Get the color at the upper left corner\n    x33 = equality(x32, x30)  # Check if the upper left corner is the line color\n    x34 = urcorner(x3)  # Get the upper right corner of the transformed grid\n    x35 = index(x2, x34)  # Get the color at the upper right corner\n    x36 = equality(x35, x30)  # Check if the upper right corner is the line color\n    x37 = llcorner(x3)  # Get the lower left corner of the transformed grid\n    x38 = index(x2, x37)  # Get the color at the lower left corner\n    x39 = equality(x38, x30)  # Check if the lower left corner is the line color\n    x40 = lrcorner(x3)  # Get the lower right corner of the transformed grid\n    x41 = index(x2, x40)  # Get the color at the lower right corner\n    x42 = equality(x41, x30)  # Check if the lower right corner is the line color\n    x43 = astuple(x33, x36)  # Combine upper left and upper right corner checks\n    x44 = astuple(x39, x42)  # Combine lower left and lower right corner checks\n    x45 = combine(x43, x44)  # Combine all corner checks\n    x46 = vmirror(x23)  # Create a vertical mirror of the line indices\n    x47 = astuple(x23, x46)  # Combine original and vertically mirrored line indices\n    x48 = hmirror(x23)  # Create a horizontal mirror of the line indices\n    x49 = hmirror(x46)  # Create a horizontal mirror of the vertically mirrored line indices\n    x50 = astuple(x48, x49)  # Combine horizontally mirrored line indices\n    x51 = combine(x47, x50)  # Combine all original and mirrored line indices\n    x52 = pair(x45, x51)  # Pair corner checks with corresponding line indices\n    x53 = sfilter(x52, first)  # Keep only the pairs where the corner check is True\n    x54 = mapply(last, x53)  # Get the line indices for the valid corners\n    x55 = fill(x2, x30, x54)  # Fill the transformed grid with the line color at the valid line indices\n    x56 = x1(x55)  # Apply the inverse transformation (identity or dmirror) to get the final output\n    return x56  # Return the final output grid\n"
  },
  "a416b8f3": {
    "original": "def verify_a416b8f3(I: Grid) -> Grid:\n    x0 = hconcat(I, I)\n    return x0\n\n",
    "annotated": "def verify_a416b8f3(I: Grid) -> Grid:\n    # Horizontally concatenate the input grid with itself\n    # This effectively doubles the width of the grid by placing an exact copy of the input grid to its right\n    x0 = hconcat(I, I)\n    \n    # Return the resulting concatenated grid\n    # The output is a grid that is twice as wide as the input, with the original pattern repeated\n    return x0\n"
  },
  "a48eeaf7": {
    "original": "def verify_a48eeaf7(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = sfilter(x0, x1)\n    x3 = argmax(x2, size)\n    x4 = other(x0, x3)\n    x5 = color(x4)\n    x6 = toindices(x4)\n    x7 = outbox(x3)\n    x8 = lbind(argmin, x7)\n    x9 = lbind(lbind, manhattan)\n    x10 = rbind(compose, initset)\n    x11 = chain(x8, x10, x9)\n    x12 = compose(x11, initset)\n    x13 = apply(x12, x6)\n    x14 = cover(I, x4)\n    x15 = fill(x14, x5, x13)\n    return x15\n\n",
    "annotated": "def verify_a48eeaf7(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x1 = fork(equality, toindices, backdrop)\n    \n    # Filter objects to keep only those that fill their bounding box (likely the inner square)\n    x2 = sfilter(x0, x1)\n    \n    # Find the largest object among the filtered objects (the inner square)\n    x3 = argmax(x2, size)\n    \n    # Get the other object (the dots) by removing the inner square from all objects\n    x4 = other(x0, x3)\n    \n    # Get the color of the dots\n    x5 = color(x4)\n    \n    # Get the indices of all dot positions\n    x6 = toindices(x4)\n    \n    # Get the outline of the inner square (one cell away from its edges)\n    x7 = outbox(x3)\n    \n    # Create a function to find the closest point on the outline to a given point\n    x8 = lbind(argmin, x7)\n    x9 = lbind(lbind, manhattan)\n    x10 = rbind(compose, initset)\n    x11 = chain(x8, x10, x9)\n    x12 = compose(x11, initset)\n    \n    # Apply the function to each dot position to find their new positions on the outline\n    x13 = apply(x12, x6)\n    \n    # Remove the original dots from the input grid\n    x14 = cover(I, x4)\n    \n    # Place the dots in their new positions on the outline of the inner square\n    x15 = fill(x14, x5, x13)\n    \n    # Return the modified grid\n    return x15\n"
  },
  "a5313dff": {
    "original": "def verify_a5313dff(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = rbind(bordering, I)\n    x2 = compose(flip, x1)\n    x3 = sfilter(x0, x2)\n    x4 = totuple(x3)\n    x5 = apply(color, x4)\n    x6 = mostcommon(x5)\n    x7 = mostcolor(I)\n    x8 = colorfilter(x0, x7)\n    x9 = rbind(bordering, I)\n    x10 = compose(flip, x9)\n    x11 = mfilter(x8, x10)\n    x12 = fill(I, ONE, x11)\n    return x12\n\n",
    "annotated": "def verify_a5313dff(I: Grid) -> Grid:\n    # Find all objects in the input grid, including diagonally connected cells\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that checks if an object is bordering the grid\n    x1 = rbind(bordering, I)\n    \n    # Create a function that checks if an object is NOT bordering the grid\n    x2 = compose(flip, x1)\n    \n    # Filter objects that are not bordering the grid\n    x3 = sfilter(x0, x2)\n    \n    # Convert the filtered objects to a tuple\n    x4 = totuple(x3)\n    \n    # Get the color of each filtered object\n    x5 = apply(color, x4)\n    \n    # Find the most common color among the filtered objects\n    x6 = mostcommon(x5)\n    \n    # Find the most common color in the entire input grid\n    x7 = mostcolor(I)\n    \n    # Filter objects that have the most common color in the grid\n    x8 = colorfilter(x0, x7)\n    \n    # Create a function that checks if an object is bordering the grid (same as x1)\n    x9 = rbind(bordering, I)\n    \n    # Create a function that checks if an object is NOT bordering the grid (same as x2)\n    x10 = compose(flip, x9)\n    \n    # Filter and merge objects with the most common color that are not bordering the grid\n    x11 = mfilter(x8, x10)\n    \n    # Fill the filtered objects with color 1 (ONE) in the input grid\n    # This effectively changes the color of background objects not touching the border to 1\n    x12 = fill(I, ONE, x11)\n    \n    # Return the modified grid\n    return x12\n"
  },
  "a5f85a15": {
    "original": "def verify_a5f85a15(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = compose(increment, double)\n    x3 = shoot(ORIGIN, UNITY)\n    x4 = apply(x2, x3)\n    x5 = order(x4, identity)\n    x6 = lbind(contained, ZERO)\n    x7 = sfilter(x1, x6)\n    x8 = lbind(shift, x5)\n    x9 = mapply(x8, x7)\n    x10 = fill(I, FOUR, x9)\n    return x10\n\n",
    "annotated": "def verify_a5f85a15(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all indices of cells with the background color\n    x1 = ofcolor(I, x0)\n    \n    # Create a function that doubles a number and then increments it\n    x2 = compose(increment, double)\n    \n    # Create a diagonal line from (0,0) to (29,29)\n    x3 = shoot(ORIGIN, UNITY)\n    \n    # Apply the doubling and incrementing function to each index in the diagonal line\n    x4 = apply(x2, x3)\n    \n    # Sort the modified diagonal indices\n    x5 = order(x4, identity)\n    \n    # Create a function that checks if a number is zero\n    x6 = lbind(contained, ZERO)\n    \n    # Filter the background color indices to keep only those with a zero coordinate\n    x7 = sfilter(x1, x6)\n    \n    # Create a function that shifts indices by the sorted diagonal\n    x8 = lbind(shift, x5)\n    \n    # Apply the shifting function to the filtered background indices\n    # This creates the indices for the cells to be colored\n    x9 = mapply(x8, x7)\n    \n    # Fill the cells at the calculated indices with color 4\n    # This creates the dotted diagonal lines on top of the existing lines\n    x10 = fill(I, FOUR, x9)\n    \n    # Return the modified grid\n    return x10\n"
  },
  "a61ba2ce": {
    "original": "def verify_a61ba2ce(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = fork(contained, lrcorner, toindices)\n    x2 = compose(flip, x1)\n    x3 = extract(x0, x2)\n    x4 = fork(contained, llcorner, toindices)\n    x5 = compose(flip, x4)\n    x6 = extract(x0, x5)\n    x7 = fork(contained, urcorner, toindices)\n    x8 = compose(flip, x7)\n    x9 = extract(x0, x8)\n    x10 = fork(contained, ulcorner, toindices)\n    x11 = compose(flip, x10)\n    x12 = extract(x0, x11)\n    x13 = height(x3)\n    x14 = height(x9)\n    x15 = add(x13, x14)\n    x16 = width(x3)\n    x17 = width(x6)\n    x18 = add(x16, x17)\n    x19 = astuple(x15, x18)\n    x20 = mostcolor(I)\n    x21 = canvas(x20, x19)\n    x22 = normalize(x3)\n    x23 = paint(x21, x22)\n    x24 = normalize(x6)\n    x25 = width(x6)\n    x26 = subtract(x18, x25)\n    x27 = tojvec(x26)\n    x28 = shift(x24, x27)\n    x29 = paint(x23, x28)\n    x30 = normalize(x9)\n    x31 = height(x9)\n    x32 = subtract(x15, x31)\n    x33 = toivec(x32)\n    x34 = shift(x30, x33)\n    x35 = paint(x29, x34)\n    x36 = normalize(x12)\n    x37 = shape(x12)\n    x38 = subtract(x19, x37)\n    x39 = shift(x36, x38)\n    x40 = paint(x35, x39)\n    return x40\n\n",
    "annotated": "def verify_a61ba2ce(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that checks if the lower right corner is contained in an object's indices\n    x1 = fork(contained, lrcorner, toindices)\n    # Flip the boolean result of x1\n    x2 = compose(flip, x1)\n    # Extract the object that doesn't contain the lower right corner\n    x3 = extract(x0, x2)\n    \n    # Create a function that checks if the lower left corner is contained in an object's indices\n    x4 = fork(contained, llcorner, toindices)\n    # Flip the boolean result of x4\n    x5 = compose(flip, x4)\n    # Extract the object that doesn't contain the lower left corner\n    x6 = extract(x0, x5)\n    \n    # Create a function that checks if the upper right corner is contained in an object's indices\n    x7 = fork(contained, urcorner, toindices)\n    # Flip the boolean result of x7\n    x8 = compose(flip, x7)\n    # Extract the object that doesn't contain the upper right corner\n    x9 = extract(x0, x8)\n    \n    # Create a function that checks if the upper left corner is contained in an object's indices\n    x10 = fork(contained, ulcorner, toindices)\n    # Flip the boolean result of x10\n    x11 = compose(flip, x10)\n    # Extract the object that doesn't contain the upper left corner\n    x12 = extract(x0, x11)\n    \n    # Get the height of the lower right corner object\n    x13 = height(x3)\n    # Get the height of the upper right corner object\n    x14 = height(x9)\n    # Calculate the total height of the output grid\n    x15 = add(x13, x14)\n    \n    # Get the width of the lower right corner object\n    x16 = width(x3)\n    # Get the width of the lower left corner object\n    x17 = width(x6)\n    # Calculate the total width of the output grid\n    x18 = add(x16, x17)\n    \n    # Create a tuple of the output grid dimensions\n    x19 = astuple(x15, x18)\n    \n    # Get the most common color from the input grid (background color)\n    x20 = mostcolor(I)\n    # Create a new canvas with the background color and calculated dimensions\n    x21 = canvas(x20, x19)\n    \n    # Normalize the lower right corner object (move it to the origin)\n    x22 = normalize(x3)\n    # Paint the normalized lower right corner object onto the new canvas\n    x23 = paint(x21, x22)\n    \n    # Normalize the lower left corner object\n    x24 = normalize(x6)\n    # Calculate the horizontal offset for the lower left corner object\n    x25 = width(x6)\n    x26 = subtract(x18, x25)\n    x27 = tojvec(x26)\n    # Shift the normalized lower left corner object to its correct position\n    x28 = shift(x24, x27)\n    # Paint the positioned lower left corner object onto the canvas\n    x29 = paint(x23, x28)\n    \n    # Normalize the upper right corner object\n    x30 = normalize(x9)\n    # Calculate the vertical offset for the upper right corner object\n    x31 = height(x9)\n    x32 = subtract(x15, x31)\n    x33 = toivec(x32)\n    # Shift the normalized upper right corner object to its correct position\n    x34 = shift(x30, x33)\n    # Paint the positioned upper right corner object onto the canvas\n    x35 = paint(x29, x34)\n    \n    # Normalize the upper left corner object\n    x36 = normalize(x12)\n    # Calculate the offset for the upper left corner object\n    x37 = shape(x12)\n    x38 = subtract(x19, x37)\n    # Shift the normalized upper left corner object to its correct position\n    x39 = shift(x36, x38)\n    # Paint the positioned upper left corner object onto the canvas\n    x40 = paint(x35, x39)\n    \n    # Return the final output grid with all corner objects in place\n    return x40\n"
  },
  "a61f2674": {
    "original": "def verify_a61f2674(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = argmax(x0, size)\n    x2 = argmin(x0, size)\n    x3 = merge(x0)\n    x4 = cover(I, x3)\n    x5 = fill(x4, ONE, x1)\n    x6 = fill(x5, TWO, x2)\n    return x6\n\n",
    "annotated": "def verify_a61f2674(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonally adjacent cells as part of the same object\n    # This effectively identifies all the vertical bars in the grid\n    x0 = objects(I, T, F, T)\n\n    # Find the largest object (bar) in the set of objects\n    # This corresponds to the tallest bar in the grid\n    x1 = argmax(x0, size)\n\n    # Find the smallest object (bar) in the set of objects\n    # This corresponds to the shortest bar in the grid\n    x2 = argmin(x0, size)\n\n    # Merge all objects into a single set of cells\n    # This combines all the bars into one object\n    x3 = merge(x0)\n\n    # Remove all the bars from the input grid\n    # This leaves only the background color\n    x4 = cover(I, x3)\n\n    # Fill the cells of the tallest bar with color 1\n    x5 = fill(x4, ONE, x1)\n\n    # Fill the cells of the shortest bar with color 2\n    x6 = fill(x5, TWO, x2)\n\n    # Return the final grid with the tallest bar colored 1, the shortest bar colored 2,\n    # and all other cells retaining their background color\n    return x6\n"
  },
  "a64e4611": {
    "original": "def verify_a64e4611(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = shape(I)\n    x2 = add(TWO, x1)\n    x3 = canvas(x0, x2)\n    x4 = asobject(I)\n    x5 = shift(x4, UNITY)\n    x6 = paint(x3, x5)\n    x7 = double(SIX)\n    x8 = astuple(ONE, x7)\n    x9 = connect(UNITY, x8)\n    x10 = outbox(x9)\n    x11 = backdrop(x10)\n    x12 = recolor(x0, x11)\n    x13 = recolor(THREE, x9)\n    x14 = lbind(shift, x13)\n    x15 = lbind(mapply, x14)\n    x16 = rbind(occurrences, x12)\n    x17 = compose(x15, x16)\n    x18 = fork(paint, identity, x17)\n    x19 = x18(x6)\n    x20 = ofcolor(x19, THREE)\n    x21 = dmirror(x6)\n    x22 = x18(x21)\n    x23 = dmirror(x22)\n    x24 = ofcolor(x23, THREE)\n    x25 = combine(x20, x24)\n    x26 = fill(x6, THREE, x25)\n    x27 = astuple(TWO, ONE)\n    x28 = dneighbors(UNITY)\n    x29 = remove(x27, x28)\n    x30 = recolor(x0, x29)\n    x31 = initset(UNITY)\n    x32 = recolor(THREE, x31)\n    x33 = combine(x30, x32)\n    x34 = recolor(x0, x33)\n    x35 = astuple(ONE, THREE)\n    x36 = initset(x35)\n    x37 = insert(ZERO_BY_TWO, x36)\n    x38 = insert(RIGHT, x37)\n    x39 = insert(DOWN, x38)\n    x40 = recolor(x0, x39)\n    x41 = astuple(ONE, TWO)\n    x42 = initset(x41)\n    x43 = insert(UNITY, x42)\n    x44 = recolor(THREE, x43)\n    x45 = combine(x40, x44)\n    x46 = recolor(x0, x45)\n    x47 = lbind(shift, x34)\n    x48 = lbind(mapply, x47)\n    x49 = rbind(occurrences, x33)\n    x50 = compose(x48, x49)\n    x51 = fork(paint, identity, x50)\n    x52 = lbind(shift, x46)\n    x53 = lbind(mapply, x52)\n    x54 = rbind(occurrences, x45)\n    x55 = compose(x53, x54)\n    x56 = fork(paint, identity, x55)\n    x57 = compose(x51, x56)\n    x58 = compose(rot90, x57)\n    x59 = power(x58, FOUR)\n    x60 = power(x59, TWO)\n    x61 = asindices(x26)\n    x62 = box(x61)\n    x63 = fill(x26, THREE, x62)\n    x64 = x60(x63)\n    x65 = trim(x64)\n    return x65\n\n",
    "annotated": "def verify_a64e4611(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    # Get the shape (dimensions) of the input grid\n    x1 = shape(I)\n    # Add 2 to each dimension of the input grid shape\n    x2 = add(TWO, x1)\n    # Create a new canvas with the expanded dimensions, filled with the background color\n    x3 = canvas(x0, x2)\n    # Convert the input grid to an object representation\n    x4 = asobject(I)\n    # Shift the input grid object by (1,1), effectively creating a 1-cell border\n    x5 = shift(x4, UNITY)\n    # Paint the shifted input grid onto the new canvas\n    x6 = paint(x3, x5)\n    # Double the value 6 to get 12\n    x7 = double(SIX)\n    # Create a tuple (1, 12)\n    x8 = astuple(ONE, x7)\n    # Create a line from (1,1) to (1,12)\n    x9 = connect(UNITY, x8)\n    # Get the outer boundary of the line\n    x10 = outbox(x9)\n    # Get all cells within the outer boundary\n    x11 = backdrop(x10)\n    # Color all cells within the outer boundary with the background color\n    x12 = recolor(x0, x11)\n    # Color the line itself with color 3 (door color)\n    x13 = recolor(THREE, x9)\n    # Prepare a function to shift the door\n    x14 = lbind(shift, x13)\n    # Prepare a function to apply the shift to multiple positions\n    x15 = lbind(mapply, x14)\n    # Prepare a function to find occurrences of the background-colored outer boundary\n    x16 = rbind(occurrences, x12)\n    # Compose the shifting and occurrence-finding functions\n    x17 = compose(x15, x16)\n    # Prepare a function to paint the shifted doors onto the grid\n    x18 = fork(paint, identity, x17)\n    # Apply the door-painting function to the expanded input grid\n    x19 = x18(x6)\n    # Find all cells with color 3 (door color) in the result\n    x20 = ofcolor(x19, THREE)\n    # Create a diagonal mirror of the expanded input grid\n    x21 = dmirror(x6)\n    # Apply the door-painting function to the mirrored grid\n    x22 = x18(x21)\n    # Mirror the result back\n    x23 = dmirror(x22)\n    # Find all cells with color 3 (door color) in the mirrored result\n    x24 = ofcolor(x23, THREE)\n    # Combine the door cells from both the original and mirrored grids\n    x25 = combine(x20, x24)\n    # Fill all the identified door cells with color 3 on the expanded input grid\n    x26 = fill(x6, THREE, x25)\n    # Create a tuple (2, 1)\n    x27 = astuple(TWO, ONE)\n    # Get the direct neighbors of (1,1)\n    x28 = dneighbors(UNITY)\n    # Remove (2,1) from the neighbors of (1,1)\n    x29 = remove(x27, x28)\n    # Color the remaining neighbors with the background color\n    x30 = recolor(x0, x29)\n    # Create a set containing only (1,1)\n    x31 = initset(UNITY)\n    # Color (1,1) with the door color (3)\n    x32 = recolor(THREE, x31)\n    # Combine the colored neighbors and (1,1)\n    x33 = combine(x30, x32)\n    # Recolor the combined set with the background color (creates a pattern)\n    x34 = recolor(x0, x33)\n    # Create a tuple (1, 3)\n    x35 = astuple(ONE, THREE)\n    # Initialize a set with (1, 3)\n    x36 = initset(x35)\n    # Add (0, 2) to the set\n    x37 = insert(ZERO_BY_TWO, x36)\n    # Add (0, 1) to the set\n    x38 = insert(RIGHT, x37)\n    # Add (1, 0) to the set\n    x39 = insert(DOWN, x38)\n    # Color this set of positions with the background color\n    x40 = recolor(x0, x39)\n    # Create a tuple (1, 2)\n    x41 = astuple(ONE, TWO)\n    # Initialize a set with (1, 2)\n    x42 = initset(x41)\n    # Add (1, 1) to the set\n    x43 = insert(UNITY, x42)\n    # Color this set of positions with the door color (3)\n    x44 = recolor(THREE, x43)\n    # Combine the two colored sets of positions\n    x45 = combine(x40, x44)\n    # Recolor the combined set with the background color (creates another pattern)\n    x46 = recolor(x0, x45)\n    # Prepare a function to shift the first pattern\n    x47 = lbind(shift, x34)\n    # Prepare a function to apply the shift to multiple positions\n    x48 = lbind(mapply, x47)\n    # Prepare a function to find occurrences of the first pattern\n    x49 = rbind(occurrences, x33)\n    # Compose the shifting and occurrence-finding functions for the first pattern\n    x50 = compose(x48, x49)\n    # Prepare a function to paint the shifted first pattern onto the grid\n    x51 = fork(paint, identity, x50)\n    # Prepare a function to shift the second pattern\n    x52 = lbind(shift, x46)\n    # Prepare a function to apply the shift to multiple positions\n    x53 = lbind(mapply, x52)\n    # Prepare a function to find occurrences of the second pattern\n    x54 = rbind(occurrences, x45)\n    # Compose the shifting and occurrence-finding functions for the second pattern\n    x55 = compose(x53, x54)\n    # Prepare a function to paint the shifted second pattern onto the grid\n    x56 = fork(paint, identity, x55)\n    # Compose the painting functions for both patterns\n    x57 = compose(x51, x56)\n    # Prepare a function to rotate the result 90 degrees\n    x58 = compose(rot90, x57)\n    # Apply the rotation and pattern-painting 4 times (covering all rotations)\n    x59 = power(x58, FOUR)\n    # Apply the entire process twice\n    x60 = power(x59, TWO)\n    # Get all indices of the grid with doors\n    x61 = asindices(x26)\n    # Create a box around all door cells\n    x62 = box(x61)\n    # Fill the box with the door color (3)\n    x63 = fill(x26, THREE, x62)\n    # Apply the entire transformation process to the boxed grid\n    x64 = x60(x63)\n    # Remove the 1-cell border added at the beginning\n    x65 = trim(x64)\n    # Return the final transformed grid\n    return x65\n"
  },
  "a65b410d": {
    "original": "def verify_a65b410d(I: Grid) -> Grid:\n    x0 = astuple(identity, rot90)\n    x1 = astuple(rot180, rot270)\n    x2 = combine(x0, x1)\n    x3 = astuple(identity, rot270)\n    x4 = astuple(rot180, rot90)\n    x5 = combine(x3, x4)\n    x6 = pair(x2, x5)\n    x7 = leastcolor(I)\n    x8 = rbind(ofcolor, x7)\n    x9 = rbind(rapply, I)\n    x10 = chain(first, x9, initset)\n    x11 = chain(hline, x8, x10)\n    x12 = rbind(ofcolor, x7)\n    x13 = rbind(rapply, I)\n    x14 = chain(first, x13, initset)\n    x15 = chain(leftmost, x12, x14)\n    x16 = matcher(x15, ZERO)\n    x17 = fork(both, x11, x16)\n    x18 = compose(x17, first)\n    x19 = extract(x6, x18)\n    x20 = first(x19)\n    x21 = last(x19)\n    x22 = x20(I)\n    x23 = ofcolor(x22, x7)\n    x24 = argmax(x23, last)\n    x25 = add(x24, UP_RIGHT)\n    x26 = shoot(x25, UP_RIGHT)\n    x27 = add(x24, DOWN_LEFT)\n    x28 = shoot(x27, DOWN_LEFT)\n    x29 = rbind(shoot, LEFT)\n    x30 = mapply(x29, x26)\n    x31 = rbind(shoot, LEFT)\n    x32 = mapply(x31, x28)\n    x33 = width(x22)\n    x34 = invert(x33)\n    x35 = tojvec(x34)\n    x36 = shift(x30, x35)\n    x37 = combine(x30, x36)\n    x38 = fill(x22, THREE, x37)\n    x39 = shift(x32, x35)\n    x40 = combine(x32, x39)\n    x41 = fill(x38, ONE, x40)\n    x42 = x21(x41)\n    return x42\n\n",
    "annotated": "def verify_a65b410d(I: Grid) -> Grid:\n    # Create a tuple of rotation functions: (identity, rot90)\n    x0 = astuple(identity, rot90)\n    # Create a tuple of rotation functions: (rot180, rot270)\n    x1 = astuple(rot180, rot270)\n    # Combine all rotation functions into a single tuple\n    x2 = combine(x0, x1)\n    # Create another tuple of rotation functions: (identity, rot270)\n    x3 = astuple(identity, rot270)\n    # Create another tuple of rotation functions: (rot180, rot90)\n    x4 = astuple(rot180, rot90)\n    # Combine these rotation functions into a single tuple\n    x5 = combine(x3, x4)\n    # Pair the two sets of rotation functions\n    x6 = pair(x2, x5)\n    # Find the least common color in the input grid (likely the line color)\n    x7 = leastcolor(I)\n    # Create a function to find cells of the least common color\n    x8 = rbind(ofcolor, x7)\n    # Create a function to apply the input grid to a function\n    x9 = rbind(rapply, I)\n    # Chain functions to get the first cell of the least common color\n    x10 = chain(first, x9, initset)\n    # Check if the least common color forms a horizontal line\n    x11 = chain(hline, x8, x10)\n    # Create another function to find cells of the least common color\n    x12 = rbind(ofcolor, x7)\n    # Create another function to apply the input grid to a function\n    x13 = rbind(rapply, I)\n    # Chain functions to get the first cell of the least common color\n    x14 = chain(first, x13, initset)\n    # Find the leftmost position of the least common color\n    x15 = chain(leftmost, x12, x14)\n    # Create a function to check if the leftmost position is at the edge (0)\n    x16 = matcher(x15, ZERO)\n    # Combine checks for horizontal line and leftmost position\n    x17 = fork(both, x11, x16)\n    # Create a function to apply the combined check to the first element\n    x18 = compose(x17, first)\n    # Extract the correct rotation functions based on the grid orientation\n    x19 = extract(x6, x18)\n    # Get the rotation function to orient the grid correctly\n    x20 = first(x19)\n    # Get the inverse rotation function to return to original orientation\n    x21 = last(x19)\n    # Apply the rotation to orient the grid correctly\n    x22 = x20(I)\n    # Find all cells of the least common color in the rotated grid\n    x23 = ofcolor(x22, x7)\n    # Find the bottommost cell of the least common color (intersection point)\n    x24 = argmax(x23, last)\n    # Calculate the starting point for the upper-right diagonal\n    x25 = add(x24, UP_RIGHT)\n    # Create the upper-right diagonal line\n    x26 = shoot(x25, UP_RIGHT)\n    # Calculate the starting point for the lower-left diagonal\n    x27 = add(x24, DOWN_LEFT)\n    # Create the lower-left diagonal line\n    x28 = shoot(x27, DOWN_LEFT)\n    # Create a function to shoot left from each point\n    x29 = rbind(shoot, LEFT)\n    # Create all horizontal lines for the upper-right section (green)\n    x30 = mapply(x29, x26)\n    # Create another function to shoot left from each point\n    x31 = rbind(shoot, LEFT)\n    # Create all horizontal lines for the lower-left section (blue)\n    x32 = mapply(x31, x28)\n    # Get the width of the rotated grid\n    x33 = width(x22)\n    # Invert the width (negative value)\n    x34 = invert(x33)\n    # Create a horizontal vector with the negative width\n    x35 = tojvec(x34)\n    # Shift the upper-right section to fill the entire width\n    x36 = shift(x30, x35)\n    # Combine the original and shifted upper-right sections\n    x37 = combine(x30, x36)\n    # Fill the upper-right section with color 3 (green)\n    x38 = fill(x22, THREE, x37)\n    # Shift the lower-left section to fill the entire width\n    x39 = shift(x32, x35)\n    # Combine the original and shifted lower-left sections\n    x40 = combine(x32, x39)\n    # Fill the lower-left section with color 1 (blue)\n    x41 = fill(x38, ONE, x40)\n    # Apply the inverse rotation to return the grid to its original orientation\n    x42 = x21(x41)\n    return x42\n"
  },
  "a68b268e": {
    "original": "def verify_a68b268e(I: Grid) -> Grid:\n    x0 = tophalf(I)\n    x1 = lefthalf(x0)\n    x2 = tophalf(I)\n    x3 = righthalf(x2)\n    x4 = bottomhalf(I)\n    x5 = lefthalf(x4)\n    x6 = bottomhalf(I)\n    x7 = righthalf(x6)\n    x8 = palette(x1)\n    x9 = palette(x3)\n    x10 = intersection(x8, x9)\n    x11 = palette(x5)\n    x12 = palette(x7)\n    x13 = intersection(x11, x12)\n    x14 = intersection(x10, x13)\n    x15 = first(x14)\n    x16 = shape(I)\n    x17 = halve(x16)\n    x18 = canvas(x15, x17)\n    x19 = matcher(first, x15)\n    x20 = compose(flip, x19)\n    x21 = rbind(sfilter, x20)\n    x22 = compose(x21, asobject)\n    x23 = x22(x1)\n    x24 = x22(x3)\n    x25 = x22(x5)\n    x26 = x22(x7)\n    x27 = paint(x18, x26)\n    x28 = paint(x27, x25)\n    x29 = paint(x28, x24)\n    x30 = paint(x29, x23)\n    return x30\n\n",
    "annotated": "def verify_a68b268e(I: Grid) -> Grid:\n    # Extract the top half of the input grid\n    x0 = tophalf(I)\n    # Extract the left half of the top half (upper-left quadrant)\n    x1 = lefthalf(x0)\n    # Extract the top half of the input grid (again)\n    x2 = tophalf(I)\n    # Extract the right half of the top half (upper-right quadrant)\n    x3 = righthalf(x2)\n    # Extract the bottom half of the input grid\n    x4 = bottomhalf(I)\n    # Extract the left half of the bottom half (lower-left quadrant)\n    x5 = lefthalf(x4)\n    # Extract the bottom half of the input grid (again)\n    x6 = bottomhalf(I)\n    # Extract the right half of the bottom half (lower-right quadrant)\n    x7 = righthalf(x6)\n    # Get the set of unique colors in the upper-left quadrant\n    x8 = palette(x1)\n    # Get the set of unique colors in the upper-right quadrant\n    x9 = palette(x3)\n    # Find the common colors between upper-left and upper-right quadrants\n    x10 = intersection(x8, x9)\n    # Get the set of unique colors in the lower-left quadrant\n    x11 = palette(x5)\n    # Get the set of unique colors in the lower-right quadrant\n    x12 = palette(x7)\n    # Find the common colors between lower-left and lower-right quadrants\n    x13 = intersection(x11, x12)\n    # Find the color(s) common to all quadrants\n    x14 = intersection(x10, x13)\n    # Select the first (or only) color common to all quadrants\n    x15 = first(x14)\n    # Get the dimensions of the input grid\n    x16 = shape(I)\n    # Halve the dimensions of the input grid\n    x17 = halve(x16)\n    # Create a new canvas with the common color and halved dimensions\n    x18 = canvas(x15, x17)\n    # Create a function that checks if the first element equals the common color\n    x19 = matcher(first, x15)\n    # Create a function that flips the result of the previous function\n    x20 = compose(flip, x19)\n    # Create a function that filters elements based on the previous function\n    x21 = rbind(sfilter, x20)\n    # Create a function that converts to object and applies the filter\n    x22 = compose(x21, asobject)\n    # Apply the filter to the upper-left quadrant, keeping non-common color cells\n    x23 = x22(x1)\n    # Apply the filter to the upper-right quadrant, keeping non-common color cells\n    x24 = x22(x3)\n    # Apply the filter to the lower-left quadrant, keeping non-common color cells\n    x25 = x22(x5)\n    # Apply the filter to the lower-right quadrant, keeping non-common color cells\n    x26 = x22(x7)\n    # Paint the filtered lower-right quadrant onto the new canvas\n    x27 = paint(x18, x26)\n    # Paint the filtered lower-left quadrant onto the canvas\n    x28 = paint(x27, x25)\n    # Paint the filtered upper-right quadrant onto the canvas\n    x29 = paint(x28, x24)\n    # Paint the filtered upper-left quadrant onto the canvas, completing the output\n    x30 = paint(x29, x23)\n    # Return the final output grid\n    return x30\n"
  },
  "a699fb00": {
    "original": "def verify_a699fb00(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = height(I)\n    x2 = vsplit(I, x1)\n    x3 = lbind(recolor, TWO)\n    x4 = rbind(ofcolor, x0)\n    x5 = chain(x3, delta, x4)\n    x6 = fork(paint, identity, x5)\n    x7 = apply(x6, x2)\n    x8 = merge(x7)\n    return x8\n\n",
    "annotated": "def verify_a699fb00(I: Grid) -> Grid:\n    # Find the least common color in the input grid, which is the background color\n    x0 = leastcolor(I)\n    \n    # Get the height of the input grid\n    x1 = height(I)\n    \n    # Split the input grid vertically into individual rows\n    x2 = vsplit(I, x1)\n    \n    # Create a function that recolors cells to color 2 (the line color)\n    x3 = lbind(recolor, TWO)\n    \n    # Create a function that finds cells of the background color\n    x4 = rbind(ofcolor, x0)\n    \n    # Create a function that:\n    # 1. Finds cells of the background color\n    # 2. Identifies cells in the bounding box but not part of the original shape (delta)\n    # 3. Recolors these cells to color 2\n    # This effectively fills in the gaps in the dashed lines\n    x5 = chain(x3, delta, x4)\n    \n    # Create a function that:\n    # 1. Applies the gap-filling function (x5)\n    # 2. Paints the result onto the original row\n    # This combines the original row with the filled-in gaps\n    x6 = fork(paint, identity, x5)\n    \n    # Apply the gap-filling and painting function to each row of the grid\n    x7 = apply(x6, x2)\n    \n    # Merge all the processed rows back into a single grid\n    x8 = merge(x7)\n    \n    # Return the final grid with all dashed lines filled in\n    return x8\n"
  },
  "a740d043": {
    "original": "def verify_a740d043(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = subgrid(x1, I)\n    x3 = mostcolor(I)\n    x4 = replace(x2, x3, ZERO)\n    return x4\n\n",
    "annotated": "def verify_a740d043(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all the foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Extract the subgrid containing the merged object from the input grid\n    # This effectively crops the grid to the bounding box of the object\n    x2 = subgrid(x1, I)\n    \n    # Determine the most common color in the input grid (background color)\n    x3 = mostcolor(I)\n    \n    # Replace the background color with 0 in the cropped subgrid\n    # This step removes the background, leaving only the object\n    x4 = replace(x2, x3, ZERO)\n    \n    # Return the processed grid, which is the compressed version of the input\n    # with the background removed and replaced by 0\n    return x4\n"
  },
  "a78176bb": {
    "original": "def verify_a78176bb(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = objects(I, T, T, F)\n    x2 = fork(connect, ulcorner, lrcorner)\n    x3 = fork(equality, toindices, x2)\n    x4 = sfilter(x1, x3)\n    x5 = size(x4)\n    x6 = positive(x5)\n    x7 = branch(x6, identity, hmirror)\n    x8 = x7(I)\n    x9 = objects(x8, T, F, T)\n    x10 = compose(flip, x3)\n    x11 = sfilter(x9, x10)\n    x12 = rbind(shoot, UNITY)\n    x13 = rbind(shoot, NEG_UNITY)\n    x14 = fork(combine, x12, x13)\n    x15 = rbind(branch, llcorner)\n    x16 = rbind(x15, urcorner)\n    x17 = rbind(branch, DOWN_LEFT)\n    x18 = rbind(x17, UP_RIGHT)\n    x19 = rbind(branch, RIGHT)\n    x20 = rbind(x19, DOWN)\n    x21 = fork(contained, urcorner, toindices)\n    x22 = lbind(index, x8)\n    x23 = compose(x20, x21)\n    x24 = fork(add, ulcorner, x23)\n    x25 = compose(x22, x24)\n    x26 = chain(initset, x16, x21)\n    x27 = fork(rapply, x26, identity)\n    x28 = compose(first, x27)\n    x29 = compose(x18, x21)\n    x30 = fork(add, x28, x29)\n    x31 = compose(x14, x30)\n    x32 = fork(recolor, x25, x31)\n    x33 = mapply(x32, x11)\n    x34 = merge(x11)\n    x35 = cover(x8, x34)\n    x36 = paint(x35, x33)\n    x37 = x7(x36)\n    return x37\n\n",
    "annotated": "def verify_a78176bb(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Find all objects in the input grid, allowing diagonal connections and ignoring the background\n    x1 = objects(I, T, T, F)\n    \n    # Create a function that connects the upper-left and lower-right corners of an object\n    x2 = fork(connect, ulcorner, lrcorner)\n    \n    # Create a function that checks if an object's indices match its diagonal line\n    x3 = fork(equality, toindices, x2)\n    \n    # Filter objects to keep only those that are perfect diagonal lines\n    x4 = sfilter(x1, x3)\n    \n    # Count the number of diagonal line objects\n    x5 = size(x4)\n    \n    # Check if there are any diagonal line objects\n    x6 = positive(x5)\n    \n    # If there are diagonal lines, keep the grid as is; otherwise, mirror it horizontally\n    x7 = branch(x6, identity, hmirror)\n    \n    # Apply the conditional mirroring to the input grid\n    x8 = x7(I)\n    \n    # Find all objects in the potentially mirrored grid, this time ignoring diagonal connections\n    x9 = objects(x8, T, F, T)\n    \n    # Create a function that checks if an object is NOT a perfect diagonal line\n    x10 = compose(flip, x3)\n    \n    # Filter objects to keep only those that are not perfect diagonal lines (i.e., triangles)\n    x11 = sfilter(x9, x10)\n    \n    # Create a function to shoot a line in the (1,1) direction\n    x12 = rbind(shoot, UNITY)\n    \n    # Create a function to shoot a line in the (-1,-1) direction\n    x13 = rbind(shoot, NEG_UNITY)\n    \n    # Create a function that combines the two shooting functions\n    x14 = fork(combine, x12, x13)\n    \n    # Create a function to choose between lower-left corner and upper-right corner based on a condition\n    x15 = rbind(branch, llcorner)\n    x16 = rbind(x15, urcorner)\n    \n    # Create a function to choose between down-left and up-right directions based on a condition\n    x17 = rbind(branch, DOWN_LEFT)\n    x18 = rbind(x17, UP_RIGHT)\n    \n    # Create a function to choose between right and down directions based on a condition\n    x19 = rbind(branch, RIGHT)\n    x20 = rbind(x19, DOWN)\n    \n    # Create a function that checks if the upper-right corner is within the object's indices\n    x21 = fork(contained, urcorner, toindices)\n    \n    # Create a function to get the color at a specific index in the mirrored grid\n    x22 = lbind(index, x8)\n    \n    # Create a function to determine the direction to move based on the upper-right corner check\n    x23 = compose(x20, x21)\n    \n    # Create a function to find the starting point for the new line\n    x24 = fork(add, ulcorner, x23)\n    \n    # Create a function to get the color of the starting point for the new line\n    x25 = compose(x22, x24)\n    \n    # Create a function to determine which corner to use based on the upper-right corner check\n    x26 = chain(initset, x16, x21)\n    \n    # Create a function to apply the corner selection and return the result\n    x27 = fork(rapply, x26, identity)\n    \n    # Create a function to get the selected corner\n    x28 = compose(first, x27)\n    \n    # Create a function to determine the direction to extend the line\n    x29 = compose(x18, x21)\n    \n    # Create a function to find the endpoint for the new line\n    x30 = fork(add, x28, x29)\n    \n    # Create a function to generate the indices for the new line\n    x31 = compose(x14, x30)\n    \n    # Create a function to generate the new object (line) with the correct color\n    x32 = fork(recolor, x25, x31)\n    \n    # Apply the line extension to all triangle objects\n    x33 = mapply(x32, x11)\n    \n    # Merge all triangle objects into a single set of indices\n    x34 = merge(x11)\n    \n    # Remove all triangle objects from the mirrored grid\n    x35 = cover(x8, x34)\n    \n    # Paint the extended lines onto the grid\n    x36 = paint(x35, x33)\n    \n    # Apply the conditional mirroring again to restore the original orientation if needed\n    x37 = x7(x36)\n    \n    # Return the final output grid\n    return x37\n"
  },
  "a79310a0": {
    "original": "def verify_a79310a0(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = mostcolor(I)\n    x3 = fill(I, x2, x1)\n    x4 = shift(x1, DOWN)\n    x5 = fill(x3, TWO, x4)\n    return x5\n\n",
    "annotated": "def verify_a79310a0(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Find the most common color in the input grid (background color)\n    x2 = mostcolor(I)\n    \n    # Create a new grid by filling the merged object with the background color\n    # This effectively removes the original shape from the grid\n    x3 = fill(I, x2, x1)\n    \n    # Shift the merged object one cell down\n    x4 = shift(x1, DOWN)\n    \n    # Fill the shifted object location with color 2 on the background grid\n    # This creates the output grid with the shape moved down and colored 2\n    x5 = fill(x3, TWO, x4)\n    \n    # Return the final output grid\n    return x5\n"
  },
  "a85d4709": {
    "original": "def verify_a85d4709(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = height(I)\n    x2 = vsplit(I, x1)\n    x3 = rbind(ofcolor, x0)\n    x4 = compose(leftmost, x3)\n    x5 = width(I)\n    x6 = divide(x5, THREE)\n    x7 = multiply(x6, TWO)\n    x8 = lbind(greater, x6)\n    x9 = compose(x8, x4)\n    x10 = lbind(greater, x7)\n    x11 = compose(x10, x4)\n    x12 = compose(flip, x9)\n    x13 = fork(both, x11, x12)\n    x14 = fork(either, x9, x13)\n    x15 = compose(flip, x14)\n    x16 = rbind(multiply, TWO)\n    x17 = compose(x16, x9)\n    x18 = rbind(multiply, FOUR)\n    x19 = compose(x18, x13)\n    x20 = rbind(multiply, THREE)\n    x21 = compose(x20, x15)\n    x22 = fork(add, x17, x19)\n    x23 = fork(add, x22, x21)\n    x24 = width(I)\n    x25 = rbind(repeat, x24)\n    x26 = compose(x25, x23)\n    x27 = apply(x26, x2)\n    return x27\n\n",
    "annotated": "def verify_a85d4709(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get the height of the input grid\n    x1 = height(I)\n    \n    # Split the input grid vertically into individual rows\n    x2 = vsplit(I, x1)\n    \n    # Create a function that finds cells of the background color\n    x3 = rbind(ofcolor, x0)\n    \n    # Create a function that finds the leftmost position of the background color\n    x4 = compose(leftmost, x3)\n    \n    # Get the width of the input grid\n    x5 = width(I)\n    \n    # Calculate one-third of the grid width\n    x6 = divide(x5, THREE)\n    \n    # Calculate two-thirds of the grid width\n    x7 = multiply(x6, TWO)\n    \n    # Create a function that checks if a value is greater than one-third of the width\n    x8 = lbind(greater, x6)\n    \n    # Create a function that checks if the leftmost background color is in the middle third\n    x9 = compose(x8, x4)\n    \n    # Create a function that checks if a value is greater than two-thirds of the width\n    x10 = lbind(greater, x7)\n    \n    # Create a function that checks if the leftmost background color is in the right third\n    x11 = compose(x10, x4)\n    \n    # Create a function that checks if the leftmost background color is in the left third\n    x12 = compose(flip, x9)\n    \n    # Create a function that checks if the leftmost background color is in the middle or right third\n    x13 = fork(both, x11, x12)\n    \n    # Create a function that checks which third the leftmost background color is in\n    x14 = fork(either, x9, x13)\n    \n    # Flip the result of x14 (used for the last case)\n    x15 = compose(flip, x14)\n    \n    # Create a function that multiplies by 2 if the dot is in the left third\n    x16 = rbind(multiply, TWO)\n    x17 = compose(x16, x9)\n    \n    # Create a function that multiplies by 4 if the dot is in the middle or right third\n    x18 = rbind(multiply, FOUR)\n    x19 = compose(x18, x13)\n    \n    # Create a function that multiplies by 3 if the dot is in the right third\n    x20 = rbind(multiply, THREE)\n    x21 = compose(x20, x15)\n    \n    # Combine the results of x17 and x19\n    x22 = fork(add, x17, x19)\n    \n    # Add the result of x21 to get the final color value for each row\n    x23 = fork(add, x22, x21)\n    \n    # Get the width of the input grid again\n    x24 = width(I)\n    \n    # Create a function that repeats a value to fill a row\n    x25 = rbind(repeat, x24)\n    \n    # Create a function that generates a full row of the calculated color\n    x26 = compose(x25, x23)\n    \n    # Apply the row-generating function to each row of the split input\n    x27 = apply(x26, x2)\n    \n    # Return the resulting grid where each row is filled with the appropriate color\n    return x27\n"
  },
  "a87f7484": {
    "original": "def verify_a87f7484(I: Grid) -> Grid:\n    x0 = height(I)\n    x1 = halve(x0)\n    x2 = increment(x1)\n    x3 = interval(THREE, x2, ONE)\n    x4 = width(I)\n    x5 = halve(x4)\n    x6 = increment(x5)\n    x7 = interval(THREE, x6, ONE)\n    x8 = palette(I)\n    x9 = lbind(apply, toindices)\n    x10 = compose(x9, partition)\n    x11 = rbind(compose, palette)\n    x12 = lbind(lbind, contained)\n    x13 = compose(x11, x12)\n    x14 = lbind(chain, size)\n    x15 = rbind(x14, x13)\n    x16 = lbind(lbind, sfilter)\n    x17 = compose(x15, x16)\n    x18 = compose(positive, size)\n    x19 = lbind(sfilter, x8)\n    x20 = fork(matcher, x17, size)\n    x21 = chain(x18, x19, x20)\n    x22 = lbind(apply, shape)\n    x23 = chain(size, dedupe, x22)\n    x24 = matcher(x23, ONE)\n    x25 = lbind(apply, x10)\n    x26 = chain(size, dedupe, x25)\n    x27 = matcher(x26, TWO)\n    x28 = compose(size, dedupe)\n    x29 = fork(equality, size, x28)\n    x30 = fork(add, x21, x24)\n    x31 = fork(add, x27, x29)\n    x32 = fork(add, x30, x31)\n    x33 = multiply(TEN, TEN)\n    x34 = lbind(multiply, x33)\n    x35 = compose(x34, x32)\n    x36 = fork(add, x35, size)\n    x37 = lbind(vsplit, I)\n    x38 = apply(x37, x3)\n    x39 = lbind(hsplit, I)\n    x40 = apply(x39, x7)\n    x41 = combine(x38, x40)\n    x42 = argmax(x41, x36)\n    x43 = apply(x10, x42)\n    x44 = mostcommon(x43)\n    x45 = matcher(x10, x44)\n    x46 = argmin(x42, x45)\n    return x46\n\n",
    "annotated": "def verify_a87f7484(I: Grid) -> Grid:\n    x0 = height(I)  # Get the height of the input grid\n    x1 = halve(x0)  # Halve the height\n    x2 = increment(x1)  # Increment the halved height by 1\n    x3 = interval(THREE, x2, ONE)  # Create a range from 3 to the incremented half-height\n    x4 = width(I)  # Get the width of the input grid\n    x5 = halve(x4)  # Halve the width\n    x6 = increment(x5)  # Increment the halved width by 1\n    x7 = interval(THREE, x6, ONE)  # Create a range from 3 to the incremented half-width\n    x8 = palette(I)  # Get the set of unique colors in the input grid\n    x9 = lbind(apply, toindices)  # Partially apply 'apply' function with 'toindices'\n    x10 = compose(x9, partition)  # Compose x9 with partition function\n    x11 = rbind(compose, palette)  # Partially apply 'compose' with 'palette'\n    x12 = lbind(lbind, contained)  # Doubly partially apply 'contained' function\n    x13 = compose(x11, x12)  # Compose x11 with x12\n    x14 = lbind(chain, size)  # Partially apply 'chain' with 'size'\n    x15 = rbind(x14, x13)  # Partially apply x14 with x13\n    x16 = lbind(lbind, sfilter)  # Doubly partially apply 'sfilter' function\n    x17 = compose(x15, x16)  # Compose x15 with x16\n    x18 = compose(positive, size)  # Compose 'positive' with 'size'\n    x19 = lbind(sfilter, x8)  # Partially apply 'sfilter' with the palette\n    x20 = fork(matcher, x17, size)  # Create a function that applies x17 and size, then compares results\n    x21 = chain(x18, x19, x20)  # Chain x18, x19, and x20 functions\n    x22 = lbind(apply, shape)  # Partially apply 'apply' with 'shape'\n    x23 = chain(size, dedupe, x22)  # Chain 'size', 'dedupe', and x22 functions\n    x24 = matcher(x23, ONE)  # Create a function that checks if x23 equals ONE\n    x25 = lbind(apply, x10)  # Partially apply 'apply' with x10\n    x26 = chain(size, dedupe, x25)  # Chain 'size', 'dedupe', and x25 functions\n    x27 = matcher(x26, TWO)  # Create a function that checks if x26 equals TWO\n    x28 = compose(size, dedupe)  # Compose 'size' with 'dedupe'\n    x29 = fork(equality, size, x28)  # Create a function that compares results of 'size' and x28\n    x30 = fork(add, x21, x24)  # Create a function that adds results of x21 and x24\n    x31 = fork(add, x27, x29)  # Create a function that adds results of x27 and x29\n    x32 = fork(add, x30, x31)  # Create a function that adds results of x30 and x31\n    x33 = multiply(TEN, TEN)  # Multiply 10 by 10 (equals 100)\n    x34 = lbind(multiply, x33)  # Partially apply 'multiply' with 100\n    x35 = compose(x34, x32)  # Compose x34 with x32\n    x36 = fork(add, x35, size)  # Create a function that adds results of x35 and 'size'\n    x37 = lbind(vsplit, I)  # Partially apply 'vsplit' with the input grid\n    x38 = apply(x37, x3)  # Apply x37 to the range created in x3\n    x39 = lbind(hsplit, I)  # Partially apply 'hsplit' with the input grid\n    x40 = apply(x39, x7)  # Apply x39 to the range created in x7\n    x41 = combine(x38, x40)  # Combine the results of vertical and horizontal splits\n    x42 = argmax(x41, x36)  # Find the subgrid that maximizes the function x36\n    x43 = apply(x10, x42)  # Apply x10 to the selected subgrid\n    x44 = mostcommon(x43)  # Find the most common element in x43\n    x45 = matcher(x10, x44)  # Create a function that checks if x10 equals x44\n    x46 = argmin(x42, x45)  # Find the subgrid that minimizes the function x45\n    return x46  # Return the selected subgrid as the output\n"
  },
  "a8c38be5": {
    "original": "def verify_a8c38be5(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = mostcolor(I)\n    x2 = palette(I)\n    x3 = remove(x1, x2)\n    x4 = lbind(colorcount, I)\n    x5 = argmax(x3, x4)\n    x6 = astuple(x1, x5)\n    x7 = rbind(contained, x6)\n    x8 = chain(flip, x7, color)\n    x9 = sfilter(x0, x8)\n    x10 = fork(connect, ulcorner, urcorner)\n    x11 = fork(connect, ulcorner, llcorner)\n    x12 = fork(combine, x10, x11)\n    x13 = fork(equality, toindices, x12)\n    x14 = fork(connect, urcorner, ulcorner)\n    x15 = fork(connect, urcorner, lrcorner)\n    x16 = fork(combine, x14, x15)\n    x17 = fork(equality, toindices, x16)\n    x18 = fork(connect, llcorner, ulcorner)\n    x19 = fork(connect, llcorner, lrcorner)\n    x20 = fork(combine, x18, x19)\n    x21 = fork(equality, toindices, x20)\n    x22 = fork(connect, lrcorner, llcorner)\n    x23 = fork(connect, lrcorner, urcorner)\n    x24 = fork(combine, x22, x23)\n    x25 = fork(equality, toindices, x24)\n    x26 = fork(contained, lrcorner, toindices)\n    x27 = compose(flip, x26)\n    x28 = fork(contained, llcorner, toindices)\n    x29 = compose(flip, x28)\n    x30 = fork(contained, urcorner, toindices)\n    x31 = compose(flip, x30)\n    x32 = fork(contained, ulcorner, toindices)\n    x33 = compose(flip, x32)\n    x34 = fork(both, x27, x29)\n    x35 = fork(both, x31, x33)\n    x36 = fork(both, x31, x27)\n    x37 = fork(both, x33, x29)\n    x38 = lbind(matcher, first)\n    x39 = compose(x38, lowermost)\n    x40 = fork(sfilter, toindices, x39)\n    x41 = compose(size, x40)\n    x42 = matcher(x41, ONE)\n    x43 = lbind(matcher, first)\n    x44 = compose(x43, uppermost)\n    x45 = fork(sfilter, toindices, x44)\n    x46 = compose(size, x45)\n    x47 = matcher(x46, ONE)\n    x48 = lbind(matcher, last)\n    x49 = compose(x48, rightmost)\n    x50 = fork(sfilter, toindices, x49)\n    x51 = compose(size, x50)\n    x52 = matcher(x51, ONE)\n    x53 = lbind(matcher, last)\n    x54 = compose(x53, leftmost)\n    x55 = fork(sfilter, toindices, x54)\n    x56 = compose(size, x55)\n    x57 = matcher(x56, ONE)\n    x58 = fork(both, x34, x42)\n    x59 = fork(both, x35, x47)\n    x60 = fork(both, x36, x52)\n    x61 = fork(both, x37, x57)\n    x62 = fork(connect, ulcorner, urcorner)\n    x63 = fork(difference, x62, toindices)\n    x64 = compose(size, x63)\n    x65 = matcher(x64, ZERO)\n    x66 = fork(connect, llcorner, lrcorner)\n    x67 = fork(difference, x66, toindices)\n    x68 = compose(size, x67)\n    x69 = matcher(x68, ZERO)\n    x70 = fork(connect, ulcorner, llcorner)\n    x71 = fork(difference, x70, toindices)\n    x72 = compose(size, x71)\n    x73 = matcher(x72, ZERO)\n    x74 = fork(connect, urcorner, lrcorner)\n    x75 = fork(difference, x74, toindices)\n    x76 = compose(size, x75)\n    x77 = matcher(x76, ZERO)\n    x78 = fork(both, x65, x58)\n    x79 = fork(both, x69, x59)\n    x80 = fork(both, x73, x60)\n    x81 = fork(both, x77, x61)\n    x82 = argmax(x9, x13)\n    x83 = argmax(x9, x17)\n    x84 = argmax(x9, x21)\n    x85 = argmax(x9, x25)\n    x86 = argmax(x9, x78)\n    x87 = argmax(x9, x79)\n    x88 = argmax(x9, x80)\n    x89 = argmax(x9, x81)\n    x90 = height(x82)\n    x91 = height(x84)\n    x92 = add(x90, x91)\n    x93 = height(x88)\n    x94 = add(x93, TWO)\n    x95 = add(x92, x94)\n    x96 = width(x82)\n    x97 = width(x83)\n    x98 = add(x96, x97)\n    x99 = width(x86)\n    x100 = add(x99, TWO)\n    x101 = add(x98, x100)\n    x102 = ulcorner(x82)\n    x103 = increment(x102)\n    x104 = index(I, x103)\n    x105 = astuple(x95, x101)\n    x106 = canvas(x104, x105)\n    x107 = normalize(x82)\n    x108 = paint(x106, x107)\n    x109 = normalize(x83)\n    x110 = width(x83)\n    x111 = subtract(x101, x110)\n    x112 = tojvec(x111)\n    x113 = shift(x109, x112)\n    x114 = paint(x108, x113)\n    x115 = normalize(x84)\n    x116 = height(x84)\n    x117 = subtract(x95, x116)\n    x118 = toivec(x117)\n    x119 = shift(x115, x118)\n    x120 = paint(x114, x119)\n    x121 = normalize(x85)\n    x122 = height(x85)\n    x123 = subtract(x95, x122)\n    x124 = width(x85)\n    x125 = subtract(x101, x124)\n    x126 = astuple(x123, x125)\n    x127 = shift(x121, x126)\n    x128 = paint(x120, x127)\n    x129 = normalize(x88)\n    x130 = height(x82)\n    x131 = increment(x130)\n    x132 = toivec(x131)\n    x133 = shift(x129, x132)\n    x134 = paint(x128, x133)\n    x135 = normalize(x86)\n    x136 = width(x82)\n    x137 = increment(x136)\n    x138 = tojvec(x137)\n    x139 = shift(x135, x138)\n    x140 = paint(x134, x139)\n    x141 = normalize(x89)\n    x142 = height(x83)\n    x143 = increment(x142)\n    x144 = width(x89)\n    x145 = subtract(x101, x144)\n    x146 = astuple(x143, x145)\n    x147 = shift(x141, x146)\n    x148 = paint(x140, x147)\n    x149 = normalize(x87)\n    x150 = height(x87)\n    x151 = subtract(x95, x150)\n    x152 = width(x84)\n    x153 = increment(x152)\n    x154 = astuple(x151, x153)\n    x155 = shift(x149, x154)\n    x156 = paint(x148, x155)\n    return x156\n\n",
    "annotated": "def verify_a8c38be5(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)  # Extract all objects from the input grid, considering only directly adjacent cells\n    x1 = mostcolor(I)  # Find the most common color in the input grid (background color)\n    x2 = palette(I)  # Get all colors used in the input grid\n    x3 = remove(x1, x2)  # Remove the background color from the palette\n    x4 = lbind(colorcount, I)  # Create a function that counts occurrences of a color in the input grid\n    x5 = argmax(x3, x4)  # Find the most common non-background color\n    x6 = astuple(x1, x5)  # Create a tuple of (background color, most common non-background color)\n    x7 = rbind(contained, x6)  # Create a function that checks if a color is one of these two colors\n    x8 = chain(flip, x7, color)  # Create a function that checks if an object's color is not one of these two colors\n    x9 = sfilter(x0, x8)  # Filter objects to keep only those with colors other than the two most common\n\n    # The following lines create functions to check if an object forms different parts of a box\n    x10 = fork(connect, ulcorner, urcorner)  # Function to create top edge of a box\n    x11 = fork(connect, ulcorner, llcorner)  # Function to create left edge of a box\n    x12 = fork(combine, x10, x11)  # Function to combine top and left edges\n    x13 = fork(equality, toindices, x12)  # Function to check if an object forms top-left corner of a box\n\n    x14 = fork(connect, urcorner, ulcorner)  # Function to create top edge of a box (reverse direction)\n    x15 = fork(connect, urcorner, lrcorner)  # Function to create right edge of a box\n    x16 = fork(combine, x14, x15)  # Function to combine top and right edges\n    x17 = fork(equality, toindices, x16)  # Function to check if an object forms top-right corner of a box\n\n    x18 = fork(connect, llcorner, ulcorner)  # Function to create left edge of a box (reverse direction)\n    x19 = fork(connect, llcorner, lrcorner)  # Function to create bottom edge of a box\n    x20 = fork(combine, x18, x19)  # Function to combine left and bottom edges\n    x21 = fork(equality, toindices, x20)  # Function to check if an object forms bottom-left corner of a box\n\n    x22 = fork(connect, lrcorner, llcorner)  # Function to create bottom edge of a box (reverse direction)\n    x23 = fork(connect, lrcorner, urcorner)  # Function to create right edge of a box (reverse direction)\n    x24 = fork(combine, x22, x23)  # Function to combine bottom and right edges\n    x25 = fork(equality, toindices, x24)  # Function to check if an object forms bottom-right corner of a box\n\n    # The following lines create functions to check if an object is not touching the grid edges\n    x26 = fork(contained, lrcorner, toindices)  # Check if lower-right corner is within the object\n    x27 = compose(flip, x26)  # Negate the above check\n    x28 = fork(contained, llcorner, toindices)  # Check if lower-left corner is within the object\n    x29 = compose(flip, x28)  # Negate the above check\n    x30 = fork(contained, urcorner, toindices)  # Check if upper-right corner is within the object\n    x31 = compose(flip, x30)  # Negate the above check\n    x32 = fork(contained, ulcorner, toindices)  # Check if upper-left corner is within the object\n    x33 = compose(flip, x32)  # Negate the above check\n\n    # Combine the above checks to ensure an object is not touching any edge\n    x34 = fork(both, x27, x29)  # Check if object is not touching bottom edge\n    x35 = fork(both, x31, x33)  # Check if object is not touching top edge\n    x36 = fork(both, x31, x27)  # Check if object is not touching right edge\n    x37 = fork(both, x33, x29)  # Check if object is not touching left edge\n\n    # The following lines create functions to check if an object has a single cell on each edge\n    x38 = lbind(matcher, first)  # Create a function to match the first element\n    x39 = compose(x38, lowermost)  # Create a function to check the lowermost cell\n    x40 = fork(sfilter, toindices, x39)  # Filter indices to get the lowermost cells\n    x41 = compose(size, x40)  # Count the number of lowermost cells\n    x42 = matcher(x41, ONE)  # Check if there's exactly one lowermost cell\n\n    x43 = lbind(matcher, first)  # Create a function to match the first element\n    x44 = compose(x43, uppermost)  # Create a function to check the uppermost cell\n    x45 = fork(sfilter, toindices, x44)  # Filter indices to get the uppermost cells\n    x46 = compose(size, x45)  # Count the number of uppermost cells\n    x47 = matcher(x46, ONE)  # Check if there's exactly one uppermost cell\n\n    x48 = lbind(matcher, last)  # Create a function to match the last element\n    x49 = compose(x48, rightmost)  # Create a function to check the rightmost cell\n    x50 = fork(sfilter, toindices, x49)  # Filter indices to get the rightmost cells\n    x51 = compose(size, x50)  # Count the number of rightmost cells\n    x52 = matcher(x51, ONE)  # Check if there's exactly one rightmost cell\n\n    x53 = lbind(matcher, last)  # Create a function to match the last element\n    x54 = compose(x53, leftmost)  # Create a function to check the leftmost cell\n    x55 = fork(sfilter, toindices, x54)  # Filter indices to get the leftmost cells\n    x56 = compose(size, x55)  # Count the number of leftmost cells\n    x57 = matcher(x56, ONE)  # Check if there's exactly one leftmost cell\n\n    # Combine the above checks for each edge\n    x58 = fork(both, x34, x42)  # Check if object is not touching bottom edge and has one lowermost cell\n    x59 = fork(both, x35, x47)  # Check if object is not touching top edge and has one uppermost cell\n    x60 = fork(both, x36, x52)  # Check if object is not touching right edge and has one rightmost cell\n    x61 = fork(both, x37, x57)  # Check if object is not touching left edge and has one leftmost cell\n\n    # The following lines create functions to check if an object forms a complete edge\n    x62 = fork(connect, ulcorner, urcorner)  # Create top edge\n    x63 = fork(difference, x62, toindices)  # Find cells on top edge not in the object\n    x64 = compose(size, x63)  # Count number of missing cells on top edge\n    x65 = matcher(x64, ZERO)  # Check if there are no missing cells on top edge\n\n    x66 = fork(connect, llcorner, lrcorner)  # Create bottom edge\n    x67 = fork(difference, x66, toindices)  # Find cells on bottom edge not in the object\n    x68 = compose(size, x67)  # Count number of missing cells on bottom edge\n    x69 = matcher(x68, ZERO)  # Check if there are no missing cells on bottom edge\n\n    x70 = fork(connect, ulcorner, llcorner)  # Create left edge\n    x71 = fork(difference, x70, toindices)  # Find cells on left edge not in the object\n    x72 = compose(size, x71)  # Count number of missing cells on left edge\n    x73 = matcher(x72, ZERO)  # Check if there are no missing cells on left edge\n\n    x74 = fork(connect, urcorner, lrcorner)  # Create right edge\n    x75 = fork(difference, x74, toindices)  # Find cells on right edge not in the object\n    x76 = compose(size, x75)  # Count number of missing cells on right edge\n    x77 = matcher(x76, ZERO)  # Check if there are no missing cells on right edge\n\n    # Combine the above checks for complete edges with the previous checks\n    x78 = fork(both, x65, x58)  # Check for complete top edge and correct bottom\n    x79 = fork(both, x69, x59)  # Check for complete bottom edge and correct top\n    x80 = fork(both, x73, x60)  # Check for complete left edge and correct right\n    x81 = fork(both, x77, x61)  # Check for complete right edge and correct left\n\n    # Find objects that satisfy each of the corner and edge conditions\n    x82 = argmax(x9, x13)  # Find object forming top-left corner\n    x83 = argmax(x9, x17)  # Find object forming top-right corner\n    x84 = argmax(x9, x21)  # Find object forming bottom-left corner\n    x85 = argmax(x9, x25)  # Find object forming bottom-right corner\n    x86 = argmax(x9, x78)  # Find object forming top edge\n    x87 = argmax(x9, x79)  # Find object forming bottom edge\n    x88 = argmax(x9, x80)  # Find object forming left edge\n    x89 = argmax(x9, x81)  # Find object forming right edge\n\n    # Calculate dimensions of the output grid\n    x90 = height(x82)  # Height of top-left corner object\n    x91 = height(x84)  # Height of bottom-left corner object\n    x92 = add(x90, x91)  # Sum of heights of left side objects\n    x93 = height(x88)  # Height of left edge object\n    x94 = add(x93, TWO)  # Height of left edge plus 2 (for gaps)\n    x95 = add(x92, x94)  # Total height of output grid\n\n    x96 = width(x82)  # Width of top-left corner object\n    x97 = width(x83)  # Width of top-right corner object\n    x98 = add(x96, x97)  # Sum of widths of top objects\n    x99 = width(x86)  # Width of top edge object\n    x100 = add(x99, TWO)  # Width of top edge plus 2 (for gaps)\n    x101 = add(x98, x100)  # Total width of output grid\n\n    # Create and fill the output grid\n    x102 = ulcorner(x82)  # Get upper-left corner of top-left object\n    x103 = increment(x102)  # Move one cell down and right\n    x104 = index(I, x103)  # Get color at this position (background color)\n    x105 = astuple(x95, x101)  # Create dimensions tuple for output grid\n    x106 = canvas(x104, x105)  # Create output grid filled with background color\n\n    # Paint each object onto the output grid in the correct position\n    x107 = normalize(x82)  # Normalize top-left corner object\n    x108 = paint(x106, x107)  # Paint top-left corner object\n\n    x109 = normalize(x83)  # Normalize top-right corner object\n    x110 = width(x83)  # Get width of top-right corner object\n    x111 = subtract(x101, x110)  # Calculate x-coordinate for top-right object\n    x112 = tojvec(x111)  # Convert to column vector\n    x113 = shift(x109, x112)  # Shift top-right object to correct position\n    x114 = paint(x108, x113)  # Paint top-right corner object\n\n    x115 = normalize(x84)  # Normalize bottom-left corner object\n    x116 = height(x84)  # Get height of bottom-left corner object\n    x117 = subtract(x95, x116)  # Calculate y-coordinate for bottom-left object\n    x118 = toivec(x117)  # Convert to row vector\n    x119 = shift(x115, x118)  # Shift bottom-left object to correct position\n    x120 = paint(x114, x119)  # Paint bottom-left corner object\n\n    x121 = normalize(x85)  # Normalize bottom-right corner object\n    x122 = height(x85)  # Get height of bottom-right corner object\n    x123 = subtract(x95, x122)  # Calculate y-coordinate for bottom-right object\n    x124 = width(x85)  # Get width of bottom-right corner object\n    x125 = subtract(x101, x124)  # Calculate x-coordinate for bottom-right object\n    x126 = astuple(x123, x125)  # Create position tuple for bottom-right object\n    x127 = shift(x121, x126)  # Shift bottom-right object to correct position\n    x128 = paint(x120, x127)  # Paint bottom-right corner object\n\n    x129 = normalize(x88)  # Normalize left edge object\n    x130 = height(x82)  # Get height of top-left corner object\n    x131 = increment(x130)  # Add 1 to create gap\n    x132 = toivec(x131)  # Convert to row vector\n    x133 = shift(x129, x132)  # Shift left edge object to correct position\n    x134 = paint(x128, x133)  # Paint left edge object\n\n    x135 = normalize(x86)  # Normalize top edge object\n    x136 = width(x82)  # Get width of top-left corner object\n    x137 = increment(x136)  # Add 1 to create gap\n    x138 = tojvec(x137)  # Convert to column vector\n    x139 = shift(x135, x138)  # Shift top edge object to correct position\n    x140 = paint(x134, x139)  # Paint top edge object\n\n    x141 = normalize(x89)  # Normalize right edge object\n    x142 = height(x83)  # Get height of top-right corner object\n    x143 = increment(x142)  # Add 1 to create gap\n    x144 = width(x89)  # Get width of right edge object\n    x145 = subtract(x101, x144)  # Calculate x-coordinate for right edge object\n    x146 = astuple(x143, x145)  # Create position tuple for right edge object\n    x147 = shift(x141, x146)  # Shift right edge object to correct position\n    x148 = paint(x140, x147)  # Paint right edge object\n\n    x149 = normalize(x87)  # Normalize bottom edge object\n    x150 = height(x87)  # Get height of bottom edge object\n    x151 = subtract(x95, x150)  # Calculate y-coordinate for bottom edge object\n    x152 = width(x84)  # Get width of bottom-left corner object\n    x153 = increment(x152)  # Add 1 to create gap\n    x154 = astuple(x151, x153)  # Create position tuple for bottom edge object\n    x155 = shift(x149, x154)  # Shift bottom edge object to correct position\n    x156 = paint(x148, x155)  # Paint bottom edge object\n\n    return x156  # Return the completed output grid\n"
  },
  "a8d7556c": {
    "original": "def verify_a8d7556c(I: Grid) -> Grid:\n    x0 = initset(ORIGIN)\n    x1 = recolor(ZERO, x0)\n    x2 = upscale(x1, TWO)\n    x3 = occurrences(I, x2)\n    x4 = lbind(shift, x2)\n    x5 = mapply(x4, x3)\n    x6 = fill(I, TWO, x5)\n    return x6\n\n",
    "annotated": "def verify_a8d7556c(I: Grid) -> Grid:\n    # Initialize a set with the origin (0, 0)\n    x0 = initset(ORIGIN)\n    \n    # Create an object with color 0 (black) at the origin\n    x1 = recolor(ZERO, x0)\n    \n    # Upscale the black object to a 2x2 square\n    x2 = upscale(x1, TWO)\n    \n    # Find all occurrences of the 2x2 black square in the input grid\n    x3 = occurrences(I, x2)\n    \n    # Create a function that shifts the 2x2 square to different positions\n    x4 = lbind(shift, x2)\n    \n    # Apply the shift function to all occurrences, creating a set of 2x2 squares at their locations\n    x5 = mapply(x4, x3)\n    \n    # Fill all the 2x2 black squares in the input grid with color 2\n    # This effectively replaces all 2x2 black squares with color 2 squares\n    x6 = fill(I, TWO, x5)\n    \n    # Return the modified grid\n    return x6\n"
  },
  "a9f96cdd": {
    "original": "def verify_a9f96cdd(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = shift(x1, NEG_UNITY)\n    x3 = recolor(THREE, x2)\n    x4 = shift(x1, UNITY)\n    x5 = recolor(SEVEN, x4)\n    x6 = shift(x1, DOWN_LEFT)\n    x7 = recolor(EIGHT, x6)\n    x8 = shift(x1, UP_RIGHT)\n    x9 = recolor(SIX, x8)\n    x10 = mostcolor(I)\n    x11 = fill(I, x10, x1)\n    x12 = combine(x3, x5)\n    x13 = combine(x7, x9)\n    x14 = combine(x12, x13)\n    x15 = paint(x11, x14)\n    return x15\n\n",
    "annotated": "def verify_a9f96cdd(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get all cells with the background color (inverse of the shapes)\n    x1 = ofcolor(I, x0)\n    \n    # Shift the background cells up and left by 1 (top-left corner of each shape)\n    x2 = shift(x1, NEG_UNITY)\n    \n    # Color the top-left corners with 3 (red)\n    x3 = recolor(THREE, x2)\n    \n    # Shift the background cells down and right by 1 (bottom-right corner of each shape)\n    x4 = shift(x1, UNITY)\n    \n    # Color the bottom-right corners with 7 (orange)\n    x5 = recolor(SEVEN, x4)\n    \n    # Shift the background cells down and left by 1 (bottom-left corner of each shape)\n    x6 = shift(x1, DOWN_LEFT)\n    \n    # Color the bottom-left corners with 8 (cyan)\n    x7 = recolor(EIGHT, x6)\n    \n    # Shift the background cells up and right by 1 (top-right corner of each shape)\n    x8 = shift(x1, UP_RIGHT)\n    \n    # Color the top-right corners with 6 (magenta)\n    x9 = recolor(SIX, x8)\n    \n    # Find the most common color in the input grid (foreground color of shapes)\n    x10 = mostcolor(I)\n    \n    # Fill the shape areas with the background color (removing the original shapes)\n    x11 = fill(I, x10, x1)\n    \n    # Combine the top-left (red) and bottom-right (orange) corners\n    x12 = combine(x3, x5)\n    \n    # Combine the bottom-left (cyan) and top-right (magenta) corners\n    x13 = combine(x7, x9)\n    \n    # Combine all four colored corners\n    x14 = combine(x12, x13)\n    \n    # Paint the colored corners onto the grid with removed shapes\n    x15 = paint(x11, x14)\n    \n    # Return the final grid with colored corners replacing the original shapes\n    return x15\n"
  },
  "aabf363d": {
    "original": "def verify_aabf363d(I: Grid) -> Grid:\n    x0 = fork(multiply, height, width)\n    x1 = lbind(ofcolor, I)\n    x2 = palette(I)\n    x3 = compose(x0, x1)\n    x4 = argmax(x2, x3)\n    x5 = leastcolor(I)\n    x6 = palette(I)\n    x7 = remove(x4, x6)\n    x8 = other(x7, x5)\n    x9 = replace(I, x5, x4)\n    x10 = replace(x9, x8, x5)\n    return x10\n\n",
    "annotated": "def verify_aabf363d(I: Grid) -> Grid:\n    # Create a function that multiplies the height and width of the input grid\n    x0 = fork(multiply, height, width)\n    \n    # Create a function that finds cells of a specific color in the input grid\n    x1 = lbind(ofcolor, I)\n    \n    # Get the set of unique colors used in the input grid\n    x2 = palette(I)\n    \n    # Compose the functions to get the number of cells for each color\n    x3 = compose(x0, x1)\n    \n    # Find the color that covers the most area in the input grid (background color)\n    x4 = argmax(x2, x3)\n    \n    # Find the least common color in the input grid (the single cell to be changed)\n    x5 = leastcolor(I)\n    \n    # Get the set of unique colors used in the input grid again\n    x6 = palette(I)\n    \n    # Remove the background color from the set of colors\n    x7 = remove(x4, x6)\n    \n    # Find the other color (shape color) by removing the least common color\n    x8 = other(x7, x5)\n    \n    # Replace the least common color with the background color\n    x9 = replace(I, x5, x4)\n    \n    # Replace the shape color with the least common color\n    # This effectively changes all cells of the shape to the color of the single cell\n    x10 = replace(x9, x8, x5)\n    \n    # Return the modified grid as the solution\n    return x10\n"
  },
  "aba27056": {
    "original": "def verify_aba27056(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = delta(x1)\n    x3 = fill(I, FOUR, x2)\n    x4 = delta(x1)\n    x5 = box(x1)\n    x6 = intersection(x4, x5)\n    x7 = uppermost(x6)\n    x8 = uppermost(x1)\n    x9 = equality(x7, x8)\n    x10 = leftmost(x6)\n    x11 = leftmost(x1)\n    x12 = equality(x10, x11)\n    x13 = lowermost(x6)\n    x14 = lowermost(x1)\n    x15 = equality(x13, x14)\n    x16 = rightmost(x6)\n    x17 = rightmost(x1)\n    x18 = equality(x16, x17)\n    x19 = urcorner(x6)\n    x20 = ulcorner(x6)\n    x21 = llcorner(x6)\n    x22 = lrcorner(x6)\n    x23 = branch(x15, x21, x22)\n    x24 = branch(x12, x20, x23)\n    x25 = branch(x9, x19, x24)\n    x26 = branch(x15, x22, x19)\n    x27 = branch(x12, x21, x26)\n    x28 = branch(x9, x20, x27)\n    x29 = branch(x15, DOWN_LEFT, UNITY)\n    x30 = branch(x12, NEG_UNITY, x29)\n    x31 = branch(x9, UP_RIGHT, x30)\n    x32 = branch(x15, UNITY, UP_RIGHT)\n    x33 = branch(x12, DOWN_LEFT, x32)\n    x34 = branch(x9, NEG_UNITY, x33)\n    x35 = branch(x15, DOWN, RIGHT)\n    x36 = branch(x12, LEFT, x35)\n    x37 = branch(x9, UP, x36)\n    x38 = shoot(x25, x31)\n    x39 = shoot(x28, x34)\n    x40 = combine(x38, x39)\n    x41 = rbind(shoot, x37)\n    x42 = mapply(x41, x6)\n    x43 = combine(x42, x40)\n    x44 = fill(x3, FOUR, x43)\n    return x44\n\n",
    "annotated": "def verify_aba27056(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    \n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Get the background cells within the bounding box of the merged object\n    x2 = delta(x1)\n    \n    # Fill the background cells with color 4 (creating the initial output grid)\n    x3 = fill(I, FOUR, x2)\n    \n    # Get the background cells within the bounding box again (same as x2)\n    x4 = delta(x1)\n    \n    # Get the outline of the merged object\n    x5 = box(x1)\n    \n    # Find the intersection of background cells and the object's outline (this is the hole)\n    x6 = intersection(x4, x5)\n    \n    # Get the uppermost row of the hole\n    x7 = uppermost(x6)\n    \n    # Get the uppermost row of the merged object\n    x8 = uppermost(x1)\n    \n    # Check if the hole touches the top of the object\n    x9 = equality(x7, x8)\n    \n    # Get the leftmost column of the hole\n    x10 = leftmost(x6)\n    \n    # Get the leftmost column of the merged object\n    x11 = leftmost(x1)\n    \n    # Check if the hole touches the left side of the object\n    x12 = equality(x10, x11)\n    \n    # Get the lowermost row of the hole\n    x13 = lowermost(x6)\n    \n    # Get the lowermost row of the merged object\n    x14 = lowermost(x1)\n    \n    # Check if the hole touches the bottom of the object\n    x15 = equality(x13, x14)\n    \n    # Get the rightmost column of the hole\n    x16 = rightmost(x6)\n    \n    # Get the rightmost column of the merged object\n    x17 = rightmost(x1)\n    \n    # Check if the hole touches the right side of the object\n    x18 = equality(x16, x17)\n    \n    # Get the upper right corner of the hole\n    x19 = urcorner(x6)\n    \n    # Get the upper left corner of the hole\n    x20 = ulcorner(x6)\n    \n    # Get the lower left corner of the hole\n    x21 = llcorner(x6)\n    \n    # Get the lower right corner of the hole\n    x22 = lrcorner(x6)\n    \n    # Choose the lower corner based on whether the hole touches the bottom\n    x23 = branch(x15, x21, x22)\n    \n    # Choose the left corner based on whether the hole touches the left side\n    x24 = branch(x12, x20, x23)\n    \n    # Choose the starting point for the first diagonal line\n    x25 = branch(x9, x19, x24)\n    \n    # Similar branching for the second diagonal line's starting point\n    x26 = branch(x15, x22, x19)\n    x27 = branch(x12, x21, x26)\n    x28 = branch(x9, x20, x27)\n    \n    # Choose the direction for the first diagonal line\n    x29 = branch(x15, DOWN_LEFT, UNITY)\n    x30 = branch(x12, NEG_UNITY, x29)\n    x31 = branch(x9, UP_RIGHT, x30)\n    \n    # Choose the direction for the second diagonal line\n    x32 = branch(x15, UNITY, UP_RIGHT)\n    x33 = branch(x12, DOWN_LEFT, x32)\n    x34 = branch(x9, NEG_UNITY, x33)\n    \n    # Choose the direction for the vertical bars\n    x35 = branch(x15, DOWN, RIGHT)\n    x36 = branch(x12, LEFT, x35)\n    x37 = branch(x9, UP, x36)\n    \n    # Create the first diagonal line\n    x38 = shoot(x25, x31)\n    \n    # Create the second diagonal line\n    x39 = shoot(x28, x34)\n    \n    # Combine both diagonal lines\n    x40 = combine(x38, x39)\n    \n    # Create a function to shoot vertical bars from each point of the hole\n    x41 = rbind(shoot, x37)\n    \n    # Apply the vertical bar function to all points of the hole\n    x42 = mapply(x41, x6)\n    \n    # Combine vertical bars with diagonal lines\n    x43 = combine(x42, x40)\n    \n    # Fill the combined pattern with color 4 on the output grid\n    x44 = fill(x3, FOUR, x43)\n    \n    # Return the final output grid\n    return x44\n"
  },
  "ac0a08a4": {
    "original": "def verify_ac0a08a4(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = colorcount(I, x0)\n    x2 = height(I)\n    x3 = width(I)\n    x4 = multiply(x2, x3)\n    x5 = subtract(x4, x1)\n    x6 = upscale(I, x5)\n    return x6\n\n",
    "annotated": "def verify_ac0a08a4(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Count the number of cells with the background color\n    x1 = colorcount(I, x0)\n    \n    # Get the height of the input grid\n    x2 = height(I)\n    \n    # Get the width of the input grid\n    x3 = width(I)\n    \n    # Calculate the total number of cells in the grid\n    x4 = multiply(x2, x3)\n    \n    # Calculate the number of non-background colored cells\n    # This is the scaling factor for upscaling\n    x5 = subtract(x4, x1)\n    \n    # Upscale the input grid by the factor calculated above\n    # This creates a larger grid where each cell is replaced by a square of cells\n    # The size of this square is equal to the number of non-background colored cells in the original grid\n    x6 = upscale(I, x5)\n    \n    # Return the upscaled grid as the output\n    return x6\n"
  },
  "ae3edfdc": {
    "original": "def verify_ae3edfdc(I: Grid) -> Grid:\n    x0 = ofcolor(I, ONE)\n    x1 = center(x0)\n    x2 = ofcolor(I, TWO)\n    x3 = center(x2)\n    x4 = ofcolor(I, THREE)\n    x5 = ofcolor(I, SEVEN)\n    x6 = lbind(add, x1)\n    x7 = initset(x1)\n    x8 = rbind(position, x7)\n    x9 = compose(invert, x8)\n    x10 = chain(x6, x9, initset)\n    x11 = lbind(add, x3)\n    x12 = initset(x3)\n    x13 = rbind(position, x12)\n    x14 = compose(invert, x13)\n    x15 = chain(x11, x14, initset)\n    x16 = apply(x10, x5)\n    x17 = apply(x15, x4)\n    x18 = combine(x4, x5)\n    x19 = cover(I, x18)\n    x20 = fill(x19, SEVEN, x16)\n    x21 = fill(x20, THREE, x17)\n    return x21\n\n",
    "annotated": "def verify_ae3edfdc(I: Grid) -> Grid:\n    # Find all cells with color 1 (blue)\n    x0 = ofcolor(I, ONE)\n    # Get the center of the blue dot\n    x1 = center(x0)\n    # Find all cells with color 2 (red)\n    x2 = ofcolor(I, TWO)\n    # Get the center of the red dot\n    x3 = center(x2)\n    # Find all cells with color 3 (green)\n    x4 = ofcolor(I, THREE)\n    # Find all cells with color 7 (orange)\n    x5 = ofcolor(I, SEVEN)\n    # Create a function that adds the blue dot's center to a given position\n    x6 = lbind(add, x1)\n    # Create a set containing only the blue dot's center\n    x7 = initset(x1)\n    # Create a function that finds the position relative to the blue dot\n    x8 = rbind(position, x7)\n    # Create a function that inverts the relative position\n    x9 = compose(invert, x8)\n    # Chain functions to move orange dots back to their original positions around the blue dot\n    x10 = chain(x6, x9, initset)\n    # Create a function that adds the red dot's center to a given position\n    x11 = lbind(add, x3)\n    # Create a set containing only the red dot's center\n    x12 = initset(x3)\n    # Create a function that finds the position relative to the red dot\n    x13 = rbind(position, x12)\n    # Create a function that inverts the relative position\n    x14 = compose(invert, x13)\n    # Chain functions to move green dots back to their original positions around the red dot\n    x15 = chain(x11, x14, initset)\n    # Apply the function to move orange dots back to their original positions\n    x16 = apply(x10, x5)\n    # Apply the function to move green dots back to their original positions\n    x17 = apply(x15, x4)\n    # Combine the sets of green and orange dots\n    x18 = combine(x4, x5)\n    # Remove all green and orange dots from the input grid\n    x19 = cover(I, x18)\n    # Place orange dots back in their original positions around the blue dot\n    x20 = fill(x19, SEVEN, x16)\n    # Place green dots back in their original positions around the red dot\n    x21 = fill(x20, THREE, x17)\n    # Return the reconstructed original grid\n    return x21\n"
  },
  "ae4f1146": {
    "original": "def verify_ae4f1146(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = objects(I, F, F, T)\n    x5 = rbind(colorcount, ONE)\n    x6 = argmax(x4, x5)\n    x7 = subgrid(x6, I)\n    return x7\n\n",
    "annotated": "def verify_ae4f1146(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Create a box (outline) around the entire grid\n    x1 = box(x0)\n    \n    # Convert the box to an object, preserving the colors from the input grid\n    x2 = toobject(x1, I)\n    \n    # Find the most common color in the box object (likely the background color)\n    x3 = mostcolor(x2)\n    \n    # Find all objects in the grid, considering 4-connected cells, ignoring diagonals, and excluding the background color\n    x4 = objects(I, F, F, T)\n    \n    # Create a function that counts cells with color 1 in an object\n    x5 = rbind(colorcount, ONE)\n    \n    # Find the object with the maximum count of color 1 cells (likely the most filled small grid)\n    x6 = argmax(x4, x5)\n    \n    # Extract the subgrid corresponding to this object from the input grid\n    x7 = subgrid(x6, I)\n    \n    # Return this subgrid as the output (which should be the most filled small grid)\n    return x7\n"
  },
  "aedd82e4": {
    "original": "def verify_aedd82e4(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = canvas(ZERO, x0)\n    x2 = hconcat(I, x1)\n    x3 = objects(x2, F, F, T)\n    x4 = matcher(color, ZERO)\n    x5 = compose(flip, x4)\n    x6 = sfilter(x3, x5)\n    x7 = sizefilter(x6, ONE)\n    x8 = merge(x7)\n    x9 = fill(I, ONE, x8)\n    return x9\n\n",
    "annotated": "def verify_aedd82e4(I: Grid) -> Grid:\n    # Get the dimensions (height and width) of the input grid\n    x0 = shape(I)\n    \n    # Create a new canvas (grid) with the same dimensions as I, filled with zeros (black)\n    x1 = canvas(ZERO, x0)\n    \n    # Concatenate the input grid I with the black canvas horizontally\n    # This effectively doubles the width of the grid, with the right half being all black\n    x2 = hconcat(I, x1)\n    \n    # Identify all objects (connected components) in the concatenated grid\n    # F, F, T parameters mean: not univalued, not diagonal, without background\n    x3 = objects(x2, F, F, T)\n    \n    # Create a function that checks if a color is zero (black)\n    x4 = matcher(color, ZERO)\n    \n    # Create a function that checks if a color is not zero (not black)\n    x5 = compose(flip, x4)\n    \n    # Filter objects to keep only those that are not black\n    x6 = sfilter(x3, x5)\n    \n    # Filter objects again to keep only those that consist of a single cell\n    x7 = sizefilter(x6, ONE)\n    \n    # Merge all single-cell, non-black objects into one set\n    x8 = merge(x7)\n    \n    # Fill all cells in the original input grid that correspond to \n    # single-cell, non-black objects with the color 1 (blue)\n    # This effectively changes all isolated colored cells to blue\n    x9 = fill(I, ONE, x8)\n    \n    # Return the modified grid\n    return x9\n"
  },
  "af902bf9": {
    "original": "def verify_af902bf9(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = interval(THREE, SEVEN, ONE)\n    x4 = product(x3, x3)\n    x5 = fork(multiply, first, last)\n    x6 = order(x4, x5)\n    x7 = lbind(canvas, NEG_ONE)\n    x8 = chain(x7, first, first)\n    x9 = chain(corners, asindices, x8)\n    x10 = lbind(recolor, x0)\n    x11 = compose(asindices, x8)\n    x12 = fork(difference, x11, x9)\n    x13 = lbind(recolor, TWO)\n    x14 = compose(inbox, x9)\n    x15 = chain(x13, backdrop, x14)\n    x16 = compose(x10, x12)\n    x17 = lbind(lbind, combine)\n    x18 = compose(x17, x16)\n    x19 = lbind(rbind, recolor)\n    x20 = compose(x19, x9)\n    x21 = fork(compose, x18, x20)\n    x22 = lbind(lbind, mapply)\n    x23 = lbind(lbind, shift)\n    x24 = chain(x22, x23, x15)\n    x25 = lbind(lbind, occurrences)\n    x26 = compose(x25, last)\n    x27 = fork(compose, x26, x21)\n    x28 = fork(compose, x24, x27)\n    x29 = rbind(mapply, x2)\n    x30 = compose(x29, x28)\n    x31 = fork(paint, last, x30)\n    x32 = compose(first, first)\n    x33 = fork(remove, x32, first)\n    x34 = fork(astuple, x33, x31)\n    x35 = size(x6)\n    x36 = power(x34, x35)\n    x37 = astuple(x6, I)\n    x38 = x36(x37)\n    x39 = last(x38)\n    return x39\n\n",
    "annotated": "def verify_af902bf9(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Remove the background color from the set of colors, leaving only the square colors\n    x2 = remove(x0, x1)\n    \n    # Create a range of integers from 3 to 6 (possible square sizes)\n    x3 = interval(THREE, SEVEN, ONE)\n    \n    # Create all possible combinations of square dimensions (3x3 to 6x6)\n    x4 = product(x3, x3)\n    \n    # Create a function to calculate the area of a square\n    x5 = fork(multiply, first, last)\n    \n    # Sort the square dimensions by area, from smallest to largest\n    x6 = order(x4, x5)\n    \n    # Create a function to make a canvas filled with -1\n    x7 = lbind(canvas, NEG_ONE)\n    \n    # Create a function to get dimensions of the first square\n    x8 = chain(x7, first, first)\n    \n    # Create a function to get corners of a square of the first dimensions\n    x9 = chain(corners, asindices, x8)\n    \n    # Create a function to recolor with the background color\n    x10 = lbind(recolor, x0)\n    \n    # Create a function to get all indices of a square of the first dimensions\n    x11 = compose(asindices, x8)\n    \n    # Create a function to get the inner part of a square (excluding corners)\n    x12 = fork(difference, x11, x9)\n    \n    # Create a function to recolor with color 2 (fill color)\n    x13 = lbind(recolor, TWO)\n    \n    # Create a function to get the inner box of a square\n    x14 = compose(inbox, x9)\n    \n    # Create a function to fill the inner box of a square with color 2\n    x15 = chain(x13, backdrop, x14)\n    \n    # Create a function to recolor the inner part of a square with background color\n    x16 = compose(x10, x12)\n    \n    # Create a partial function for combining sets\n    x17 = lbind(lbind, combine)\n    \n    # Create a function to combine the inner part and corners of a square\n    x18 = compose(x17, x16)\n    \n    # Create a partial function for recoloring\n    x19 = lbind(rbind, recolor)\n    \n    # Create a function to recolor the corners of a square\n    x20 = compose(x19, x9)\n    \n    # Create a function to generate a complete square (inner part and corners)\n    x21 = fork(compose, x18, x20)\n    \n    # Create a partial function for mapping and applying\n    x22 = lbind(lbind, mapply)\n    \n    # Create a partial function for shifting\n    x23 = lbind(lbind, shift)\n    \n    # Create a function to shift and fill the inner part of a square\n    x24 = chain(x22, x23, x15)\n    \n    # Create a partial function for finding occurrences\n    x25 = lbind(lbind, occurrences)\n    \n    # Create a function to get the color of a square\n    x26 = compose(x25, last)\n    \n    # Create a function to find occurrences of a complete square\n    x27 = fork(compose, x26, x21)\n    \n    # Create a function to generate and place squares\n    x28 = fork(compose, x24, x27)\n    \n    # Create a function to apply the square generation to all colors\n    x29 = rbind(mapply, x2)\n    \n    # Create a function to generate all squares for all colors\n    x30 = compose(x29, x28)\n    \n    # Create a function to paint the generated squares on the input grid\n    x31 = fork(paint, last, x30)\n    \n    # Create a function to get the first square dimensions\n    x32 = compose(first, first)\n    \n    # Create a function to remove the first square dimensions from the list\n    x33 = fork(remove, x32, first)\n    \n    # Create a function to process one iteration (generate squares and update dimensions)\n    x34 = fork(astuple, x33, x31)\n    \n    # Get the number of different square sizes\n    x35 = size(x6)\n    \n    # Create a function to process all square sizes\n    x36 = power(x34, x35)\n    \n    # Combine square dimensions with the input grid\n    x37 = astuple(x6, I)\n    \n    # Apply the processing function to generate the output grid\n    x38 = x36(x37)\n    \n    # Get the final output grid\n    x39 = last(x38)\n    \n    # Return the output grid with all squares filled\n    return x39\n"
  },
  "b0c4d837": {
    "original": "def verify_b0c4d837(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = remove(x2, x0)\n    x4 = argmin(x3, x1)\n    x5 = argmax(x3, x1)\n    x6 = ulcorner(x5)\n    x7 = llcorner(x5)\n    x8 = connect(x6, x7)\n    x9 = urcorner(x5)\n    x10 = lrcorner(x5)\n    x11 = connect(x9, x10)\n    x12 = combine(x8, x11)\n    x13 = toindices(x5)\n    x14 = difference(x12, x13)\n    x15 = size(x14)\n    x16 = equality(x15, ZERO)\n    x17 = branch(x16, height, width)\n    x18 = x17(x5)\n    x19 = x17(x4)\n    x20 = subtract(x18, x19)\n    x21 = decrement(x20)\n    x22 = color(x4)\n    x23 = color(x2)\n    x24 = repeat(x22, x21)\n    x25 = subtract(NINE, x21)\n    x26 = repeat(x23, x25)\n    x27 = combine(x24, x26)\n    x28 = repeat(x27, ONE)\n    x29 = hsplit(x28, THREE)\n    x30 = interval(ZERO, THREE, ONE)\n    x31 = pair(x30, x29)\n    x32 = matcher(first, ZERO)\n    x33 = extract(x31, x32)\n    x34 = last(x33)\n    x35 = matcher(first, ONE)\n    x36 = extract(x31, x35)\n    x37 = last(x36)\n    x38 = matcher(first, TWO)\n    x39 = extract(x31, x38)\n    x40 = last(x39)\n    x41 = vmirror(x37)\n    x42 = vconcat(x34, x41)\n    x43 = vconcat(x42, x40)\n    return x43\n\n",
    "annotated": "def verify_b0c4d837(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies height and width\n    x1 = fork(multiply, height, width)\n    \n    # Find the largest object in the partition based on area (height * width)\n    x2 = argmax(x0, x1)\n    \n    # Remove the largest object from the partition\n    x3 = remove(x2, x0)\n    \n    # Find the smallest remaining object (likely the inner fill)\n    x4 = argmin(x3, x1)\n    \n    # Find the largest remaining object (likely the outer box)\n    x5 = argmax(x3, x1)\n    \n    # Get the upper-left corner of the outer box\n    x6 = ulcorner(x5)\n    \n    # Get the lower-left corner of the outer box\n    x7 = llcorner(x5)\n    \n    # Create a line connecting the upper-left and lower-left corners\n    x8 = connect(x6, x7)\n    \n    # Get the upper-right corner of the outer box\n    x9 = urcorner(x5)\n    \n    # Get the lower-right corner of the outer box\n    x10 = lrcorner(x5)\n    \n    # Create a line connecting the upper-right and lower-right corners\n    x11 = connect(x9, x10)\n    \n    # Combine the left and right vertical lines\n    x12 = combine(x8, x11)\n    \n    # Get all indices of the outer box\n    x13 = toindices(x5)\n    \n    # Find the difference between the vertical lines and the box indices\n    # This checks if the box is filled or has a gap\n    x14 = difference(x12, x13)\n    \n    # Count the number of indices in the difference\n    x15 = size(x14)\n    \n    # Check if the difference is zero (box is filled)\n    x16 = equality(x15, ZERO)\n    \n    # Choose height if box is filled, width otherwise\n    x17 = branch(x16, height, width)\n    \n    # Get the chosen dimension (height or width) of the outer box\n    x18 = x17(x5)\n    \n    # Get the chosen dimension (height or width) of the inner fill\n    x19 = x17(x4)\n    \n    # Calculate the difference between outer and inner dimensions\n    x20 = subtract(x18, x19)\n    \n    # Decrease the difference by 1 to get the number of filled rows/columns\n    x21 = decrement(x20)\n    \n    # Get the color of the inner fill\n    x22 = color(x4)\n    \n    # Get the color of the background (largest object)\n    x23 = color(x2)\n    \n    # Create a sequence of the fill color repeated 'filled rows/columns' times\n    x24 = repeat(x22, x21)\n    \n    # Calculate the number of empty rows/columns (9 minus filled)\n    x25 = subtract(NINE, x21)\n    \n    # Create a sequence of the background color repeated 'empty rows/columns' times\n    x26 = repeat(x23, x25)\n    \n    # Combine the filled and empty color sequences\n    x27 = combine(x24, x26)\n    \n    # Repeat the combined sequence once (creating a single row)\n    x28 = repeat(x27, ONE)\n    \n    # Split the row into three parts\n    x29 = hsplit(x28, THREE)\n    \n    # Create a sequence [0, 1, 2]\n    x30 = interval(ZERO, THREE, ONE)\n    \n    # Pair the sequence with the split parts\n    x31 = pair(x30, x29)\n    \n    # Create a function to match the first element of a pair with 0\n    x32 = matcher(first, ZERO)\n    \n    # Extract the pair where the first element is 0\n    x33 = extract(x31, x32)\n    \n    # Get the second element of the extracted pair (first row of output)\n    x34 = last(x33)\n    \n    # Create a function to match the first element of a pair with 1\n    x35 = matcher(first, ONE)\n    \n    # Extract the pair where the first element is 1\n    x36 = extract(x31, x35)\n    \n    # Get the second element of the extracted pair (second row of output)\n    x37 = last(x36)\n    \n    # Create a function to match the first element of a pair with 2\n    x38 = matcher(first, TWO)\n    \n    # Extract the pair where the first element is 2\n    x39 = extract(x31, x38)\n    \n    # Get the second element of the extracted pair (third row of output)\n    x40 = last(x39)\n    \n    # Mirror the second row horizontally\n    x41 = vmirror(x37)\n    \n    # Concatenate the first row with the mirrored second row\n    x42 = vconcat(x34, x41)\n    \n    # Concatenate the result with the third row to form the final 3x3 output grid\n    x43 = vconcat(x42, x40)\n    \n    # Return the final 3x3 output grid\n    return x43\n"
  },
  "b190f7f5": {
    "original": "def verify_b190f7f5(I: Grid) -> Grid:\n    x0 = lbind(contained, TWO)\n    x1 = lbind(apply, numcolors)\n    x2 = compose(x0, x1)\n    x3 = lbind(apply, shape)\n    x4 = chain(size, dedupe, x3)\n    x5 = matcher(x4, ONE)\n    x6 = compose(palette, first)\n    x7 = compose(palette, last)\n    x8 = fork(intersection, x6, x7)\n    x9 = compose(size, x8)\n    x10 = matcher(x9, ONE)\n    x11 = lbind(contained, ONE)\n    x12 = compose(minimum, shape)\n    x13 = lbind(apply, x12)\n    x14 = chain(flip, x11, x13)\n    x15 = fork(add, x2, x5)\n    x16 = fork(add, x10, x14)\n    x17 = fork(add, x15, x16)\n    x18 = vsplit(I, TWO)\n    x19 = hsplit(I, TWO)\n    x20 = astuple(x18, x19)\n    x21 = argmax(x20, x17)\n    x22 = argmin(x21, numcolors)\n    x23 = argmax(x21, numcolors)\n    x24 = palette(x22)\n    x25 = palette(x23)\n    x26 = intersection(x24, x25)\n    x27 = first(x26)\n    x28 = asindices(x22)\n    x29 = ofcolor(x22, x27)\n    x30 = difference(x28, x29)\n    x31 = asobject(x23)\n    x32 = matcher(first, x27)\n    x33 = sfilter(x31, x32)\n    x34 = difference(x31, x33)\n    x35 = shape(x22)\n    x36 = multiply(x35, x35)\n    x37 = canvas(x27, x36)\n    x38 = lbind(shift, x30)\n    x39 = lbind(multiply, x35)\n    x40 = chain(x38, x39, last)\n    x41 = fork(recolor, first, x40)\n    x42 = mapply(x41, x34)\n    x43 = paint(x37, x42)\n    return x43\n\n",
    "annotated": "def verify_b190f7f5(I: Grid) -> Grid:\n    # Create a function that checks if 2 is contained in the result\n    x0 = lbind(contained, TWO)\n    # Create a function that applies numcolors to each element\n    x1 = lbind(apply, numcolors)\n    # Compose x0 and x1: checks if any grid has exactly 2 colors\n    x2 = compose(x0, x1)\n    # Create a function that applies shape to each element\n    x3 = lbind(apply, shape)\n    # Chain size, dedupe, and x3: counts unique shapes in the grid\n    x4 = chain(size, dedupe, x3)\n    # Create a function that checks if x4 equals 1 (all grids have same shape)\n    x5 = matcher(x4, ONE)\n    # Get the palette of the first grid\n    x6 = compose(palette, first)\n    # Get the palette of the last grid\n    x7 = compose(palette, last)\n    # Find the intersection of palettes from first and last grids\n    x8 = fork(intersection, x6, x7)\n    # Count the number of colors in the intersection\n    x9 = compose(size, x8)\n    # Create a function that checks if x9 equals 1 (exactly one common color)\n    x10 = matcher(x9, ONE)\n    # Create a function that checks if 1 is contained in the result\n    x11 = lbind(contained, ONE)\n    # Get the minimum dimension (height or width) of a grid\n    x12 = compose(minimum, shape)\n    # Create a function that applies x12 to each element\n    x13 = lbind(apply, x12)\n    # Chain flip, x11, and x13: checks if any grid has a dimension greater than 1\n    x14 = chain(flip, x11, x13)\n    # Combine checks for 2 colors and same shape\n    x15 = fork(add, x2, x5)\n    # Combine checks for common color and dimensions > 1\n    x16 = fork(add, x10, x14)\n    # Combine all checks\n    x17 = fork(add, x15, x16)\n    # Split the input grid vertically into two parts\n    x18 = vsplit(I, TWO)\n    # Split the input grid horizontally into two parts\n    x19 = hsplit(I, TWO)\n    # Create a tuple of vertical and horizontal splits\n    x20 = astuple(x18, x19)\n    # Select the split (vertical or horizontal) that maximizes the checks\n    x21 = argmax(x20, x17)\n    # From the selected split, choose the grid with fewer colors (source grid)\n    x22 = argmin(x21, numcolors)\n    # From the selected split, choose the grid with more colors (target grid)\n    x23 = argmax(x21, numcolors)\n    # Get the palette of the source grid\n    x24 = palette(x22)\n    # Get the palette of the target grid\n    x25 = palette(x23)\n    # Find the common color between source and target grids\n    x26 = intersection(x24, x25)\n    # Get the first (and only) common color\n    x27 = first(x26)\n    # Get all indices of the source grid\n    x28 = asindices(x22)\n    # Get indices of cells with the common color in the source grid\n    x29 = ofcolor(x22, x27)\n    # Get indices of cells that are not the common color in the source grid\n    x30 = difference(x28, x29)\n    # Convert the target grid to an object representation\n    x31 = asobject(x23)\n    # Create a function to match cells with the common color\n    x32 = matcher(first, x27)\n    # Filter out cells with the common color from the target object\n    x33 = sfilter(x31, x32)\n    # Get cells that are not the common color in the target object\n    x34 = difference(x31, x33)\n    # Get the shape of the source grid\n    x35 = shape(x22)\n    # Calculate the shape of the output grid (square of source grid shape)\n    x36 = multiply(x35, x35)\n    # Create a canvas filled with the common color and output grid shape\n    x37 = canvas(x27, x36)\n    # Create a function to shift the source pattern\n    x38 = lbind(shift, x30)\n    # Create a function to scale the shift based on source grid shape\n    x39 = lbind(multiply, x35)\n    # Chain shift, scale, and get last element (position in target grid)\n    x40 = chain(x38, x39, last)\n    # Create a function to recolor and position cells from target to output\n    x41 = fork(recolor, first, x40)\n    # Apply the recolor and position function to non-common color cells\n    x42 = mapply(x41, x34)\n    # Paint the transformed cells onto the output canvas\n    x43 = paint(x37, x42)\n    # Return the final output grid\n    return x43\n"
  },
  "b1948b0a": {
    "original": "def verify_b1948b0a(I: Grid) -> Grid:\n    x0 = replace(I, SIX, TWO)\n    return x0\n\n",
    "annotated": "def verify_b1948b0a(I: Grid) -> Grid:\n    # Replace all occurrences of color 6 (light gray) with color 2 (red) in the input grid\n    # This effectively changes all light gray pixels to red, while leaving other colors unchanged\n    x0 = replace(I, SIX, TWO)\n    \n    # Return the modified grid\n    # The output grid will have all light gray pixels turned red, representing the solution\n    return x0\n"
  },
  "b230c067": {
    "original": "def verify_b230c067(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = lbind(sfilter, x0)\n    x2 = lbind(matcher, normalize)\n    x3 = compose(x2, normalize)\n    x4 = chain(size, x1, x3)\n    x5 = argmin(x0, x4)\n    x6 = remove(x5, x0)\n    x7 = merge(x6)\n    x8 = fill(I, TWO, x5)\n    x9 = fill(x8, ONE, x7)\n    return x9\n\n",
    "annotated": "def verify_b230c067(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including background and diagonally connected cells\n    x0 = objects(I, T, T, T)\n    \n    # Create a partially applied function that filters a set based on a condition\n    x1 = lbind(sfilter, x0)\n    \n    # Create a function that matches normalized shapes\n    x2 = lbind(matcher, normalize)\n    \n    # Compose functions to normalize and then match shapes\n    x3 = compose(x2, normalize)\n    \n    # Create a function that counts objects with the same normalized shape\n    x4 = chain(size, x1, x3)\n    \n    # Find the object with the least occurrences (unique shape)\n    x5 = argmin(x0, x4)\n    \n    # Remove the unique shape from the set of objects\n    x6 = remove(x5, x0)\n    \n    # Merge all remaining objects into a single set of cells\n    x7 = merge(x6)\n    \n    # Fill the unique shape with color 2 on the input grid\n    x8 = fill(I, TWO, x5)\n    \n    # Fill the remaining shapes with color 1 on the previous grid\n    x9 = fill(x8, ONE, x7)\n    \n    # Return the final grid with unique shape colored 2 and others colored 1\n    return x9\n"
  },
  "b27ca6d3": {
    "original": "def verify_b27ca6d3(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = sizefilter(x0, TWO)\n    x2 = mapply(outbox, x1)\n    x3 = fill(I, THREE, x2)\n    return x3\n\n",
    "annotated": "def verify_b27ca6d3(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and excluding the background color\n    x0 = objects(I, T, F, T)\n    \n    # Filter objects to keep only those with size 2 (dots)\n    x1 = sizefilter(x0, TWO)\n    \n    # For each dot, get its outbox (surrounding cells)\n    x2 = mapply(outbox, x1)\n    \n    # Fill the outboxes of all dots with color 3 on the input grid\n    # This effectively creates a border around each dot\n    x3 = fill(I, THREE, x2)\n    \n    # Return the modified grid with borders around dots\n    return x3\n"
  },
  "b2862040": {
    "original": "def verify_b2862040(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = mostcolor(I)\n    x2 = colorfilter(x0, x1)\n    x3 = rbind(bordering, I)\n    x4 = compose(flip, x3)\n    x5 = mfilter(x2, x4)\n    x6 = difference(x0, x2)\n    x7 = apply(toindices, x6)\n    x8 = rbind(adjacent, x5)\n    x9 = mfilter(x7, x8)\n    x10 = fill(I, EIGHT, x9)\n    return x10\n\n",
    "annotated": "def verify_b2862040(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Filter objects to keep only those with the background color\n    x2 = colorfilter(x0, x1)\n    \n    # Create a function to check if an object borders the grid edge\n    x3 = rbind(bordering, I)\n    \n    # Create a function that returns True if an object does NOT border the grid edge\n    x4 = compose(flip, x3)\n    \n    # Filter background objects to keep only those not bordering the grid edge\n    x5 = mfilter(x2, x4)\n    \n    # Get all non-background objects\n    x6 = difference(x0, x2)\n    \n    # Convert non-background objects to sets of indices\n    x7 = apply(toindices, x6)\n    \n    # Create a function to check if an object is adjacent to the filtered background objects\n    x8 = rbind(adjacent, x5)\n    \n    # Filter non-background objects to keep only those adjacent to the filtered background objects\n    x9 = mfilter(x7, x8)\n    \n    # Fill the selected non-background objects with color 8 (highlighting them)\n    x10 = fill(I, EIGHT, x9)\n    \n    # Return the modified grid with highlighted objects\n    return x10\n"
  },
  "b527c5c6": {
    "original": "def verify_b527c5c6(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = lbind(matcher, first)\n    x2 = compose(x1, leastcolor)\n    x3 = fork(sfilter, identity, x2)\n    x4 = compose(center, x3)\n    x5 = compose(dneighbors, x4)\n    x6 = fork(difference, x5, toindices)\n    x7 = compose(first, x6)\n    x8 = fork(subtract, x7, x4)\n    x9 = compose(invert, x8)\n    x10 = fork(shoot, x4, x9)\n    x11 = fork(intersection, toindices, x10)\n    x12 = chain(decrement, size, x11)\n    x13 = fork(shoot, x4, x8)\n    x14 = lbind(power, outbox)\n    x15 = compose(x14, x12)\n    x16 = compose(initset, x15)\n    x17 = fork(rapply, x16, x13)\n    x18 = chain(backdrop, first, x17)\n    x19 = fork(recolor, leastcolor, x13)\n    x20 = fork(difference, x18, x13)\n    x21 = fork(recolor, mostcolor, x20)\n    x22 = fork(combine, x19, x21)\n    x23 = mapply(x22, x0)\n    x24 = paint(I, x23)\n    return x24\n\n",
    "annotated": "def verify_b527c5c6(I: Grid) -> Grid:\n    # Get all objects from the input grid, considering background and allowing diagonal connections\n    x0 = objects(I, F, F, T)\n    \n    # Create a function that matches the first element of a tuple\n    x1 = lbind(matcher, first)\n    \n    # Create a function that finds the least common color in an object\n    x2 = compose(x1, leastcolor)\n    \n    # Create a function that filters objects based on their least common color\n    x3 = fork(sfilter, identity, x2)\n    \n    # Find the center of the filtered object (the dot)\n    x4 = compose(center, x3)\n    \n    # Get the direct neighbors of the center point\n    x5 = compose(dneighbors, x4)\n    \n    # Find the difference between the neighbors and the object indices (finds the direction of expansion)\n    x6 = fork(difference, x5, toindices)\n    \n    # Get the first element of the difference (the expansion direction)\n    x7 = compose(first, x6)\n    \n    # Calculate the vector from the center to the expansion direction\n    x8 = fork(subtract, x7, x4)\n    \n    # Invert the expansion vector (for the opposite direction)\n    x9 = compose(invert, x8)\n    \n    # Create a line from the center in the opposite direction of expansion\n    x10 = fork(shoot, x4, x9)\n    \n    # Find the intersection of the object and the line (to determine the length of the diagonal)\n    x11 = fork(intersection, toindices, x10)\n    \n    # Calculate the length of the diagonal minus one\n    x12 = chain(decrement, size, x11)\n    \n    # Create a line from the center in the direction of expansion\n    x13 = fork(shoot, x4, x8)\n    \n    # Create a function to generate multiple outboxes\n    x14 = lbind(power, outbox)\n    \n    # Generate the number of outboxes needed based on the diagonal length\n    x15 = compose(x14, x12)\n    \n    # Create an initial set with the outbox function\n    x16 = compose(initset, x15)\n    \n    # Apply the outbox function to the expansion line\n    x17 = fork(rapply, x16, x13)\n    \n    # Create a backdrop for the expanded object\n    x18 = chain(backdrop, first, x17)\n    \n    # Color the diagonal line with the least common color (dot color)\n    x19 = fork(recolor, leastcolor, x13)\n    \n    # Find the area to be filled with the most common color (square color)\n    x20 = fork(difference, x18, x13)\n    \n    # Color the expanded area with the most common color (square color)\n    x21 = fork(recolor, mostcolor, x20)\n    \n    # Combine the colored diagonal and the colored expanded area\n    x22 = fork(combine, x19, x21)\n    \n    # Apply the transformation to all objects in the grid\n    x23 = mapply(x22, x0)\n    \n    # Paint the transformed objects onto the input grid to create the output\n    x24 = paint(I, x23)\n    \n    # Return the final transformed grid\n    return x24\n"
  },
  "b548a754": {
    "original": "def verify_b548a754(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(equality, toindices, box)\n    x2 = fork(multiply, height, width)\n    x3 = fork(equality, size, x2)\n    x4 = compose(flip, x3)\n    x5 = fork(both, x1, x4)\n    x6 = extract(x0, x5)\n    x7 = inbox(x6)\n    x8 = backdrop(x7)\n    x9 = toobject(x8, I)\n    x10 = remove(x9, x0)\n    x11 = remove(x6, x10)\n    x12 = argmin(x11, size)\n    x13 = combine(x12, x6)\n    x14 = backdrop(x13)\n    x15 = color(x9)\n    x16 = fill(I, x15, x14)\n    x17 = color(x6)\n    x18 = box(x14)\n    x19 = fill(x16, x17, x18)\n    return x19\n\n",
    "annotated": "def verify_b548a754(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x1 = fork(equality, toindices, box)\n    \n    # Create a function that calculates the area of an object\n    x2 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its area\n    x3 = fork(equality, size, x2)\n    \n    # Invert the result of x3 (True becomes False, False becomes True)\n    x4 = compose(flip, x3)\n    \n    # Combine x1 and x4 checks with logical AND\n    x5 = fork(both, x1, x4)\n    \n    # Extract the object that satisfies x5 (likely the partial box)\n    x6 = extract(x0, x5)\n    \n    # Get the inner area of the extracted object\n    x7 = inbox(x6)\n    \n    # Get all cells in the bounding box of the inner area\n    x8 = backdrop(x7)\n    \n    # Create an object from x8 using colors from the input grid\n    x9 = toobject(x8, I)\n    \n    # Remove x9 from the partitioned objects\n    x10 = remove(x9, x0)\n    \n    # Remove the partial box from x10\n    x11 = remove(x6, x10)\n    \n    # Find the smallest object in x11 (likely the dot)\n    x12 = argmin(x11, size)\n    \n    # Combine the dot with the partial box\n    x13 = combine(x12, x6)\n    \n    # Get the bounding box of the combined object (full box)\n    x14 = backdrop(x13)\n    \n    # Get the color of the inner area\n    x15 = color(x9)\n    \n    # Fill the full box area with the inner color\n    x16 = fill(I, x15, x14)\n    \n    # Get the color of the partial box (outline color)\n    x17 = color(x6)\n    \n    # Get the outline of the full box\n    x18 = box(x14)\n    \n    # Draw the outline of the full box with the outline color\n    x19 = fill(x16, x17, x18)\n    \n    # Return the completed grid with the full box\n    return x19\n"
  },
  "b60334d2": {
    "original": "def verify_b60334d2(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = mostcolor(I)\n    x2 = ofcolor(I, x0)\n    x3 = replace(I, x0, x1)\n    x4 = mapply(dneighbors, x2)\n    x5 = mapply(ineighbors, x2)\n    x6 = fill(x3, ONE, x4)\n    x7 = fill(x6, x0, x5)\n    return x7\n\n",
    "annotated": "def verify_b60334d2(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Find the most common color in the input grid (foreground color)\n    x1 = mostcolor(I)\n    \n    # Get all indices of cells with the background color\n    x2 = ofcolor(I, x0)\n    \n    # Replace all background color cells with foreground color\n    # This effectively inverts the input grid\n    x3 = replace(I, x0, x1)\n    \n    # Find all directly adjacent neighbors for each background color cell\n    x4 = mapply(dneighbors, x2)\n    \n    # Find all diagonally adjacent neighbors for each background color cell\n    x5 = mapply(ineighbors, x2)\n    \n    # Fill the directly adjacent neighbors with color 1\n    # This creates a cross pattern around each original foreground cell\n    x6 = fill(x3, ONE, x4)\n    \n    # Fill the diagonally adjacent neighbors with the original background color\n    # This completes the pattern by filling the corners with the background color\n    x7 = fill(x6, x0, x5)\n    \n    # Return the final transformed grid\n    return x7\n"
  },
  "b6afb2da": {
    "original": "def verify_b6afb2da(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = compose(flip, x1)\n    x3 = extract(x0, x2)\n    x4 = color(x3)\n    x5 = matcher(color, x4)\n    x6 = compose(flip, x5)\n    x7 = sfilter(x0, x6)\n    x8 = merge(x7)\n    x9 = fill(I, TWO, x8)\n    x10 = mapply(box, x7)\n    x11 = fill(x9, FOUR, x10)\n    x12 = mapply(corners, x7)\n    x13 = fill(x11, ONE, x12)\n    return x13\n\n",
    "annotated": "def verify_b6afb2da(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that checks if an object's indices match its backdrop\n    x1 = fork(equality, toindices, backdrop)\n    \n    # Invert the result of x1 function\n    x2 = compose(flip, x1)\n    \n    # Find the first object that doesn't match its backdrop (likely the background)\n    x3 = extract(x0, x2)\n    \n    # Get the color of the extracted object (background color)\n    x4 = color(x3)\n    \n    # Create a function that matches colors to the background color\n    x5 = matcher(color, x4)\n    \n    # Invert the result of x5 function\n    x6 = compose(flip, x5)\n    \n    # Filter objects, keeping only those that are not the background color\n    x7 = sfilter(x0, x6)\n    \n    # Merge all non-background objects into a single set of indices\n    x8 = merge(x7)\n    \n    # Fill all non-background object areas with color 2 (body color)\n    x9 = fill(I, TWO, x8)\n    \n    # Get the box (outline) of each non-background object\n    x10 = mapply(box, x7)\n    \n    # Fill the outlines of all objects with color 4 (border color)\n    x11 = fill(x9, FOUR, x10)\n    \n    # Get the corner indices of each non-background object\n    x12 = mapply(corners, x7)\n    \n    # Fill the corners of all objects with color 1 (corner color)\n    x13 = fill(x11, ONE, x12)\n    \n    # Return the final transformed grid\n    return x13\n"
  },
  "b7249182": {
    "original": "def verify_b7249182(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = merge(x0)\n    x2 = portrait(x1)\n    x3 = branch(x2, identity, dmirror)\n    x4 = x3(I)\n    x5 = objects(x4, T, F, T)\n    x6 = order(x5, uppermost)\n    x7 = first(x6)\n    x8 = last(x6)\n    x9 = color(x7)\n    x10 = color(x8)\n    x11 = compose(first, toindices)\n    x12 = x11(x7)\n    x13 = x11(x8)\n    x14 = connect(x12, x13)\n    x15 = centerofmass(x14)\n    x16 = connect(x12, x15)\n    x17 = fill(x4, x10, x14)\n    x18 = fill(x17, x9, x16)\n    x19 = add(x15, DOWN)\n    x20 = initset(x15)\n    x21 = insert(x19, x20)\n    x22 = toobject(x21, x18)\n    x23 = astuple(ZERO, NEG_TWO)\n    x24 = shift(x22, ZERO_BY_TWO)\n    x25 = shift(x22, x23)\n    x26 = combine(x24, x25)\n    x27 = ulcorner(x26)\n    x28 = urcorner(x26)\n    x29 = connect(x27, x28)\n    x30 = shift(x29, UP)\n    x31 = llcorner(x26)\n    x32 = lrcorner(x26)\n    x33 = connect(x31, x32)\n    x34 = shift(x33, DOWN)\n    x35 = paint(x18, x26)\n    x36 = fill(x35, x9, x30)\n    x37 = fill(x36, x10, x34)\n    x38 = cover(x37, x21)\n    x39 = x3(x38)\n    return x39\n\n",
    "annotated": "def verify_b7249182(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Merge all extracted objects into a single object\n    x1 = merge(x0)\n    \n    # Check if the merged object is taller than it is wide\n    x2 = portrait(x1)\n    \n    # Create a function that either returns the identity or applies diagonal mirroring based on the portrait check\n    # This ensures the input is oriented correctly for further processing\n    x3 = branch(x2, identity, dmirror)\n    \n    # Apply the orientation function to the input grid\n    x4 = x3(I)\n    \n    # Extract objects from the oriented grid\n    x5 = objects(x4, T, F, T)\n    \n    # Sort the objects based on their uppermost position\n    x6 = order(x5, uppermost)\n    \n    # Get the topmost object (marker A)\n    x7 = first(x6)\n    \n    # Get the bottommost object (marker B)\n    x8 = last(x6)\n    \n    # Get the color of the topmost object (color A)\n    x9 = color(x7)\n    \n    # Get the color of the bottommost object (color B)\n    x10 = color(x8)\n    \n    # Create a function to get the first index of an object\n    x11 = compose(first, toindices)\n    \n    # Get the position of marker A\n    x12 = x11(x7)\n    \n    # Get the position of marker B\n    x13 = x11(x8)\n    \n    # Create a line connecting markers A and B\n    x14 = connect(x12, x13)\n    \n    # Find the center point of the connecting line\n    x15 = centerofmass(x14)\n    \n    # Create a line from marker A to the center point\n    x16 = connect(x12, x15)\n    \n    # Draw the full vertical line with color B\n    x17 = fill(x4, x10, x14)\n    \n    # Draw the half vertical line with color A\n    x18 = fill(x17, x9, x16)\n    \n    # Calculate the position just below the center point\n    x19 = add(x15, DOWN)\n    \n    # Create a set with the center point\n    x20 = initset(x15)\n    \n    # Add the point below the center to the set\n    x21 = insert(x19, x20)\n    \n    # Create an object from the two central points, using colors from the grid\n    x22 = toobject(x21, x18)\n    \n    # Define an offset of (0, -2)\n    x23 = astuple(ZERO, NEG_TWO)\n    \n    # Create a copy of the central object, shifted 2 units to the right\n    x24 = shift(x22, ZERO_BY_TWO)\n    \n    # Create another copy of the central object, shifted 2 units to the left\n    x25 = shift(x22, x23)\n    \n    # Combine the two shifted objects\n    x26 = combine(x24, x25)\n    \n    # Get the upper-left corner of the combined object\n    x27 = ulcorner(x26)\n    \n    # Get the upper-right corner of the combined object\n    x28 = urcorner(x26)\n    \n    # Create a line connecting the top corners\n    x29 = connect(x27, x28)\n    \n    # Shift the top line up by one unit\n    x30 = shift(x29, UP)\n    \n    # Get the lower-left corner of the combined object\n    x31 = llcorner(x26)\n    \n    # Get the lower-right corner of the combined object\n    x32 = lrcorner(x26)\n    \n    # Create a line connecting the bottom corners\n    x33 = connect(x31, x32)\n    \n    # Shift the bottom line down by one unit\n    x34 = shift(x33, DOWN)\n    \n    # Paint the combined object onto the grid\n    x35 = paint(x18, x26)\n    \n    # Draw the top horizontal line with color A\n    x36 = fill(x35, x9, x30)\n    \n    # Draw the bottom horizontal line with color B\n    x37 = fill(x36, x10, x34)\n    \n    # Remove the central points used for construction\n    x38 = cover(x37, x21)\n    \n    # Apply the orientation function to the final grid, potentially mirroring it back\n    x39 = x3(x38)\n    \n    # Return the final grid\n    return x39\n"
  },
  "b775ac94": {
    "original": "def verify_b775ac94(I: Grid) -> Grid:\n    x0 = objects(I, F, T, T)\n    x1 = neighbors(ORIGIN)\n    x2 = lbind(extract, x1)\n    x3 = matcher(first, ZERO)\n    x4 = matcher(last, ZERO)\n    x5 = rbind(branch, hmirror)\n    x6 = rbind(x5, identity)\n    x7 = rbind(branch, vmirror)\n    x8 = rbind(x7, identity)\n    x9 = compose(x6, x3)\n    x10 = compose(x8, x4)\n    x11 = fork(compose, x9, x10)\n    x12 = lbind(matcher, first)\n    x13 = compose(x12, mostcolor)\n    x14 = fork(sfilter, identity, x13)\n    x15 = fork(difference, identity, x14)\n    x16 = lbind(rbind, multiply)\n    x17 = chain(x16, shape, x14)\n    x18 = lbind(lbind, shift)\n    x19 = chain(x18, backdrop, x14)\n    x20 = fork(compose, x19, x17)\n    x21 = lbind(lbind, contained)\n    x22 = compose(x21, last)\n    x23 = rbind(compose, x22)\n    x24 = lbind(rbind, compose)\n    x25 = chain(x23, x24, x20)\n    x26 = lbind(fork, recolor)\n    x27 = lbind(x26, first)\n    x28 = lbind(fork, shift)\n    x29 = lbind(chain, x11)\n    x30 = lbind(x29, x2)\n    x31 = rbind(compose, x2)\n    x32 = compose(x31, x17)\n    x33 = fork(compose, x32, x25)\n    x34 = compose(x30, x25)\n    x35 = lbind(chain, first)\n    x36 = lbind(rbind, rapply)\n    x37 = compose(x36, x14)\n    x38 = lbind(compose, initset)\n    x39 = compose(x38, x34)\n    x40 = fork(x35, x37, x39)\n    x41 = compose(x27, x40)\n    x42 = fork(x28, x41, x33)\n    x43 = fork(mapply, x42, x15)\n    x44 = mapply(x43, x0)\n    x45 = paint(I, x44)\n    return x45\n\n",
    "annotated": "def verify_b775ac94(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including background and diagonally connected\n    x0 = objects(I, F, T, T)\n    # Get the neighboring cells of the origin (0,0)\n    x1 = neighbors(ORIGIN)\n    # Create a function to extract a specific neighbor from a set of neighbors\n    x2 = lbind(extract, x1)\n    # Create a function to check if the first element of a tuple is 0\n    x3 = matcher(first, ZERO)\n    # Create a function to check if the last element of a tuple is 0\n    x4 = matcher(last, ZERO)\n    # Create a function that branches between horizontal mirroring and identity based on a condition\n    x5 = rbind(branch, hmirror)\n    x6 = rbind(x5, identity)\n    # Create a function that branches between vertical mirroring and identity based on a condition\n    x7 = rbind(branch, vmirror)\n    x8 = rbind(x7, identity)\n    # Compose functions to determine horizontal mirroring based on first element\n    x9 = compose(x6, x3)\n    # Compose functions to determine vertical mirroring based on last element\n    x10 = compose(x8, x4)\n    # Create a function that combines horizontal and vertical mirroring decisions\n    x11 = fork(compose, x9, x10)\n    # Create a function to match the first element of a tuple\n    x12 = lbind(matcher, first)\n    # Create a function to match the most common color\n    x13 = compose(x12, mostcolor)\n    # Create a function to filter elements with the most common color\n    x14 = fork(sfilter, identity, x13)\n    # Create a function to get elements that are not the most common color\n    x15 = fork(difference, identity, x14)\n    # Prepare a function to multiply shapes\n    x16 = lbind(rbind, multiply)\n    # Create a function to get the shape of non-background elements\n    x17 = chain(x16, shape, x14)\n    # Prepare a function to shift elements\n    x18 = lbind(lbind, shift)\n    # Create a function to get the backdrop of non-background elements\n    x19 = chain(x18, backdrop, x14)\n    # Combine shape and backdrop functions\n    x20 = fork(compose, x19, x17)\n    # Prepare a function to check if an element is contained\n    x21 = lbind(lbind, contained)\n    # Create a function to check if the last element is contained\n    x22 = compose(x21, last)\n    # Prepare a function to compose with the containment check\n    x23 = rbind(compose, x22)\n    # Prepare a function for right-side composition\n    x24 = lbind(rbind, compose)\n    # Create a complex function for checking valid positions\n    x25 = chain(x23, x24, x20)\n    # Prepare a function for recoloring\n    x26 = lbind(fork, recolor)\n    x27 = lbind(x26, first)\n    # Prepare a function for shifting\n    x28 = lbind(fork, shift)\n    # Create functions for determining object transformations\n    x29 = lbind(chain, x11)\n    x30 = lbind(x29, x2)\n    x31 = rbind(compose, x2)\n    x32 = compose(x31, x17)\n    # Create a function to determine valid positions for transformed objects\n    x33 = fork(compose, x32, x25)\n    # Create a function to determine object transformations based on valid positions\n    x34 = compose(x30, x25)\n    # Prepare functions for applying transformations\n    x35 = lbind(chain, first)\n    x36 = lbind(rbind, rapply)\n    x37 = compose(x36, x14)\n    x38 = lbind(compose, initset)\n    x39 = compose(x38, x34)\n    # Create a function to apply transformations to objects\n    x40 = fork(x35, x37, x39)\n    # Create a function to recolor transformed objects\n    x41 = compose(x27, x40)\n    # Create a function to shift and transform objects\n    x42 = fork(x28, x41, x33)\n    # Create a function to apply transformations to non-background objects\n    x43 = fork(mapply, x42, x15)\n    # Apply all transformations to the extracted objects\n    x44 = mapply(x43, x0)\n    # Paint the transformed objects onto the input grid to create the output\n    x45 = paint(I, x44)\n    return x45\n"
  },
  "b782dc8a": {
    "original": "def verify_b782dc8a(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = lbind(colorcount, I)\n    x4 = argmin(x2, x3)\n    x5 = ofcolor(I, x0)\n    x6 = ofcolor(I, x4)\n    x7 = combine(x5, x6)\n    x8 = mapply(neighbors, x7)\n    x9 = difference(x8, x7)\n    x10 = toobject(x9, I)\n    x11 = leastcolor(x10)\n    x12 = ofcolor(I, x0)\n    x13 = first(x12)\n    x14 = initset(x13)\n    x15 = objects(I, T, F, F)\n    x16 = colorfilter(x15, x11)\n    x17 = lbind(adjacent, x7)\n    x18 = mfilter(x16, x17)\n    x19 = toindices(x18)\n    x20 = rbind(manhattan, x14)\n    x21 = chain(even, x20, initset)\n    x22 = sfilter(x19, x21)\n    x23 = fill(I, x4, x19)\n    x24 = fill(x23, x0, x22)\n    return x24\n\n",
    "annotated": "def verify_b782dc8a(I: Grid) -> Grid:\n    # Find the least common color in the input grid (likely the dot color)\n    x0 = leastcolor(I)\n    # Get all unique colors used in the input grid\n    x1 = palette(I)\n    # Remove the least common color from the palette\n    x2 = remove(x0, x1)\n    # Create a function that counts occurrences of a color in the input grid\n    x3 = lbind(colorcount, I)\n    # Find the color with the least occurrences among the remaining colors (likely the number color)\n    x4 = argmin(x2, x3)\n    # Get all cells with the least common color (dot cells)\n    x5 = ofcolor(I, x0)\n    # Get all cells with the second least common color (number cells)\n    x6 = ofcolor(I, x4)\n    # Combine dot and number cells\n    x7 = combine(x5, x6)\n    # Get all neighbors of dot and number cells\n    x8 = mapply(neighbors, x7)\n    # Find cells that are neighbors but not dot or number cells (path cells)\n    x9 = difference(x8, x7)\n    # Create an object from the path cells\n    x10 = toobject(x9, I)\n    # Find the most common color in the path cells (wall color)\n    x11 = leastcolor(x10)\n    # Get all dot cells again\n    x12 = ofcolor(I, x0)\n    # Get the first dot cell\n    x13 = first(x12)\n    # Create a set with only the first dot cell\n    x14 = initset(x13)\n    # Identify all objects in the input grid\n    x15 = objects(I, T, F, F)\n    # Filter objects to keep only those with the wall color\n    x16 = colorfilter(x15, x11)\n    # Create a function to check if an object is adjacent to dot or number cells\n    x17 = lbind(adjacent, x7)\n    # Filter and merge wall objects that are adjacent to dot or number cells\n    x18 = mfilter(x16, x17)\n    # Convert the filtered wall objects to indices\n    x19 = toindices(x18)\n    # Create a function to calculate Manhattan distance from the first dot cell\n    x20 = rbind(manhattan, x14)\n    # Create a function to check if a cell has even Manhattan distance from the first dot\n    x21 = chain(even, x20, initset)\n    # Filter cells with even Manhattan distance from the first dot\n    x22 = sfilter(x19, x21)\n    # Fill all path cells with the number color\n    x23 = fill(I, x4, x19)\n    # Fill cells with even Manhattan distance with the dot color\n    x24 = fill(x23, x0, x22)\n    # Return the final grid with the maze solution\n    return x24\n"
  },
  "b8825c91": {
    "original": "def verify_b8825c91(I: Grid) -> Grid:\n    x0 = replace(I, FOUR, NEG_ONE)\n    x1 = dmirror(x0)\n    x2 = papply(pair, x0, x1)\n    x3 = lbind(apply, maximum)\n    x4 = apply(x3, x2)\n    x5 = cmirror(x4)\n    x6 = papply(pair, x4, x5)\n    x7 = apply(x3, x6)\n    x8 = hmirror(x7)\n    x9 = papply(pair, x7, x8)\n    x10 = apply(x3, x9)\n    x11 = vmirror(x10)\n    x12 = papply(pair, x11, x10)\n    x13 = apply(x3, x12)\n    return x13\n\n",
    "annotated": "def verify_b8825c91(I: Grid) -> Grid:\n    # Replace all occurrences of 4 with -1 in the input grid\n    # This effectively removes the rectangles added in the corners\n    x0 = replace(I, FOUR, NEG_ONE)\n\n    # Mirror the grid diagonally\n    x1 = dmirror(x0)\n\n    # Pair each cell of the original grid with its diagonally mirrored counterpart\n    x2 = papply(pair, x0, x1)\n\n    # Create a function that applies the 'maximum' function to each pair\n    x3 = lbind(apply, maximum)\n\n    # Apply the maximum function to each pair, effectively keeping the upper triangle of the symmetric pattern\n    x4 = apply(x3, x2)\n\n    # Mirror the resulting grid along the counter-diagonal\n    x5 = cmirror(x4)\n\n    # Pair each cell with its counter-diagonally mirrored counterpart\n    x6 = papply(pair, x4, x5)\n\n    # Apply the maximum function again, completing the symmetry in the upper-right quadrant\n    x7 = apply(x3, x6)\n\n    # Mirror the grid horizontally\n    x8 = hmirror(x7)\n\n    # Pair each cell with its horizontally mirrored counterpart\n    x9 = papply(pair, x7, x8)\n\n    # Apply the maximum function, completing the symmetry in the right half of the grid\n    x10 = apply(x3, x9)\n\n    # Mirror the grid vertically\n    x11 = vmirror(x10)\n\n    # Pair each cell with its vertically mirrored counterpart\n    x12 = papply(pair, x11, x10)\n\n    # Apply the maximum function one last time, completing the symmetry for the entire grid\n    # This results in a fully symmetric pattern that matches the original input, minus the corner rectangles\n    x13 = apply(x3, x12)\n\n    # Return the final symmetric grid\n    return x13\n"
  },
  "b8cdaf2b": {
    "original": "def verify_b8cdaf2b(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = astuple(dmirror, cmirror)\n    x2 = astuple(hmirror, identity)\n    x3 = combine(x1, x2)\n    x4 = rbind(rapply, I)\n    x5 = chain(first, x4, initset)\n    x6 = rbind(ofcolor, x0)\n    x7 = chain(lowermost, x6, x5)\n    x8 = chain(decrement, height, x5)\n    x9 = fork(equality, x7, x8)\n    x10 = extract(x3, x9)\n    x11 = x10(I)\n    x12 = ofcolor(x11, x0)\n    x13 = shift(x12, UP)\n    x14 = ulcorner(x13)\n    x15 = urcorner(x13)\n    x16 = shoot(x14, NEG_UNITY)\n    x17 = shoot(x15, UP_RIGHT)\n    x18 = combine(x16, x17)\n    x19 = underfill(x11, x0, x18)\n    x20 = x10(x19)\n    return x20\n\n",
    "annotated": "def verify_b8cdaf2b(I: Grid) -> Grid:\n    # Find the least common color in the input grid (likely the dot color)\n    x0 = leastcolor(I)\n    \n    # Create a tuple of diagonal mirror functions\n    x1 = astuple(dmirror, cmirror)\n    \n    # Create a tuple with horizontal mirror and identity functions\n    x2 = astuple(hmirror, identity)\n    \n    # Combine all mirror functions into a single tuple\n    x3 = combine(x1, x2)\n    \n    # Create a function that applies all mirror functions to the input grid\n    x4 = rbind(rapply, I)\n    \n    # Create a function chain to get the first mirrored grid\n    x5 = chain(first, x4, initset)\n    \n    # Create a function to find cells of the least common color\n    x6 = rbind(ofcolor, x0)\n    \n    # Find the lowest row containing the least common color in the first mirrored grid\n    x7 = chain(lowermost, x6, x5)\n    \n    # Get the height of the first mirrored grid minus one\n    x8 = chain(decrement, height, x5)\n    \n    # Check if the lowest row with least common color is at the bottom of the grid\n    x9 = fork(equality, x7, x8)\n    \n    # Find the correct mirror function that puts the dots at the bottom\n    x10 = extract(x3, x9)\n    \n    # Apply the correct mirror function to the input grid\n    x11 = x10(I)\n    \n    # Find all cells with the least common color (dots) in the mirrored grid\n    x12 = ofcolor(x11, x0)\n    \n    # Shift the dot positions up by one row\n    x13 = shift(x12, UP)\n    \n    # Find the upper-left corner of the shifted dots\n    x14 = ulcorner(x13)\n    \n    # Find the upper-right corner of the shifted dots\n    x15 = urcorner(x13)\n    \n    # Create a diagonal line from the upper-left corner towards top-left\n    x16 = shoot(x14, NEG_UNITY)\n    \n    # Create a diagonal line from the upper-right corner towards top-right\n    x17 = shoot(x15, UP_RIGHT)\n    \n    # Combine both diagonal lines\n    x18 = combine(x16, x17)\n    \n    # Fill the area between the diagonal lines with the least common color (dots)\n    x19 = underfill(x11, x0, x18)\n    \n    # Apply the inverse mirror function to get the final output grid\n    x20 = x10(x19)\n    \n    return x20\n"
  },
  "b91ae062": {
    "original": "def verify_b91ae062(I: Grid) -> Grid:\n    x0 = numcolors(I)\n    x1 = decrement(x0)\n    x2 = upscale(I, x1)\n    return x2\n\n",
    "annotated": "def verify_b91ae062(I: Grid) -> Grid:\n    # Count the number of unique colors in the input grid\n    # This determines the upscaling factor\n    x0 = numcolors(I)\n    \n    # Decrease the color count by 1\n    # This gives us the actual upscaling factor to use\n    x1 = decrement(x0)\n    \n    # Upscale the input grid by the factor (number of colors - 1)\n    # Each cell in the input grid becomes an x1 x x1 block in the output\n    x2 = upscale(I, x1)\n    \n    # Return the upscaled grid as the output\n    # The output grid is larger than the input, with each cell expanded\n    return x2\n"
  },
  "b94a9452": {
    "original": "def verify_b94a9452(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = remove(x2, x0)\n    x4 = merge(x3)\n    x5 = subgrid(x4, I)\n    x6 = mostcolor(x5)\n    x7 = leastcolor(x5)\n    x8 = switch(x5, x6, x7)\n    return x8\n\n",
    "annotated": "def verify_b94a9452(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    \n    # Find the largest object (in terms of area) from the partitioned objects\n    x2 = argmax(x0, x1)\n    \n    # Remove the largest object from the set of partitioned objects\n    x3 = remove(x2, x0)\n    \n    # Merge the remaining objects into a single set of cells\n    x4 = merge(x3)\n    \n    # Extract the subgrid from the input that corresponds to the merged objects\n    # This effectively isolates the inner rectangle\n    x5 = subgrid(x4, I)\n    \n    # Find the most common color in the subgrid (color of the outer rectangle)\n    x6 = mostcolor(x5)\n    \n    # Find the least common color in the subgrid (color of the inner rectangle)\n    x7 = leastcolor(x5)\n    \n    # Switch the colors of the outer and inner rectangles in the subgrid\n    # This is the final transformation required by the puzzle\n    x8 = switch(x5, x6, x7)\n    \n    # Return the transformed subgrid as the solution\n    return x8\n"
  },
  "b9b7f026": {
    "original": "def verify_b9b7f026(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = compose(flip, x1)\n    x3 = extract(x0, x2)\n    x4 = color(x3)\n    x5 = canvas(x4, UNITY)\n    return x5\n\n",
    "annotated": "def verify_b9b7f026(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Create a function that checks if an object's indices are equal to its backdrop\n    # This identifies objects that are rectangular and filled\n    x1 = fork(equality, toindices, backdrop)\n    \n    # Invert the boolean result of x1\n    # This will be True for objects that have an inner empty space\n    x2 = compose(flip, x1)\n    \n    # Extract the object from x0 that satisfies the condition in x2\n    # This finds the object with an inner empty space\n    x3 = extract(x0, x2)\n    \n    # Get the color of the extracted object\n    x4 = color(x3)\n    \n    # Create a 1x1 grid (canvas) with the color obtained in x4\n    x5 = canvas(x4, UNITY)\n    \n    # Return the 1x1 grid as the output\n    return x5\n"
  },
  "ba26e723": {
    "original": "def verify_ba26e723(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = matcher(first, ZERO)\n    x2 = compose(flip, x1)\n    x3 = sfilter(x0, x2)\n    x4 = rbind(multiply, THREE)\n    x5 = rbind(divide, THREE)\n    x6 = compose(x4, x5)\n    x7 = fork(equality, identity, x6)\n    x8 = toindices(x3)\n    x9 = compose(x7, last)\n    x10 = sfilter(x8, x9)\n    x11 = fill(I, SIX, x10)\n    return x11\n\n",
    "annotated": "def verify_ba26e723(I: Grid) -> Grid:\n    # Convert the input grid to an object (set of colored cells)\n    x0 = asobject(I)\n    \n    # Create a function that checks if the first element (color) of a cell is zero\n    x1 = matcher(first, ZERO)\n    \n    # Create a function that checks if the first element (color) of a cell is non-zero\n    x2 = compose(flip, x1)\n    \n    # Filter the grid object to keep only non-zero colored cells\n    x3 = sfilter(x0, x2)\n    \n    # Create a function that multiplies its input by 3\n    x4 = rbind(multiply, THREE)\n    \n    # Create a function that divides its input by 3\n    x5 = rbind(divide, THREE)\n    \n    # Compose the multiply-by-3 and divide-by-3 functions (effectively checking if a number is divisible by 3)\n    x6 = compose(x4, x5)\n    \n    # Create a function that checks if a value is equal to its rounded division by 3\n    # This effectively checks if the column index is divisible by 3\n    x7 = fork(equality, identity, x6)\n    \n    # Extract the indices of all non-zero colored cells\n    x8 = toindices(x3)\n    \n    # Create a function that checks if the column index (last element of a cell's position) is divisible by 3\n    x9 = compose(x7, last)\n    \n    # Filter the indices to keep only those in columns divisible by 3\n    x10 = sfilter(x8, x9)\n    \n    # Fill the cells in columns divisible by 3 with color 6 (SIX)\n    # This creates the output grid by modifying the input grid\n    x11 = fill(I, SIX, x10)\n    \n    # Return the modified grid as the output\n    return x11\n"
  },
  "ba97ae07": {
    "original": "def verify_ba97ae07(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = mostcommon(x2)\n    x4 = ofcolor(I, x3)\n    x5 = backdrop(x4)\n    x6 = fill(I, x3, x5)\n    return x6\n\n",
    "annotated": "def verify_ba97ae07(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    \n    # Extract the color of each object\n    x2 = apply(color, x1)\n    \n    # Find the most common color among the objects (this will be the color of the lines)\n    x3 = mostcommon(x2)\n    \n    # Get all cells in the input grid that have the most common color (i.e., the lines)\n    x4 = ofcolor(I, x3)\n    \n    # Create a bounding box that encompasses all the cells of the most common color\n    x5 = backdrop(x4)\n    \n    # Fill the entire bounding box with the most common color\n    # This effectively \"completes\" the grid by filling in the gaps between the lines\n    x6 = fill(I, x3, x5)\n    \n    # Return the modified grid\n    # The result is a grid where the area enclosed by the lines is completely filled\n    return x6\n"
  },
  "bb43febb": {
    "original": "def verify_bb43febb(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(equality, toindices, backdrop)\n    x2 = rbind(greater, ONE)\n    x3 = chain(x2, minimum, shape)\n    x4 = fork(both, x1, x3)\n    x5 = sfilter(x0, x4)\n    x6 = compose(backdrop, inbox)\n    x7 = mapply(x6, x5)\n    x8 = fill(I, TWO, x7)\n    return x8\n\n",
    "annotated": "def verify_bb43febb(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonally adjacent cells as part of the same object\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that checks if an object's indices are equal to its backdrop (i.e., if it's a solid rectangle)\n    x1 = fork(equality, toindices, backdrop)\n    \n    # Create a function that checks if a value is greater than 1\n    x2 = rbind(greater, ONE)\n    \n    # Create a function that checks if the minimum dimension (height or width) of an object is greater than 1\n    x3 = chain(x2, minimum, shape)\n    \n    # Combine the two conditions: object is a solid rectangle and has minimum dimension > 1\n    x4 = fork(both, x1, x3)\n    \n    # Filter objects that satisfy both conditions (solid rectangles with min dimension > 1)\n    x5 = sfilter(x0, x4)\n    \n    # Create a function that gets the inner area of an object (excluding its border)\n    x6 = compose(backdrop, inbox)\n    \n    # Apply the inner area function to all filtered objects and merge the results\n    x7 = mapply(x6, x5)\n    \n    # Fill the inner areas of all valid objects with color 2 (keeping the borders unchanged)\n    x8 = fill(I, TWO, x7)\n    \n    # Return the modified grid\n    return x8\n\n# In essence, this verifier identifies rectangular objects in the input grid,\n# fills their inner areas with color 2 while preserving their borders,\n# effectively solving the puzzle described in the generator function.\n"
  },
  "bbc9ae5d": {
    "original": "def verify_bbc9ae5d(I: Grid) -> Grid:\n    x0 = index(I, ORIGIN)\n    x1 = width(I)\n    x2 = halve(x1)\n    x3 = astuple(x2, x1)\n    x4 = canvas(x0, x3)\n    x5 = rbind(shoot, UNITY)\n    x6 = compose(x5, last)\n    x7 = fork(recolor, first, x6)\n    x8 = asobject(I)\n    x9 = mapply(x7, x8)\n    x10 = paint(x4, x9)\n    return x10\n\n",
    "annotated": "def verify_bbc9ae5d(I: Grid) -> Grid:\n    # Get the color of the top-left cell in the input grid\n    x0 = index(I, ORIGIN)\n    \n    # Get the width of the input grid\n    x1 = width(I)\n    \n    # Calculate half of the input grid's width\n    x2 = halve(x1)\n    \n    # Create a tuple (half_width, full_width) for the output grid dimensions\n    x3 = astuple(x2, x1)\n    \n    # Create a blank canvas for the output grid with dimensions (half_width, full_width)\n    # and fill it with the color of the top-left cell from the input\n    x4 = canvas(x0, x3)\n    \n    # Create a function that shoots a line in the (1,1) direction\n    x5 = rbind(shoot, UNITY)\n    \n    # Create a function that gets the last element (rightmost cell) of a row\n    x6 = compose(x5, last)\n    \n    # Create a function that takes a cell from the input, extracts its color and position,\n    # and creates a diagonal line starting from that position\n    x7 = fork(recolor, first, x6)\n    \n    # Convert the input grid to an object (set of colored cells)\n    x8 = asobject(I)\n    \n    # Apply the diagonal line function to each cell in the input object\n    # This creates a set of diagonal lines, one for each colored cell in the input\n    x9 = mapply(x7, x8)\n    \n    # Paint the diagonal lines onto the output canvas\n    # This creates the final output grid with diagonal lines corresponding to input colors\n    x10 = paint(x4, x9)\n    \n    return x10\n"
  },
  "bc1d5164": {
    "original": "def verify_bc1d5164(I: Grid) -> Grid:\n    x0 = height(I)\n    x1 = halve(x0)\n    x2 = increment(x1)\n    x3 = width(I)\n    x4 = halve(x3)\n    x5 = frontiers(I)\n    x6 = merge(x5)\n    x7 = mostcolor(x6)\n    x8 = astuple(x2, x4)\n    x9 = canvas(x7, x8)\n    x10 = asindices(x9)\n    x11 = toobject(x10, I)\n    x12 = increment(x4)\n    x13 = tojvec(x12)\n    x14 = shift(x10, x13)\n    x15 = toobject(x14, I)\n    x16 = decrement(x2)\n    x17 = toivec(x16)\n    x18 = shift(x10, x17)\n    x19 = toobject(x18, I)\n    x20 = decrement(x2)\n    x21 = increment(x4)\n    x22 = astuple(x20, x21)\n    x23 = shift(x10, x22)\n    x24 = toobject(x23, I)\n    x25 = palette(I)\n    x26 = other(x25, x7)\n    x27 = matcher(first, x26)\n    x28 = rbind(sfilter, x27)\n    x29 = chain(toindices, x28, normalize)\n    x30 = x29(x11)\n    x31 = x29(x15)\n    x32 = x29(x19)\n    x33 = x29(x24)\n    x34 = combine(x30, x31)\n    x35 = combine(x32, x33)\n    x36 = combine(x34, x35)\n    x37 = fill(x9, x26, x36)\n    return x37\n\n",
    "annotated": "def verify_bc1d5164(I: Grid) -> Grid:\n    # Get the height of the input grid\n    x0 = height(I)\n    \n    # Calculate half of the input grid's height\n    x1 = halve(x0)\n    \n    # Increment the halved height by 1 (this will be the output grid's height)\n    x2 = increment(x1)\n    \n    # Get the width of the input grid\n    x3 = width(I)\n    \n    # Calculate half of the input grid's width (this will be the output grid's width)\n    x4 = halve(x3)\n    \n    # Find all frontiers (rows or columns with the same color) in the input grid\n    x5 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x6 = merge(x5)\n    \n    # Find the most common color in the merged frontiers (this is the background color)\n    x7 = mostcolor(x6)\n    \n    # Create a tuple with the output grid's dimensions\n    x8 = astuple(x2, x4)\n    \n    # Create a canvas (empty grid) with the background color and output dimensions\n    x9 = canvas(x7, x8)\n    \n    # Get all indices of the output grid\n    x10 = asindices(x9)\n    \n    # Create an object from the top-left quadrant of the input grid\n    x11 = toobject(x10, I)\n    \n    # Calculate the horizontal shift for the top-right quadrant\n    x12 = increment(x4)\n    x13 = tojvec(x12)\n    \n    # Shift the indices to the top-right quadrant\n    x14 = shift(x10, x13)\n    \n    # Create an object from the top-right quadrant of the input grid\n    x15 = toobject(x14, I)\n    \n    # Calculate the vertical shift for the bottom-left quadrant\n    x16 = decrement(x2)\n    x17 = toivec(x16)\n    \n    # Shift the indices to the bottom-left quadrant\n    x18 = shift(x10, x17)\n    \n    # Create an object from the bottom-left quadrant of the input grid\n    x19 = toobject(x18, I)\n    \n    # Calculate the shift for the bottom-right quadrant\n    x20 = decrement(x2)\n    x21 = increment(x4)\n    x22 = astuple(x20, x21)\n    \n    # Shift the indices to the bottom-right quadrant\n    x23 = shift(x10, x22)\n    \n    # Create an object from the bottom-right quadrant of the input grid\n    x24 = toobject(x23, I)\n    \n    # Get all colors used in the input grid\n    x25 = palette(I)\n    \n    # Find the color that is not the background color (object color)\n    x26 = other(x25, x7)\n    \n    # Create a function to match the object color\n    x27 = matcher(first, x26)\n    \n    # Create a function to filter objects by the object color\n    x28 = rbind(sfilter, x27)\n    \n    # Create a function to normalize, filter by color, and get indices of objects\n    x29 = chain(toindices, x28, normalize)\n    \n    # Apply the function to each quadrant object\n    x30 = x29(x11)  # Top-left\n    x31 = x29(x15)  # Top-right\n    x32 = x29(x19)  # Bottom-left\n    x33 = x29(x24)  # Bottom-right\n    \n    # Combine the filtered indices from all quadrants\n    x34 = combine(x30, x31)\n    x35 = combine(x32, x33)\n    x36 = combine(x34, x35)\n    \n    # Fill the output grid with the object color at the combined indices\n    x37 = fill(x9, x26, x36)\n    \n    # Return the final output grid\n    return x37\n"
  },
  "bd4472b8": {
    "original": "def verify_bd4472b8(I: Grid) -> Grid:\n    x0 = compose(positive, size)\n    x1 = rbind(sfilter, hline)\n    x2 = chain(x0, x1, frontiers)\n    x3 = chain(size, dedupe, first)\n    x4 = chain(size, dedupe, last)\n    x5 = fork(greater, x3, x4)\n    x6 = fork(both, x2, x5)\n    x7 = astuple(identity, rot90)\n    x8 = astuple(rot180, rot270)\n    x9 = combine(x7, x8)\n    x10 = astuple(identity, rot270)\n    x11 = astuple(rot180, rot90)\n    x12 = combine(x10, x11)\n    x13 = pair(x9, x12)\n    x14 = rbind(rapply, I)\n    x15 = compose(initset, first)\n    x16 = chain(first, x14, x15)\n    x17 = compose(x6, x16)\n    x18 = extract(x13, x17)\n    x19 = first(x18)\n    x20 = last(x18)\n    x21 = x19(I)\n    x22 = first(x21)\n    x23 = repeat(x22, ONE)\n    x24 = dmirror(x23)\n    x25 = width(x21)\n    x26 = hupscale(x24, x25)\n    x27 = asobject(x26)\n    x28 = height(x21)\n    x29 = height(x27)\n    x30 = interval(ZERO, x28, x29)\n    x31 = lbind(shift, x27)\n    x32 = apply(toivec, x30)\n    x33 = mapply(x31, x32)\n    x34 = shift(x33, TWO_BY_ZERO)\n    x35 = paint(x21, x34)\n    x36 = x20(x35)\n    return x36\n\n",
    "annotated": "def verify_bd4472b8(I: Grid) -> Grid:\n    # Create a function that checks if the size of something is positive\n    x0 = compose(positive, size)\n    \n    # Create a function that filters horizontal lines\n    x1 = rbind(sfilter, hline)\n    \n    # Create a function chain: find frontiers, filter horizontal lines, check if size is positive\n    x2 = chain(x0, x1, frontiers)\n    \n    # Create a function chain: get first element, remove duplicates, get size\n    x3 = chain(size, dedupe, first)\n    \n    # Create a function chain: get last element, remove duplicates, get size\n    x4 = chain(size, dedupe, last)\n    \n    # Create a function that checks if x3 is greater than x4\n    x5 = fork(greater, x3, x4)\n    \n    # Create a function that checks if both x2 and x5 are true\n    x6 = fork(both, x2, x5)\n    \n    # Create a tuple of identity and 90-degree rotation functions\n    x7 = astuple(identity, rot90)\n    \n    # Create a tuple of 180-degree and 270-degree rotation functions\n    x8 = astuple(rot180, rot270)\n    \n    # Combine x7 and x8 into a single tuple\n    x9 = combine(x7, x8)\n    \n    # Create a tuple of identity and 270-degree rotation functions\n    x10 = astuple(identity, rot270)\n    \n    # Create a tuple of 180-degree and 90-degree rotation functions\n    x11 = astuple(rot180, rot90)\n    \n    # Combine x10 and x11 into a single tuple\n    x12 = combine(x10, x11)\n    \n    # Pair x9 and x12 into a tuple of tuples\n    x13 = pair(x9, x12)\n    \n    # Create a function that applies the input grid I to a function\n    x14 = rbind(rapply, I)\n    \n    # Create a function that initializes a set with the first element\n    x15 = compose(initset, first)\n    \n    # Create a function chain: get first element, apply x14, then x15\n    x16 = chain(first, x14, x15)\n    \n    # Compose x6 and x16 into a single function\n    x17 = compose(x6, x16)\n    \n    # Extract the first element from x13 that satisfies x17\n    x18 = extract(x13, x17)\n    \n    # Get the first element of x18 (a rotation function)\n    x19 = first(x18)\n    \n    # Get the last element of x18 (inverse rotation function)\n    x20 = last(x18)\n    \n    # Apply the rotation function x19 to the input grid I\n    x21 = x19(I)\n    \n    # Get the first row of the rotated grid\n    x22 = first(x21)\n    \n    # Create a tuple with x22 repeated once\n    x23 = repeat(x22, ONE)\n    \n    # Mirror x23 diagonally\n    x24 = dmirror(x23)\n    \n    # Get the width of the rotated grid\n    x25 = width(x21)\n    \n    # Upscale x24 horizontally by the width of the rotated grid\n    x26 = hupscale(x24, x25)\n    \n    # Convert x26 to an object representation\n    x27 = asobject(x26)\n    \n    # Get the height of the rotated grid\n    x28 = height(x21)\n    \n    # Get the height of the pattern object\n    x29 = height(x27)\n    \n    # Create an interval from 0 to x28 with step x29\n    x30 = interval(ZERO, x28, x29)\n    \n    # Create a function that shifts x27\n    x31 = lbind(shift, x27)\n    \n    # Convert x30 to a list of vertical vectors\n    x32 = apply(toivec, x30)\n    \n    # Apply x31 to x32, creating multiple shifted versions of the pattern\n    x33 = mapply(x31, x32)\n    \n    # Shift x33 down by 2 rows\n    x34 = shift(x33, TWO_BY_ZERO)\n    \n    # Paint x34 onto the rotated grid x21\n    x35 = paint(x21, x34)\n    \n    # Apply the inverse rotation function to x35\n    x36 = x20(x35)\n    \n    # Return the final transformed grid\n    return x36\n"
  },
  "bda2d7a6": {
    "original": "def verify_bda2d7a6(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = compose(maximum, shape)\n    x2 = order(x0, x1)\n    x3 = first(x2)\n    x4 = last(x2)\n    x5 = color(x3)\n    x6 = color(x4)\n    x7 = equality(x5, x6)\n    x8 = combine(x3, x4)\n    x9 = repeat(x8, ONE)\n    x10 = remove(x3, x2)\n    x11 = remove(x4, x10)\n    x12 = combine(x9, x11)\n    x13 = branch(x7, x12, x2)\n    x14 = apply(color, x13)\n    x15 = last(x13)\n    x16 = remove(x15, x13)\n    x17 = repeat(x15, ONE)\n    x18 = combine(x17, x16)\n    x19 = mpapply(recolor, x14, x18)\n    x20 = paint(I, x19)\n    return x20\n\n",
    "annotated": "def verify_bda2d7a6(I: Grid) -> Grid:\n    # Identify all objects in the input grid I\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that returns the maximum dimension (height or width) of an object\n    x1 = compose(maximum, shape)\n    \n    # Sort the objects by their maximum dimension, largest first\n    x2 = order(x0, x1)\n    \n    # Get the largest object\n    x3 = first(x2)\n    \n    # Get the smallest object\n    x4 = last(x2)\n    \n    # Get the color of the largest object\n    x5 = color(x3)\n    \n    # Get the color of the smallest object\n    x6 = color(x4)\n    \n    # Check if the largest and smallest objects have the same color\n    x7 = equality(x5, x6)\n    \n    # Combine the largest and smallest objects into a single object\n    x8 = combine(x3, x4)\n    \n    # Create a tuple containing only this combined object\n    x9 = repeat(x8, ONE)\n    \n    # Remove the largest object from the sorted list\n    x10 = remove(x3, x2)\n    \n    # Remove the smallest object from the remaining list\n    x11 = remove(x4, x10)\n    \n    # Combine the new largest object with the remaining objects\n    x12 = combine(x9, x11)\n    \n    # If largest and smallest had same color, use combined objects; otherwise, use original sorted list\n    x13 = branch(x7, x12, x2)\n    \n    # Get the colors of all objects in the final list\n    x14 = apply(color, x13)\n    \n    # Get the last (smallest) object in the final list\n    x15 = last(x13)\n    \n    # Remove the smallest object from the final list\n    x16 = remove(x15, x13)\n    \n    # Create a tuple containing only the smallest object\n    x17 = repeat(x15, ONE)\n    \n    # Add the smallest object to the end of the list (creating a circular shift)\n    x18 = combine(x17, x16)\n    \n    # Recolor each object with the color of the next object in the list (circular shift of colors)\n    x19 = mpapply(recolor, x14, x18)\n    \n    # Paint the recolored objects onto the original input grid\n    x20 = paint(I, x19)\n    \n    # Return the modified grid as the output\n    return x20\n"
  },
  "bdad9b1f": {
    "original": "def verify_bdad9b1f(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = sfilter(x0, hline)\n    x2 = sfilter(x0, vline)\n    x3 = compose(hfrontier, center)\n    x4 = fork(recolor, color, x3)\n    x5 = mapply(x4, x1)\n    x6 = compose(vfrontier, center)\n    x7 = fork(recolor, color, x6)\n    x8 = mapply(x7, x2)\n    x9 = combine(x5, x8)\n    x10 = paint(I, x9)\n    x11 = toindices(x5)\n    x12 = toindices(x8)\n    x13 = intersection(x11, x12)\n    x14 = fill(x10, FOUR, x13)\n    return x14\n\n",
    "annotated": "def verify_bdad9b1f(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Filter out horizontal lines from the extracted objects\n    x1 = sfilter(x0, hline)\n    \n    # Filter out vertical lines from the extracted objects\n    x2 = sfilter(x0, vline)\n    \n    # Create a function that finds the horizontal frontier passing through the center of an object\n    x3 = compose(hfrontier, center)\n    \n    # Create a function that recolors an object to its original color and extends it horizontally\n    x4 = fork(recolor, color, x3)\n    \n    # Apply the recoloring and horizontal extension to all horizontal lines\n    x5 = mapply(x4, x1)\n    \n    # Create a function that finds the vertical frontier passing through the center of an object\n    x6 = compose(vfrontier, center)\n    \n    # Create a function that recolors an object to its original color and extends it vertically\n    x7 = fork(recolor, color, x6)\n    \n    # Apply the recoloring and vertical extension to all vertical lines\n    x8 = mapply(x7, x2)\n    \n    # Combine the extended horizontal and vertical lines\n    x9 = combine(x5, x8)\n    \n    # Paint the extended lines onto the input grid\n    x10 = paint(I, x9)\n    \n    # Get the indices of all cells in the extended horizontal lines\n    x11 = toindices(x5)\n    \n    # Get the indices of all cells in the extended vertical lines\n    x12 = toindices(x8)\n    \n    # Find the intersection points of horizontal and vertical lines\n    x13 = intersection(x11, x12)\n    \n    # Fill the intersection points with color 4 (FOUR) on the grid with extended lines\n    x14 = fill(x10, FOUR, x13)\n    \n    # Return the final grid with extended lines and marked intersections\n    return x14\n"
  },
  "be94b721": {
    "original": "def verify_be94b721(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = argmax(x0, size)\n    x2 = color(x1)\n    x3 = remove(x1, x0)\n    x4 = argmax(x3, size)\n    x5 = shape(x4)\n    x6 = canvas(x2, x5)\n    x7 = normalize(x4)\n    x8 = paint(x6, x7)\n    return x8\n\n",
    "annotated": "def verify_be94b721(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, F)\n    \n    # Find the largest object (main shape) in the grid\n    x1 = argmax(x0, size)\n    \n    # Get the color of the main shape\n    x2 = color(x1)\n    \n    # Remove the main shape from the set of objects, leaving only the smaller shapes\n    x3 = remove(x1, x0)\n    \n    # Find the largest object among the remaining smaller shapes\n    x4 = argmax(x3, size)\n    \n    # Get the dimensions (height and width) of the largest smaller shape\n    x5 = shape(x4)\n    \n    # Create a new canvas with the color of the main shape and dimensions of the largest smaller shape\n    x6 = canvas(x2, x5)\n    \n    # Normalize the position of the largest smaller shape (move it to the top-left corner)\n    x7 = normalize(x4)\n    \n    # Paint the normalized shape onto the new canvas\n    # This effectively creates the output grid with the main shape's color as background\n    # and the largest smaller shape positioned in the top-left corner\n    x8 = paint(x6, x7)\n    \n    # Return the final output grid\n    return x8\n"
  },
  "beb8660c": {
    "original": "def verify_beb8660c(I: Grid) -> Grid:\n    x0 = astuple(identity, rot90)\n    x1 = astuple(rot180, rot270)\n    x2 = combine(x0, x1)\n    x3 = astuple(identity, rot270)\n    x4 = astuple(rot180, rot90)\n    x5 = combine(x3, x4)\n    x6 = pair(x2, x5)\n    x7 = rbind(rapply, I)\n    x8 = compose(initset, first)\n    x9 = chain(first, x7, x8)\n    x10 = rbind(ofcolor, EIGHT)\n    x11 = chain(lowermost, x10, x9)\n    x12 = matcher(x11, ZERO)\n    x13 = extract(x6, x12)\n    x14 = first(x13)\n    x15 = last(x13)\n    x16 = x14(I)\n    x17 = rot180(x16)\n    x18 = shape(x17)\n    x19 = lbind(apply, first)\n    x20 = lbind(ofcolor, x17)\n    x21 = chain(size, x19, x20)\n    x22 = palette(I)\n    x23 = argmax(x22, x21)\n    x24 = partition(x17)\n    x25 = matcher(color, x23)\n    x26 = compose(flip, x25)\n    x27 = sfilter(x24, x26)\n    x28 = compose(invert, size)\n    x29 = order(x27, x28)\n    x30 = apply(normalize, x29)\n    x31 = size(x30)\n    x32 = interval(ZERO, x31, ONE)\n    x33 = apply(toivec, x32)\n    x34 = mpapply(shift, x30, x33)\n    x35 = canvas(x23, x18)\n    x36 = paint(x35, x34)\n    x37 = x15(x36)\n    return x37\n\n",
    "annotated": "def verify_beb8660c(I: Grid) -> Grid:\n    # Create a tuple of rotation functions: (identity, rot90)\n    x0 = astuple(identity, rot90)\n    # Create a tuple of rotation functions: (rot180, rot270)\n    x1 = astuple(rot180, rot270)\n    # Combine the two tuples of rotation functions\n    x2 = combine(x0, x1)\n    # Create a tuple of rotation functions: (identity, rot270)\n    x3 = astuple(identity, rot270)\n    # Create a tuple of rotation functions: (rot180, rot90)\n    x4 = astuple(rot180, rot90)\n    # Combine the two tuples of rotation functions\n    x5 = combine(x3, x4)\n    # Pair the two combined tuples of rotation functions\n    x6 = pair(x2, x5)\n    # Partially apply rapply function with input grid I\n    x7 = rbind(rapply, I)\n    # Create a function that initializes a set with the first element\n    x8 = compose(initset, first)\n    # Chain functions to get the first element of the result of applying all rotations to I\n    x9 = chain(first, x7, x8)\n    # Partially apply ofcolor function with color 8 (black)\n    x10 = rbind(ofcolor, EIGHT)\n    # Chain functions to find the lowermost black cell in the rotated grids\n    x11 = chain(lowermost, x10, x9)\n    # Create a function that checks if the lowermost black cell is at row 0\n    x12 = matcher(x11, ZERO)\n    # Extract the rotation functions that put the black line at the bottom\n    x13 = extract(x6, x12)\n    # Get the rotation function that orients the grid correctly\n    x14 = first(x13)\n    # Get the inverse rotation function\n    x15 = last(x13)\n    # Apply the correct rotation to the input grid\n    x16 = x14(I)\n    # Rotate the correctly oriented grid 180 degrees (to mirror it vertically)\n    x17 = rot180(x16)\n    # Get the shape (dimensions) of the mirrored grid\n    x18 = shape(x17)\n    # Partially apply the 'apply' function with 'first'\n    x19 = lbind(apply, first)\n    # Partially apply the 'ofcolor' function with the mirrored grid\n    x20 = lbind(ofcolor, x17)\n    # Chain functions to count the occurrences of each color in the mirrored grid\n    x21 = chain(size, x19, x20)\n    # Get the palette (unique colors) of the input grid\n    x22 = palette(I)\n    # Find the most common color in the mirrored grid (background color)\n    x23 = argmax(x22, x21)\n    # Partition the mirrored grid into objects\n    x24 = partition(x17)\n    # Create a function that checks if an object's color matches the background color\n    x25 = matcher(color, x23)\n    # Create a function that checks if an object's color is not the background color\n    x26 = compose(flip, x25)\n    # Filter out objects with the background color\n    x27 = sfilter(x24, x26)\n    # Create a function that returns the negative size of an object\n    x28 = compose(invert, size)\n    # Order the non-background objects by size (largest to smallest)\n    x29 = order(x27, x28)\n    # Normalize the positions of all objects (move them to the top-left corner)\n    x30 = apply(normalize, x29)\n    # Count the number of objects\n    x31 = size(x30)\n    # Create an interval from 0 to the number of objects\n    x32 = interval(ZERO, x31, ONE)\n    # Convert the interval to vertical offset vectors\n    x33 = apply(toivec, x32)\n    # Shift each normalized object downward based on its index\n    x34 = mpapply(shift, x30, x33)\n    # Create a new grid filled with the background color\n    x35 = canvas(x23, x18)\n    # Paint the shifted objects onto the new grid\n    x36 = paint(x35, x34)\n    # Apply the inverse rotation to get the final output grid\n    x37 = x15(x36)\n    return x37\n"
  },
  "c0f76784": {
    "original": "def verify_c0f76784(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = mostcolor(I)\n    x2 = colorfilter(x0, x1)\n    x3 = sizefilter(x2, ONE)\n    x4 = merge(x3)\n    x5 = sizefilter(x2, FOUR)\n    x6 = merge(x5)\n    x7 = sizefilter(x2, NINE)\n    x8 = merge(x7)\n    x9 = fill(I, SIX, x4)\n    x10 = fill(x9, SEVEN, x6)\n    x11 = fill(x10, EIGHT, x8)\n    return x11\n\n",
    "annotated": "def verify_c0f76784(I: Grid) -> Grid:\n    # Find all objects in the input grid, allowing diagonal connections and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Determine the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Filter objects to keep only those with the background color\n    x2 = colorfilter(x0, x1)\n    \n    # Filter objects to keep only those of size 1 (single cells)\n    x3 = sizefilter(x2, ONE)\n    \n    # Merge all single-cell objects into one set\n    x4 = merge(x3)\n    \n    # Filter objects to keep only those of size 4 (2x2 squares)\n    x5 = sizefilter(x2, FOUR)\n    \n    # Merge all 2x2 square objects into one set\n    x6 = merge(x5)\n    \n    # Filter objects to keep only those of size 9 (3x3 squares)\n    x7 = sizefilter(x2, NINE)\n    \n    # Merge all 3x3 square objects into one set\n    x8 = merge(x7)\n    \n    # Fill single cells with color 6 in the input grid\n    # This creates an outline around the original objects\n    x9 = fill(I, SIX, x4)\n    \n    # Fill 2x2 squares with color 7 in the previous result\n    # This creates a middle layer around the original objects\n    x10 = fill(x9, SEVEN, x6)\n    \n    # Fill 3x3 squares with color 8 in the previous result\n    # This creates the innermost layer, replacing the original objects\n    x11 = fill(x10, EIGHT, x8)\n    \n    # Return the final grid with layered outlines around the original objects\n    return x11\n"
  },
  "c1d99e64": {
    "original": "def verify_c1d99e64(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = fill(I, TWO, x1)\n    return x2\n\n",
    "annotated": "def verify_c1d99e64(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    # This identifies the areas that need to be changed\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single set of indices\n    # This combines all the areas that need to be changed into one set\n    x1 = merge(x0)\n    \n    # Fill all frontier cells with color 2 (usually blue in ARC)\n    # This replaces all identified frontier areas with the target color\n    # Effectively, this highlights or marks all the frontier lines in the grid\n    x2 = fill(I, TWO, x1)\n    \n    # Return the modified grid\n    # The output is the input grid with all frontiers changed to color 2\n    return x2\n"
  },
  "c3e719e8": {
    "original": "def verify_c3e719e8(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = multiply(x0, x0)\n    x2 = canvas(ZERO, x1)\n    x3 = mostcolor(I)\n    x4 = ofcolor(I, x3)\n    x5 = lbind(multiply, x0)\n    x6 = apply(x5, x4)\n    x7 = asobject(I)\n    x8 = lbind(shift, x7)\n    x9 = mapply(x8, x6)\n    x10 = paint(x2, x9)\n    return x10\n\n",
    "annotated": "def verify_c3e719e8(I: Grid) -> Grid:\n    # Get the shape (height, width) of the input grid\n    x0 = shape(I)\n    \n    # Calculate the dimensions of the output grid by squaring the input dimensions\n    # This effectively creates a zoomed-in version of the input\n    x1 = multiply(x0, x0)\n    \n    # Create a blank canvas (filled with zeros) with the calculated dimensions\n    x2 = canvas(ZERO, x1)\n    \n    # Determine the most common color in the input grid\n    # This color represents the \"background\" or main color\n    x3 = mostcolor(I)\n    \n    # Get all cells in the input grid that have the most common color\n    x4 = ofcolor(I, x3)\n    \n    # Create a function that multiplies by the input grid's dimensions\n    # This will be used to scale up the coordinates\n    x5 = lbind(multiply, x0)\n    \n    # Apply the scaling function to all coordinates of the main color\n    # This maps the coordinates from the input grid to the output grid\n    x6 = apply(x5, x4)\n    \n    # Convert the input grid to an object representation\n    x7 = asobject(I)\n    \n    # Create a function that shifts the input object\n    # This prepares for placing the scaled object onto the output grid\n    x8 = lbind(shift, x7)\n    \n    # Apply the shift function to all scaled coordinates\n    # This creates a set of scaled and positioned objects\n    x9 = mapply(x8, x6)\n    \n    # Paint the scaled and positioned objects onto the blank canvas\n    # This creates the final zoomed-in version of the main color pattern\n    x10 = paint(x2, x9)\n    \n    # Return the final output grid\n    return x10\n"
  },
  "c3f564a4": {
    "original": "def verify_c3f564a4(I: Grid) -> Grid:\n    x0 = height(I)\n    x1 = vsplit(I, x0)\n    x2 = apply(asobject, x1)\n    x3 = apply(hperiod, x2)\n    x4 = minimum(x3)\n    x5 = width(I)\n    x6 = hsplit(I, x5)\n    x7 = apply(asobject, x6)\n    x8 = apply(vperiod, x7)\n    x9 = minimum(x8)\n    x10 = matcher(hperiod, x4)\n    x11 = sfilter(x2, x10)\n    x12 = mapply(palette, x11)\n    x13 = matcher(vperiod, x9)\n    x14 = sfilter(x7, x13)\n    x15 = mapply(palette, x14)\n    x16 = palette(I)\n    x17 = combine(x12, x15)\n    x18 = rbind(contained, x17)\n    x19 = argmin(x16, x18)\n    x20 = asobject(I)\n    x21 = matcher(first, x19)\n    x22 = compose(flip, x21)\n    x23 = sfilter(x20, x22)\n    x24 = height(I)\n    x25 = divide(x24, x9)\n    x26 = increment(x25)\n    x27 = width(I)\n    x28 = divide(x27, x4)\n    x29 = increment(x28)\n    x30 = invert(x26)\n    x31 = interval(x30, x26, ONE)\n    x32 = invert(x29)\n    x33 = interval(x32, x29, ONE)\n    x34 = product(x31, x33)\n    x35 = astuple(x9, x4)\n    x36 = lbind(multiply, x35)\n    x37 = apply(x36, x34)\n    x38 = lbind(shift, x23)\n    x39 = mapply(x38, x37)\n    x40 = paint(I, x39)\n    return x40\n\n",
    "annotated": "def verify_c3f564a4(I: Grid) -> Grid:\n    # Get the height of the input grid\n    x0 = height(I)\n    \n    # Split the input grid vertically into x0 number of rows\n    x1 = vsplit(I, x0)\n    \n    # Convert each row into an object representation\n    x2 = apply(asobject, x1)\n    \n    # Calculate the horizontal period for each row object\n    x3 = apply(hperiod, x2)\n    \n    # Find the minimum horizontal period among all rows\n    x4 = minimum(x3)\n    \n    # Get the width of the input grid\n    x5 = width(I)\n    \n    # Split the input grid horizontally into x5 number of columns\n    x6 = hsplit(I, x5)\n    \n    # Convert each column into an object representation\n    x7 = apply(asobject, x6)\n    \n    # Calculate the vertical period for each column object\n    x8 = apply(vperiod, x7)\n    \n    # Find the minimum vertical period among all columns\n    x9 = minimum(x8)\n    \n    # Create a matcher function to check if horizontal period equals x4\n    x10 = matcher(hperiod, x4)\n    \n    # Filter row objects that have the minimum horizontal period\n    x11 = sfilter(x2, x10)\n    \n    # Get the palette (unique colors) for each filtered row object\n    x12 = mapply(palette, x11)\n    \n    # Create a matcher function to check if vertical period equals x9\n    x13 = matcher(vperiod, x9)\n    \n    # Filter column objects that have the minimum vertical period\n    x14 = sfilter(x7, x13)\n    \n    # Get the palette (unique colors) for each filtered column object\n    x15 = mapply(palette, x14)\n    \n    # Get the palette (unique colors) of the entire input grid\n    x16 = palette(I)\n    \n    # Combine palettes from filtered rows and columns\n    x17 = combine(x12, x15)\n    \n    # Create a function to check if a color is contained in the combined palette\n    x18 = rbind(contained, x17)\n    \n    # Find the color in the input grid's palette that is not in the combined palette\n    # This is likely the color used for the fixed squares\n    x19 = argmin(x16, x18)\n    \n    # Convert the entire input grid to an object representation\n    x20 = asobject(I)\n    \n    # Create a matcher function to check if a cell's color is not the fixed color\n    x21 = matcher(first, x19)\n    x22 = compose(flip, x21)\n    \n    # Filter out all cells that are not the fixed color\n    x23 = sfilter(x20, x22)\n    \n    # Calculate the number of vertical repetitions of the pattern\n    x24 = height(I)\n    x25 = divide(x24, x9)\n    x26 = increment(x25)\n    \n    # Calculate the number of horizontal repetitions of the pattern\n    x27 = width(I)\n    x28 = divide(x27, x4)\n    x29 = increment(x28)\n    \n    # Generate a range of vertical offsets for the pattern\n    x30 = invert(x26)\n    x31 = interval(x30, x26, ONE)\n    \n    # Generate a range of horizontal offsets for the pattern\n    x32 = invert(x29)\n    x33 = interval(x32, x29, ONE)\n    \n    # Create all possible combinations of vertical and horizontal offsets\n    x34 = product(x31, x33)\n    \n    # Create a tuple of vertical and horizontal periods\n    x35 = astuple(x9, x4)\n    \n    # Create a function to multiply offsets by the period\n    x36 = lbind(multiply, x35)\n    \n    # Calculate actual pixel offsets for each combination\n    x37 = apply(x36, x34)\n    \n    # Create a function to shift the pattern\n    x38 = lbind(shift, x23)\n    \n    # Apply the shift to create all instances of the pattern\n    x39 = mapply(x38, x37)\n    \n    # Paint the repeated pattern onto the input grid, effectively removing the fixed squares\n    x40 = paint(I, x39)\n    \n    # Return the grid with the pattern restored and fixed squares removed\n    return x40\n"
  },
  "c444b776": {
    "original": "def verify_c444b776(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = leastcolor(x1)\n    x3 = shape(I)\n    x4 = canvas(x2, x3)\n    x5 = hconcat(I, x4)\n    x6 = objects(x5, F, F, T)\n    x7 = argmax(x6, numcolors)\n    x8 = apply(ulcorner, x6)\n    x9 = normalize(x7)\n    x10 = lbind(shift, x9)\n    x11 = mapply(x10, x8)\n    x12 = paint(I, x11)\n    return x12\n\n",
    "annotated": "def verify_c444b776(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Find the least common color in the merged frontiers (likely the background color)\n    x2 = leastcolor(x1)\n    \n    # Get the dimensions of the input grid\n    x3 = shape(I)\n    \n    # Create a new canvas with the background color and same size as input\n    x4 = canvas(x2, x3)\n    \n    # Concatenate the input grid and the background canvas horizontally\n    x5 = hconcat(I, x4)\n    \n    # Find all objects in the concatenated grid, ignoring background\n    # F, F, T: univalued=False, diagonal=False, without_bg=True\n    x6 = objects(x5, F, F, T)\n    \n    # Find the object with the most colors (likely the pattern to be replicated)\n    x7 = argmax(x6, numcolors)\n    \n    # Get the upper-left corners of all objects\n    x8 = apply(ulcorner, x6)\n    \n    # Normalize the pattern object (move it to origin)\n    x9 = normalize(x7)\n    \n    # Create a function that shifts the normalized pattern\n    x10 = lbind(shift, x9)\n    \n    # Apply the shift function to all object corners, creating copies of the pattern\n    x11 = mapply(x10, x8)\n    \n    # Paint the shifted patterns onto the input grid, replicating the pattern\n    x12 = paint(I, x11)\n    \n    # Return the final grid with the pattern replicated in all cells\n    return x12\n"
  },
  "c59eb873": {
    "original": "def verify_c59eb873(I: Grid) -> Grid:\n    x0 = upscale(I, TWO)\n    return x0\n\n",
    "annotated": "def verify_c59eb873(I: Grid) -> Grid:\n    # Upscale the input grid I by a factor of 2\n    # This doubles the size of the grid in both dimensions\n    # Each cell in the original grid becomes a 2x2 block in the new grid\n    x0 = upscale(I, TWO)\n    \n    # Return the upscaled grid\n    # This is the final output of the function\n    return x0\n"
  },
  "c8cbb738": {
    "original": "def verify_c8cbb738(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = valmax(x0, height)\n    x2 = valmax(x0, width)\n    x3 = astuple(x1, x2)\n    x4 = mostcolor(I)\n    x5 = canvas(x4, x3)\n    x6 = asindices(x5)\n    x7 = apply(normalize, x0)\n    x8 = box(x6)\n    x9 = maximum(x3)\n    x10 = double(x9)\n    x11 = asindices(x5)\n    x12 = center(x11)\n    x13 = initset(x12)\n    x14 = lbind(manhattan, x13)\n    x15 = lbind(multiply, x10)\n    x16 = lbind(intersection, x8)\n    x17 = chain(x15, size, x16)\n    x18 = lbind(fork, subtract)\n    x19 = lbind(chain, x17)\n    x20 = lbind(x19, toindices)\n    x21 = lbind(lbind, shift)\n    x22 = compose(x20, x21)\n    x23 = lbind(chain, x14)\n    x24 = compose(initset, center)\n    x25 = lbind(x23, x24)\n    x26 = lbind(lbind, shift)\n    x27 = compose(x25, x26)\n    x28 = lbind(argmax, x6)\n    x29 = fork(x18, x22, x27)\n    x30 = compose(x28, x29)\n    x31 = fork(shift, identity, x30)\n    x32 = mapply(x31, x7)\n    x33 = paint(x5, x32)\n    return x33\n\n",
    "annotated": "def verify_c8cbb738(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Find the maximum height among all objects\n    x1 = valmax(x0, height)\n    \n    # Find the maximum width among all objects\n    x2 = valmax(x0, width)\n    \n    # Create a tuple of the maximum height and width\n    x3 = astuple(x1, x2)\n    \n    # Determine the most common color in the input grid (background color)\n    x4 = mostcolor(I)\n    \n    # Create a new canvas with the background color and dimensions of the largest object\n    x5 = canvas(x4, x3)\n    \n    # Get all indices of the new canvas\n    x6 = asindices(x5)\n    \n    # Normalize all objects (shift to origin)\n    x7 = apply(normalize, x0)\n    \n    # Create a box (outline) of the new canvas\n    x8 = box(x6)\n    \n    # Find the maximum dimension (height or width) of the largest object\n    x9 = maximum(x3)\n    \n    # Double the maximum dimension\n    x10 = double(x9)\n    \n    # Get all indices of the new canvas (same as x6)\n    x11 = asindices(x5)\n    \n    # Find the center of the new canvas\n    x12 = center(x11)\n    \n    # Create a set with only the center point\n    x13 = initset(x12)\n    \n    # Partially apply the manhattan function with the center point\n    x14 = lbind(manhattan, x13)\n    \n    # Partially apply the multiply function with the doubled max dimension\n    x15 = lbind(multiply, x10)\n    \n    # Partially apply the intersection function with the box outline\n    x16 = lbind(intersection, x8)\n    \n    # Create a chain of functions: multiply by x10, get size, intersect with box\n    x17 = chain(x15, size, x16)\n    \n    # Prepare a fork function with subtract as the outer function\n    x18 = lbind(fork, subtract)\n    \n    # Partially apply the chain function with x17\n    x19 = lbind(chain, x17)\n    \n    # Add toindices to the chain\n    x20 = lbind(x19, toindices)\n    \n    # Prepare a partial application of shift\n    x21 = lbind(lbind, shift)\n    \n    # Compose x20 and x21\n    x22 = compose(x20, x21)\n    \n    # Partially apply the chain function with the manhattan distance function\n    x23 = lbind(chain, x14)\n    \n    # Compose center and initset functions\n    x24 = compose(initset, center)\n    \n    # Add x24 to the chain\n    x25 = lbind(x23, x24)\n    \n    # Prepare another partial application of shift\n    x26 = lbind(lbind, shift)\n    \n    # Compose x25 and x26\n    x27 = compose(x25, x26)\n    \n    # Prepare to find the argmax over the canvas indices\n    x28 = lbind(argmax, x6)\n    \n    # Create a fork with subtract, x22, and x27\n    x29 = fork(x18, x22, x27)\n    \n    # Compose x28 and x29\n    x30 = compose(x28, x29)\n    \n    # Create a fork to shift objects based on the result of x30\n    x31 = fork(shift, identity, x30)\n    \n    # Apply the shifting operation to all normalized objects\n    x32 = mapply(x31, x7)\n    \n    # Paint the shifted objects onto the new canvas\n    x33 = paint(x5, x32)\n    \n    # Return the final output grid\n    return x33\n"
  },
  "c8f0f002": {
    "original": "def verify_c8f0f002(I: Grid) -> Grid:\n    x0 = replace(I, SEVEN, FIVE)\n    return x0\n\n",
    "annotated": "def verify_c8f0f002(I: Grid) -> Grid:\n    # Replace all occurrences of 7 (orange) with 5 (light blue) in the input grid\n    # This effectively changes all orange cells to light blue while keeping other colors unchanged\n    x0 = replace(I, SEVEN, FIVE)\n    \n    # Return the modified grid\n    # The output grid is identical to the input, except orange cells are now light blue\n    return x0\n"
  },
  "c909285e": {
    "original": "def verify_c909285e(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = lbind(contained, ONE)\n    x2 = chain(flip, x1, shape)\n    x3 = sfilter(x0, x2)\n    x4 = fork(equality, toindices, box)\n    x5 = sfilter(x3, x4)\n    x6 = fork(multiply, height, width)\n    x7 = argmin(x5, x6)\n    x8 = subgrid(x7, I)\n    return x8\n\n",
    "annotated": "def verify_c909285e(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that checks if the shape of an object is not (1, 1)\n    x1 = lbind(contained, ONE)\n    x2 = chain(flip, x1, shape)\n    \n    # Filter objects that are larger than 1x1\n    x3 = sfilter(x0, x2)\n    \n    # Create a function that checks if an object forms a complete box\n    x4 = fork(equality, toindices, box)\n    \n    # Filter objects that form complete boxes\n    x5 = sfilter(x3, x4)\n    \n    # Create a function that calculates the area of an object\n    x6 = fork(multiply, height, width)\n    \n    # Find the smallest box (by area) among the filtered objects\n    x7 = argmin(x5, x6)\n    \n    # Extract the subgrid within the smallest box\n    x8 = subgrid(x7, I)\n    \n    # Return the extracted subgrid as the output\n    return x8\n"
  },
  "c9e6f938": {
    "original": "def verify_c9e6f938(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = hconcat(I, x0)\n    return x1\n\n",
    "annotated": "def verify_c9e6f938(I: Grid) -> Grid:\n    # Create a vertically mirrored version of the input grid I\n    # This effectively flips the grid left to right\n    x0 = vmirror(I)\n    \n    # Horizontally concatenate the original input grid I with its mirrored version x0\n    # This creates a new grid that is twice as wide as the original,\n    # with the mirrored version appended to the right side\n    x1 = hconcat(I, x0)\n    \n    # Return the final grid, which is the original grid with its mirror image added to the right\n    return x1\n"
  },
  "c9f8e694": {
    "original": "def verify_c9f8e694(I: Grid) -> Grid:\n    x0 = astuple(identity, dmirror)\n    x1 = astuple(cmirror, vmirror)\n    x2 = combine(x0, x1)\n    x3 = compose(first, dmirror)\n    x4 = chain(size, dedupe, x3)\n    x5 = rbind(rapply, I)\n    x6 = compose(first, x5)\n    x7 = chain(x4, x6, initset)\n    x8 = argmax(x2, x7)\n    x9 = x8(I)\n    x10 = height(x9)\n    x11 = width(x9)\n    x12 = ofcolor(x9, ZERO)\n    x13 = astuple(x10, ONE)\n    x14 = crop(x9, ORIGIN, x13)\n    x15 = hupscale(x14, x11)\n    x16 = fill(x15, ZERO, x12)\n    x17 = x8(x16)\n    return x17\n\n",
    "annotated": "def verify_c9f8e694(I: Grid) -> Grid:\n    # Create a tuple of identity and diagonal mirror functions\n    x0 = astuple(identity, dmirror)\n    # Create a tuple of counter-diagonal mirror and vertical mirror functions\n    x1 = astuple(cmirror, vmirror)\n    # Combine the two tuples of mirror functions\n    x2 = combine(x0, x1)\n    # Create a function that applies diagonal mirror and then takes the first element\n    x3 = compose(first, dmirror)\n    # Create a chain of functions: size -> dedupe -> x3\n    x4 = chain(size, dedupe, x3)\n    # Create a function that applies all functions in I to an argument\n    x5 = rbind(rapply, I)\n    # Create a function that takes the first element after applying x5\n    x6 = compose(first, x5)\n    # Create a chain of functions: x4 -> x6 -> initset\n    x7 = chain(x4, x6, initset)\n    # Find the mirror function that maximizes x7\n    x8 = argmax(x2, x7)\n    # Apply the best mirror function to the input grid\n    x9 = x8(I)\n    # Get the height of the mirrored grid\n    x10 = height(x9)\n    # Get the width of the mirrored grid\n    x11 = width(x9)\n    # Find all black (color 0) cells in the mirrored grid\n    x12 = ofcolor(x9, ZERO)\n    # Create a tuple (height, 1)\n    x13 = astuple(x10, ONE)\n    # Crop the leftmost column of the mirrored grid\n    x14 = crop(x9, ORIGIN, x13)\n    # Horizontally upscale the leftmost column to match the grid width\n    x15 = hupscale(x14, x11)\n    # Fill the black cells from the original grid in the upscaled column\n    x16 = fill(x15, ZERO, x12)\n    # Apply the best mirror function to the result\n    x17 = x8(x16)\n    # Return the final transformed grid\n    return x17\n"
  },
  "caa06a1f": {
    "original": "def verify_caa06a1f(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = asobject(I)\n    x5 = matcher(first, x3)\n    x6 = compose(flip, x5)\n    x7 = sfilter(x4, x6)\n    x8 = hperiod(x7)\n    x9 = vperiod(x7)\n    x10 = width(I)\n    x11 = width(x7)\n    x12 = subtract(x10, x11)\n    x13 = add(x12, TWO)\n    x14 = height(I)\n    x15 = height(x7)\n    x16 = subtract(x14, x15)\n    x17 = add(x16, TWO)\n    x18 = rbind(multiply, x8)\n    x19 = invert(x13)\n    x20 = interval(x19, x13, ONE)\n    x21 = apply(x18, x20)\n    x22 = rbind(multiply, x9)\n    x23 = invert(x17)\n    x24 = interval(x23, x17, ONE)\n    x25 = apply(x22, x24)\n    x26 = product(x25, x21)\n    x27 = lbind(shift, x7)\n    x28 = mapply(x27, x26)\n    x29 = index(I, ORIGIN)\n    x30 = equality(x29, x3)\n    x31 = flip(x30)\n    x32 = asindices(I)\n    x33 = urcorner(x32)\n    x34 = index(I, x33)\n    x35 = equality(x34, x3)\n    x36 = flip(x35)\n    x37 = asindices(I)\n    x38 = lrcorner(x37)\n    x39 = index(I, x38)\n    x40 = equality(x39, x3)\n    x41 = flip(x40)\n    x42 = asindices(I)\n    x43 = llcorner(x42)\n    x44 = index(I, x43)\n    x45 = equality(x44, x3)\n    x46 = flip(x45)\n    x47 = multiply(x31, LEFT)\n    x48 = multiply(x36, UP)\n    x49 = add(x47, x48)\n    x50 = multiply(x41, RIGHT)\n    x51 = multiply(x46, DOWN)\n    x52 = add(x50, x51)\n    x53 = add(x49, x52)\n    x54 = shift(x28, x53)\n    x55 = paint(I, x54)\n    return x55\n\n",
    "annotated": "def verify_caa06a1f(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    # Get the outline (box) of the grid\n    x1 = box(x0)\n    # Convert the outline to an object using colors from the input grid\n    x2 = toobject(x1, I)\n    # Find the most common color in the outline (likely the background color)\n    x3 = mostcolor(x2)\n    # Convert the entire input grid to an object\n    x4 = asobject(I)\n    # Create a function that matches the first element to the background color\n    x5 = matcher(first, x3)\n    # Create a function that flips the result of x5 (to find non-background colors)\n    x6 = compose(flip, x5)\n    # Filter the grid object to keep only non-background colored cells\n    x7 = sfilter(x4, x6)\n    # Find the horizontal period of the pattern\n    x8 = hperiod(x7)\n    # Find the vertical period of the pattern\n    x9 = vperiod(x7)\n    # Get the width of the input grid\n    x10 = width(I)\n    # Get the width of the pattern\n    x11 = width(x7)\n    # Calculate the horizontal space not covered by the pattern\n    x12 = subtract(x10, x11)\n    # Add 2 to the horizontal space (for potential shift)\n    x13 = add(x12, TWO)\n    # Get the height of the input grid\n    x14 = height(I)\n    # Get the height of the pattern\n    x15 = height(x7)\n    # Calculate the vertical space not covered by the pattern\n    x16 = subtract(x14, x15)\n    # Add 2 to the vertical space (for potential shift)\n    x17 = add(x16, TWO)\n    # Create a function to multiply by the horizontal period\n    x18 = rbind(multiply, x8)\n    # Invert the horizontal space (negative value)\n    x19 = invert(x13)\n    # Create a range of horizontal shifts\n    x20 = interval(x19, x13, ONE)\n    # Apply horizontal shifts to create potential x-coordinates\n    x21 = apply(x18, x20)\n    # Create a function to multiply by the vertical period\n    x22 = rbind(multiply, x9)\n    # Invert the vertical space (negative value)\n    x23 = invert(x17)\n    # Create a range of vertical shifts\n    x24 = interval(x23, x17, ONE)\n    # Apply vertical shifts to create potential y-coordinates\n    x25 = apply(x22, x24)\n    # Create all possible combinations of x and y coordinates for shifting\n    x26 = product(x25, x21)\n    # Create a function to shift the pattern\n    x27 = lbind(shift, x7)\n    # Apply all possible shifts to the pattern\n    x28 = mapply(x27, x26)\n    # Get the color of the top-left corner of the input grid\n    x29 = index(I, ORIGIN)\n    # Check if the top-left corner is the background color\n    x30 = equality(x29, x3)\n    # Flip the result (True if it's not the background color)\n    x31 = flip(x30)\n    # Get all indices of the input grid\n    x32 = asindices(I)\n    # Get the top-right corner of the grid\n    x33 = urcorner(x32)\n    # Get the color of the top-right corner\n    x34 = index(I, x33)\n    # Check if the top-right corner is the background color\n    x35 = equality(x34, x3)\n    # Flip the result (True if it's not the background color)\n    x36 = flip(x35)\n    # Get all indices of the input grid\n    x37 = asindices(I)\n    # Get the bottom-right corner of the grid\n    x38 = lrcorner(x37)\n    # Get the color of the bottom-right corner\n    x39 = index(I, x38)\n    # Check if the bottom-right corner is the background color\n    x40 = equality(x39, x3)\n    # Flip the result (True if it's not the background color)\n    x41 = flip(x40)\n    # Get all indices of the input grid\n    x42 = asindices(I)\n    # Get the bottom-left corner of the grid\n    x43 = llcorner(x42)\n    # Get the color of the bottom-left corner\n    x44 = index(I, x43)\n    # Check if the bottom-left corner is the background color\n    x45 = equality(x44, x3)\n    # Flip the result (True if it's not the background color)\n    x46 = flip(x45)\n    # If top-left is not background, shift left\n    x47 = multiply(x31, LEFT)\n    # If top-right is not background, shift up\n    x48 = multiply(x36, UP)\n    # Combine left and up shifts\n    x49 = add(x47, x48)\n    # If bottom-right is not background, shift right\n    x50 = multiply(x41, RIGHT)\n    # If bottom-left is not background, shift down\n    x51 = multiply(x46, DOWN)\n    # Combine right and down shifts\n    x52 = add(x50, x51)\n    # Combine all shifts\n    x53 = add(x49, x52)\n    # Apply the final shift to the pattern\n    x54 = shift(x28, x53)\n    # Paint the shifted pattern onto the input grid\n    x55 = paint(I, x54)\n    # Return the final grid with the pattern shifted\n    return x55\n"
  },
  "cbded52d": {
    "original": "def verify_cbded52d(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = palette(I)\n    x4 = remove(x2, x3)\n    x5 = lbind(colorcount, I)\n    x6 = argmax(x4, x5)\n    x7 = remove(x6, x4)\n    x8 = height(I)\n    x9 = increment(x8)\n    x10 = frontiers(I)\n    x11 = sfilter(x10, hline)\n    x12 = size(x11)\n    x13 = increment(x12)\n    x14 = divide(x9, x13)\n    x15 = width(I)\n    x16 = increment(x15)\n    x17 = frontiers(I)\n    x18 = sfilter(x17, vline)\n    x19 = size(x18)\n    x20 = increment(x19)\n    x21 = divide(x16, x20)\n    x22 = rbind(multiply, x14)\n    x23 = rbind(divide, x14)\n    x24 = compose(x22, x23)\n    x25 = fork(equality, identity, x24)\n    x26 = rbind(multiply, x21)\n    x27 = rbind(divide, x21)\n    x28 = compose(x26, x27)\n    x29 = fork(equality, identity, x28)\n    x30 = lbind(fork, both)\n    x31 = rbind(compose, first)\n    x32 = lbind(compose, x25)\n    x33 = lbind(rbind, subtract)\n    x34 = compose(x33, uppermost)\n    x35 = chain(x31, x32, x34)\n    x36 = rbind(compose, last)\n    x37 = lbind(compose, x29)\n    x38 = lbind(rbind, subtract)\n    x39 = compose(x38, leftmost)\n    x40 = chain(x36, x37, x39)\n    x41 = fork(x30, x35, x40)\n    x42 = fork(sfilter, identity, x41)\n    x43 = fork(connect, first, last)\n    x44 = lbind(apply, x43)\n    x45 = lbind(ofcolor, I)\n    x46 = fork(product, x45, x45)\n    x47 = fork(either, vline, hline)\n    x48 = rbind(sfilter, x47)\n    x49 = chain(x48, x44, x46)\n    x50 = lbind(mapply, x42)\n    x51 = compose(x50, x49)\n    x52 = fork(recolor, identity, x51)\n    x53 = mapply(x52, x7)\n    x54 = paint(I, x53)\n    return x54\n\n",
    "annotated": "def verify_cbded52d(I: Grid) -> Grid:\n    # Get all frontiers (horizontal and vertical lines) from the input grid\n    x0 = frontiers(I)\n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    # Get the color of the merged frontiers (likely the line color)\n    x2 = color(x1)\n    # Get all colors used in the input grid\n    x3 = palette(I)\n    # Remove the line color from the palette, leaving object colors\n    x4 = remove(x2, x3)\n    # Create a function that counts occurrences of a color in the input grid\n    x5 = lbind(colorcount, I)\n    # Find the most common object color\n    x6 = argmax(x4, x5)\n    # Remove the most common object color, leaving other object colors\n    x7 = remove(x6, x4)\n    # Get the height of the input grid\n    x8 = height(I)\n    # Increment the height (add 1)\n    x9 = increment(x8)\n    # Get all frontiers again\n    x10 = frontiers(I)\n    # Filter out horizontal lines from frontiers\n    x11 = sfilter(x10, hline)\n    # Count the number of horizontal lines\n    x12 = size(x11)\n    # Increment the number of horizontal lines (add 1)\n    x13 = increment(x12)\n    # Calculate the height of each object (total height / number of horizontal spaces)\n    x14 = divide(x9, x13)\n    # Get the width of the input grid\n    x15 = width(I)\n    # Increment the width (add 1)\n    x16 = increment(x15)\n    # Get all frontiers once more\n    x17 = frontiers(I)\n    # Filter out vertical lines from frontiers\n    x18 = sfilter(x17, vline)\n    # Count the number of vertical lines\n    x19 = size(x18)\n    # Increment the number of vertical lines (add 1)\n    x20 = increment(x19)\n    # Calculate the width of each object (total width / number of vertical spaces)\n    x21 = divide(x16, x20)\n    # Create a function to multiply by object height\n    x22 = rbind(multiply, x14)\n    # Create a function to divide by object height\n    x23 = rbind(divide, x14)\n    # Compose multiplication and division by object height\n    x24 = compose(x22, x23)\n    # Create a function to check if a value is equal to its multiple and division by object height\n    x25 = fork(equality, identity, x24)\n    # Create a function to multiply by object width\n    x26 = rbind(multiply, x21)\n    # Create a function to divide by object width\n    x27 = rbind(divide, x21)\n    # Compose multiplication and division by object width\n    x28 = compose(x26, x27)\n    # Create a function to check if a value is equal to its multiple and division by object width\n    x29 = fork(equality, identity, x28)\n    # Create a function to combine two conditions with logical AND\n    x30 = lbind(fork, both)\n    # Create a function to get the first element and apply a function\n    x31 = rbind(compose, first)\n    # Create a function to check if a value is divisible by object height\n    x32 = lbind(compose, x25)\n    # Create a function to subtract a value\n    x33 = lbind(rbind, subtract)\n    # Create a function to get the uppermost coordinate and subtract\n    x34 = compose(x33, uppermost)\n    # Chain functions to check if vertical coordinate is valid\n    x35 = chain(x31, x32, x34)\n    # Create a function to get the last element and apply a function\n    x36 = rbind(compose, last)\n    # Create a function to check if a value is divisible by object width\n    x37 = lbind(compose, x29)\n    # Create a function to subtract a value\n    x38 = lbind(rbind, subtract)\n    # Create a function to get the leftmost coordinate and subtract\n    x39 = compose(x38, leftmost)\n    # Chain functions to check if horizontal coordinate is valid\n    x40 = chain(x36, x37, x39)\n    # Combine vertical and horizontal coordinate checks\n    x41 = fork(x30, x35, x40)\n    # Create a function to filter based on coordinate validity\n    x42 = fork(sfilter, identity, x41)\n    # Create a function to connect two points\n    x43 = fork(connect, first, last)\n    # Create a function to apply the connect function\n    x44 = lbind(apply, x43)\n    # Create a function to get cells of a specific color in the input grid\n    x45 = lbind(ofcolor, I)\n    # Create a function to get the product of colored cells with themselves\n    x46 = fork(product, x45, x45)\n    # Create a function to check if a line is vertical or horizontal\n    x47 = fork(either, vline, hline)\n    # Create a function to filter lines that are vertical or horizontal\n    x48 = rbind(sfilter, x47)\n    # Chain functions to get valid lines between colored cells\n    x49 = chain(x48, x44, x46)\n    # Create a function to apply the coordinate validity filter\n    x50 = lbind(mapply, x42)\n    # Compose functions to get valid lines and filter them\n    x51 = compose(x50, x49)\n    # Create a function to recolor valid lines\n    x52 = fork(recolor, identity, x51)\n    # Apply the recoloring function to each object color\n    x53 = mapply(x52, x7)\n    # Paint the recolored objects onto the input grid to create the output\n    x54 = paint(I, x53)\n    # Return the final output grid\n    return x54\n"
  },
  "cce03e0d": {
    "original": "def verify_cce03e0d(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = shape(I)\n    x2 = multiply(x1, x1)\n    x3 = canvas(ZERO, x2)\n    x4 = rbind(multiply, x1)\n    x5 = apply(x4, x0)\n    x6 = asobject(I)\n    x7 = lbind(shift, x6)\n    x8 = mapply(x7, x5)\n    x9 = paint(x3, x8)\n    return x9\n\n",
    "annotated": "def verify_cce03e0d(I: Grid) -> Grid:\n    # Get indices of all red cells (color 2) in the input grid\n    x0 = ofcolor(I, TWO)\n    \n    # Get the dimensions (height, width) of the input grid\n    x1 = shape(I)\n    \n    # Calculate the dimensions of the output grid (input dimensions squared)\n    x2 = multiply(x1, x1)\n    \n    # Create an empty output grid filled with black (0) with the calculated dimensions\n    x3 = canvas(ZERO, x2)\n    \n    # Create a function that multiplies a tuple by the input grid dimensions\n    # This will be used to calculate new positions in the output grid\n    x4 = rbind(multiply, x1)\n    \n    # Calculate new positions for red cells in the output grid\n    x5 = apply(x4, x0)\n    \n    # Convert the input grid to an object representation\n    x6 = asobject(I)\n    \n    # Create a function that shifts the input grid object\n    x7 = lbind(shift, x6)\n    \n    # Create objects representing the input grid at each new red cell position\n    # This effectively creates copies of the input grid at each red cell's new position\n    x8 = mapply(x7, x5)\n    \n    # Paint these objects onto the output grid\n    # This creates the final output with multiple copies of the input grid\n    x9 = paint(x3, x8)\n    \n    # Return the final output grid\n    return x9\n"
  },
  "cdecee7f": {
    "original": "def verify_cdecee7f(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = mostcolor(I)\n    x2 = matcher(first, x1)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x0, x3)\n    x5 = apply(initset, x4)\n    x6 = astuple(ONE, THREE)\n    x7 = size(x5)\n    x8 = order(x5, leftmost)\n    x9 = apply(color, x8)\n    x10 = rbind(canvas, UNITY)\n    x11 = apply(x10, x9)\n    x12 = merge(x11)\n    x13 = dmirror(x12)\n    x14 = subtract(NINE, x7)\n    x15 = astuple(ONE, x14)\n    x16 = mostcolor(I)\n    x17 = canvas(x16, x15)\n    x18 = hconcat(x13, x17)\n    x19 = hsplit(x18, THREE)\n    x20 = merge(x19)\n    x21 = crop(x20, ORIGIN, x6)\n    x22 = crop(x20, DOWN, x6)\n    x23 = crop(x20, TWO_BY_ZERO, x6)\n    x24 = vmirror(x22)\n    x25 = vconcat(x21, x24)\n    x26 = vconcat(x25, x23)\n    return x26\n\n",
    "annotated": "def verify_cdecee7f(I: Grid) -> Grid:\n    # Convert the input grid to an object representation\n    x0 = asobject(I)\n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    # Create a function that checks if the first element of a tuple is the background color\n    x2 = matcher(first, x1)\n    # Create a function that inverts the result of x2 (checks if color is not background)\n    x3 = compose(flip, x2)\n    # Filter the object representation to keep only non-background colored cells\n    x4 = sfilter(x0, x3)\n    # Convert each non-background cell to a single-element set\n    x5 = apply(initset, x4)\n    # Create a tuple (1, 3) representing dimensions\n    x6 = astuple(ONE, THREE)\n    # Count the number of non-background colored cells\n    x7 = size(x5)\n    # Sort the non-background cells by their leftmost position\n    x8 = order(x5, leftmost)\n    # Extract the colors of the sorted non-background cells\n    x9 = apply(color, x8)\n    # Create a function that generates a 1x1 grid for each color\n    x10 = rbind(canvas, UNITY)\n    # Apply the 1x1 grid function to each extracted color\n    x11 = apply(x10, x9)\n    # Merge the 1x1 grids into a single grid\n    x12 = merge(x11)\n    # Mirror the merged grid diagonally (transpose)\n    x13 = dmirror(x12)\n    # Calculate how many background color cells are needed to reach 9 total\n    x14 = subtract(NINE, x7)\n    # Create a tuple (1, x14) representing dimensions for background color padding\n    x15 = astuple(ONE, x14)\n    # Get the background color\n    x16 = mostcolor(I)\n    # Create a grid of background color with calculated dimensions\n    x17 = canvas(x16, x15)\n    # Concatenate the color grid with the background padding horizontally\n    x18 = hconcat(x13, x17)\n    # Split the concatenated grid into three parts horizontally\n    x19 = hsplit(x18, THREE)\n    # Merge the three parts into a single grid\n    x20 = merge(x19)\n    # Extract the top 1x3 section of the grid\n    x21 = crop(x20, ORIGIN, x6)\n    # Extract the middle 1x3 section of the grid\n    x22 = crop(x20, DOWN, x6)\n    # Extract the bottom 1x3 section of the grid\n    x23 = crop(x20, TWO_BY_ZERO, x6)\n    # Mirror the middle section vertically (reverse order)\n    x24 = vmirror(x22)\n    # Concatenate the top and reversed middle sections vertically\n    x25 = vconcat(x21, x24)\n    # Concatenate the result with the bottom section vertically\n    x26 = vconcat(x25, x23)\n    # Return the final 3x3 grid representing the sorted and reorganized colors\n    return x26\n"
  },
  "ce22a75a": {
    "original": "def verify_ce22a75a(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = apply(initset, x1)\n    x3 = apply(outbox, x2)\n    x4 = mapply(backdrop, x3)\n    x5 = fill(I, ONE, x4)\n    return x5\n\n",
    "annotated": "def verify_ce22a75a(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    # This will be the foreground color of the dots\n    x0 = leastcolor(I)\n\n    # Get all positions of cells with the foreground color\n    # These are the positions of the original dots\n    x1 = ofcolor(I, x0)\n\n    # Convert each dot position into a single-element set\n    # This prepares the dots for further processing\n    x2 = apply(initset, x1)\n\n    # For each dot, get its outbox (surrounding cells)\n    # This creates a set of positions around each dot\n    x3 = apply(outbox, x2)\n\n    # Get all cells within the bounding box of each dot's outbox\n    # This includes the dot itself and its surrounding cells\n    x4 = mapply(backdrop, x3)\n\n    # Fill all the cells identified in x4 with color 1\n    # This creates the final output where dots and their surroundings are filled\n    x5 = fill(I, ONE, x4)\n\n    # Return the modified grid as the output\n    return x5\n"
  },
  "ce4f8723": {
    "original": "def verify_ce4f8723(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, tophalf, lefthalf)\n    x5 = branch(x3, bottomhalf, righthalf)\n    x6 = x4(I)\n    x7 = x5(I)\n    x8 = palette(x6)\n    x9 = palette(x7)\n    x10 = intersection(x8, x9)\n    x11 = first(x10)\n    x12 = shape(x6)\n    x13 = canvas(x11, x12)\n    x14 = palette(x6)\n    x15 = other(x14, x11)\n    x16 = palette(x7)\n    x17 = other(x16, x11)\n    x18 = ofcolor(x6, x15)\n    x19 = ofcolor(x7, x17)\n    x20 = combine(x18, x19)\n    x21 = fill(x13, THREE, x20)\n    return x21\n\n",
    "annotated": "def verify_ce4f8723(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out only the horizontal frontiers\n    x1 = sfilter(x0, hline)\n    # Count the number of horizontal frontiers\n    x2 = size(x1)\n    # Check if there are any horizontal frontiers\n    x3 = positive(x2)\n    # If there are horizontal frontiers, use tophalf function, else use lefthalf\n    # This determines which half of the grid contains the first set of colored cells\n    x4 = branch(x3, tophalf, lefthalf)\n    # If there are horizontal frontiers, use bottomhalf function, else use righthalf\n    # This determines which half of the grid contains the second set of colored cells\n    x5 = branch(x3, bottomhalf, righthalf)\n    # Apply the chosen function to get the first half of the input grid\n    x6 = x4(I)\n    # Apply the chosen function to get the second half of the input grid\n    x7 = x5(I)\n    # Get the set of colors used in the first half\n    x8 = palette(x6)\n    # Get the set of colors used in the second half\n    x9 = palette(x7)\n    # Find the color(s) that appear in both halves (should be the background color)\n    x10 = intersection(x8, x9)\n    # Get the first (and only) color from the intersection (the background color)\n    x11 = first(x10)\n    # Get the dimensions of the first half of the grid\n    x12 = shape(x6)\n    # Create a new grid with the background color and the same size as the first half\n    x13 = canvas(x11, x12)\n    # Get the set of colors used in the first half again\n    x14 = palette(x6)\n    # Find the color in the first half that's not the background color\n    x15 = other(x14, x11)\n    # Get the set of colors used in the second half again\n    x16 = palette(x7)\n    # Find the color in the second half that's not the background color\n    x17 = other(x16, x11)\n    # Get the indices of cells with the non-background color in the first half\n    x18 = ofcolor(x6, x15)\n    # Get the indices of cells with the non-background color in the second half\n    x19 = ofcolor(x7, x17)\n    # Combine the indices from both halves\n    x20 = combine(x18, x19)\n    # Fill the new grid with color 3 at the combined indices\n    # This creates the output grid where all colored cells from both halves are now color 3\n    x21 = fill(x13, THREE, x20)\n    # Return the final output grid\n    return x21\n"
  },
  "ce602527": {
    "original": "def verify_ce602527(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = rbind(bordering, I)\n    x2 = extract(x0, x1)\n    x3 = remove(x2, x0)\n    x4 = totuple(x3)\n    x5 = first(x4)\n    x6 = last(x4)\n    x7 = color(x5)\n    x8 = mostcolor(I)\n    x9 = shape(x5)\n    x10 = canvas(x8, x9)\n    x11 = normalize(x5)\n    x12 = paint(x10, x11)\n    x13 = upscale(x12, TWO)\n    x14 = shape(x6)\n    x15 = canvas(x8, x14)\n    x16 = normalize(x6)\n    x17 = paint(x15, x16)\n    x18 = upscale(x17, TWO)\n    x19 = shape(x2)\n    x20 = canvas(x8, x19)\n    x21 = normalize(x2)\n    x22 = paint(x20, x21)\n    x23 = color(x2)\n    x24 = replace(x22, x23, x7)\n    x25 = asobject(x24)\n    x26 = occurrences(x13, x25)\n    x27 = size(x26)\n    x28 = positive(x27)\n    x29 = downscale(x13, TWO)\n    x30 = downscale(x18, TWO)\n    x31 = branch(x28, x29, x30)\n    return x31\n\n",
    "annotated": "def verify_ce602527(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    \n    # Create a function that checks if an object is bordering the input grid\n    x1 = rbind(bordering, I)\n    \n    # Extract the object that is bordering the grid (the partially visible upscaled object)\n    x2 = extract(x0, x1)\n    \n    # Remove the bordering object from the set of foreground objects\n    x3 = remove(x2, x0)\n    \n    # Convert the remaining objects (the two small objects) to a tuple\n    x4 = totuple(x3)\n    \n    # Get the first small object\n    x5 = first(x4)\n    \n    # Get the second small object\n    x6 = last(x4)\n    \n    # Get the color of the first small object\n    x7 = color(x5)\n    \n    # Get the most common color in the input grid (background color)\n    x8 = mostcolor(I)\n    \n    # Get the shape (dimensions) of the first small object\n    x9 = shape(x5)\n    \n    # Create a canvas with the background color and the shape of the first small object\n    x10 = canvas(x8, x9)\n    \n    # Normalize the first small object (move it to the origin)\n    x11 = normalize(x5)\n    \n    # Paint the normalized first small object onto the canvas\n    x12 = paint(x10, x11)\n    \n    # Upscale the painted first small object by a factor of 2\n    x13 = upscale(x12, TWO)\n    \n    # Get the shape (dimensions) of the second small object\n    x14 = shape(x6)\n    \n    # Create a canvas with the background color and the shape of the second small object\n    x15 = canvas(x8, x14)\n    \n    # Normalize the second small object (move it to the origin)\n    x16 = normalize(x6)\n    \n    # Paint the normalized second small object onto the canvas\n    x17 = paint(x15, x16)\n    \n    # Upscale the painted second small object by a factor of 2\n    x18 = upscale(x17, TWO)\n    \n    # Get the shape (dimensions) of the bordering object\n    x19 = shape(x2)\n    \n    # Create a canvas with the background color and the shape of the bordering object\n    x20 = canvas(x8, x19)\n    \n    # Normalize the bordering object (move it to the origin)\n    x21 = normalize(x2)\n    \n    # Paint the normalized bordering object onto the canvas\n    x22 = paint(x20, x21)\n    \n    # Get the color of the bordering object\n    x23 = color(x2)\n    \n    # Replace the color of the bordering object with the color of the first small object\n    x24 = replace(x22, x23, x7)\n    \n    # Convert the recolored bordering object to an object representation\n    x25 = asobject(x24)\n    \n    # Find occurrences of the recolored bordering object in the upscaled first small object\n    x26 = occurrences(x13, x25)\n    \n    # Count the number of occurrences\n    x27 = size(x26)\n    \n    # Check if there are any occurrences (positive count)\n    x28 = positive(x27)\n    \n    # Downscale the upscaled first small object back to its original size\n    x29 = downscale(x13, TWO)\n    \n    # Downscale the upscaled second small object back to its original size\n    x30 = downscale(x18, TWO)\n    \n    # If the recolored bordering object matches the first small object, return the first small object,\n    # otherwise return the second small object\n    x31 = branch(x28, x29, x30)\n    \n    # Return the selected object as the output\n    return x31\n"
  },
  "ce9e57f2": {
    "original": "def verify_ce9e57f2(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = asindices(I)\n    x2 = outbox(x1)\n    x3 = lbind(adjacent, x2)\n    x4 = compose(x3, initset)\n    x5 = rbind(extract, x4)\n    x6 = compose(x5, toindices)\n    x7 = rbind(compose, initset)\n    x8 = lbind(rbind, manhattan)\n    x9 = chain(x7, x8, initset)\n    x10 = lbind(lbind, greater)\n    x11 = chain(x10, halve, size)\n    x12 = compose(x9, x6)\n    x13 = fork(compose, x11, x12)\n    x14 = fork(sfilter, toindices, x13)\n    x15 = mapply(x14, x0)\n    x16 = fill(I, EIGHT, x15)\n    return x16\n\n",
    "annotated": "def verify_ce9e57f2(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    \n    # Get all indices of the input grid\n    x1 = asindices(I)\n    \n    # Find the outer boundary of the grid\n    x2 = outbox(x1)\n    \n    # Create a function that checks if a cell is adjacent to the grid boundary\n    x3 = lbind(adjacent, x2)\n    \n    # Create a function that initializes a set with a single element and checks if it's adjacent to the boundary\n    x4 = compose(x3, initset)\n    \n    # Create a function that extracts the first element satisfying the adjacency condition\n    x5 = rbind(extract, x4)\n    \n    # Create a function that converts an object to indices and finds the first boundary-adjacent cell\n    x6 = compose(x5, toindices)\n    \n    # Create a function that initializes a set with a single element\n    x7 = rbind(compose, initset)\n    \n    # Create a function that calculates the Manhattan distance from a fixed point\n    x8 = lbind(rbind, manhattan)\n    \n    # Chain functions to create a distance calculator from a reference point\n    x9 = chain(x7, x8, initset)\n    \n    # Create a function to check if a value is greater than another\n    x10 = lbind(lbind, greater)\n    \n    # Create a function that checks if an object's size is greater than half its height\n    x11 = chain(x10, halve, size)\n    \n    # Create a function that finds the reference point for distance calculation\n    x12 = compose(x9, x6)\n    \n    # Combine size check and distance calculation functions\n    x13 = fork(compose, x11, x12)\n    \n    # Create a function that filters object cells based on size and distance criteria\n    x14 = fork(sfilter, toindices, x13)\n    \n    # Apply the filtering function to all objects in the grid\n    x15 = mapply(x14, x0)\n    \n    # Fill the filtered cells with color 8 (grey) in the input grid\n    # This effectively greys out the lower half of each vertical bar\n    x16 = fill(I, EIGHT, x15)\n    \n    # Return the modified grid with greyed out lower halves of vertical bars\n    return x16\n"
  },
  "cf98881b": {
    "original": "def verify_cf98881b(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = increment(x0)\n    x2 = divide(x1, THREE)\n    x3 = decrement(x2)\n    x4 = height(I)\n    x5 = astuple(x4, x3)\n    x6 = crop(I, ORIGIN, x5)\n    x7 = add(x3, ONE)\n    x8 = tojvec(x7)\n    x9 = crop(I, x8, x5)\n    x10 = double(x3)\n    x11 = add(x10, TWO)\n    x12 = tojvec(x11)\n    x13 = crop(I, x12, x5)\n    x14 = palette(x6)\n    x15 = palette(x9)\n    x16 = palette(x13)\n    x17 = intersection(x14, x15)\n    x18 = intersection(x17, x16)\n    x19 = first(x18)\n    x20 = other(x14, x19)\n    x21 = other(x15, x19)\n    x22 = other(x16, x19)\n    x23 = canvas(x19, x5)\n    x24 = ofcolor(x6, x20)\n    x25 = ofcolor(x9, x21)\n    x26 = ofcolor(x13, x22)\n    x27 = fill(x23, x22, x26)\n    x28 = fill(x27, x21, x25)\n    x29 = fill(x28, x20, x24)\n    return x29\n\n",
    "annotated": "def verify_cf98881b(I: Grid) -> Grid:\n    # Get the width of the input grid\n    x0 = width(I)\n    # Increment the width by 1 (to account for separator bars)\n    x1 = increment(x0)\n    # Divide the incremented width by 3 to get the width of each section\n    x2 = divide(x1, THREE)\n    # Decrement the section width by 1 (to remove the separator bar)\n    x3 = decrement(x2)\n    # Get the height of the input grid\n    x4 = height(I)\n    # Create a tuple of the grid's height and section width\n    x5 = astuple(x4, x3)\n    # Crop the first section of the input grid\n    x6 = crop(I, ORIGIN, x5)\n    # Calculate the starting column of the second section\n    x7 = add(x3, ONE)\n    # Convert the starting column to a column vector\n    x8 = tojvec(x7)\n    # Crop the second section of the input grid\n    x9 = crop(I, x8, x5)\n    # Calculate the starting column of the third section\n    x10 = double(x3)\n    x11 = add(x10, TWO)\n    # Convert the starting column of the third section to a column vector\n    x12 = tojvec(x11)\n    # Crop the third section of the input grid\n    x13 = crop(I, x12, x5)\n    # Get the color palette of each section\n    x14 = palette(x6)\n    x15 = palette(x9)\n    x16 = palette(x13)\n    # Find the common color (background) across all sections\n    x17 = intersection(x14, x15)\n    x18 = intersection(x17, x16)\n    x19 = first(x18)\n    # Identify the unique color in each section\n    x20 = other(x14, x19)\n    x21 = other(x15, x19)\n    x22 = other(x16, x19)\n    # Create a canvas with the background color\n    x23 = canvas(x19, x5)\n    # Get the indices of colored cells in each section\n    x24 = ofcolor(x6, x20)\n    x25 = ofcolor(x9, x21)\n    x26 = ofcolor(x13, x22)\n    # Fill the canvas with colors from right to left (reverse order of input)\n    # Fill with the color from the third section\n    x27 = fill(x23, x22, x26)\n    # Fill with the color from the second section\n    x28 = fill(x27, x21, x25)\n    # Fill with the color from the first section\n    x29 = fill(x28, x20, x24)\n    # Return the final output grid\n    return x29\n"
  },
  "d037b0a7": {
    "original": "def verify_d037b0a7(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = rbind(shoot, DOWN)\n    x3 = compose(x2, last)\n    x4 = fork(recolor, first, x3)\n    x5 = mapply(x4, x1)\n    x6 = paint(I, x5)\n    return x6\n\n",
    "annotated": "def verify_d037b0a7(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all the objects into a single set of cells\n    x1 = merge(x0)\n    \n    # Create a function that shoots downwards from a given point\n    x2 = rbind(shoot, DOWN)\n    \n    # Create a function that finds the last (bottom-most) point of a downward shoot\n    x3 = compose(x2, last)\n    \n    # Create a function that recolors a cell to its original color and extends it downwards\n    x4 = fork(recolor, first, x3)\n    \n    # Apply the recoloring and extension function to each cell in the merged set\n    # This creates vertical lines from each colored cell to the bottom of the grid\n    x5 = mapply(x4, x1)\n    \n    # Paint the resulting vertical lines onto the original input grid\n    # This creates the final output where each colored cell has been extended downwards\n    x6 = paint(I, x5)\n    \n    # Return the modified grid as the output\n    return x6\n"
  },
  "d06dbe63": {
    "original": "def verify_d06dbe63(I: Grid) -> Grid:\n    x0 = double(TEN)\n    x1 = interval(ZERO, x0, ONE)\n    x2 = connect(ORIGIN, DOWN)\n    x3 = connect(ORIGIN, ZERO_BY_TWO)\n    x4 = combine(x2, x3)\n    x5 = astuple(NEG_TWO, TWO)\n    x6 = lbind(multiply, x5)\n    x7 = toivec(NEG_TWO)\n    x8 = apply(x6, x1)\n    x9 = rbind(subtract, TWO_BY_ZERO)\n    x10 = fork(ofcolor, identity, leastcolor)\n    x11 = chain(x9, center, x10)\n    x12 = rbind(mapply, x8)\n    x13 = lbind(lbind, shift)\n    x14 = lbind(shift, x4)\n    x15 = compose(x14, x11)\n    x16 = chain(x12, x13, x15)\n    x17 = lbind(recolor, FIVE)\n    x18 = compose(x17, x16)\n    x19 = fork(paint, identity, x18)\n    x20 = compose(rot180, x19)\n    x21 = fork(ofcolor, x20, leastcolor)\n    x22 = compose(center, x21)\n    x23 = fork(subtract, x22, x11)\n    x24 = fork(shift, x16, x23)\n    x25 = lbind(recolor, FIVE)\n    x26 = rbind(shift, x7)\n    x27 = chain(x25, x26, x24)\n    x28 = fork(paint, x20, x27)\n    x29 = compose(rot180, x28)\n    x30 = rbind(ofcolor, FIVE)\n    x31 = compose(x30, x29)\n    x32 = leastcolor(I)\n    x33 = ofcolor(I, x32)\n    x34 = mostcolor(I)\n    x35 = shape(I)\n    x36 = canvas(x34, x35)\n    x37 = lbind(paint, x36)\n    x38 = lbind(recolor, x32)\n    x39 = chain(x37, x38, initset)\n    x40 = compose(x31, x39)\n    x41 = mapply(x40, x33)\n    x42 = fill(I, FIVE, x41)\n    x43 = fill(x42, x32, x33)\n    return x43\n\n",
    "annotated": "def verify_d06dbe63(I: Grid) -> Grid:\n    # Double the value 10\n    x0 = double(TEN)\n    # Create a range from 0 to 20 with step 1\n    x1 = interval(ZERO, x0, ONE)\n    # Create a vertical line from origin to (1,0)\n    x2 = connect(ORIGIN, DOWN)\n    # Create a horizontal line from origin to (0,2)\n    x3 = connect(ORIGIN, ZERO_BY_TWO)\n    # Combine the vertical and horizontal lines to form an L shape\n    x4 = combine(x2, x3)\n    # Create a tuple (-2, 2)\n    x5 = astuple(NEG_TWO, TWO)\n    # Partially apply multiply function with (-2, 2)\n    x6 = lbind(multiply, x5)\n    # Create a vertical vector (-2, 0)\n    x7 = toivec(NEG_TWO)\n    # Apply multiplication to the range, creating a set of coordinates\n    x8 = apply(x6, x1)\n    # Partially apply subtract function with (2, 0)\n    x9 = rbind(subtract, TWO_BY_ZERO)\n    # Create a function to get color and identity of least common color\n    x10 = fork(ofcolor, identity, leastcolor)\n    # Chain functions to find center of least common color area and subtract (2,0)\n    x11 = chain(x9, center, x10)\n    # Partially apply mapply function with the coordinate set\n    x12 = rbind(mapply, x8)\n    # Prepare shift function for binding\n    x13 = lbind(lbind, shift)\n    # Partially apply shift function with the L shape\n    x14 = lbind(shift, x4)\n    # Compose functions to shift L shape to center of least common color\n    x15 = compose(x14, x11)\n    # Chain functions to create a set of shifted L shapes\n    x16 = chain(x12, x13, x15)\n    # Partially apply recolor function with color 5\n    x17 = lbind(recolor, FIVE)\n    # Compose functions to recolor the shifted L shapes\n    x18 = compose(x17, x16)\n    # Create a function to paint the recolored L shapes on the input\n    x19 = fork(paint, identity, x18)\n    # Rotate the painted grid 180 degrees\n    x20 = compose(rot180, x19)\n    # Find the least common color in the rotated grid\n    x21 = fork(ofcolor, x20, leastcolor)\n    # Find the center of the least common color area in the rotated grid\n    x22 = compose(center, x21)\n    # Calculate the difference between centers of least common colors\n    x23 = fork(subtract, x22, x11)\n    # Shift the L shapes by the calculated difference\n    x24 = fork(shift, x16, x23)\n    # Prepare to recolor the shifted L shapes with color 5\n    x25 = lbind(recolor, FIVE)\n    # Prepare to shift by (-2, 0)\n    x26 = rbind(shift, x7)\n    # Chain functions to recolor, shift, and apply the L shapes\n    x27 = chain(x25, x26, x24)\n    # Paint the shifted and recolored L shapes on the rotated grid\n    x28 = fork(paint, x20, x27)\n    # Rotate the grid back to its original orientation\n    x29 = compose(rot180, x28)\n    # Prepare to find cells with color 5\n    x30 = rbind(ofcolor, FIVE)\n    # Find all cells with color 5 in the final grid\n    x31 = compose(x30, x29)\n    # Find the least common color in the input grid\n    x32 = leastcolor(I)\n    # Find all cells with the least common color in the input grid\n    x33 = ofcolor(I, x32)\n    # Find the most common color in the input grid (background color)\n    x34 = mostcolor(I)\n    # Get the shape of the input grid\n    x35 = shape(I)\n    # Create a new grid with the background color\n    x36 = canvas(x34, x35)\n    # Prepare to paint on the new grid\n    x37 = lbind(paint, x36)\n    # Prepare to recolor with the least common color\n    x38 = lbind(recolor, x32)\n    # Chain functions to create, paint, and recolor a single cell\n    x39 = chain(x37, x38, initset)\n    # Compose functions to find color 5 cells in the processed grid\n    x40 = compose(x31, x39)\n    # Apply the composed function to all least common color cells\n    x41 = mapply(x40, x33)\n    # Fill the input grid with color 5 where the L shapes were detected\n    x42 = fill(I, FIVE, x41)\n    # Fill the resulting grid with the least common color at original positions\n    x43 = fill(x42, x32, x33)\n    # Return the final processed grid\n    return x43\n"
  },
  "d07ae81c": {
    "original": "def verify_d07ae81c(I: Grid) -> Grid:\n    x0 = lbind(ofcolor, I)\n    x1 = lbind(mapply, neighbors)\n    x2 = compose(x1, x0)\n    x3 = fork(intersection, x0, x2)\n    x4 = compose(size, x3)\n    x5 = palette(I)\n    x6 = matcher(x4, ZERO)\n    x7 = sfilter(x5, x6)\n    x8 = totuple(x7)\n    x9 = first(x8)\n    x10 = last(x8)\n    x11 = ofcolor(I, x9)\n    x12 = mapply(neighbors, x11)\n    x13 = toobject(x12, I)\n    x14 = mostcolor(x13)\n    x15 = ofcolor(I, x10)\n    x16 = mapply(neighbors, x15)\n    x17 = toobject(x16, I)\n    x18 = mostcolor(x17)\n    x19 = rbind(shoot, UNITY)\n    x20 = rbind(shoot, NEG_UNITY)\n    x21 = fork(combine, x19, x20)\n    x22 = rbind(shoot, UP_RIGHT)\n    x23 = rbind(shoot, DOWN_LEFT)\n    x24 = fork(combine, x22, x23)\n    x25 = fork(combine, x21, x24)\n    x26 = ofcolor(I, x10)\n    x27 = ofcolor(I, x9)\n    x28 = combine(x26, x27)\n    x29 = mapply(x25, x28)\n    x30 = ofcolor(I, x14)\n    x31 = intersection(x30, x29)\n    x32 = ofcolor(I, x18)\n    x33 = intersection(x32, x29)\n    x34 = fill(I, x9, x31)\n    x35 = fill(x34, x10, x33)\n    return x35\n\n",
    "annotated": "def verify_d07ae81c(I: Grid) -> Grid:\n    # Create a function that finds cells of a specific color in the input grid\n    x0 = lbind(ofcolor, I)\n    \n    # Create a function that finds neighbors of given cells\n    x1 = lbind(mapply, neighbors)\n    \n    # Compose functions to find neighbors of cells with a specific color\n    x2 = compose(x1, x0)\n    \n    # Create a function to find isolated cells of a specific color (no neighbors of same color)\n    x3 = fork(intersection, x0, x2)\n    \n    # Create a function to count the number of isolated cells of a color\n    x4 = compose(size, x3)\n    \n    # Get the palette (unique colors) of the input grid\n    x5 = palette(I)\n    \n    # Create a function to check if a color has zero isolated cells\n    x6 = matcher(x4, ZERO)\n    \n    # Filter the palette to keep only colors with zero isolated cells\n    x7 = sfilter(x5, x6)\n    \n    # Convert the filtered palette to a tuple\n    x8 = totuple(x7)\n    \n    # Get the first color (source color 1)\n    x9 = first(x8)\n    \n    # Get the last color (source color 2)\n    x10 = last(x8)\n    \n    # Find all cells of source color 1\n    x11 = ofcolor(I, x9)\n    \n    # Find neighbors of all cells of source color 1\n    x12 = mapply(neighbors, x11)\n    \n    # Create an object from these neighbors in the input grid\n    x13 = toobject(x12, I)\n    \n    # Find the most common color in this object (target color 1)\n    x14 = mostcolor(x13)\n    \n    # Find all cells of source color 2\n    x15 = ofcolor(I, x10)\n    \n    # Find neighbors of all cells of source color 2\n    x16 = mapply(neighbors, x15)\n    \n    # Create an object from these neighbors in the input grid\n    x17 = toobject(x16, I)\n    \n    # Find the most common color in this object (target color 2)\n    x18 = mostcolor(x17)\n    \n    # Create a function to shoot a line in the (1,1) direction\n    x19 = rbind(shoot, UNITY)\n    \n    # Create a function to shoot a line in the (-1,-1) direction\n    x20 = rbind(shoot, NEG_UNITY)\n    \n    # Combine the two diagonal line functions\n    x21 = fork(combine, x19, x20)\n    \n    # Create a function to shoot a line in the (-1,1) direction\n    x22 = rbind(shoot, UP_RIGHT)\n    \n    # Create a function to shoot a line in the (1,-1) direction\n    x23 = rbind(shoot, DOWN_LEFT)\n    \n    # Combine the two diagonal line functions\n    x24 = fork(combine, x22, x23)\n    \n    # Combine all four diagonal line functions\n    x25 = fork(combine, x21, x24)\n    \n    # Find all cells of source color 2\n    x26 = ofcolor(I, x10)\n    \n    # Find all cells of source color 1\n    x27 = ofcolor(I, x9)\n    \n    # Combine cells of both source colors\n    x28 = combine(x26, x27)\n    \n    # Shoot diagonal lines from all source color cells\n    x29 = mapply(x25, x28)\n    \n    # Find all cells of target color 1\n    x30 = ofcolor(I, x14)\n    \n    # Find intersection of target color 1 cells and diagonal lines\n    x31 = intersection(x30, x29)\n    \n    # Find all cells of target color 2\n    x32 = ofcolor(I, x18)\n    \n    # Find intersection of target color 2 cells and diagonal lines\n    x33 = intersection(x32, x29)\n    \n    # Fill the intersections of target color 1 with source color 1\n    x34 = fill(I, x9, x31)\n    \n    # Fill the intersections of target color 2 with source color 2\n    x35 = fill(x34, x10, x33)\n    \n    # Return the final transformed grid\n    return x35\n"
  },
  "d0f5fe59": {
    "original": "def verify_d0f5fe59(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = size(x0)\n    x2 = astuple(x1, x1)\n    x3 = mostcolor(I)\n    x4 = canvas(x3, x2)\n    x5 = shoot(ORIGIN, UNITY)\n    x6 = leastcolor(I)\n    x7 = fill(x4, x6, x5)\n    return x7\n\n",
    "annotated": "def verify_d0f5fe59(I: Grid) -> Grid:\n    # Extract all objects from the input grid I, considering diagonally adjacent cells as part of the same object\n    # and excluding the background color\n    x0 = objects(I, T, F, T)\n    \n    # Count the number of objects found in the input grid\n    x1 = size(x0)\n    \n    # Create a tuple (n, n) where n is the number of objects, to be used as dimensions for the output grid\n    x2 = astuple(x1, x1)\n    \n    # Determine the most common color in the input grid (background color)\n    x3 = mostcolor(I)\n    \n    # Create a new grid filled with the background color, with dimensions equal to the number of objects\n    x4 = canvas(x3, x2)\n    \n    # Generate a line of indices starting from (0,0) and moving diagonally to the bottom-right corner\n    x5 = shoot(ORIGIN, UNITY)\n    \n    # Determine the least common color in the input grid (foreground color used for objects)\n    x6 = leastcolor(I)\n    \n    # Fill the diagonal line on the output grid with the foreground color\n    # This creates a diagonal line from top-left to bottom-right\n    x7 = fill(x4, x6, x5)\n    \n    # Return the final output grid\n    return x7\n"
  },
  "d10ecb37": {
    "original": "def verify_d10ecb37(I: Grid) -> Grid:\n    x0 = crop(I, ORIGIN, TWO_BY_TWO)\n    return x0\n\n",
    "annotated": "def verify_d10ecb37(I: Grid) -> Grid:\n    # Extract the top-left 2x2 subgrid from the input grid I\n    # ORIGIN is (0, 0) and TWO_BY_TWO is (2, 2)\n    # This effectively crops out the top-left corner of the input grid\n    x0 = crop(I, ORIGIN, TWO_BY_TWO)\n    \n    # Return the extracted 2x2 subgrid as the output\n    # This operation preserves the colors and arrangement of the top-left corner of the input grid\n    return x0\n"
  },
  "d13f3404": {
    "original": "def verify_d13f3404(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = mostcolor(I)\n    x2 = matcher(first, x1)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x0, x3)\n    x5 = apply(initset, x4)\n    x6 = rbind(shoot, UNITY)\n    x7 = compose(x6, center)\n    x8 = fork(recolor, color, x7)\n    x9 = mapply(x8, x5)\n    x10 = shape(I)\n    x11 = double(x10)\n    x12 = mostcolor(I)\n    x13 = canvas(x12, x11)\n    x14 = paint(x13, x9)\n    return x14\n\n",
    "annotated": "def verify_d13f3404(I: Grid) -> Grid:\n    # Convert the input grid to an object (set of (color, position) tuples)\n    x0 = asobject(I)\n    \n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Create a function that checks if the first element of a tuple is NOT the background color\n    x2 = matcher(first, x1)\n    x3 = compose(flip, x2)\n    \n    # Filter the object to keep only non-background colored cells\n    x4 = sfilter(x0, x3)\n    \n    # Convert each remaining cell to a single-element set\n    x5 = apply(initset, x4)\n    \n    # Create a function that shoots a diagonal line in the (1,1) direction\n    x6 = rbind(shoot, UNITY)\n    \n    # Create a function that finds the center of a patch and then shoots a diagonal line from it\n    x7 = compose(x6, center)\n    \n    # Create a function that recolors a diagonal line with the original cell's color\n    x8 = fork(recolor, color, x7)\n    \n    # Apply the recoloring function to each non-background cell, creating diagonal lines\n    x9 = mapply(x8, x5)\n    \n    # Get the shape (dimensions) of the input grid\n    x10 = shape(I)\n    \n    # Double the dimensions of the input grid\n    x11 = double(x10)\n    \n    # Get the background color of the input grid\n    x12 = mostcolor(I)\n    \n    # Create a new canvas with doubled dimensions and the same background color\n    x13 = canvas(x12, x11)\n    \n    # Paint the diagonal lines onto the new canvas, creating the output grid\n    x14 = paint(x13, x9)\n    \n    # Return the final output grid\n    return x14\n"
  },
  "d22278a0": {
    "original": "def verify_d22278a0(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = repeat(NEG_ONE, ONE)\n    x4 = combine(x2, x3)\n    x5 = multiply(TEN, TEN)\n    x6 = apply(center, x1)\n    x7 = astuple(x5, x5)\n    x8 = repeat(x7, ONE)\n    x9 = combine(x6, x8)\n    x10 = identity(I)\n    x11 = asindices(I)\n    x12 = shape(I)\n    x13 = maximum(x12)\n    x14 = halve(x13)\n    x15 = add(TWO, x14)\n    x16 = interval(ONE, x15, ONE)\n    x17 = compose(outbox, outbox)\n    x18 = lbind(power, x17)\n    x19 = apply(x18, x16)\n    x20 = lbind(rapply, x19)\n    x21 = chain(merge, x20, initset)\n    x22 = fork(combine, initset, x21)\n    x23 = lbind(rbind, manhattan)\n    x24 = rbind(chain, initset)\n    x25 = rbind(x24, x23)\n    x26 = lbind(rbind, apply)\n    x27 = lbind(apply, initset)\n    x28 = rbind(remove, x9)\n    x29 = chain(x25, x26, x27)\n    x30 = chain(x29, x28, last)\n    x31 = lbind(sfilter, x11)\n    x32 = rbind(compose, initset)\n    x33 = lbind(compose, minimum)\n    x34 = lbind(fork, greater)\n    x35 = compose(x33, x30)\n    x36 = compose(initset, last)\n    x37 = chain(x32, x23, x36)\n    x38 = fork(x34, x35, x37)\n    x39 = compose(x31, x38)\n    x40 = compose(x22, last)\n    x41 = fork(intersection, x39, x40)\n    x42 = fork(recolor, first, x41)\n    x43 = pair(x4, x9)\n    x44 = mapply(x42, x43)\n    x45 = paint(x10, x44)\n    return x45\n\n",
    "annotated": "def verify_d22278a0(I: Grid) -> Grid:\n    # Extract objects from the input grid, considering diagonal connections and ignoring the background\n    x0 = objects(I, T, F, T)\n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    # Extract the color of each object\n    x2 = apply(color, x1)\n    # Create a tuple with a single element -1\n    x3 = repeat(NEG_ONE, ONE)\n    # Combine the colors of objects with -1 (possibly to mark the end or for comparison)\n    x4 = combine(x2, x3)\n    # Calculate 100 (10 * 10)\n    x5 = multiply(TEN, TEN)\n    # Find the center of each object\n    x6 = apply(center, x1)\n    # Create a tuple (100, 100)\n    x7 = astuple(x5, x5)\n    # Create a tuple containing (100, 100)\n    x8 = repeat(x7, ONE)\n    # Combine the centers of objects with (100, 100) (possibly to set a maximum boundary)\n    x9 = combine(x6, x8)\n    # Create a copy of the input grid\n    x10 = identity(I)\n    # Get all indices of the input grid\n    x11 = asindices(I)\n    # Get the dimensions of the input grid\n    x12 = shape(I)\n    # Find the maximum dimension of the grid\n    x13 = maximum(x12)\n    # Halve the maximum dimension\n    x14 = halve(x13)\n    # Add 2 to the halved maximum dimension\n    x15 = add(TWO, x14)\n    # Create a range from 1 to (max_dim/2 + 2)\n    x16 = interval(ONE, x15, ONE)\n    # Create a function that applies outbox twice\n    x17 = compose(outbox, outbox)\n    # Create a function that raises x17 to a power\n    x18 = lbind(power, x17)\n    # Apply x18 to each value in x16, creating expanding \"rings\"\n    x19 = apply(x18, x16)\n    # Create a function that applies each function in x19 to a value\n    x20 = lbind(rapply, x19)\n    # Create a chain of functions: merge -> x20 -> initset\n    x21 = chain(merge, x20, initset)\n    # Create a function that combines initset and x21\n    x22 = fork(combine, initset, x21)\n    # Prepare a function for calculating Manhattan distance\n    x23 = lbind(rbind, manhattan)\n    # Chain of functions to prepare for distance calculations\n    x24 = rbind(chain, initset)\n    x25 = rbind(x24, x23)\n    x26 = lbind(rbind, apply)\n    x27 = lbind(apply, initset)\n    x28 = rbind(remove, x9)\n    x29 = chain(x25, x26, x27)\n    x30 = chain(x29, x28, last)\n    # Create a function to filter indices\n    x31 = lbind(sfilter, x11)\n    # Chain of functions to prepare for comparison\n    x32 = rbind(compose, initset)\n    x33 = lbind(compose, minimum)\n    x34 = lbind(fork, greater)\n    x35 = compose(x33, x30)\n    x36 = compose(initset, last)\n    x37 = chain(x32, x23, x36)\n    x38 = fork(x34, x35, x37)\n    # Create a function that filters indices based on distance comparison\n    x39 = compose(x31, x38)\n    # Get the last expanding \"ring\"\n    x40 = compose(x22, last)\n    # Create a function that intersects filtered indices with the last ring\n    x41 = fork(intersection, x39, x40)\n    # Create a function that recolors based on the first color and filtered indices\n    x42 = fork(recolor, first, x41)\n    # Pair colors with object centers\n    x43 = pair(x4, x9)\n    # Apply the recoloring function to each color-center pair\n    x44 = mapply(x42, x43)\n    # Paint the recolored objects onto the copy of the input grid\n    x45 = paint(x10, x44)\n    # Return the final painted grid\n    return x45\n"
  },
  "d23f8c26": {
    "original": "def verify_d23f8c26(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = matcher(first, x0)\n    x2 = compose(flip, x1)\n    x3 = width(I)\n    x4 = halve(x3)\n    x5 = compose(last, last)\n    x6 = matcher(x5, x4)\n    x7 = compose(flip, x6)\n    x8 = asobject(I)\n    x9 = fork(both, x2, x7)\n    x10 = sfilter(x8, x9)\n    x11 = fill(I, x0, x10)\n    return x11\n\n",
    "annotated": "def verify_d23f8c26(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Create a function that checks if the first element of a tuple is the background color\n    x1 = matcher(first, x0)\n    \n    # Create a function that returns True if the first element is not the background color\n    x2 = compose(flip, x1)\n    \n    # Get the width of the input grid\n    x3 = width(I)\n    \n    # Calculate half the width of the input grid\n    x4 = halve(x3)\n    \n    # Create a function that gets the last element of the last element (rightmost column index)\n    x5 = compose(last, last)\n    \n    # Create a function that checks if the rightmost column index is equal to half the width\n    x6 = matcher(x5, x4)\n    \n    # Create a function that returns True if the rightmost column index is not equal to half the width\n    x7 = compose(flip, x6)\n    \n    # Convert the input grid to an object (set of (color, position) tuples)\n    x8 = asobject(I)\n    \n    # Create a function that checks if a cell is both non-background color and not in the middle column\n    x9 = fork(both, x2, x7)\n    \n    # Filter the grid object to keep only cells that satisfy the condition in x9\n    x10 = sfilter(x8, x9)\n    \n    # Fill the filtered cells with the background color, effectively removing them\n    # This keeps only the middle column and background cells intact\n    x11 = fill(I, x0, x10)\n    \n    # Return the modified grid, which is the solution to the puzzle\n    return x11\n"
  },
  "d2abd087": {
    "original": "def verify_d2abd087(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = matcher(size, SIX)\n    x2 = compose(flip, x1)\n    x3 = mfilter(x0, x1)\n    x4 = mfilter(x0, x2)\n    x5 = fill(I, TWO, x3)\n    x6 = fill(x5, ONE, x4)\n    return x6\n\n",
    "annotated": "def verify_d2abd087(I: Grid) -> Grid:\n    # Get all objects in the input grid, allowing diagonal connections and excluding background\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that checks if an object has exactly 6 cells\n    x1 = matcher(size, SIX)\n    \n    # Create a function that checks if an object does NOT have 6 cells\n    x2 = compose(flip, x1)\n    \n    # Filter objects with exactly 6 cells\n    x3 = mfilter(x0, x1)\n    \n    # Filter objects that do not have 6 cells\n    x4 = mfilter(x0, x2)\n    \n    # Fill the input grid with color 2 for objects with 6 cells\n    # This marks all 6-cell objects on the board\n    x5 = fill(I, TWO, x3)\n    \n    # Fill the previous result with color 1 for objects not having 6 cells\n    # This completes the board by marking all other objects with 1\n    x6 = fill(x5, ONE, x4)\n    \n    # Return the final grid where 6-cell objects are colored 2 and others are colored 1\n    return x6\n"
  },
  "d364b489": {
    "original": "def verify_d364b489(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = toindices(x1)\n    x3 = shift(x2, DOWN)\n    x4 = fill(I, EIGHT, x3)\n    x5 = shift(x2, UP)\n    x6 = fill(x4, TWO, x5)\n    x7 = shift(x2, RIGHT)\n    x8 = fill(x6, SIX, x7)\n    x9 = shift(x2, LEFT)\n    x10 = fill(x8, SEVEN, x9)\n    return x10\n\n",
    "annotated": "def verify_d364b489(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all foreground objects into a single object\n    x1 = merge(x0)\n    \n    # Extract the indices of all foreground cells\n    x2 = toindices(x1)\n    \n    # Shift the foreground cells one step down\n    x3 = shift(x2, DOWN)\n    \n    # Fill the cells below the original foreground cells with color 8 (dark green)\n    x4 = fill(I, EIGHT, x3)\n    \n    # Shift the foreground cells one step up\n    x5 = shift(x2, UP)\n    \n    # Fill the cells above the original foreground cells with color 2 (red)\n    x6 = fill(x4, TWO, x5)\n    \n    # Shift the foreground cells one step right\n    x7 = shift(x2, RIGHT)\n    \n    # Fill the cells to the right of the original foreground cells with color 6 (pink)\n    x8 = fill(x6, SIX, x7)\n    \n    # Shift the foreground cells one step left\n    x9 = shift(x2, LEFT)\n    \n    # Fill the cells to the left of the original foreground cells with color 7 (orange)\n    x10 = fill(x8, SEVEN, x9)\n    \n    # Return the final grid with colored cells surrounding the original foreground cells\n    return x10\n"
  },
  "d406998b": {
    "original": "def verify_d406998b(I: Grid) -> Grid:\n    x0 = vmirror(I)\n    x1 = fgpartition(x0)\n    x2 = merge(x1)\n    x3 = toindices(x2)\n    x4 = compose(double, halve)\n    x5 = fork(equality, identity, x4)\n    x6 = compose(x5, last)\n    x7 = sfilter(x3, x6)\n    x8 = fill(x0, THREE, x7)\n    x9 = vmirror(x8)\n    return x9\n\n",
    "annotated": "def verify_d406998b(I: Grid) -> Grid:\n    # Mirror the input grid horizontally\n    x0 = vmirror(I)\n    \n    # Partition the mirrored grid into objects, excluding the background color\n    x1 = fgpartition(x0)\n    \n    # Merge all objects into a single set of cells\n    x2 = merge(x1)\n    \n    # Extract the indices (coordinates) of all non-background cells\n    x3 = toindices(x2)\n    \n    # Create a function that doubles a number and then halves it (effectively rounding to even)\n    x4 = compose(double, halve)\n    \n    # Create a function that checks if a number is equal to its rounded even value\n    x5 = fork(equality, identity, x4)\n    \n    # Create a function that applies x5 to the last element (column index) of a coordinate\n    x6 = compose(x5, last)\n    \n    # Filter the indices, keeping only those with even column indices\n    x7 = sfilter(x3, x6)\n    \n    # Fill the filtered indices with color 3 (THREE) in the mirrored grid\n    x8 = fill(x0, THREE, x7)\n    \n    # Mirror the result back horizontally to match the original orientation\n    x9 = vmirror(x8)\n    \n    # Return the final transformed grid\n    return x9\n\n# In essence, this function:\n# 1. Mirrors the input grid\n# 2. Identifies all non-background dots\n# 3. Changes the color of dots in even-indexed columns (from right) to color 3\n# 4. Mirrors the grid back to its original orientation\n"
  },
  "d43fd935": {
    "original": "def verify_d43fd935(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = asobject(I)\n    x2 = matcher(first, x0)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x1, x3)\n    x5 = partition(I)\n    x6 = fork(multiply, height, width)\n    x7 = fork(equality, size, x6)\n    x8 = sfilter(x5, x7)\n    x9 = argmax(x8, size)\n    x10 = difference(x4, x9)\n    x11 = apply(initset, x10)\n    x12 = rbind(hmatching, x9)\n    x13 = rbind(vmatching, x9)\n    x14 = fork(either, x12, x13)\n    x15 = sfilter(x11, x14)\n    x16 = rbind(gravitate, x9)\n    x17 = fork(add, center, x16)\n    x18 = fork(connect, center, x17)\n    x19 = fork(recolor, color, x18)\n    x20 = mapply(x19, x15)\n    x21 = paint(I, x20)\n    return x21\n\n",
    "annotated": "def verify_d43fd935(I: Grid) -> Grid:\n    # Find the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Convert the input grid to an object representation\n    x1 = asobject(I)\n    \n    # Create a matcher function that checks if a cell's color is the background color\n    x2 = matcher(first, x0)\n    \n    # Invert the matcher function to check for non-background colors\n    x3 = compose(flip, x2)\n    \n    # Filter out all non-background colored cells from the grid object\n    x4 = sfilter(x1, x3)\n    \n    # Partition the input grid into objects based on color\n    x5 = partition(I)\n    \n    # Create a function that multiplies height and width\n    x6 = fork(multiply, height, width)\n    \n    # Create a function that checks if an object's size equals its bounding box area\n    x7 = fork(equality, size, x6)\n    \n    # Filter objects that fill their bounding box completely (likely the central box)\n    x8 = sfilter(x5, x7)\n    \n    # Find the largest object among the filtered objects (the central box)\n    x9 = argmax(x8, size)\n    \n    # Get all non-background cells that are not part of the central box\n    x10 = difference(x4, x9)\n    \n    # Convert each cell outside the central box into a single-element set\n    x11 = apply(initset, x10)\n    \n    # Create a function to check if a cell horizontally aligns with the central box\n    x12 = rbind(hmatching, x9)\n    \n    # Create a function to check if a cell vertically aligns with the central box\n    x13 = rbind(vmatching, x9)\n    \n    # Combine horizontal and vertical alignment checks with logical OR\n    x14 = fork(either, x12, x13)\n    \n    # Filter cells that align either horizontally or vertically with the central box\n    x15 = sfilter(x11, x14)\n    \n    # Create a function to find the gravitation direction towards the central box\n    x16 = rbind(gravitate, x9)\n    \n    # Create a function to find the endpoint of a line from a cell to the central box\n    x17 = fork(add, center, x16)\n    \n    # Create a function to generate a line from a cell to the central box\n    x18 = fork(connect, center, x17)\n    \n    # Create a function to color the generated line with the cell's color\n    x19 = fork(recolor, color, x18)\n    \n    # Apply the line-drawing function to all aligned cells and merge results\n    x20 = mapply(x19, x15)\n    \n    # Paint the generated lines onto the input grid to create the output\n    x21 = paint(I, x20)\n    \n    # Return the modified grid as the output\n    return x21\n"
  },
  "d4469b4b": {
    "original": "def verify_d4469b4b(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = contained(ONE, x0)\n    x2 = contained(TWO, x0)\n    x3 = branch(x1, UNITY, TWO_BY_TWO)\n    x4 = branch(x2, RIGHT, x3)\n    x5 = fork(combine, vfrontier, hfrontier)\n    x6 = x5(x4)\n    x7 = canvas(ZERO, THREE_BY_THREE)\n    x8 = fill(x7, FIVE, x6)\n    return x8\n\n",
    "annotated": "def verify_d4469b4b(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Check if color 1 is present in the input grid\n    x1 = contained(ONE, x0)\n    \n    # Check if color 2 is present in the input grid\n    x2 = contained(TWO, x0)\n    \n    # If color 1 is present, use (1,1) as dimensions, else use (2,2)\n    # This determines which pattern (B or A) to use\n    x3 = branch(x1, UNITY, TWO_BY_TWO)\n    \n    # If color 2 is present, use (0,1) as dimensions, else use the result from x3\n    # This determines which pattern (A, B, or C) to use based on input colors\n    x4 = branch(x2, RIGHT, x3)\n    \n    # Create a function that combines vertical and horizontal frontiers\n    # This will be used to determine the positions of 0s in the output\n    x5 = fork(combine, vfrontier, hfrontier)\n    \n    # Apply the frontier function to the dimensions determined earlier\n    # This creates the set of indices where 0s should be placed in the output\n    x6 = x5(x4)\n    \n    # Create a 3x3 canvas filled with 0s\n    x7 = canvas(ZERO, THREE_BY_THREE)\n    \n    # Fill the canvas with 5s at the positions determined by x6\n    # This creates the final output pattern (A, B, or C) based on the input colors\n    x8 = fill(x7, FIVE, x6)\n    \n    # Return the final 3x3 output grid\n    return x8\n"
  },
  "d4a91cb9": {
    "original": "def verify_d4a91cb9(I: Grid) -> Grid:\n    x0 = ofcolor(I, EIGHT)\n    x1 = ofcolor(I, TWO)\n    x2 = first(x0)\n    x3 = first(x1)\n    x4 = last(x2)\n    x5 = first(x3)\n    x6 = astuple(x5, x4)\n    x7 = connect(x6, x2)\n    x8 = connect(x6, x3)\n    x9 = combine(x7, x8)\n    x10 = underfill(I, FOUR, x9)\n    return x10\n\n",
    "annotated": "def verify_d4a91cb9(I: Grid) -> Grid:\n    # Find all cells with color 8 (green dot)\n    x0 = ofcolor(I, EIGHT)\n    \n    # Find all cells with color 2 (red dot)\n    x1 = ofcolor(I, TWO)\n    \n    # Get the first (and only) green dot cell\n    x2 = first(x0)\n    \n    # Get the first (and only) red dot cell\n    x3 = first(x1)\n    \n    # Get the column index of the green dot\n    x4 = last(x2)\n    \n    # Get the row index of the red dot\n    x5 = first(x3)\n    \n    # Create a tuple with the row of the red dot and column of the green dot\n    # This represents the \"corner\" where the line should bend\n    x6 = astuple(x5, x4)\n    \n    # Create a line from the corner to the green dot\n    x7 = connect(x6, x2)\n    \n    # Create a line from the corner to the red dot\n    x8 = connect(x6, x3)\n    \n    # Combine both lines to form the complete path\n    x9 = combine(x7, x8)\n    \n    # Fill the path with color 4 (blue) on the input grid,\n    # but only where the background color is present\n    x10 = underfill(I, FOUR, x9)\n    \n    # Return the modified grid with the blue line drawn\n    return x10\n"
  },
  "d4f3cd78": {
    "original": "def verify_d4f3cd78(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = toindices(x1)\n    x3 = box(x2)\n    x4 = difference(x3, x2)\n    x5 = inbox(x2)\n    x6 = backdrop(x5)\n    x7 = lbind(position, x6)\n    x8 = compose(x7, initset)\n    x9 = lowermost(x6)\n    x10 = rightmost(x6)\n    x11 = uppermost(x6)\n    x12 = leftmost(x6)\n    x13 = rbind(greater, x9)\n    x14 = compose(x13, first)\n    x15 = lbind(greater, x11)\n    x16 = compose(x15, first)\n    x17 = rbind(greater, x10)\n    x18 = compose(x17, last)\n    x19 = lbind(greater, x12)\n    x20 = compose(x19, last)\n    x21 = compose(invert, x16)\n    x22 = fork(add, x14, x21)\n    x23 = compose(invert, x20)\n    x24 = fork(add, x18, x23)\n    x25 = fork(astuple, x22, x24)\n    x26 = fork(shoot, identity, x25)\n    x27 = mapply(x26, x4)\n    x28 = combine(x27, x6)\n    x29 = fill(I, EIGHT, x28)\n    return x29\n\n",
    "annotated": "def verify_d4f3cd78(I: Grid) -> Grid:\n    # Get all non-background objects from the input grid\n    x0 = fgpartition(I)\n    # Merge all non-background objects into a single object\n    x1 = merge(x0)\n    # Convert the merged object to a set of indices\n    x2 = toindices(x1)\n    # Get the outline (box) of the merged object\n    x3 = box(x2)\n    # Find the holes in the outline by subtracting the object from its box\n    x4 = difference(x3, x2)\n    # Get the inner box (one cell inside the outline)\n    x5 = inbox(x2)\n    # Get all cells inside the inner box\n    x6 = backdrop(x5)\n    # Create a function to find the position relative to the inner area\n    x7 = lbind(position, x6)\n    # Create a function to initialize a set with a single position\n    x8 = compose(x7, initset)\n    # Find the lowermost row of the inner area\n    x9 = lowermost(x6)\n    # Find the rightmost column of the inner area\n    x10 = rightmost(x6)\n    # Find the uppermost row of the inner area\n    x11 = uppermost(x6)\n    # Find the leftmost column of the inner area\n    x12 = leftmost(x6)\n    # Create a function to check if a row is below the inner area\n    x13 = rbind(greater, x9)\n    # Create a function to get the vertical direction (down)\n    x14 = compose(x13, first)\n    # Create a function to check if a row is above the inner area\n    x15 = lbind(greater, x11)\n    # Create a function to get the vertical direction (up)\n    x16 = compose(x15, first)\n    # Create a function to check if a column is right of the inner area\n    x17 = rbind(greater, x10)\n    # Create a function to get the horizontal direction (right)\n    x18 = compose(x17, last)\n    # Create a function to check if a column is left of the inner area\n    x19 = lbind(greater, x12)\n    # Create a function to get the horizontal direction (left)\n    x20 = compose(x19, last)\n    # Invert the up direction to get a consistent sign\n    x21 = compose(invert, x16)\n    # Combine up/down directions\n    x22 = fork(add, x14, x21)\n    # Invert the left direction to get a consistent sign\n    x23 = compose(invert, x20)\n    # Combine left/right directions\n    x24 = fork(add, x18, x23)\n    # Create a tuple of vertical and horizontal directions\n    x25 = fork(astuple, x22, x24)\n    # Create a function to shoot a line from a point in the calculated direction\n    x26 = fork(shoot, identity, x25)\n    # Apply the shooting function to all holes in the outline\n    x27 = mapply(x26, x4)\n    # Combine the shot lines with the inner area\n    x28 = combine(x27, x6)\n    # Fill the combined area with color 8 (EIGHT) on the input grid\n    x29 = fill(I, EIGHT, x28)\n    # Return the modified grid as the output\n    return x29\n"
  },
  "d511f180": {
    "original": "def verify_d511f180(I: Grid) -> Grid:\n    x0 = switch(I, FIVE, EIGHT)\n    return x0\n\n",
    "annotated": "def verify_d511f180(I: Grid) -> Grid:\n    # Switch all occurrences of 5 (FIVE) with 8 (EIGHT) and vice versa in the input grid I\n    # This effectively swaps the background colors (grey and blue) while leaving other colors unchanged\n    x0 = switch(I, FIVE, EIGHT)\n    \n    # Return the modified grid\n    # The output grid is identical to the input, except for the swapped background colors\n    return x0\n"
  },
  "d5d6de2d": {
    "original": "def verify_d5d6de2d(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = merge(x0)\n    x2 = cover(I, x1)\n    x3 = mapply(delta, x0)\n    x4 = fill(x2, THREE, x3)\n    return x4\n\n",
    "annotated": "def verify_d5d6de2d(I: Grid) -> Grid:\n    # Identify all objects in the input grid I, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Merge all identified objects into a single set of cells\n    x1 = merge(x0)\n    \n    # Create a new grid by covering (removing) all identified objects from the input grid\n    # This effectively leaves only the background color\n    x2 = cover(I, x1)\n    \n    # For each object, find the cells within its bounding box that are not part of the object itself\n    # This creates a set of \"inner\" cells for each object\n    x3 = mapply(delta, x0)\n    \n    # Fill the inner cells of each object with color 3 (THREE) on the background grid\n    # This creates the final output where object interiors are filled with color 3\n    x4 = fill(x2, THREE, x3)\n    \n    # Return the final grid with object interiors filled\n    return x4\n"
  },
  "d631b094": {
    "original": "def verify_d631b094(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = other(x0, ZERO)\n    x2 = colorcount(I, x1)\n    x3 = astuple(ONE, x2)\n    x4 = canvas(x1, x3)\n    return x4\n\n",
    "annotated": "def verify_d631b094(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Find the non-zero color (foreground color) from the palette\n    # This assumes there are only two colors: 0 (background) and another color\n    x1 = other(x0, ZERO)\n    \n    # Count the number of cells with the foreground color in the input grid\n    x2 = colorcount(I, x1)\n    \n    # Create a tuple representing the dimensions of the output grid (1 row, x2 columns)\n    x3 = astuple(ONE, x2)\n    \n    # Create a new grid (canvas) with the dimensions from x3, filled with the foreground color\n    # This effectively creates a 1xN grid where N is the count of foreground cells in the input\n    x4 = canvas(x1, x3)\n    \n    # Return the created grid, which represents a condensed version of the input\n    # where all foreground cells are moved to a single row\n    return x4\n"
  },
  "d687bc17": {
    "original": "def verify_d687bc17(I: Grid) -> Grid:\n    x0 = trim(I)\n    x1 = asobject(x0)\n    x2 = shift(x1, UNITY)\n    x3 = apply(initset, x2)\n    x4 = toindices(x2)\n    x5 = asindices(I)\n    x6 = corners(x5)\n    x7 = combine(x4, x6)\n    x8 = fill(I, NEG_ONE, x7)\n    x9 = fgpartition(x8)\n    x10 = asindices(I)\n    x11 = corners(x10)\n    x12 = toobject(x11, I)\n    x13 = combine(x2, x12)\n    x14 = mostcolor(x13)\n    x15 = fill(x8, x14, x7)\n    x16 = apply(color, x9)\n    x17 = rbind(contained, x16)\n    x18 = compose(x17, color)\n    x19 = sfilter(x3, x18)\n    x20 = lbind(colorfilter, x9)\n    x21 = chain(first, x20, color)\n    x22 = fork(gravitate, identity, x21)\n    x23 = fork(shift, identity, x22)\n    x24 = mapply(x23, x19)\n    x25 = paint(x15, x24)\n    return x25\n\n",
    "annotated": "def verify_d687bc17(I: Grid) -> Grid:\n    # Remove the outer border of the input grid\n    x0 = trim(I)\n    # Convert the trimmed grid to an object representation\n    x1 = asobject(x0)\n    # Shift all cells in the object by (1,1), effectively moving them down and right\n    x2 = shift(x1, UNITY)\n    # Create a set of single-element sets for each cell in the shifted object\n    x3 = apply(initset, x2)\n    # Get the indices of all cells in the shifted object\n    x4 = toindices(x2)\n    # Get all indices of the original input grid\n    x5 = asindices(I)\n    # Find the corner indices of the original grid\n    x6 = corners(x5)\n    # Combine the shifted indices and corner indices\n    x7 = combine(x4, x6)\n    # Fill the cells at the combined indices with -1 in the input grid\n    # This effectively creates a new border and removes the old one\n    x8 = fill(I, NEG_ONE, x7)\n    # Partition the grid into objects, excluding the background color\n    x9 = fgpartition(x8)\n    # Get all indices of the original input grid (again)\n    x10 = asindices(I)\n    # Find the corner indices of the original grid (again)\n    x11 = corners(x10)\n    # Create an object representation of the corners using their original colors\n    x12 = toobject(x11, I)\n    # Combine the shifted object and the corner object\n    x13 = combine(x2, x12)\n    # Find the most common color in the combined object (likely the background color)\n    x14 = mostcolor(x13)\n    # Fill the cells at the combined indices with the most common color\n    # This restores the background color to the new border\n    x15 = fill(x8, x14, x7)\n    # Get the colors of all partitioned objects\n    x16 = apply(color, x9)\n    # Create a function that checks if a color is in the set of object colors\n    x17 = rbind(contained, x16)\n    # Create a function that checks if an object's color is in the set of object colors\n    x18 = compose(x17, color)\n    # Filter the set of single-element sets to keep only those with colors in the object set\n    x19 = sfilter(x3, x18)\n    # Create a function that filters objects by color\n    x20 = lbind(colorfilter, x9)\n    # Create a function that gets the first object of a specific color\n    x21 = chain(first, x20, color)\n    # Create a function that calculates the gravitation direction for each object\n    x22 = fork(gravitate, identity, x21)\n    # Create a function that shifts each object based on its gravitation direction\n    x23 = fork(shift, identity, x22)\n    # Apply the shift function to all filtered objects\n    # This moves each colored dot to its correct position on the border\n    x24 = mapply(x23, x19)\n    # Paint the shifted objects onto the grid with the restored background\n    # This creates the final output with colored dots on the border\n    x25 = paint(x15, x24)\n    return x25\n"
  },
  "d6ad076f": {
    "original": "def verify_d6ad076f(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = product(x0, x0)\n    x2 = fork(equality, first, last)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x1, x3)\n    x5 = fork(adjacent, first, last)\n    x6 = compose(flip, x5)\n    x7 = extract(x4, x6)\n    x8 = totuple(x7)\n    x9 = first(x8)\n    x10 = last(x8)\n    x11 = combine(x9, x10)\n    x12 = leftmost(x11)\n    x13 = increment(x12)\n    x14 = rightmost(x11)\n    x15 = decrement(x14)\n    x16 = apply(uppermost, x8)\n    x17 = maximum(x16)\n    x18 = increment(x17)\n    x19 = apply(lowermost, x8)\n    x20 = minimum(x19)\n    x21 = decrement(x20)\n    x22 = apply(leftmost, x8)\n    x23 = maximum(x22)\n    x24 = increment(x23)\n    x25 = apply(rightmost, x8)\n    x26 = minimum(x25)\n    x27 = decrement(x26)\n    x28 = uppermost(x11)\n    x29 = increment(x28)\n    x30 = lowermost(x11)\n    x31 = decrement(x30)\n    x32 = hmatching(x9, x10)\n    x33 = branch(x32, x13, x24)\n    x34 = branch(x32, x15, x27)\n    x35 = branch(x32, x21, x31)\n    x36 = branch(x32, x18, x29)\n    x37 = astuple(x35, x34)\n    x38 = astuple(x36, x33)\n    x39 = initset(x38)\n    x40 = insert(x37, x39)\n    x41 = backdrop(x40)\n    x42 = merge(x7)\n    x43 = toindices(x42)\n    x44 = rbind(contained, x43)\n    x45 = compose(flip, x44)\n    x46 = sfilter(x41, x45)\n    x47 = fill(I, EIGHT, x46)\n    return x47\n\n",
    "annotated": "def verify_d6ad076f(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    # Create all possible pairs of objects\n    x1 = product(x0, x0)\n    # Create a function that checks if the first and last elements are equal\n    x2 = fork(equality, first, last)\n    # Flip the result of the equality check\n    x3 = compose(flip, x2)\n    # Filter pairs where the objects are different\n    x4 = sfilter(x1, x3)\n    # Create a function that checks if two objects are adjacent\n    x5 = fork(adjacent, first, last)\n    # Flip the result of the adjacency check\n    x6 = compose(flip, x5)\n    # Extract the first pair of objects that are not adjacent\n    x7 = extract(x4, x6)\n    # Convert the pair of objects to a tuple\n    x8 = totuple(x7)\n    # Get the first object from the pair\n    x9 = first(x8)\n    # Get the second object from the pair\n    x10 = last(x8)\n    # Combine the two objects\n    x11 = combine(x9, x10)\n    # Find the leftmost coordinate of the combined objects\n    x12 = leftmost(x11)\n    # Increment the leftmost coordinate\n    x13 = increment(x12)\n    # Find the rightmost coordinate of the combined objects\n    x14 = rightmost(x11)\n    # Decrement the rightmost coordinate\n    x15 = decrement(x14)\n    # Get the uppermost coordinates of both objects\n    x16 = apply(uppermost, x8)\n    # Find the maximum of the uppermost coordinates\n    x17 = maximum(x16)\n    # Increment the maximum uppermost coordinate\n    x18 = increment(x17)\n    # Get the lowermost coordinates of both objects\n    x19 = apply(lowermost, x8)\n    # Find the minimum of the lowermost coordinates\n    x20 = minimum(x19)\n    # Decrement the minimum lowermost coordinate\n    x21 = decrement(x20)\n    # Get the leftmost coordinates of both objects\n    x22 = apply(leftmost, x8)\n    # Find the maximum of the leftmost coordinates\n    x23 = maximum(x22)\n    # Increment the maximum leftmost coordinate\n    x24 = increment(x23)\n    # Get the rightmost coordinates of both objects\n    x25 = apply(rightmost, x8)\n    # Find the minimum of the rightmost coordinates\n    x26 = minimum(x25)\n    # Decrement the minimum rightmost coordinate\n    x27 = decrement(x26)\n    # Find the uppermost coordinate of the combined objects\n    x28 = uppermost(x11)\n    # Increment the uppermost coordinate of the combined objects\n    x29 = increment(x28)\n    # Find the lowermost coordinate of the combined objects\n    x30 = lowermost(x11)\n    # Decrement the lowermost coordinate of the combined objects\n    x31 = decrement(x30)\n    # Check if the two objects are horizontally matching\n    x32 = hmatching(x9, x10)\n    # Choose the appropriate left boundary based on horizontal matching\n    x33 = branch(x32, x13, x24)\n    # Choose the appropriate right boundary based on horizontal matching\n    x34 = branch(x32, x15, x27)\n    # Choose the appropriate bottom boundary based on horizontal matching\n    x35 = branch(x32, x21, x31)\n    # Choose the appropriate top boundary based on horizontal matching\n    x36 = branch(x32, x18, x29)\n    # Create a tuple representing the bottom-right corner of the area to fill\n    x37 = astuple(x35, x34)\n    # Create a tuple representing the top-left corner of the area to fill\n    x38 = astuple(x36, x33)\n    # Initialize a set with the top-left corner\n    x39 = initset(x38)\n    # Add the bottom-right corner to the set\n    x40 = insert(x37, x39)\n    # Create a backdrop (bounding box) from the corner points\n    x41 = backdrop(x40)\n    # Merge the two original objects\n    x42 = merge(x7)\n    # Get the indices of the merged objects\n    x43 = toindices(x42)\n    # Create a function to check if a point is contained in the merged objects\n    x44 = rbind(contained, x43)\n    # Flip the result of the containment check\n    x45 = compose(flip, x44)\n    # Filter the backdrop to only include points not in the original objects\n    x46 = sfilter(x41, x45)\n    # Fill the filtered area with color 8 (EIGHT) on the input grid\n    x47 = fill(I, EIGHT, x46)\n    # Return the modified grid\n    return x47\n"
  },
  "d89b689b": {
    "original": "def verify_d89b689b(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = sfilter(x0, square)\n    x2 = argmax(x1, size)\n    x3 = toindices(x2)\n    x4 = sizefilter(x1, ONE)\n    x5 = apply(initset, x3)\n    x6 = lbind(argmin, x5)\n    x7 = lbind(rbind, manhattan)\n    x8 = compose(x6, x7)\n    x9 = fork(recolor, color, x8)\n    x10 = mapply(x9, x4)\n    x11 = merge(x4)\n    x12 = cover(I, x11)\n    x13 = paint(x12, x10)\n    return x13\n\n",
    "annotated": "def verify_d89b689b(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering all cells connected (including diagonally)\n    x0 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those that are square-shaped\n    x1 = sfilter(x0, square)\n    \n    # Find the largest square object (should be the 2x2 square)\n    x2 = argmax(x1, size)\n    \n    # Get the indices of cells in the largest square object\n    x3 = toindices(x2)\n    \n    # Filter objects to keep only those of size 1 (individual colored cells)\n    x4 = sizefilter(x1, ONE)\n    \n    # Create a set of individual indices from the largest square object\n    x5 = apply(initset, x3)\n    \n    # Prepare a function to find the minimum distance\n    x6 = lbind(argmin, x5)\n    \n    # Prepare a function to calculate Manhattan distance\n    x7 = lbind(rbind, manhattan)\n    \n    # Compose functions to find the closest cell in the largest square\n    x8 = compose(x6, x7)\n    \n    # Create a function to recolor objects based on their closest position in the square\n    x9 = fork(recolor, color, x8)\n    \n    # Apply the recoloring function to all single-cell objects\n    x10 = mapply(x9, x4)\n    \n    # Merge all single-cell objects into one set\n    x11 = merge(x4)\n    \n    # Cover (remove) all single-cell objects from the input grid\n    x12 = cover(I, x11)\n    \n    # Paint the recolored objects onto the grid, creating the final output\n    x13 = paint(x12, x10)\n    \n    # Return the final transformed grid\n    return x13\n"
  },
  "d8c310e9": {
    "original": "def verify_d8c310e9(I: Grid) -> Grid:\n    x0 = astuple(identity, rot90)\n    x1 = astuple(rot180, rot270)\n    x2 = combine(x0, x1)\n    x3 = astuple(identity, rot270)\n    x4 = astuple(rot180, rot90)\n    x5 = combine(x3, x4)\n    x6 = pair(x2, x5)\n    x7 = chain(size, dedupe, first)\n    x8 = matcher(x7, ONE)\n    x9 = compose(first, cmirror)\n    x10 = chain(size, dedupe, x9)\n    x11 = matcher(x10, ONE)\n    x12 = fork(both, x8, x11)\n    x13 = rbind(rapply, I)\n    x14 = compose(initset, first)\n    x15 = chain(first, x13, x14)\n    x16 = compose(x12, x15)\n    x17 = extract(x6, x16)\n    x18 = first(x17)\n    x19 = last(x17)\n    x20 = x18(I)\n    x21 = width(x20)\n    x22 = decrement(x21)\n    x23 = tojvec(x22)\n    x24 = index(x20, x23)\n    x25 = asobject(x20)\n    x26 = matcher(first, x24)\n    x27 = compose(flip, x26)\n    x28 = sfilter(x25, x27)\n    x29 = hperiod(x28)\n    x30 = width(x20)\n    x31 = increment(x30)\n    x32 = interval(ZERO, x31, x29)\n    x33 = apply(tojvec, x32)\n    x34 = lbind(shift, x28)\n    x35 = mapply(x34, x33)\n    x36 = paint(x20, x35)\n    x37 = x19(x36)\n    return x37\n\n",
    "annotated": "def verify_d8c310e9(I: Grid) -> Grid:\n    # Create a tuple of rotation functions (0, 90 degrees)\n    x0 = astuple(identity, rot90)\n    # Create a tuple of rotation functions (180, 270 degrees)\n    x1 = astuple(rot180, rot270)\n    # Combine all rotation functions into a single tuple\n    x2 = combine(x0, x1)\n    # Create a tuple of rotation functions (0, 270 degrees)\n    x3 = astuple(identity, rot270)\n    # Create a tuple of rotation functions (180, 90 degrees)\n    x4 = astuple(rot180, rot90)\n    # Combine the two tuples of rotation functions\n    x5 = combine(x3, x4)\n    # Pair the two combined tuples of rotation functions\n    x6 = pair(x2, x5)\n    # Create a function chain to get the size of unique elements\n    x7 = chain(size, dedupe, first)\n    # Create a matcher function to check if the result of x7 is 1\n    x8 = matcher(x7, ONE)\n    # Create a function to apply counter-diagonal mirror and get the first element\n    x9 = compose(first, cmirror)\n    # Create a function chain to get the size of unique elements after counter-diagonal mirroring\n    x10 = chain(size, dedupe, x9)\n    # Create a matcher function to check if the result of x10 is 1\n    x11 = matcher(x10, ONE)\n    # Create a function to check if both x8 and x11 are true\n    x12 = fork(both, x8, x11)\n    # Create a function to apply all functions in a tuple to I\n    x13 = rbind(rapply, I)\n    # Create a function to initialize a set with the first element\n    x14 = compose(initset, first)\n    # Create a function chain to apply x13 and x14\n    x15 = chain(first, x13, x14)\n    # Create a function to apply x12 to the result of x15\n    x16 = compose(x12, x15)\n    # Extract the first pair of rotation functions that satisfy x16\n    x17 = extract(x6, x16)\n    # Get the first rotation function from the extracted pair\n    x18 = first(x17)\n    # Get the second rotation function from the extracted pair\n    x19 = last(x17)\n    # Apply the first rotation function to the input grid\n    x20 = x18(I)\n    # Get the width of the rotated grid\n    x21 = width(x20)\n    # Decrement the width by 1\n    x22 = decrement(x21)\n    # Create a vector pointing to the rightmost column\n    x23 = tojvec(x22)\n    # Get the color of the rightmost cell in the bottom row\n    x24 = index(x20, x23)\n    # Convert the rotated grid to an object representation\n    x25 = asobject(x20)\n    # Create a matcher function to check if a cell's color is not x24\n    x26 = matcher(first, x24)\n    # Create a function to flip the result of x26\n    x27 = compose(flip, x26)\n    # Filter the object to keep only cells with colors different from x24\n    x28 = sfilter(x25, x27)\n    # Calculate the horizontal period of the filtered object\n    x29 = hperiod(x28)\n    # Get the width of the rotated grid\n    x30 = width(x20)\n    # Increment the width by 1\n    x31 = increment(x30)\n    # Create an interval from 0 to x31 with step size x29\n    x32 = interval(ZERO, x31, x29)\n    # Convert each number in the interval to a horizontal vector\n    x33 = apply(tojvec, x32)\n    # Create a function to shift x28 by a given vector\n    x34 = lbind(shift, x28)\n    # Apply the shift function to each vector in x33 and merge the results\n    x35 = mapply(x34, x33)\n    # Paint the shifted objects onto the rotated grid\n    x36 = paint(x20, x35)\n    # Apply the second rotation function to reverse the initial rotation\n    x37 = x19(x36)\n    # Return the final transformed grid\n    return x37\n"
  },
  "d90796e8": {
    "original": "def verify_d90796e8(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = ofcolor(I, THREE)\n    x2 = compose(positive, size)\n    x3 = lbind(intersection, x1)\n    x4 = chain(x2, x3, dneighbors)\n    x5 = compose(positive, size)\n    x6 = lbind(intersection, x0)\n    x7 = chain(x5, x6, dneighbors)\n    x8 = sfilter(x0, x4)\n    x9 = sfilter(x1, x7)\n    x10 = cover(I, x8)\n    x11 = fill(x10, EIGHT, x9)\n    return x11\n\n",
    "annotated": "def verify_d90796e8(I: Grid) -> Grid:\n    # Find all cells with color 2 (red) in the input grid\n    x0 = ofcolor(I, TWO)\n    \n    # Find all cells with color 3 (green) in the input grid\n    x1 = ofcolor(I, THREE)\n    \n    # Create a function that checks if the size of a set is positive\n    x2 = compose(positive, size)\n    \n    # Create a function that finds the intersection with green cells\n    x3 = lbind(intersection, x1)\n    \n    # Create a function chain: \n    # 1. Find directly adjacent neighbors\n    # 2. Intersect with green cells\n    # 3. Check if the intersection is non-empty\n    x4 = chain(x2, x3, dneighbors)\n    \n    # Create another function that checks if the size of a set is positive\n    x5 = compose(positive, size)\n    \n    # Create a function that finds the intersection with red cells\n    x6 = lbind(intersection, x0)\n    \n    # Create a function chain:\n    # 1. Find directly adjacent neighbors\n    # 2. Intersect with red cells\n    # 3. Check if the intersection is non-empty\n    x7 = chain(x5, x6, dneighbors)\n    \n    # Filter red cells that have at least one adjacent green cell\n    x8 = sfilter(x0, x4)\n    \n    # Filter green cells that have at least one adjacent red cell\n    x9 = sfilter(x1, x7)\n    \n    # Remove the filtered red cells from the input grid (replace with background color)\n    x10 = cover(I, x8)\n    \n    # Fill the filtered green cells with color 8 (blue) in the modified grid\n    x11 = fill(x10, EIGHT, x9)\n    \n    # Return the final modified grid\n    return x11\n"
  },
  "d9f24cd1": {
    "original": "def verify_d9f24cd1(I: Grid) -> Grid:\n    x0 = astuple(identity, identity)\n    x1 = astuple(rot90, rot270)\n    x2 = astuple(x0, x1)\n    x3 = astuple(rot180, rot180)\n    x4 = astuple(rot270, rot90)\n    x5 = astuple(x3, x4)\n    x6 = combine(x2, x5)\n    x7 = rbind(greater, ONE)\n    x8 = chain(size, dedupe, last)\n    x9 = compose(x7, x8)\n    x10 = rbind(rapply, I)\n    x11 = compose(initset, first)\n    x12 = chain(first, x10, x11)\n    x13 = compose(x9, x12)\n    x14 = extract(x6, x13)\n    x15 = first(x14)\n    x16 = last(x14)\n    x17 = x15(I)\n    x18 = mostcolor(I)\n    x19 = trim(I)\n    x20 = palette(x19)\n    x21 = other(x20, x18)\n    x22 = asindices(I)\n    x23 = box(x22)\n    x24 = toobject(x23, I)\n    x25 = palette(x24)\n    x26 = other(x25, x18)\n    x27 = ofcolor(x17, x26)\n    x28 = ofcolor(x17, x21)\n    x29 = prapply(connect, x27, x28)\n    x30 = mfilter(x29, vline)\n    x31 = underfill(x17, x26, x30)\n    x32 = matcher(numcolors, TWO)\n    x33 = objects(x31, F, F, T)\n    x34 = sfilter(x33, x32)\n    x35 = difference(x33, x34)\n    x36 = colorfilter(x35, x26)\n    x37 = mapply(toindices, x36)\n    x38 = apply(urcorner, x34)\n    x39 = shift(x38, UNITY)\n    x40 = rbind(shoot, UP)\n    x41 = mapply(x40, x39)\n    x42 = fill(x31, x26, x41)\n    x43 = mapply(vfrontier, x37)\n    x44 = fill(x42, x26, x43)\n    x45 = x16(x44)\n    return x45\n\n",
    "annotated": "def verify_d9f24cd1(I: Grid) -> Grid:\n    # Create tuples of rotation functions and their inverses\n    x0 = astuple(identity, identity)  # No rotation\n    x1 = astuple(rot90, rot270)  # 90-degree rotation and its inverse\n    x2 = astuple(x0, x1)  # Combine no rotation and 90-degree rotation\n    x3 = astuple(rot180, rot180)  # 180-degree rotation (self-inverse)\n    x4 = astuple(rot270, rot90)  # 270-degree rotation and its inverse\n    x5 = astuple(x3, x4)  # Combine 180-degree and 270-degree rotations\n    x6 = combine(x2, x5)  # Create a set of all rotation function pairs\n\n    # Create helper functions\n    x7 = rbind(greater, ONE)  # Function to check if a value is greater than 1\n    x8 = chain(size, dedupe, last)  # Get size of unique elements in last row\n    x9 = compose(x7, x8)  # Check if size of unique elements in last row > 1\n\n    # Apply rotations to input grid and find correct orientation\n    x10 = rbind(rapply, I)  # Apply each rotation to input grid\n    x11 = compose(initset, first)  # Get first element as a set\n    x12 = chain(first, x10, x11)  # Get first element of rotated grid\n    x13 = compose(x9, x12)  # Check condition on rotated grid\n    x14 = extract(x6, x13)  # Find rotation pair that satisfies condition\n\n    # Extract rotation and inverse rotation functions\n    x15 = first(x14)  # Get rotation function\n    x16 = last(x14)  # Get inverse rotation function\n\n    # Apply correct rotation to input grid\n    x17 = x15(I)  # Rotate input grid to correct orientation\n\n    # Identify colors\n    x18 = mostcolor(I)  # Get background color\n    x19 = trim(I)  # Remove border from grid\n    x20 = palette(x19)  # Get colors used in trimmed grid\n    x21 = other(x20, x18)  # Get color of dots\n\n    # Find border color\n    x22 = asindices(I)  # Get all indices of the grid\n    x23 = box(x22)  # Get indices of the grid border\n    x24 = toobject(x23, I)  # Convert border indices to object\n    x25 = palette(x24)  # Get colors used in border\n    x26 = other(x25, x18)  # Get color of lines (not background)\n\n    # Find start and end points for vertical lines\n    x27 = ofcolor(x17, x26)  # Get indices of line color in rotated grid\n    x28 = ofcolor(x17, x21)  # Get indices of dot color in rotated grid\n    x29 = prapply(connect, x27, x28)  # Connect all line starts to all dots\n    x30 = mfilter(x29, vline)  # Keep only vertical lines\n\n    # Draw vertical lines\n    x31 = underfill(x17, x26, x30)  # Draw vertical lines on rotated grid\n\n    # Identify objects with two colors (dots with lines)\n    x32 = matcher(numcolors, TWO)  # Function to check if object has two colors\n    x33 = objects(x31, F, F, T)  # Get all objects in the grid\n    x34 = sfilter(x33, x32)  # Keep only objects with two colors\n\n    # Process remaining single-color objects (unconnected dots)\n    x35 = difference(x33, x34)  # Get objects without lines\n    x36 = colorfilter(x35, x26)  # Keep only objects of line color\n    x37 = mapply(toindices, x36)  # Convert objects to indices\n\n    # Find upper-right corners of two-color objects\n    x38 = apply(urcorner, x34)  # Get upper-right corners\n    x39 = shift(x38, UNITY)  # Shift corners up and right by 1\n\n    # Draw lines from shifted corners to top of grid\n    x40 = rbind(shoot, UP)  # Create function to draw line upwards\n    x41 = mapply(x40, x39)  # Draw lines from all shifted corners\n    x42 = fill(x31, x26, x41)  # Add these lines to the grid\n\n    # Draw vertical lines for unconnected dots\n    x43 = mapply(vfrontier, x37)  # Create vertical lines for unconnected dots\n    x44 = fill(x42, x26, x43)  # Add these lines to the grid\n\n    # Rotate grid back to original orientation\n    x45 = x16(x44)  # Apply inverse rotation to get final output\n\n    return x45  # Return the processed grid\n"
  },
  "d9fac9be": {
    "original": "def verify_d9fac9be(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = totuple(x2)\n    x4 = first(x3)\n    x5 = last(x3)\n    x6 = neighbors(UNITY)\n    x7 = initset(UNITY)\n    x8 = recolor(x4, x6)\n    x9 = recolor(x5, x7)\n    x10 = combine(x8, x9)\n    x11 = occurrences(I, x10)\n    x12 = size(x11)\n    x13 = positive(x12)\n    x14 = branch(x13, x5, x4)\n    x15 = canvas(x14, UNITY)\n    return x15\n\n",
    "annotated": "def verify_d9fac9be(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Remove the background color from the palette, leaving noise and ring colors\n    x2 = remove(x0, x1)\n    \n    # Convert the remaining colors (noise and ring) to a tuple\n    x3 = totuple(x2)\n    \n    # Get the first color in the tuple (noise color)\n    x4 = first(x3)\n    \n    # Get the last color in the tuple (ring color)\n    x5 = last(x3)\n    \n    # Define the shape of a ring (3x3 square without center)\n    x6 = neighbors(UNITY)\n    \n    # Create a set with just the center cell\n    x7 = initset(UNITY)\n    \n    # Create a ring-shaped object with the noise color\n    x8 = recolor(x4, x6)\n    \n    # Create a single-cell object with the ring color\n    x9 = recolor(x5, x7)\n    \n    # Combine the ring and center cell to form a complete ring pattern\n    x10 = combine(x8, x9)\n    \n    # Find all occurrences of the complete ring pattern in the input grid\n    x11 = occurrences(I, x10)\n    \n    # Count the number of occurrences of the complete ring pattern\n    x12 = size(x11)\n    \n    # Check if there are any occurrences of the complete ring pattern\n    x13 = positive(x12)\n    \n    # If the complete ring pattern is found, use the ring color; otherwise, use the noise color\n    # This determines the color of the output based on whether a complete ring exists\n    x14 = branch(x13, x5, x4)\n    \n    # Create a 1x1 grid with the chosen color (ring color if a complete ring was found, noise color otherwise)\n    x15 = canvas(x14, UNITY)\n    \n    # Return the 1x1 grid as the output\n    return x15\n"
  },
  "dae9d2b5": {
    "original": "def verify_dae9d2b5(I: Grid) -> Grid:\n    x0 = hsplit(I, TWO)\n    x1 = apply(numcolors, x0)\n    x2 = equality(x1, TWO_BY_TWO)\n    x3 = branch(x2, hsplit, vsplit)\n    x4 = x3(I, TWO)\n    x5 = first(x4)\n    x6 = last(x4)\n    x7 = palette(x5)\n    x8 = palette(x6)\n    x9 = intersection(x7, x8)\n    x10 = first(x9)\n    x11 = palette(x5)\n    x12 = other(x11, x10)\n    x13 = palette(x6)\n    x14 = other(x13, x10)\n    x15 = shape(x5)\n    x16 = canvas(x10, x15)\n    x17 = ofcolor(x5, x12)\n    x18 = ofcolor(x6, x14)\n    x19 = combine(x17, x18)\n    x20 = fill(x16, SIX, x19)\n    return x20\n\n",
    "annotated": "def verify_dae9d2b5(I: Grid) -> Grid:\n    # Split the input grid horizontally into two parts\n    x0 = hsplit(I, TWO)\n    \n    # Count the number of colors in each part\n    x1 = apply(numcolors, x0)\n    \n    # Check if both parts have exactly two colors\n    x2 = equality(x1, TWO_BY_TWO)\n    \n    # If both parts have two colors, split horizontally; otherwise, split vertically\n    # This adapts to whether the input was mirrored diagonally or not\n    x3 = branch(x2, hsplit, vsplit)\n    \n    # Split the input grid into two parts based on the previous decision\n    x4 = x3(I, TWO)\n    \n    # Get the first part of the split (shape A)\n    x5 = first(x4)\n    \n    # Get the second part of the split (shape B)\n    x6 = last(x4)\n    \n    # Get the set of colors used in shape A\n    x7 = palette(x5)\n    \n    # Get the set of colors used in shape B\n    x8 = palette(x6)\n    \n    # Find the common color between shapes A and B (background color)\n    x9 = intersection(x7, x8)\n    \n    # Extract the background color\n    x10 = first(x9)\n    \n    # Get the non-background color of shape A\n    x11 = palette(x5)\n    x12 = other(x11, x10)\n    \n    # Get the non-background color of shape B\n    x13 = palette(x6)\n    x14 = other(x13, x10)\n    \n    # Get the dimensions of shape A (which will be the same as the output)\n    x15 = shape(x5)\n    \n    # Create a canvas with the background color and dimensions of shape A\n    x16 = canvas(x10, x15)\n    \n    # Get the indices of non-background color in shape A\n    x17 = ofcolor(x5, x12)\n    \n    # Get the indices of non-background color in shape B\n    x18 = ofcolor(x6, x14)\n    \n    # Combine the indices from both shapes\n    x19 = combine(x17, x18)\n    \n    # Fill the canvas with color 6 at the combined indices\n    # This creates the output where the union of shapes A and B is colored 6\n    x20 = fill(x16, SIX, x19)\n    \n    # Return the final output grid\n    return x20\n"
  },
  "db3e9e38": {
    "original": "def verify_db3e9e38(I: Grid) -> Grid:\n    x0 = astuple(identity, dmirror)\n    x1 = astuple(cmirror, hmirror)\n    x2 = combine(x0, x1)\n    x3 = chain(uppermost, merge, fgpartition)\n    x4 = rbind(rapply, I)\n    x5 = chain(first, x4, initset)\n    x6 = compose(x3, x5)\n    x7 = matcher(x6, ZERO)\n    x8 = extract(x2, x7)\n    x9 = x8(I)\n    x10 = fgpartition(x9)\n    x11 = merge(x10)\n    x12 = width(x11)\n    x13 = astuple(NEG_ONE, x12)\n    x14 = invert(x12)\n    x15 = astuple(NEG_ONE, x14)\n    x16 = double(x12)\n    x17 = astuple(NEG_TWO, x16)\n    x18 = double(x12)\n    x19 = invert(x18)\n    x20 = astuple(NEG_TWO, x19)\n    x21 = multiply(THREE, TEN)\n    x22 = interval(ZERO, x21, ONE)\n    x23 = lbind(multiply, x13)\n    x24 = apply(x23, x22)\n    x25 = lbind(multiply, x15)\n    x26 = apply(x25, x22)\n    x27 = lbind(multiply, x17)\n    x28 = apply(x27, x22)\n    x29 = lbind(multiply, x20)\n    x30 = apply(x29, x22)\n    x31 = lbind(shift, x11)\n    x32 = mapply(x31, x24)\n    x33 = lbind(shift, x11)\n    x34 = mapply(x33, x26)\n    x35 = lbind(shift, x11)\n    x36 = mapply(x35, x28)\n    x37 = lbind(shift, x11)\n    x38 = mapply(x37, x30)\n    x39 = combine(x32, x34)\n    x40 = fill(x9, EIGHT, x39)\n    x41 = combine(x36, x38)\n    x42 = paint(x40, x41)\n    x43 = x8(x42)\n    return x43\n\n",
    "annotated": "def verify_db3e9e38(I: Grid) -> Grid:\n    # Create a tuple of identity and diagonal mirror functions\n    x0 = astuple(identity, dmirror)\n    \n    # Create a tuple of counter-diagonal mirror and horizontal mirror functions\n    x1 = astuple(cmirror, hmirror)\n    \n    # Combine the two tuples of mirror functions\n    x2 = combine(x0, x1)\n    \n    # Create a chain of functions to find the uppermost row of the foreground partition\n    x3 = chain(uppermost, merge, fgpartition)\n    \n    # Partially apply the input grid I to the rapply function\n    x4 = rbind(rapply, I)\n    \n    # Create a chain to initialize a set with the first element of x4\n    x5 = chain(first, x4, initset)\n    \n    # Compose x3 and x5 functions\n    x6 = compose(x3, x5)\n    \n    # Create a matcher function that checks if x6 equals ZERO\n    x7 = matcher(x6, ZERO)\n    \n    # Extract the correct mirror function based on the matcher\n    x8 = extract(x2, x7)\n    \n    # Apply the extracted mirror function to the input grid\n    x9 = x8(I)\n    \n    # Partition the mirrored grid into foreground objects\n    x10 = fgpartition(x9)\n    \n    # Merge all foreground objects into a single object\n    x11 = merge(x10)\n    \n    # Get the width of the merged foreground object\n    x12 = width(x11)\n    \n    # Create a tuple (-1, width)\n    x13 = astuple(NEG_ONE, x12)\n    \n    # Invert the width\n    x14 = invert(x12)\n    \n    # Create a tuple (-1, -width)\n    x15 = astuple(NEG_ONE, x14)\n    \n    # Double the width\n    x16 = double(x12)\n    \n    # Create a tuple (-2, 2*width)\n    x17 = astuple(NEG_TWO, x16)\n    \n    # Double the width again\n    x18 = double(x12)\n    \n    # Invert the doubled width\n    x19 = invert(x18)\n    \n    # Create a tuple (-2, -2*width)\n    x20 = astuple(NEG_TWO, x19)\n    \n    # Calculate 3 * 10\n    x21 = multiply(THREE, TEN)\n    \n    # Create an interval from 0 to 30 with step 1\n    x22 = interval(ZERO, x21, ONE)\n    \n    # Partially apply multiplication with x13\n    x23 = lbind(multiply, x13)\n    \n    # Apply x23 to the interval, creating shifts for right bars\n    x24 = apply(x23, x22)\n    \n    # Partially apply multiplication with x15\n    x25 = lbind(multiply, x15)\n    \n    # Apply x25 to the interval, creating shifts for left bars\n    x26 = apply(x25, x22)\n    \n    # Partially apply multiplication with x17\n    x27 = lbind(multiply, x17)\n    \n    # Apply x27 to the interval, creating shifts for right color 8 bars\n    x28 = apply(x27, x22)\n    \n    # Partially apply multiplication with x20\n    x29 = lbind(multiply, x20)\n    \n    # Apply x29 to the interval, creating shifts for left color 8 bars\n    x30 = apply(x29, x22)\n    \n    # Partially apply shift with the merged foreground object\n    x31 = lbind(shift, x11)\n    \n    # Apply shifts to create right bars\n    x32 = mapply(x31, x24)\n    \n    # Partially apply shift with the merged foreground object\n    x33 = lbind(shift, x11)\n    \n    # Apply shifts to create left bars\n    x34 = mapply(x33, x26)\n    \n    # Partially apply shift with the merged foreground object\n    x35 = lbind(shift, x11)\n    \n    # Apply shifts to create right color 8 bars\n    x36 = mapply(x35, x28)\n    \n    # Partially apply shift with the merged foreground object\n    x37 = lbind(shift, x11)\n    \n    # Apply shifts to create left color 8 bars\n    x38 = mapply(x37, x30)\n    \n    # Combine right and left bars\n    x39 = combine(x32, x34)\n    \n    # Fill the mirrored grid with color 8 for the combined bars\n    x40 = fill(x9, EIGHT, x39)\n    \n    # Combine right and left color 8 bars\n    x41 = combine(x36, x38)\n    \n    # Paint the color 8 filled grid with the original foreground color bars\n    x42 = paint(x40, x41)\n    \n    # Apply the inverse mirror function to get the final output\n    x43 = x8(x42)\n    \n    return x43\n"
  },
  "db93a21d": {
    "original": "def verify_db93a21d(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = merge(x0)\n    x2 = toindices(x1)\n    x3 = rbind(shoot, DOWN)\n    x4 = mapply(x3, x2)\n    x5 = underfill(I, ONE, x4)\n    x6 = lbind(power, outbox)\n    x7 = chain(x6, halve, width)\n    x8 = initset(x7)\n    x9 = lbind(rapply, x8)\n    x10 = fork(rapply, x9, identity)\n    x11 = compose(first, x10)\n    x12 = compose(backdrop, x11)\n    x13 = fork(difference, x12, toindices)\n    x14 = mapply(x13, x0)\n    x15 = mostcolor(I)\n    x16 = ofcolor(I, x15)\n    x17 = intersection(x14, x16)\n    x18 = fill(x5, THREE, x17)\n    return x18\n\n",
    "annotated": "def verify_db93a21d(I: Grid) -> Grid:\n    # Identify all objects in the input grid, including diagonally connected cells and background\n    x0 = objects(I, T, T, T)\n    \n    # Merge all identified objects into a single set\n    x1 = merge(x0)\n    \n    # Extract the indices of all object cells\n    x2 = toindices(x1)\n    \n    # Create a function that shoots downwards from a given point\n    x3 = rbind(shoot, DOWN)\n    \n    # Apply the downward shoot function to all object indices, creating vertical lines below objects\n    x4 = mapply(x3, x2)\n    \n    # Fill the areas below objects with color 1 (stripe color) where it doesn't overlap existing objects\n    x5 = underfill(I, ONE, x4)\n    \n    # Create a function that applies the outbox function twice (creating a larger box)\n    x6 = lbind(power, outbox)\n    \n    # Create a function that halves the width of an object and then applies the double outbox\n    x7 = chain(x6, halve, width)\n    \n    # Create a set containing the above function\n    x8 = initset(x7)\n    \n    # Create a function that applies the set of functions to an input\n    x9 = lbind(rapply, x8)\n    \n    # Create a function that applies x9 and the identity function to an input\n    x10 = fork(rapply, x9, identity)\n    \n    # Create a function that gets the first result of x10\n    x11 = compose(first, x10)\n    \n    # Create a function that gets the backdrop of the result of x11\n    x12 = compose(backdrop, x11)\n    \n    # Create a function that finds the difference between x12 and the original object indices\n    x13 = fork(difference, x12, toindices)\n    \n    # Apply x13 to all objects, creating frames around each object\n    x14 = mapply(x13, x0)\n    \n    # Find the most common color in the input grid (background color)\n    x15 = mostcolor(I)\n    \n    # Get all cells of the background color\n    x16 = ofcolor(I, x15)\n    \n    # Find the intersection of the frames and the background cells\n    x17 = intersection(x14, x16)\n    \n    # Fill the frame areas with color 3, creating frames around objects\n    x18 = fill(x5, THREE, x17)\n    \n    # Return the final grid with stripes and frames added\n    return x18\n"
  },
  "dbc1a6ce": {
    "original": "def verify_dbc1a6ce(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = lbind(recolor, EIGHT)\n    x3 = rbind(ofcolor, x0)\n    x4 = chain(x2, backdrop, x3)\n    x5 = fork(paint, identity, x4)\n    x6 = height(I)\n    x7 = vsplit(I, x6)\n    x8 = mapply(x5, x7)\n    x9 = ofcolor(x8, EIGHT)\n    x10 = dmirror(I)\n    x11 = width(I)\n    x12 = vsplit(x10, x11)\n    x13 = mapply(x5, x12)\n    x14 = dmirror(x13)\n    x15 = ofcolor(x14, EIGHT)\n    x16 = combine(x9, x15)\n    x17 = difference(x16, x1)\n    x18 = fill(I, EIGHT, x17)\n    return x18\n\n",
    "annotated": "def verify_dbc1a6ce(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Get indices of all cells with the background color\n    x1 = ofcolor(I, x0)\n    \n    # Create a function that recolors cells to color 8 (connection color)\n    x2 = lbind(recolor, EIGHT)\n    \n    # Create a function that finds cells of the background color\n    x3 = rbind(ofcolor, x0)\n    \n    # Create a function that finds the backdrop of background color cells and recolors them to 8\n    # This effectively creates potential horizontal connections\n    x4 = chain(x2, backdrop, x3)\n    \n    # Create a function that paints the potential horizontal connections onto a copy of the input\n    x5 = fork(paint, identity, x4)\n    \n    # Get the height of the input grid\n    x6 = height(I)\n    \n    # Split the input grid into individual rows\n    x7 = vsplit(I, x6)\n    \n    # Apply the horizontal connection painting function to each row\n    x8 = mapply(x5, x7)\n    \n    # Get indices of all cells with color 8 (horizontal connections) in the processed grid\n    x9 = ofcolor(x8, EIGHT)\n    \n    # Create a diagonally mirrored version of the input grid (for vertical processing)\n    x10 = dmirror(I)\n    \n    # Get the width of the input grid\n    x11 = width(I)\n    \n    # Split the mirrored grid into individual columns\n    x12 = vsplit(x10, x11)\n    \n    # Apply the connection painting function to each column\n    x13 = mapply(x5, x12)\n    \n    # Mirror the processed grid back to original orientation\n    x14 = dmirror(x13)\n    \n    # Get indices of all cells with color 8 (vertical connections) in the processed grid\n    x15 = ofcolor(x14, EIGHT)\n    \n    # Combine horizontal and vertical connection indices\n    x16 = combine(x9, x15)\n    \n    # Remove background color cells from the connection indices\n    # This ensures we don't overwrite foreground cells\n    x17 = difference(x16, x1)\n    \n    # Fill the input grid with color 8 at the calculated connection indices\n    # This creates the final output with both horizontal and vertical connections\n    x18 = fill(I, EIGHT, x17)\n    \n    return x18\n"
  },
  "dc0a314f": {
    "original": "def verify_dc0a314f(I: Grid) -> Grid:\n    x0 = replace(I, THREE, NEG_ONE)\n    x1 = dmirror(x0)\n    x2 = papply(pair, x0, x1)\n    x3 = lbind(apply, maximum)\n    x4 = apply(x3, x2)\n    x5 = cmirror(x4)\n    x6 = papply(pair, x4, x5)\n    x7 = apply(x3, x6)\n    x8 = hmirror(x7)\n    x9 = papply(pair, x7, x8)\n    x10 = apply(x3, x9)\n    x11 = vmirror(x10)\n    x12 = papply(pair, x11, x10)\n    x13 = apply(x3, x12)\n    x14 = ofcolor(I, THREE)\n    x15 = subgrid(x14, x13)\n    return x15\n\n",
    "annotated": "def verify_dc0a314f(I: Grid) -> Grid:\n    # Replace all occurrences of 3 with -1 in the input grid\n    # This effectively marks the area where the subgrid was extracted\n    x0 = replace(I, THREE, NEG_ONE)\n\n    # Create a diagonal mirror of the grid\n    # This is the first step in reconstructing the full symmetric pattern\n    x1 = dmirror(x0)\n\n    # Pair corresponding elements from x0 and x1\n    # This combines the original and diagonally mirrored grids\n    x2 = papply(pair, x0, x1)\n\n    # Create a function that applies the maximum function to each pair\n    # This will be used to select the higher value from each pair\n    x3 = lbind(apply, maximum)\n\n    # Apply the maximum function to each pair in x2\n    # This reconstructs the upper-right quarter of the full pattern\n    x4 = apply(x3, x2)\n\n    # Create a counter-diagonal mirror of x4\n    # This completes the upper half of the full pattern\n    x5 = cmirror(x4)\n\n    # Pair corresponding elements from x4 and x5\n    x6 = papply(pair, x4, x5)\n\n    # Apply the maximum function to each pair in x6\n    # This reconstructs the upper half of the full pattern\n    x7 = apply(x3, x6)\n\n    # Create a horizontal mirror of x7\n    # This creates the lower half of the full pattern\n    x8 = hmirror(x7)\n\n    # Pair corresponding elements from x7 and x8\n    x9 = papply(pair, x7, x8)\n\n    # Apply the maximum function to each pair in x9\n    # This reconstructs the full pattern\n    x10 = apply(x3, x9)\n\n    # Create a vertical mirror of x10\n    # This ensures the pattern is symmetric in all directions\n    x11 = vmirror(x10)\n\n    # Pair corresponding elements from x11 and x10\n    x12 = papply(pair, x11, x10)\n\n    # Apply the maximum function to each pair in x12\n    # This creates the final, fully symmetric pattern\n    x13 = apply(x3, x12)\n\n    # Find all cells in the original input grid that have color 3\n    # These cells mark the area where the subgrid was extracted\n    x14 = ofcolor(I, THREE)\n\n    # Extract the subgrid from x13 using the indices found in x14\n    # This reconstructs the extracted subgrid from the full pattern\n    x15 = subgrid(x14, x13)\n\n    # Return the reconstructed subgrid\n    return x15\n"
  },
  "dc1df850": {
    "original": "def verify_dc1df850(I: Grid) -> Grid:\n    x0 = ofcolor(I, TWO)\n    x1 = mapply(neighbors, x0)\n    x2 = underfill(I, ONE, x1)\n    return x2\n\n",
    "annotated": "def verify_dc1df850(I: Grid) -> Grid:\n    # Find all cells in the input grid I that have color 2 (red)\n    # This identifies the red cells in the original grid\n    x0 = ofcolor(I, TWO)\n    \n    # Get all neighboring cells for each red cell\n    # This creates a set of all cells adjacent to red cells\n    x1 = mapply(neighbors, x0)\n    \n    # Fill the neighboring cells with color 1 (likely blue)\n    # But only fill cells that weren't already colored in the input\n    # This effectively creates a border around red cells, but only where there was background before\n    x2 = underfill(I, ONE, x1)\n    \n    # Return the modified grid\n    # The output grid is the same as the input, but with color 1 borders around red cells\n    return x2\n"
  },
  "dc433765": {
    "original": "def verify_dc433765(I: Grid) -> Grid:\n    x0 = mostcolor(I)\n    x1 = palette(I)\n    x2 = remove(x0, x1)\n    x3 = other(x2, FOUR)\n    x4 = ofcolor(I, x3)\n    x5 = ofcolor(I, FOUR)\n    x6 = center(x4)\n    x7 = center(x5)\n    x8 = subtract(x7, x6)\n    x9 = sign(x8)\n    x10 = recolor(x3, x4)\n    x11 = move(I, x10, x9)\n    return x11\n\n",
    "annotated": "def verify_dc433765(I: Grid) -> Grid:\n    # Get the most common color in the input grid (background color)\n    x0 = mostcolor(I)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Remove the background color from the palette, leaving non-background colors\n    x2 = remove(x0, x1)\n    \n    # Get the color that is not 4 from the non-background colors (source color)\n    x3 = other(x2, FOUR)\n    \n    # Get all cells with the source color\n    x4 = ofcolor(I, x3)\n    \n    # Get all cells with color 4 (end point)\n    x5 = ofcolor(I, FOUR)\n    \n    # Find the center of the source color cells\n    x6 = center(x4)\n    \n    # Find the center of the color 4 cells (end point)\n    x7 = center(x5)\n    \n    # Calculate the vector from source to end point\n    x8 = subtract(x7, x6)\n    \n    # Get the direction of movement (normalizes the vector to -1, 0, or 1 for each component)\n    x9 = sign(x8)\n    \n    # Create an object with the source color\n    x10 = recolor(x3, x4)\n    \n    # Move the source color object one step in the calculated direction\n    # This effectively shifts the source color towards the end point\n    x11 = move(I, x10, x9)\n    \n    # Return the modified grid\n    return x11\n"
  },
  "ddf7fa4f": {
    "original": "def verify_ddf7fa4f(I: Grid) -> Grid:\n    x0 = width(I)\n    x1 = decrement(x0)\n    x2 = tojvec(x1)\n    x3 = connect(ORIGIN, x2)\n    x4 = height(I)\n    x5 = decrement(x4)\n    x6 = toivec(x5)\n    x7 = connect(ORIGIN, x6)\n    x8 = width(I)\n    x9 = decrement(x8)\n    x10 = tojvec(x9)\n    x11 = shape(I)\n    x12 = decrement(x11)\n    x13 = connect(x10, x12)\n    x14 = height(I)\n    x15 = decrement(x14)\n    x16 = toivec(x15)\n    x17 = shape(I)\n    x18 = decrement(x17)\n    x19 = connect(x16, x18)\n    x20 = asindices(I)\n    x21 = box(x20)\n    x22 = toobject(x21, I)\n    x23 = mostcolor(x22)\n    x24 = matcher(color, x23)\n    x25 = compose(flip, x24)\n    x26 = rbind(sfilter, x25)\n    x27 = rbind(sizefilter, ONE)\n    x28 = rbind(objects, F)\n    x29 = rbind(x28, F)\n    x30 = rbind(x29, T)\n    x31 = rbind(subgrid, I)\n    x32 = chain(x26, x30, x31)\n    x33 = chain(size, x27, x32)\n    x34 = astuple(x3, x7)\n    x35 = astuple(x13, x19)\n    x36 = combine(x34, x35)\n    x37 = argmax(x36, x33)\n    x38 = rbind(toobject, I)\n    x39 = compose(x38, initset)\n    x40 = ofcolor(I, x23)\n    x41 = difference(x37, x40)\n    x42 = apply(x39, x41)\n    x43 = rbind(intersection, x37)\n    x44 = chain(size, x43, toindices)\n    x45 = matcher(x44, ZERO)\n    x46 = objects(I, T, F, T)\n    x47 = sfilter(x46, x45)\n    x48 = lbind(fork, either)\n    x49 = lbind(lbind, hmatching)\n    x50 = lbind(lbind, vmatching)\n    x51 = fork(x48, x49, x50)\n    x52 = lbind(chain, size)\n    x53 = rbind(x52, x51)\n    x54 = lbind(lbind, sfilter)\n    x55 = compose(last, last)\n    x56 = chain(x53, x54, x55)\n    x57 = rbind(compose, x51)\n    x58 = lbind(lbind, extract)\n    x59 = compose(last, last)\n    x60 = chain(x57, x58, x59)\n    x61 = compose(first, last)\n    x62 = rbind(matcher, ONE)\n    x63 = compose(x62, x56)\n    x64 = fork(sfilter, x61, x63)\n    x65 = lbind(fork, recolor)\n    x66 = lbind(x65, color)\n    x67 = compose(x66, x60)\n    x68 = fork(mapply, x67, x64)\n    x69 = fork(combine, first, x68)\n    x70 = compose(first, last)\n    x71 = fork(difference, x70, x64)\n    x72 = compose(last, last)\n    x73 = fork(apply, x60, x64)\n    x74 = fork(difference, x72, x73)\n    x75 = fork(astuple, x71, x74)\n    x76 = fork(astuple, x69, x75)\n    x77 = difference(x42, x42)\n    x78 = power(x76, TEN)\n    x79 = astuple(x42, x47)\n    x80 = astuple(x77, x79)\n    x81 = x78(x80)\n    x82 = first(x81)\n    x83 = paint(I, x82)\n    return x83\n\n",
    "annotated": "def verify_ddf7fa4f(I: Grid) -> Grid:\n    x0 = width(I)  # Get the width of the input grid\n    x1 = decrement(x0)  # Decrease the width by 1\n    x2 = tojvec(x1)  # Convert to a horizontal vector (0, width-1)\n    x3 = connect(ORIGIN, x2)  # Create a line from (0,0) to (0, width-1) - top edge of grid\n    x4 = height(I)  # Get the height of the input grid\n    x5 = decrement(x4)  # Decrease the height by 1\n    x6 = toivec(x5)  # Convert to a vertical vector (height-1, 0)\n    x7 = connect(ORIGIN, x6)  # Create a line from (0,0) to (height-1, 0) - left edge of grid\n    x8 = width(I)  # Get the width of the input grid again\n    x9 = decrement(x8)  # Decrease the width by 1\n    x10 = tojvec(x9)  # Convert to a horizontal vector (0, width-1)\n    x11 = shape(I)  # Get the shape (height, width) of the input grid\n    x12 = decrement(x11)  # Decrease both dimensions by 1\n    x13 = connect(x10, x12)  # Create a line from (0, width-1) to (height-1, width-1) - right edge of grid\n    x14 = height(I)  # Get the height of the input grid again\n    x15 = decrement(x14)  # Decrease the height by 1\n    x16 = toivec(x15)  # Convert to a vertical vector (height-1, 0)\n    x17 = shape(I)  # Get the shape (height, width) of the input grid again\n    x18 = decrement(x17)  # Decrease both dimensions by 1\n    x19 = connect(x16, x18)  # Create a line from (height-1, 0) to (height-1, width-1) - bottom edge of grid\n    x20 = asindices(I)  # Get all indices of the input grid\n    x21 = box(x20)  # Create a box (outline) of the entire grid\n    x22 = toobject(x21, I)  # Convert the box to an object with colors from the input grid\n    x23 = mostcolor(x22)  # Find the most common color in the box (likely the background color)\n    x24 = matcher(color, x23)  # Create a function that matches the background color\n    x25 = compose(flip, x24)  # Create a function that matches non-background colors\n    x26 = rbind(sfilter, x25)  # Bind the non-background color matcher to sfilter\n    x27 = rbind(sizefilter, ONE)  # Create a function to filter objects of size 1\n    x28 = rbind(objects, F)  # Create a function to find objects (not univalued)\n    x29 = rbind(x28, F)  # Set diagonal connectivity to False\n    x30 = rbind(x29, T)  # Set without_bg to True\n    x31 = rbind(subgrid, I)  # Create a function to get subgrids from I\n    x32 = chain(x26, x30, x31)  # Chain functions to get non-background objects from subgrids\n    x33 = chain(size, x27, x32)  # Chain functions to get size of filtered objects\n    x34 = astuple(x3, x7)  # Combine top and left edges\n    x35 = astuple(x13, x19)  # Combine right and bottom edges\n    x36 = combine(x34, x35)  # Combine all edges\n    x37 = argmax(x36, x33)  # Find the edge with the most non-background single-cell objects\n    x38 = rbind(toobject, I)  # Create a function to convert indices to objects from I\n    x39 = compose(x38, initset)  # Compose functions to create single-cell objects\n    x40 = ofcolor(I, x23)  # Get indices of background color in I\n    x41 = difference(x37, x40)  # Remove background cells from the chosen edge\n    x42 = apply(x39, x41)  # Convert remaining edge cells to objects\n    x43 = rbind(intersection, x37)  # Create a function to intersect with the chosen edge\n    x44 = chain(size, x43, toindices)  # Chain functions to get size of intersection with edge\n    x45 = matcher(x44, ZERO)  # Create a function to match objects not touching the edge\n    x46 = objects(I, T, F, T)  # Find all objects in I\n    x47 = sfilter(x46, x45)  # Filter objects not touching the chosen edge\n    x48 = lbind(fork, either)  # Prepare a function to combine horizontal and vertical matching\n    x49 = lbind(lbind, hmatching)  # Prepare horizontal matching function\n    x50 = lbind(lbind, vmatching)  # Prepare vertical matching function\n    x51 = fork(x48, x49, x50)  # Combine horizontal and vertical matching\n    x52 = lbind(chain, size)  # Prepare a function to get size after matching\n    x53 = rbind(x52, x51)  # Combine size and matching functions\n    x54 = lbind(lbind, sfilter)  # Prepare a filtering function\n    x55 = compose(last, last)  # Get the last element of the last tuple\n    x56 = chain(x53, x54, x55)  # Chain functions to filter and get last element\n    x57 = rbind(compose, x51)  # Prepare a function to compose with matching\n    x58 = lbind(lbind, extract)  # Prepare an extraction function\n    x59 = compose(last, last)  # Get the last element of the last tuple\n    x60 = chain(x57, x58, x59)  # Chain functions to match, extract, and get last element\n    x61 = compose(first, last)  # Get the first element of the last tuple\n    x62 = rbind(matcher, ONE)  # Create a function to match with 1\n    x63 = compose(x62, x56)  # Compose matching with filtering and last element\n    x64 = fork(sfilter, x61, x63)  # Filter objects based on matching and size\n    x65 = lbind(fork, recolor)  # Prepare a recoloring function\n    x66 = lbind(x65, color)  # Bind color to the recoloring function\n    x67 = compose(x66, x60)  # Compose recoloring with matching and extraction\n    x68 = fork(mapply, x67, x64)  # Apply recoloring to filtered objects\n    x69 = fork(combine, first, x68)  # Combine first element with recolored objects\n    x70 = compose(first, last)  # Get the first element of the last tuple\n    x71 = fork(difference, x70, x64)  # Remove filtered objects from the first element\n    x72 = compose(last, last)  # Get the last element of the last tuple\n    x73 = fork(apply, x60, x64)  # Apply matching and extraction to filtered objects\n    x74 = fork(difference, x72, x73)  # Remove matched objects from the last element\n    x75 = fork(astuple, x71, x74)  # Combine remaining objects into a tuple\n    x76 = fork(astuple, x69, x75)  # Combine recolored objects with remaining objects\n    x77 = difference(x42, x42)  # Create an empty set (all edge objects minus themselves)\n    x78 = power(x76, TEN)  # Apply the transformation 10 times\n    x79 = astuple(x42, x47)  # Combine edge objects with non-edge objects\n    x80 = astuple(x77, x79)  # Combine empty set with all objects\n    x81 = x78(x80)  # Apply the 10-time transformation to all objects\n    x82 = first(x81)  # Get the first (and only) element of the result\n    x83 = paint(I, x82)  # Paint the transformed objects onto the input grid\n    return x83  # Return the final transformed grid\n\n"
  },
  "de1cd16c": {
    "original": "def verify_de1cd16c(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = totuple(x0)\n    x2 = apply(color, x1)\n    x3 = size(x2)\n    x4 = dedupe(x2)\n    x5 = size(x4)\n    x6 = equality(x3, x5)\n    x7 = compose(leastcolor, merge)\n    x8 = lbind(apply, color)\n    x9 = chain(mostcommon, x8, totuple)\n    x10 = branch(x6, x7, x9)\n    x11 = x10(x0)\n    x12 = objects(I, T, F, F)\n    x13 = colorfilter(x12, x11)\n    x14 = difference(x12, x13)\n    x15 = rbind(subgrid, I)\n    x16 = apply(x15, x14)\n    x17 = rbind(colorcount, x11)\n    x18 = argmax(x16, x17)\n    x19 = mostcolor(x18)\n    x20 = canvas(x19, UNITY)\n    return x20\n\n",
    "annotated": "def verify_de1cd16c(I: Grid) -> Grid:\n    # Find all objects in the input grid (connected regions of the same color)\n    x0 = objects(I, T, F, F)\n    \n    # Convert the set of objects to a tuple\n    x1 = totuple(x0)\n    \n    # Get the color of each object\n    x2 = apply(color, x1)\n    \n    # Count the total number of objects\n    x3 = size(x2)\n    \n    # Remove duplicate colors\n    x4 = dedupe(x2)\n    \n    # Count the number of unique colors\n    x5 = size(x4)\n    \n    # Check if the number of objects equals the number of unique colors\n    # This determines if each object has a unique color\n    x6 = equality(x3, x5)\n    \n    # Create a function that finds the least common color among merged objects\n    x7 = compose(leastcolor, merge)\n    \n    # Create a function that applies the color function to each object\n    x8 = lbind(apply, color)\n    \n    # Create a function chain that finds the most common color among objects\n    x9 = chain(mostcommon, x8, totuple)\n    \n    # Choose between finding the least common color (if objects have unique colors)\n    # or the most common color (if objects share colors)\n    x10 = branch(x6, x7, x9)\n    \n    # Apply the chosen function to get the target color\n    x11 = x10(x0)\n    \n    # Find all objects in the input grid again\n    x12 = objects(I, T, F, F)\n    \n    # Filter objects to keep only those with the target color\n    x13 = colorfilter(x12, x11)\n    \n    # Get all objects that are not of the target color\n    x14 = difference(x12, x13)\n    \n    # Create a function that extracts subgrids from the input grid\n    x15 = rbind(subgrid, I)\n    \n    # Extract subgrids for all non-target color objects\n    x16 = apply(x15, x14)\n    \n    # Create a function that counts occurrences of the target color\n    x17 = rbind(colorcount, x11)\n    \n    # Find the subgrid with the most occurrences of the target color\n    # This identifies the object with the most noise of the target color\n    x18 = argmax(x16, x17)\n    \n    # Find the most common color in the identified object\n    # This is the color of the object without considering the noise\n    x19 = mostcolor(x18)\n    \n    # Create a 1x1 grid with the identified color\n    # This is the final output, representing the color of the object with the most noise\n    x20 = canvas(x19, UNITY)\n    \n    # Return the 1x1 grid as the solution\n    return x20\n"
  },
  "ded97339": {
    "original": "def verify_ded97339(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = lbind(recolor, NEG_ONE)\n    x2 = rbind(ofcolor, x0)\n    x3 = chain(x1, backdrop, x2)\n    x4 = fork(paint, identity, x3)\n    x5 = height(I)\n    x6 = vsplit(I, x5)\n    x7 = mapply(x4, x6)\n    x8 = ofcolor(x7, NEG_ONE)\n    x9 = dmirror(I)\n    x10 = width(I)\n    x11 = vsplit(x9, x10)\n    x12 = mapply(x4, x11)\n    x13 = dmirror(x12)\n    x14 = ofcolor(x13, NEG_ONE)\n    x15 = combine(x8, x14)\n    x16 = fill(I, x0, x15)\n    return x16\n\n",
    "annotated": "def verify_ded97339(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Create a function that recolors to -1 (temporary color for lines)\n    x1 = lbind(recolor, NEG_ONE)\n    \n    # Create a function that finds cells of the background color\n    x2 = rbind(ofcolor, x0)\n    \n    # Chain functions: find background cells, get their backdrop, recolor to -1\n    # This creates potential horizontal lines\n    x3 = chain(x1, backdrop, x2)\n    \n    # Create a function that paints the potential lines on a copy of the input\n    x4 = fork(paint, identity, x3)\n    \n    # Get the height of the input grid\n    x5 = height(I)\n    \n    # Split the input grid into individual rows\n    x6 = vsplit(I, x5)\n    \n    # Apply the painting function to each row, creating horizontal lines\n    x7 = mapply(x4, x6)\n    \n    # Find all cells colored -1 in the horizontally lined grid\n    x8 = ofcolor(x7, NEG_ONE)\n    \n    # Mirror the input grid diagonally (transpose)\n    x9 = dmirror(I)\n    \n    # Get the width of the input grid\n    x10 = width(I)\n    \n    # Split the transposed grid into individual columns (now rows)\n    x11 = vsplit(x9, x10)\n    \n    # Apply the painting function to each column, creating vertical lines\n    x12 = mapply(x4, x11)\n    \n    # Mirror back the grid with vertical lines\n    x13 = dmirror(x12)\n    \n    # Find all cells colored -1 in the vertically lined grid\n    x14 = ofcolor(x13, NEG_ONE)\n    \n    # Combine the horizontal and vertical line cells\n    x15 = combine(x8, x14)\n    \n    # Fill the input grid with the background color at all line positions\n    # This effectively draws the lines connecting the dots\n    x16 = fill(I, x0, x15)\n    \n    # Return the final grid with lines drawn\n    return x16\n"
  },
  "e179c5f4": {
    "original": "def verify_e179c5f4(I: Grid) -> Grid:\n    x0 = portrait(I)\n    x1 = branch(x0, identity, dmirror)\n    x2 = x1(I)\n    x3 = asindices(x2)\n    x4 = shoot(ORIGIN, UNITY)\n    x5 = intersection(x4, x3)\n    x6 = lrcorner(x5)\n    x7 = shoot(x6, DOWN_LEFT)\n    x8 = intersection(x7, x3)\n    x9 = combine(x5, x8)\n    x10 = llcorner(x9)\n    x11 = remove(x10, x9)\n    x12 = lbind(shift, x11)\n    x13 = height(x11)\n    x14 = lbind(multiply, x13)\n    x15 = chain(x12, toivec, x14)\n    x16 = height(x2)\n    x17 = height(x11)\n    x18 = divide(x16, x17)\n    x19 = increment(x18)\n    x20 = interval(ZERO, x19, ONE)\n    x21 = mapply(x15, x20)\n    x22 = rbind(contained, x21)\n    x23 = sfilter(x3, x22)\n    x24 = asindices(I)\n    x25 = corners(x24)\n    x26 = difference(x24, x25)\n    x27 = toobject(x26, I)\n    x28 = mostcolor(x27)\n    x29 = palette(I)\n    x30 = other(x29, x28)\n    x31 = ulcorner(x3)\n    x32 = index(x2, x31)\n    x33 = equality(x32, x30)\n    x34 = urcorner(x3)\n    x35 = index(x2, x34)\n    x36 = equality(x35, x30)\n    x37 = llcorner(x3)\n    x38 = index(x2, x37)\n    x39 = equality(x38, x30)\n    x40 = lrcorner(x3)\n    x41 = index(x2, x40)\n    x42 = equality(x41, x30)\n    x43 = astuple(x33, x36)\n    x44 = astuple(x39, x42)\n    x45 = combine(x43, x44)\n    x46 = vmirror(x23)\n    x47 = astuple(x23, x46)\n    x48 = hmirror(x23)\n    x49 = hmirror(x46)\n    x50 = astuple(x48, x49)\n    x51 = combine(x47, x50)\n    x52 = pair(x45, x51)\n    x53 = sfilter(x52, first)\n    x54 = mapply(last, x53)\n    x55 = fill(x2, x30, x54)\n    x56 = x1(x55)\n    x57 = replace(x56, x28, EIGHT)\n    return x57\n\n",
    "annotated": "def verify_e179c5f4(I: Grid) -> Grid:\n    # Check if the input grid is portrait (taller than wide)\n    x0 = portrait(I)\n    # If portrait, use identity function; otherwise, use diagonal mirror\n    x1 = branch(x0, identity, dmirror)\n    # Apply the chosen transformation to the input grid\n    x2 = x1(I)\n    # Get all indices of the transformed grid\n    x3 = asindices(x2)\n    # Create a line from origin (0,0) to (1,1) and extend it\n    x4 = shoot(ORIGIN, UNITY)\n    # Find the intersection of this line with the grid indices\n    x5 = intersection(x4, x3)\n    # Get the lower right corner of this intersection\n    x6 = lrcorner(x5)\n    # Create a line from this corner going down and left\n    x7 = shoot(x6, DOWN_LEFT)\n    # Find the intersection of this new line with the grid indices\n    x8 = intersection(x7, x3)\n    # Combine the two intersecting lines\n    x9 = combine(x5, x8)\n    # Get the lower left corner of the combined shape\n    x10 = llcorner(x9)\n    # Remove the lower left corner from the combined shape\n    x11 = remove(x10, x9)\n    # Create a function that shifts by the removed corner\n    x12 = lbind(shift, x11)\n    # Get the height of the shape without the corner\n    x13 = height(x11)\n    # Create a function that multiplies by this height\n    x14 = lbind(multiply, x13)\n    # Chain functions: multiply by height, convert to vertical vector, then shift\n    x15 = chain(x12, toivec, x14)\n    # Get the height of the transformed input grid\n    x16 = height(x2)\n    # Get the height of the shape without the corner\n    x17 = height(x11)\n    # Divide the grid height by the shape height\n    x18 = divide(x16, x17)\n    # Increment this division result\n    x19 = increment(x18)\n    # Create a range from 0 to the incremented division result\n    x20 = interval(ZERO, x19, ONE)\n    # Apply the chained function to this range\n    x21 = mapply(x15, x20)\n    # Create a function that checks if a point is in the result\n    x22 = rbind(contained, x21)\n    # Filter the grid indices based on this containment check\n    x23 = sfilter(x3, x22)\n    # Get all indices of the original input grid\n    x24 = asindices(I)\n    # Get the corner indices of the input grid\n    x25 = corners(x24)\n    # Remove the corners from all indices\n    x26 = difference(x24, x25)\n    # Create an object from these non-corner indices\n    x27 = toobject(x26, I)\n    # Find the most common color in this object (background color)\n    x28 = mostcolor(x27)\n    # Get all colors used in the input grid\n    x29 = palette(I)\n    # Find the other color (not the background color)\n    x30 = other(x29, x28)\n    # Get the upper left corner of the transformed grid\n    x31 = ulcorner(x3)\n    # Get the color at this corner in the transformed grid\n    x32 = index(x2, x31)\n    # Check if this color is the non-background color\n    x33 = equality(x32, x30)\n    # Repeat for upper right corner\n    x34 = urcorner(x3)\n    x35 = index(x2, x34)\n    x36 = equality(x35, x30)\n    # Repeat for lower left corner\n    x37 = llcorner(x3)\n    x38 = index(x2, x37)\n    x39 = equality(x38, x30)\n    # Repeat for lower right corner\n    x40 = lrcorner(x3)\n    x41 = index(x2, x40)\n    x42 = equality(x41, x30)\n    # Combine the corner color checks into tuples\n    x43 = astuple(x33, x36)\n    x44 = astuple(x39, x42)\n    x45 = combine(x43, x44)\n    # Create vertical mirror of the filtered indices\n    x46 = vmirror(x23)\n    # Combine original and vertically mirrored indices\n    x47 = astuple(x23, x46)\n    # Create horizontal mirror of the filtered indices\n    x48 = hmirror(x23)\n    # Create horizontal mirror of the vertical mirror\n    x49 = hmirror(x46)\n    # Combine horizontal mirrors\n    x50 = astuple(x48, x49)\n    # Combine all mirrored versions\n    x51 = combine(x47, x50)\n    # Pair corner checks with mirrored indices\n    x52 = pair(x45, x51)\n    # Filter pairs based on corner checks\n    x53 = sfilter(x52, first)\n    # Get the indices from the filtered pairs\n    x54 = mapply(last, x53)\n    # Fill these indices with the non-background color\n    x55 = fill(x2, x30, x54)\n    # Apply the original transformation (identity or diagonal mirror)\n    x56 = x1(x55)\n    # Replace the background color with 8\n    x57 = replace(x56, x28, EIGHT)\n    return x57\n"
  },
  "e21d9049": {
    "original": "def verify_e21d9049(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = compose(first, last)\n    x3 = totuple(x1)\n    x4 = apply(x2, x3)\n    x5 = mostcommon(x4)\n    x6 = compose(last, last)\n    x7 = totuple(x1)\n    x8 = apply(x6, x7)\n    x9 = mostcommon(x8)\n    x10 = compose(first, last)\n    x11 = matcher(x10, x5)\n    x12 = sfilter(x1, x11)\n    x13 = compose(last, last)\n    x14 = matcher(x13, x9)\n    x15 = sfilter(x1, x14)\n    x16 = objects(I, F, T, T)\n    x17 = size(x16)\n    x18 = equality(x17, TWO)\n    x19 = mfilter(x16, hline)\n    x20 = mfilter(x16, vline)\n    x21 = branch(x18, x19, x12)\n    x22 = branch(x18, x20, x15)\n    x23 = width(x21)\n    x24 = lbind(multiply, x23)\n    x25 = width(I)\n    x26 = divide(x25, x23)\n    x27 = increment(x26)\n    x28 = interval(ZERO, x27, ONE)\n    x29 = apply(x24, x28)\n    x30 = apply(invert, x29)\n    x31 = combine(x29, x30)\n    x32 = apply(tojvec, x31)\n    x33 = lbind(shift, x21)\n    x34 = mapply(x33, x32)\n    x35 = height(x22)\n    x36 = lbind(multiply, x35)\n    x37 = height(I)\n    x38 = height(x21)\n    x39 = divide(x37, x38)\n    x40 = increment(x39)\n    x41 = interval(ZERO, x40, ONE)\n    x42 = apply(x36, x41)\n    x43 = apply(invert, x42)\n    x44 = combine(x42, x43)\n    x45 = apply(toivec, x44)\n    x46 = lbind(shift, x22)\n    x47 = mapply(x46, x45)\n    x48 = combine(x34, x47)\n    x49 = paint(I, x48)\n    return x49\n\n",
    "annotated": "def verify_e21d9049(I: Grid) -> Grid:\n    # Partition the foreground objects in the input grid\n    x0 = fgpartition(I)\n    # Merge all partitioned objects into a single set\n    x1 = merge(x0)\n    # Create a function that gets the first element of the last element\n    x2 = compose(first, last)\n    # Convert the merged set to a tuple\n    x3 = totuple(x1)\n    # Apply the composed function to each element in the tuple\n    x4 = apply(x2, x3)\n    # Find the most common element (color) from the result\n    x5 = mostcommon(x4)\n    # Create a function that gets the last element of the last element\n    x6 = compose(last, last)\n    # Convert the merged set to a tuple again\n    x7 = totuple(x1)\n    # Apply the new composed function to each element in the tuple\n    x8 = apply(x6, x7)\n    # Find the most common element (position) from the result\n    x9 = mostcommon(x8)\n    # Recreate the function that gets the first element of the last element\n    x10 = compose(first, last)\n    # Create a matcher function for the most common color\n    x11 = matcher(x10, x5)\n    # Filter the merged set to keep only elements matching the most common color\n    x12 = sfilter(x1, x11)\n    # Recreate the function that gets the last element of the last element\n    x13 = compose(last, last)\n    # Create a matcher function for the most common position\n    x14 = matcher(x13, x9)\n    # Filter the merged set to keep only elements matching the most common position\n    x15 = sfilter(x1, x14)\n    # Find all objects in the input grid, allowing diagonal connections\n    x16 = objects(I, F, T, T)\n    # Count the number of objects found\n    x17 = size(x16)\n    # Check if there are exactly two objects\n    x18 = equality(x17, TWO)\n    # Filter objects to keep only horizontal lines\n    x19 = mfilter(x16, hline)\n    # Filter objects to keep only vertical lines\n    x20 = mfilter(x16, vline)\n    # Choose horizontal line if there are two objects, otherwise use color-filtered set\n    x21 = branch(x18, x19, x12)\n    # Choose vertical line if there are two objects, otherwise use position-filtered set\n    x22 = branch(x18, x20, x15)\n    # Get the width of the horizontal pattern\n    x23 = width(x21)\n    # Create a function to multiply by the pattern width\n    x24 = lbind(multiply, x23)\n    # Get the width of the input grid\n    x25 = width(I)\n    # Calculate how many times the pattern fits horizontally\n    x26 = divide(x25, x23)\n    # Add 1 to include the original pattern\n    x27 = increment(x26)\n    # Create a range from 0 to the number of pattern repetitions\n    x28 = interval(ZERO, x27, ONE)\n    # Calculate horizontal offsets for each pattern repetition\n    x29 = apply(x24, x28)\n    # Calculate negative horizontal offsets\n    x30 = apply(invert, x29)\n    # Combine positive and negative horizontal offsets\n    x31 = combine(x29, x30)\n    # Convert horizontal offsets to vector format\n    x32 = apply(tojvec, x31)\n    # Create a function to shift the horizontal pattern\n    x33 = lbind(shift, x21)\n    # Apply shifts to create all horizontal pattern repetitions\n    x34 = mapply(x33, x32)\n    # Get the height of the vertical pattern\n    x35 = height(x22)\n    # Create a function to multiply by the pattern height\n    x36 = lbind(multiply, x35)\n    # Get the height of the input grid\n    x37 = height(I)\n    # Get the height of the horizontal pattern\n    x38 = height(x21)\n    # Calculate how many times the pattern fits vertically\n    x39 = divide(x37, x38)\n    # Add 1 to include the original pattern\n    x40 = increment(x39)\n    # Create a range from 0 to the number of vertical pattern repetitions\n    x41 = interval(ZERO, x40, ONE)\n    # Calculate vertical offsets for each pattern repetition\n    x42 = apply(x36, x41)\n    # Calculate negative vertical offsets\n    x43 = apply(invert, x42)\n    # Combine positive and negative vertical offsets\n    x44 = combine(x42, x43)\n    # Convert vertical offsets to vector format\n    x45 = apply(toivec, x44)\n    # Create a function to shift the vertical pattern\n    x46 = lbind(shift, x22)\n    # Apply shifts to create all vertical pattern repetitions\n    x47 = mapply(x46, x45)\n    # Combine all horizontal and vertical pattern repetitions\n    x48 = combine(x34, x47)\n    # Paint the repeated patterns onto the input grid to create the output\n    x49 = paint(I, x48)\n    return x49\n"
  },
  "e26a3af2": {
    "original": "def verify_e26a3af2(I: Grid) -> Grid:\n    x0 = rot90(I)\n    x1 = apply(mostcommon, I)\n    x2 = apply(mostcommon, x0)\n    x3 = repeat(x1, ONE)\n    x4 = repeat(x2, ONE)\n    x5 = compose(size, dedupe)\n    x6 = x5(x1)\n    x7 = x5(x2)\n    x8 = greater(x7, x6)\n    x9 = branch(x8, height, width)\n    x10 = x9(I)\n    x11 = rot90(x3)\n    x12 = branch(x8, x4, x11)\n    x13 = branch(x8, vupscale, hupscale)\n    x14 = x13(x12, x10)\n    return x14\n\n",
    "annotated": "def verify_e26a3af2(I: Grid) -> Grid:\n    # Rotate the input grid 90 degrees clockwise\n    x0 = rot90(I)\n    \n    # Find the most common color in each row of the input grid\n    x1 = apply(mostcommon, I)\n    \n    # Find the most common color in each column of the original input grid\n    x2 = apply(mostcommon, x0)\n    \n    # Create a single-row grid from the most common colors in rows\n    x3 = repeat(x1, ONE)\n    \n    # Create a single-row grid from the most common colors in columns\n    x4 = repeat(x2, ONE)\n    \n    # Create a function that counts unique elements\n    x5 = compose(size, dedupe)\n    \n    # Count the number of unique colors in rows\n    x6 = x5(x1)\n    \n    # Count the number of unique colors in columns\n    x7 = x5(x2)\n    \n    # Check if there are more unique colors in columns than in rows\n    x8 = greater(x7, x6)\n    \n    # Choose height if more unique colors in columns, otherwise width\n    x9 = branch(x8, height, width)\n    \n    # Get either the height or width of the input grid based on the previous condition\n    x10 = x9(I)\n    \n    # Rotate the row of most common colors to create a column\n    x11 = rot90(x3)\n    \n    # Choose between column and row of most common colors based on earlier condition\n    x12 = branch(x8, x4, x11)\n    \n    # Choose between vertical and horizontal upscaling based on earlier condition\n    x13 = branch(x8, vupscale, hupscale)\n    \n    # Upscale the chosen color pattern (x12) to match the input grid's dimensions\n    # This effectively \"denoises\" the input by expanding the most common color pattern\n    x14 = x13(x12, x10)\n    \n    # Return the upscaled and denoised grid\n    return x14\n"
  },
  "e3497940": {
    "original": "def verify_e3497940(I: Grid) -> Grid:\n    x0 = lefthalf(I)\n    x1 = righthalf(I)\n    x2 = vmirror(x1)\n    x3 = width(I)\n    x4 = hsplit(I, x3)\n    x5 = first(x4)\n    x6 = mostcolor(x5)\n    x7 = objects(x2, T, F, F)\n    x8 = matcher(color, x6)\n    x9 = compose(flip, x8)\n    x10 = sfilter(x7, x9)\n    x11 = merge(x10)\n    x12 = paint(x0, x11)\n    return x12\n\n",
    "annotated": "def verify_e3497940(I: Grid) -> Grid:\n    # Get the left half of the input grid\n    x0 = lefthalf(I)\n    \n    # Get the right half of the input grid\n    x1 = righthalf(I)\n    \n    # Mirror the right half vertically\n    x2 = vmirror(x1)\n    \n    # Get the width of the input grid\n    x3 = width(I)\n    \n    # Split the input grid horizontally into x3 parts (effectively getting each column)\n    x4 = hsplit(I, x3)\n    \n    # Get the first column (which is the separator column)\n    x5 = first(x4)\n    \n    # Find the most common color in the separator column (background color)\n    x6 = mostcolor(x5)\n    \n    # Find all objects in the mirrored right half, including diagonally connected cells\n    x7 = objects(x2, T, F, F)\n    \n    # Create a function that checks if a color matches the background color\n    x8 = matcher(color, x6)\n    \n    # Create a function that checks if a color does NOT match the background color\n    x9 = compose(flip, x8)\n    \n    # Filter objects to keep only those that are not of the background color\n    x10 = sfilter(x7, x9)\n    \n    # Merge all non-background colored objects into a single object\n    x11 = merge(x10)\n    \n    # Paint the merged object onto the left half of the input grid\n    # This effectively copies the pattern from the right to the left, mirrored\n    x12 = paint(x0, x11)\n    \n    # Return the modified left half as the output grid\n    return x12\n"
  },
  "e40b9e2f": {
    "original": "def verify_e40b9e2f(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = mostcolor(I)\n    x3 = uppermost(x1)\n    x4 = leftmost(x1)\n    x5 = height(x1)\n    x6 = width(x1)\n    x7 = interval(SEVEN, ONE, NEG_ONE)\n    x8 = add(x3, x5)\n    x9 = increment(x8)\n    x10 = lbind(subtract, x9)\n    x11 = add(x4, x6)\n    x12 = increment(x11)\n    x13 = lbind(subtract, x12)\n    x14 = lbind(interval, x3)\n    x15 = rbind(x14, ONE)\n    x16 = compose(x15, x10)\n    x17 = lbind(interval, x4)\n    x18 = rbind(x17, ONE)\n    x19 = compose(x18, x13)\n    x20 = fork(product, x16, x19)\n    x21 = fork(equality, identity, rot90)\n    x22 = fork(equality, identity, rot180)\n    x23 = fork(equality, identity, rot270)\n    x24 = fork(both, x22, x23)\n    x25 = fork(both, x21, x24)\n    x26 = fork(astuple, identity, identity)\n    x27 = fork(multiply, identity, identity)\n    x28 = compose(decrement, x27)\n    x29 = initset(ORIGIN)\n    x30 = difference(x29, x29)\n    x31 = rbind(branch, x30)\n    x32 = rbind(colorcount, x2)\n    x33 = rbind(subgrid, I)\n    x34 = lbind(compose, backdrop)\n    x35 = lbind(fork, insert)\n    x36 = lbind(x35, identity)\n    x37 = lbind(compose, initset)\n    x38 = chain(x34, x36, x37)\n    x39 = lbind(rbind, add)\n    x40 = chain(x38, x39, decrement)\n    x41 = lbind(fork, x31)\n    x42 = lbind(fork, both)\n    x43 = lbind(x42, x25)\n    x44 = rbind(compose, shape)\n    x45 = compose(x43, x44)\n    x46 = rbind(compose, x32)\n    x47 = lbind(lbind, greater)\n    x48 = chain(x46, x47, x28)\n    x49 = lbind(rbind, equality)\n    x50 = chain(x45, x49, x26)\n    x51 = fork(x42, x48, x50)\n    x52 = lbind(compose, x33)\n    x53 = compose(x52, x40)\n    x54 = fork(compose, x51, x53)\n    x55 = lbind(compose, initset)\n    x56 = lbind(rbind, astuple)\n    x57 = compose(x55, x56)\n    x58 = fork(x41, x54, x57)\n    x59 = fork(mapply, x58, x20)\n    x60 = center(x1)\n    x61 = astuple(x60, ONE)\n    x62 = repeat(x61, ONE)\n    x63 = mapply(x59, x7)\n    x64 = combine(x62, x63)\n    x65 = valmax(x64, last)\n    x66 = matcher(last, x65)\n    x67 = sfilter(x64, x66)\n    x68 = center(x1)\n    x69 = initset(x68)\n    x70 = rbind(manhattan, x69)\n    x71 = compose(halve, last)\n    x72 = fork(add, first, x71)\n    x73 = compose(initset, x72)\n    x74 = compose(x70, x73)\n    x75 = argmin(x67, x74)\n    x76 = first(x75)\n    x77 = last(x75)\n    x78 = decrement(x77)\n    x79 = add(x76, x78)\n    x80 = initset(x79)\n    x81 = insert(x76, x80)\n    x82 = backdrop(x81)\n    x83 = subgrid(x82, I)\n    x84 = asobject(x83)\n    x85 = rot90(I)\n    x86 = fgpartition(x85)\n    x87 = merge(x86)\n    x88 = rot180(I)\n    x89 = fgpartition(x88)\n    x90 = merge(x89)\n    x91 = rot270(I)\n    x92 = fgpartition(x91)\n    x93 = merge(x92)\n    x94 = rot90(I)\n    x95 = occurrences(x94, x84)\n    x96 = first(x95)\n    x97 = invert(x96)\n    x98 = shift(x87, x97)\n    x99 = shift(x98, x76)\n    x100 = rot180(I)\n    x101 = occurrences(x100, x84)\n    x102 = first(x101)\n    x103 = invert(x102)\n    x104 = shift(x90, x103)\n    x105 = shift(x104, x76)\n    x106 = rot270(I)\n    x107 = occurrences(x106, x84)\n    x108 = first(x107)\n    x109 = invert(x108)\n    x110 = shift(x93, x109)\n    x111 = shift(x110, x76)\n    x112 = combine(x99, x105)\n    x113 = combine(x112, x111)\n    x114 = paint(I, x113)\n    return x114\n\n",
    "annotated": "def verify_e40b9e2f(I: Grid) -> Grid:\n    x0 = fgpartition(I)  # Partition the input grid into foreground objects\n    x1 = merge(x0)  # Merge all foreground objects into a single object\n    x2 = mostcolor(I)  # Find the most common color in the input grid (background color)\n    x3 = uppermost(x1)  # Find the uppermost row of the merged object\n    x4 = leftmost(x1)  # Find the leftmost column of the merged object\n    x5 = height(x1)  # Calculate the height of the merged object\n    x6 = width(x1)  # Calculate the width of the merged object\n    x7 = interval(SEVEN, ONE, NEG_ONE)  # Create a range from 7 to 1 with step -1\n    x8 = add(x3, x5)  # Calculate the lower bound of the object (uppermost + height)\n    x9 = increment(x8)  # Increment the lower bound\n    x10 = lbind(subtract, x9)  # Create a function to subtract from the lower bound\n    x11 = add(x4, x6)  # Calculate the right bound of the object (leftmost + width)\n    x12 = increment(x11)  # Increment the right bound\n    x13 = lbind(subtract, x12)  # Create a function to subtract from the right bound\n    x14 = lbind(interval, x3)  # Create a function to generate intervals starting from uppermost\n    x15 = rbind(x14, ONE)  # Set the step of the interval to 1\n    x16 = compose(x15, x10)  # Compose functions to create vertical intervals within the object\n    x17 = lbind(interval, x4)  # Create a function to generate intervals starting from leftmost\n    x18 = rbind(x17, ONE)  # Set the step of the interval to 1\n    x19 = compose(x18, x13)  # Compose functions to create horizontal intervals within the object\n    x20 = fork(product, x16, x19)  # Create a product of vertical and horizontal intervals (all cells in the object)\n    x21 = fork(equality, identity, rot90)  # Check if the object is equal to its 90-degree rotation\n    x22 = fork(equality, identity, rot180)  # Check if the object is equal to its 180-degree rotation\n    x23 = fork(equality, identity, rot270)  # Check if the object is equal to its 270-degree rotation\n    x24 = fork(both, x22, x23)  # Combine 180 and 270-degree rotation checks\n    x25 = fork(both, x21, x24)  # Combine all rotation checks\n    x26 = fork(astuple, identity, identity)  # Create a tuple of two identical elements\n    x27 = fork(multiply, identity, identity)  # Multiply an element by itself\n    x28 = compose(decrement, x27)  # Decrement the result of self-multiplication\n    x29 = initset(ORIGIN)  # Create a set containing the origin (0, 0)\n    x30 = difference(x29, x29)  # Create an empty set\n    x31 = rbind(branch, x30)  # Create a branch function with empty set as the else condition\n    x32 = rbind(colorcount, x2)  # Create a function to count occurrences of the background color\n    x33 = rbind(subgrid, I)  # Create a function to extract subgrids from the input grid\n    x34 = lbind(compose, backdrop)  # Prepare to compose with the backdrop function\n    x35 = lbind(fork, insert)  # Prepare to fork with the insert function\n    x36 = lbind(x35, identity)  # Prepare to fork insert with identity\n    x37 = lbind(compose, initset)  # Prepare to compose with the initset function\n    x38 = chain(x34, x36, x37)  # Chain multiple functions for set operations\n    x39 = lbind(rbind, add)  # Prepare to bind the right argument of add\n    x40 = chain(x38, x39, decrement)  # Chain set operations with addition and decrement\n    x41 = lbind(fork, x31)  # Prepare to fork with the branch function\n    x42 = lbind(fork, both)  # Prepare to fork with the both function\n    x43 = lbind(x42, x25)  # Prepare to fork both with rotation checks\n    x44 = rbind(compose, shape)  # Prepare to compose with the shape function\n    x45 = compose(x43, x44)  # Compose rotation checks with shape\n    x46 = rbind(compose, x32)  # Prepare to compose with the background color count function\n    x47 = lbind(lbind, greater)  # Prepare to create a greater than function\n    x48 = chain(x46, x47, x28)  # Chain color count, greater than, and decrement operations\n    x49 = lbind(rbind, equality)  # Prepare to bind the right argument of equality\n    x50 = chain(x45, x49, x26)  # Chain rotation checks, equality, and tuple creation\n    x51 = fork(x42, x48, x50)  # Combine color count and rotation check conditions\n    x52 = lbind(compose, x33)  # Prepare to compose with the subgrid function\n    x53 = compose(x52, x40)  # Compose subgrid extraction with set operations\n    x54 = fork(compose, x51, x53)  # Combine condition checks with subgrid extraction\n    x55 = lbind(compose, initset)  # Prepare to compose with the initset function\n    x56 = lbind(rbind, astuple)  # Prepare to bind the right argument of astuple\n    x57 = compose(x55, x56)  # Compose set initialization with tuple creation\n    x58 = fork(x41, x54, x57)  # Combine branching, condition checks, and set operations\n    x59 = fork(mapply, x58, x20)  # Apply the combined operations to all cells in the object\n    x60 = center(x1)  # Find the center of the merged object\n    x61 = astuple(x60, ONE)  # Create a tuple of the center coordinates and 1\n    x62 = repeat(x61, ONE)  # Create a list containing one instance of the center tuple\n    x63 = mapply(x59, x7)  # Apply the combined operations to the range 7 to 1\n    x64 = combine(x62, x63)  # Combine the center tuple with the results of the operations\n    x65 = valmax(x64, last)  # Find the maximum value based on the last element of each tuple\n    x66 = matcher(last, x65)  # Create a function to match the last element with the maximum value\n    x67 = sfilter(x64, x66)  # Filter the combined results to keep only the maximum values\n    x68 = center(x1)  # Find the center of the merged object again\n    x69 = initset(x68)  # Create a set containing the center coordinates\n    x70 = rbind(manhattan, x69)  # Create a function to calculate Manhattan distance from the center\n    x71 = compose(halve, last)  # Create a function to halve the last element of a tuple\n    x72 = fork(add, first, x71)  # Create a function to add the first element and half of the last\n    x73 = compose(initset, x72)  # Create a function to make a set from the result of x72\n    x74 = compose(x70, x73)  # Compose Manhattan distance calculation with set creation\n    x75 = argmin(x67, x74)  # Find the argument with the minimum distance from the center\n    x76 = first(x75)  # Get the first element of the minimum distance tuple\n    x77 = last(x75)  # Get the last element of the minimum distance tuple\n    x78 = decrement(x77)  # Decrement the last element\n    x79 = add(x76, x78)  # Add the first element and the decremented last element\n    x80 = initset(x79)  # Create a set containing the sum\n    x81 = insert(x76, x80)  # Insert the first element into the set\n    x82 = backdrop(x81)  # Create a backdrop (bounding box) for the set\n    x83 = subgrid(x82, I)  # Extract a subgrid from the input using the backdrop\n    x84 = asobject(x83)  # Convert the subgrid to an object\n    x85 = rot90(I)  # Rotate the input grid 90 degrees\n    x86 = fgpartition(x85)  # Partition the rotated grid into foreground objects\n    x87 = merge(x86)  # Merge the partitioned objects of the rotated grid\n    x88 = rot180(I)  # Rotate the input grid 180 degrees\n    x89 = fgpartition(x88)  # Partition the 180-degree rotated grid into foreground objects\n    x90 = merge(x89)  # Merge the partitioned objects of the 180-degree rotated grid\n    x91 = rot270(I)  # Rotate the input grid 270 degrees\n    x92 = fgpartition(x91)  # Partition the 270-degree rotated grid into foreground objects\n    x93 = merge(x92)  # Merge the partitioned objects of the 270-degree rotated grid\n    x94 = rot90(I)  # Rotate the input grid 90 degrees again\n    x95 = occurrences(x94, x84)  # Find occurrences of the subgrid object in the 90-degree rotated grid\n    x96 = first(x95)  # Get the first occurrence\n    x97 = invert(x96)  # Invert the coordinates of the first occurrence\n    x98 = shift(x87, x97)  # Shift the merged objects of the 90-degree rotated grid\n    x99 = shift(x98, x76)  # Shift the result again by the first element of the minimum distance tuple\n    x100 = rot180(I)  # Rotate the input grid 180 degrees again\n    x101 = occurrences(x100, x84)  # Find occurrences of the subgrid object in the 180-degree rotated grid\n    x102 = first(x101)  # Get the first occurrence\n    x103 = invert(x102)  # Invert the coordinates of the first occurrence\n    x104 = shift(x90, x103)  # Shift the merged objects of the 180-degree rotated grid\n    x105 = shift(x104, x76)  # Shift the result again by the first element of the minimum distance tuple\n    x106 = rot270(I)  # Rotate the input grid 270 degrees again\n    x107 = occurrences(x106, x84)  # Find occurrences of the subgrid object in the 270-degree rotated grid\n    x108 = first(x107)  # Get the first occurrence\n    x109 = invert(x108)  # Invert the coordinates of the first occurrence\n    x110 = shift(x93, x109)  # Shift the merged objects of the 270-degree rotated grid\n    x111 = shift(x110, x76)  # Shift the result again by the first element of the minimum distance tuple\n    x112 = combine(x99, x105)  # Combine the shifted objects from 90 and 180-degree rotations\n    x113 = combine(x112, x111)  # Combine the result with the shifted objects from 270-degree rotation\n    x114 = paint(I, x113)  # Paint the combined objects onto the original input grid\n    return x114  # Return the final painted grid\n"
  },
  "e48d4e1a": {
    "original": "def verify_e48d4e1a(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = merge(x0)\n    x2 = color(x1)\n    x3 = asobject(I)\n    x4 = difference(x3, x1)\n    x5 = leastcolor(x4)\n    x6 = colorcount(I, x5)\n    x7 = mostcolor(x4)\n    x8 = ofcolor(I, x5)\n    x9 = toindices(x1)\n    x10 = combine(x9, x8)\n    x11 = fill(I, x7, x10)\n    x12 = argmax(x0, width)\n    x13 = uppermost(x12)\n    x14 = argmax(x0, height)\n    x15 = leftmost(x14)\n    x16 = astuple(x13, x15)\n    x17 = initset(x16)\n    x18 = position(x8, x17)\n    x19 = multiply(x18, x6)\n    x20 = add(x16, x19)\n    x21 = hfrontier(x20)\n    x22 = vfrontier(x20)\n    x23 = combine(x21, x22)\n    x24 = fill(x11, x2, x23)\n    return x24\n\n",
    "annotated": "def verify_e48d4e1a(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines) in the input grid\n    x0 = frontiers(I)\n    \n    # Merge all frontiers into a single object\n    x1 = merge(x0)\n    \n    # Get the color of the merged frontiers (the line color)\n    x2 = color(x1)\n    \n    # Convert the entire input grid to an object\n    x3 = asobject(I)\n    \n    # Remove the frontiers from the grid object, leaving background and dots\n    x4 = difference(x3, x1)\n    \n    # Find the least common color in the remaining grid (likely the dot color)\n    x5 = leastcolor(x4)\n    \n    # Count the number of dots in the input grid\n    x6 = colorcount(I, x5)\n    \n    # Find the most common color in the remaining grid (likely the background color)\n    x7 = mostcolor(x4)\n    \n    # Get the indices of all dots in the input grid\n    x8 = ofcolor(I, x5)\n    \n    # Convert the frontiers to indices\n    x9 = toindices(x1)\n    \n    # Combine the frontier indices with the dot indices\n    x10 = combine(x9, x8)\n    \n    # Fill the combined indices with the background color, effectively erasing the original lines and dots\n    x11 = fill(I, x7, x10)\n    \n    # Find the widest frontier (horizontal line)\n    x12 = argmax(x0, width)\n    \n    # Get the uppermost row of the widest frontier\n    x13 = uppermost(x12)\n    \n    # Find the tallest frontier (vertical line)\n    x14 = argmax(x0, height)\n    \n    # Get the leftmost column of the tallest frontier\n    x15 = leftmost(x14)\n    \n    # Create a tuple of the row and column indices of the original intersection point\n    x16 = astuple(x13, x15)\n    \n    # Create a set with the intersection point\n    x17 = initset(x16)\n    \n    # Determine the relative position of the dots to the intersection point\n    x18 = position(x8, x17)\n    \n    # Multiply the relative position by the number of dots to get the shift amount\n    x19 = multiply(x18, x6)\n    \n    # Calculate the new intersection point by adding the shift to the original point\n    x20 = add(x16, x19)\n    \n    # Create a horizontal frontier at the new intersection point\n    x21 = hfrontier(x20)\n    \n    # Create a vertical frontier at the new intersection point\n    x22 = vfrontier(x20)\n    \n    # Combine the new horizontal and vertical frontiers\n    x23 = combine(x21, x22)\n    \n    # Fill the new frontiers with the original line color on the cleared grid\n    x24 = fill(x11, x2, x23)\n    \n    # Return the final grid with the shifted intersection point\n    return x24\n"
  },
  "e5062a87": {
    "original": "def verify_e5062a87(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = ofcolor(I, x0)\n    x2 = recolor(ZERO, x1)\n    x3 = normalize(x2)\n    x4 = occurrences(I, x3)\n    x5 = toindices(x3)\n    x6 = lbind(shift, x5)\n    x7 = mapply(x6, x4)\n    x8 = fill(I, x0, x7)\n    return x8\n\n",
    "annotated": "def verify_e5062a87(I: Grid) -> Grid:\n    # Find the least common color in the input grid\n    # This is likely the color of the object we're looking for\n    x0 = leastcolor(I)\n\n    # Get all cells in the input grid that have the least common color\n    # This creates a set of indices where the object appears\n    x1 = ofcolor(I, x0)\n\n    # Recolor all cells of the object to 0 (black)\n    # This creates a standardized representation of the object\n    x2 = recolor(ZERO, x1)\n\n    # Normalize the object by moving it to the origin (top-left corner)\n    # This allows us to compare it regardless of its position in the grid\n    x3 = normalize(x2)\n\n    # Find all occurrences of the normalized object in the input grid\n    # This identifies all instances of the object, including those with different colors\n    x4 = occurrences(I, x3)\n\n    # Convert the normalized object to a set of indices\n    # This gives us the shape of the object as a set of coordinate pairs\n    x5 = toindices(x3)\n\n    # Create a partially applied function that shifts the object shape\n    # This function will be used to move the object to different positions\n    x6 = lbind(shift, x5)\n\n    # Apply the shift function to all occurrences of the object\n    # This creates a set of all object instances at their actual positions in the grid\n    x7 = mapply(x6, x4)\n\n    # Fill all instances of the object with the least common color\n    # This creates the output grid where all object instances are colored uniformly\n    x8 = fill(I, x0, x7)\n\n    # Return the modified grid as the output\n    return x8\n"
  },
  "e509e548": {
    "original": "def verify_e509e548(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = fork(add, height, width)\n    x2 = compose(decrement, x1)\n    x3 = fork(equality, size, x2)\n    x4 = fork(difference, toindices, box)\n    x5 = compose(size, x4)\n    x6 = matcher(x5, ZERO)\n    x7 = sfilter(x0, x3)\n    x8 = difference(x0, x7)\n    x9 = sfilter(x8, x6)\n    x10 = merge(x0)\n    x11 = fill(I, TWO, x10)\n    x12 = merge(x7)\n    x13 = fill(x11, ONE, x12)\n    x14 = merge(x9)\n    x15 = fill(x13, SIX, x14)\n    return x15\n\n",
    "annotated": "def verify_e509e548(I: Grid) -> Grid:\n    # Extract all objects from the input grid, considering diagonal connections and ignoring the background color\n    x0 = objects(I, T, F, T)\n    \n    # Create a function that adds the height and width of an object\n    x1 = fork(add, height, width)\n    \n    # Create a function that decrements the sum of height and width by 1\n    x2 = compose(decrement, x1)\n    \n    # Create a function that checks if an object's size equals its height + width - 1\n    x3 = fork(equality, size, x2)\n    \n    # Create a function that finds the difference between an object's indices and its bounding box\n    x4 = fork(difference, toindices, box)\n    \n    # Create a function that returns the size of the difference between an object's indices and its bounding box\n    x5 = compose(size, x4)\n    \n    # Create a function that checks if an object perfectly fills its bounding box (no gaps)\n    x6 = matcher(x5, ZERO)\n    \n    # Filter objects that have size equal to height + width - 1 (L-shapes)\n    x7 = sfilter(x0, x3)\n    \n    # Get all objects that are not L-shapes\n    x8 = difference(x0, x7)\n    \n    # Filter non-L-shape objects that perfectly fill their bounding box (U-shapes and H-shapes)\n    x9 = sfilter(x8, x6)\n    \n    # Merge all object indices into a single set\n    x10 = merge(x0)\n    \n    # Fill all object areas with color 2 (default for H-shapes)\n    x11 = fill(I, TWO, x10)\n    \n    # Merge all L-shape object indices\n    x12 = merge(x7)\n    \n    # Fill L-shape areas with color 1\n    x13 = fill(x11, ONE, x12)\n    \n    # Merge all U-shape and H-shape object indices\n    x14 = merge(x9)\n    \n    # Fill U-shape and H-shape areas with color 6 (U-shapes will keep this color, H-shapes already have color 2)\n    x15 = fill(x13, SIX, x14)\n    \n    # Return the final grid with all shapes colored according to their type\n    return x15\n"
  },
  "e50d258f": {
    "original": "def verify_e50d258f(I: Grid) -> Grid:\n    x0 = asindices(I)\n    x1 = box(x0)\n    x2 = toobject(x1, I)\n    x3 = mostcolor(x2)\n    x4 = shape(I)\n    x5 = canvas(x3, x4)\n    x6 = hconcat(I, x5)\n    x7 = objects(x6, F, F, T)\n    x8 = rbind(colorcount, TWO)\n    x9 = argmax(x7, x8)\n    x10 = subgrid(x9, I)\n    return x10\n\n",
    "annotated": "def verify_e50d258f(I: Grid) -> Grid:\n    # Get all indices of the input grid\n    x0 = asindices(I)\n    \n    # Create a box (outline) around the entire grid\n    x1 = box(x0)\n    \n    # Convert the box outline to an object using the colors from the input grid\n    x2 = toobject(x1, I)\n    \n    # Find the most common color in the box outline (likely the background color)\n    x3 = mostcolor(x2)\n    \n    # Get the dimensions (shape) of the input grid\n    x4 = shape(I)\n    \n    # Create a new grid with the same dimensions as the input, filled with the most common color\n    x5 = canvas(x3, x4)\n    \n    # Concatenate the input grid and the new background grid horizontally\n    # This effectively doubles the width of the grid\n    x6 = hconcat(I, x5)\n    \n    # Find all objects in the concatenated grid, ignoring background\n    # F, F, T parameters mean: not univalued, not diagonal, without background\n    x7 = objects(x6, F, F, T)\n    \n    # Create a function that counts the number of cells with color 2 (red) in an object\n    x8 = rbind(colorcount, TWO)\n    \n    # Find the object with the maximum number of red (color 2) cells\n    x9 = argmax(x7, x8)\n    \n    # Extract the subgrid from the original input that corresponds to this object\n    # This is the final output - the object with the most red cells\n    x10 = subgrid(x9, I)\n    \n    return x10\n"
  },
  "e6721834": {
    "original": "def verify_e6721834(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = sfilter(x0, vline)\n    x4 = size(x3)\n    x5 = greater(x2, x4)\n    x6 = branch(x5, vsplit, hsplit)\n    x7 = x6(I, TWO)\n    x8 = order(x7, numcolors)\n    x9 = first(x8)\n    x10 = last(x8)\n    x11 = objects(x10, F, F, T)\n    x12 = merge(x11)\n    x13 = mostcolor(x12)\n    x14 = matcher(first, x13)\n    x15 = compose(flip, x14)\n    x16 = rbind(sfilter, x15)\n    x17 = mostcolor(x9)\n    x18 = lbind(recolor, x17)\n    x19 = rbind(sfilter, x14)\n    x20 = compose(toindices, x19)\n    x21 = fork(combine, x20, outbox)\n    x22 = compose(x18, x21)\n    x23 = fork(combine, x16, x22)\n    x24 = shape(x9)\n    x25 = add(TWO, x24)\n    x26 = canvas(x17, x25)\n    x27 = asobject(x9)\n    x28 = shift(x27, UNITY)\n    x29 = paint(x26, x28)\n    x30 = rbind(shift, NEG_UNITY)\n    x31 = lbind(occurrences, x29)\n    x32 = compose(x30, x31)\n    x33 = compose(x32, x23)\n    x34 = chain(positive, size, x33)\n    x35 = sfilter(x11, x34)\n    x36 = chain(first, x32, x23)\n    x37 = compose(ulcorner, x23)\n    x38 = fork(subtract, x36, x37)\n    x39 = fork(shift, identity, x38)\n    x40 = mapply(x39, x35)\n    x41 = paint(x9, x40)\n    return x41\n\n",
    "annotated": "def verify_e6721834(I: Grid) -> Grid:\n    # Get all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out horizontal frontiers\n    x1 = sfilter(x0, hline)\n    # Count the number of horizontal frontiers\n    x2 = size(x1)\n    # Filter out vertical frontiers\n    x3 = sfilter(x0, vline)\n    # Count the number of vertical frontiers\n    x4 = size(x3)\n    # Check if there are more horizontal frontiers than vertical\n    x5 = greater(x2, x4)\n    # Choose vsplit if more horizontal frontiers, else hsplit\n    x6 = branch(x5, vsplit, hsplit)\n    # Split the input grid into two parts based on the chosen split function\n    x7 = x6(I, TWO)\n    # Order the two parts based on the number of colors in each\n    x8 = order(x7, numcolors)\n    # Get the part with fewer colors (likely the background)\n    x9 = first(x8)\n    # Get the part with more colors (likely containing the objects)\n    x10 = last(x8)\n    # Identify objects in the part with more colors, ignoring background\n    x11 = objects(x10, F, F, T)\n    # Merge all objects into a single set of cells\n    x12 = merge(x11)\n    # Find the most common color in the merged objects (likely the square color)\n    x13 = mostcolor(x12)\n    # Create a function to match cells with the square color\n    x14 = matcher(first, x13)\n    # Create a function to match cells that are not the square color\n    x15 = compose(flip, x14)\n    # Create a function to filter objects that are not the square color\n    x16 = rbind(sfilter, x15)\n    # Find the most common color in the background part (likely the new background color)\n    x17 = mostcolor(x9)\n    # Create a function to recolor objects with the new background color\n    x18 = lbind(recolor, x17)\n    # Create a function to filter objects that are the square color\n    x19 = rbind(sfilter, x14)\n    # Create a function to get indices of cells that are the square color\n    x20 = compose(toindices, x19)\n    # Create a function to combine square color cells with their outbox\n    x21 = fork(combine, x20, outbox)\n    # Create a function to recolor the combined cells with the new background color\n    x22 = compose(x18, x21)\n    # Create a function to process objects: keep non-square color cells and recolor square areas\n    x23 = fork(combine, x16, x22)\n    # Get the dimensions of the background part\n    x24 = shape(x9)\n    # Increase dimensions by 2 in each direction\n    x25 = add(TWO, x24)\n    # Create a new canvas with the new background color and increased dimensions\n    x26 = canvas(x17, x25)\n    # Convert the background part to an object\n    x27 = asobject(x9)\n    # Shift the background object by (1, 1)\n    x28 = shift(x27, UNITY)\n    # Paint the shifted background onto the new canvas\n    x29 = paint(x26, x28)\n    # Create a function to shift objects by (-1, -1)\n    x30 = rbind(shift, NEG_UNITY)\n    # Create a function to find occurrences of objects in the new canvas\n    x31 = lbind(occurrences, x29)\n    # Combine the shift and occurrence functions\n    x32 = compose(x30, x31)\n    # Create a function to process and find occurrences of objects\n    x33 = compose(x32, x23)\n    # Create a function to check if an object has any valid occurrences\n    x34 = chain(positive, size, x33)\n    # Filter objects that have valid occurrences\n    x35 = sfilter(x11, x34)\n    # Create a function to get the first valid occurrence of an object\n    x36 = chain(first, x32, x23)\n    # Create a function to get the upper-left corner of the processed object\n    x37 = compose(ulcorner, x23)\n    # Create a function to calculate the shift needed for each object\n    x38 = fork(subtract, x36, x37)\n    # Create a function to shift objects to their new positions\n    x39 = fork(shift, identity, x38)\n    # Apply the shift function to all valid objects\n    x40 = mapply(x39, x35)\n    # Paint the shifted objects onto the background part\n    x41 = paint(x9, x40)\n    # Return the final output grid\n    return x41\n"
  },
  "e73095fd": {
    "original": "def verify_e73095fd(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = mostcolor(I)\n    x2 = colorfilter(x0, x1)\n    x3 = fork(equality, toindices, backdrop)\n    x4 = sfilter(x2, x3)\n    x5 = lbind(mapply, dneighbors)\n    x6 = chain(x5, corners, outbox)\n    x7 = fork(difference, x6, outbox)\n    x8 = leastcolor(I)\n    x9 = ofcolor(I, x8)\n    x10 = rbind(intersection, x9)\n    x11 = matcher(size, ZERO)\n    x12 = chain(x11, x10, x7)\n    x13 = mfilter(x4, x12)\n    x14 = fill(I, FOUR, x13)\n    return x14\n\n",
    "annotated": "def verify_e73095fd(I: Grid) -> Grid:\n    # Identify all objects in the input grid, considering connectivity and ignoring background\n    x0 = objects(I, T, F, F)\n    \n    # Find the most common color in the input grid (background color)\n    x1 = mostcolor(I)\n    \n    # Filter objects to keep only those with the background color\n    x2 = colorfilter(x0, x1)\n    \n    # Create a function that checks if an object's indices match its backdrop\n    x3 = fork(equality, toindices, backdrop)\n    \n    # Filter objects to keep only those that are rectangular (indices match backdrop)\n    x4 = sfilter(x2, x3)\n    \n    # Create a function to get the directly adjacent neighbors of all corners\n    x5 = lbind(mapply, dneighbors)\n    \n    # Create a function to get the outer neighbors of the outbox of an object's corners\n    x6 = chain(x5, corners, outbox)\n    \n    # Create a function to get the outer neighbors excluding the immediate outbox\n    x7 = fork(difference, x6, outbox)\n    \n    # Find the least common color in the input grid (likely the line color)\n    x8 = leastcolor(I)\n    \n    # Get all cells with the least common color\n    x9 = ofcolor(I, x8)\n    \n    # Create a function to intersect a set with x9 (line color cells)\n    x10 = rbind(intersection, x9)\n    \n    # Create a function that checks if a set has zero size\n    x11 = matcher(size, ZERO)\n    \n    # Create a function to check if an object has no line color cells in its outer neighbors\n    x12 = chain(x11, x10, x7)\n    \n    # Filter and merge objects that satisfy the condition (boxes to be filled)\n    x13 = mfilter(x4, x12)\n    \n    # Fill the identified boxes with color 4 in the input grid\n    x14 = fill(I, FOUR, x13)\n    \n    # Return the modified grid with filled boxes\n    return x14\n"
  },
  "e76a88a6": {
    "original": "def verify_e76a88a6(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = argmax(x0, numcolors)\n    x2 = normalize(x1)\n    x3 = remove(x1, x0)\n    x4 = apply(ulcorner, x3)\n    x5 = lbind(shift, x2)\n    x6 = mapply(x5, x4)\n    x7 = paint(I, x6)\n    return x7\n\n",
    "annotated": "def verify_e76a88a6(I: Grid) -> Grid:\n    # Find all objects in the input grid, ignoring the background color\n    x0 = objects(I, F, F, T)\n    \n    # Select the object with the most colors (likely the template shape)\n    x1 = argmax(x0, numcolors)\n    \n    # Normalize the position of the template shape to the origin\n    x2 = normalize(x1)\n    \n    # Remove the template shape from the set of all objects\n    x3 = remove(x1, x0)\n    \n    # Get the upper-left corners of all remaining objects (dummy shapes)\n    x4 = apply(ulcorner, x3)\n    \n    # Create a function that shifts the normalized template shape\n    x5 = lbind(shift, x2)\n    \n    # Apply the shift function to all upper-left corners, effectively placing the template shape at each dummy shape position\n    x6 = mapply(x5, x4)\n    \n    # Paint all the newly positioned template shapes onto the input grid\n    # This replaces all dummy shapes with copies of the template shape\n    x7 = paint(I, x6)\n    \n    # Return the modified grid as the output\n    return x7\n"
  },
  "e8593010": {
    "original": "def verify_e8593010(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = sizefilter(x0, ONE)\n    x2 = sizefilter(x0, TWO)\n    x3 = sizefilter(x0, THREE)\n    x4 = merge(x1)\n    x5 = fill(I, THREE, x4)\n    x6 = merge(x2)\n    x7 = fill(x5, TWO, x6)\n    x8 = merge(x3)\n    x9 = fill(x7, ONE, x8)\n    return x9\n\n",
    "annotated": "def verify_e8593010(I: Grid) -> Grid:\n    # Extract all objects from the input grid, allowing multi-colored objects and considering diagonals as not connected\n    x0 = objects(I, T, F, T)\n    \n    # Filter objects to keep only those with size 1 (single pixels)\n    x1 = sizefilter(x0, ONE)\n    \n    # Filter objects to keep only those with size 2 (two connected pixels)\n    x2 = sizefilter(x0, TWO)\n    \n    # Filter objects to keep only those with size 3 (three connected pixels)\n    x3 = sizefilter(x0, THREE)\n    \n    # Merge all single-pixel objects into one set\n    x4 = merge(x1)\n    \n    # Fill the input grid with color 3 at the positions of single-pixel objects\n    # This effectively colors all isolated pixels with 3\n    x5 = fill(I, THREE, x4)\n    \n    # Merge all two-pixel objects into one set\n    x6 = merge(x2)\n    \n    # Fill the previously modified grid (x5) with color 2 at the positions of two-pixel objects\n    # This colors all two-pixel shapes (lines) with 2\n    x7 = fill(x5, TWO, x6)\n    \n    # Merge all three-pixel objects into one set\n    x8 = merge(x3)\n    \n    # Fill the previously modified grid (x7) with color 1 at the positions of three-pixel objects\n    # This colors all three-pixel shapes (L-shapes, corners, lines) with 1\n    x9 = fill(x7, ONE, x8)\n    \n    # Return the final modified grid\n    # The result is a grid where single pixels are colored 3, two-pixel shapes are colored 2,\n    # three-pixel shapes are colored 1, and all other pixels retain their original color\n    return x9\n"
  },
  "e8dc4411": {
    "original": "def verify_e8dc4411(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = argmax(x0, size)\n    x2 = other(x0, x1)\n    x3 = ineighbors(ORIGIN)\n    x4 = height(x1)\n    x5 = increment(x4)\n    x6 = interval(ZERO, x5, ONE)\n    x7 = lbind(intersection, x1)\n    x8 = chain(positive, size, x7)\n    x9 = lbind(shift, x1)\n    x10 = rbind(multiply, UNITY)\n    x11 = chain(x8, x9, x10)\n    x12 = sfilter(x6, x11)\n    x13 = maximum(x12)\n    x14 = increment(x13)\n    x15 = toindices(x2)\n    x16 = lbind(intersection, x15)\n    x17 = lbind(shift, x1)\n    x18 = rbind(multiply, x14)\n    x19 = chain(toindices, x17, x18)\n    x20 = chain(size, x16, x19)\n    x21 = argmax(x3, x20)\n    x22 = shape(I)\n    x23 = maximum(x22)\n    x24 = increment(x23)\n    x25 = interval(ONE, x24, ONE)\n    x26 = lbind(shift, x1)\n    x27 = multiply(x14, x21)\n    x28 = lbind(multiply, x27)\n    x29 = pair(x25, x25)\n    x30 = apply(x28, x29)\n    x31 = mapply(x26, x30)\n    x32 = color(x2)\n    x33 = recolor(x32, x31)\n    x34 = paint(I, x33)\n    return x34\n\n",
    "annotated": "def verify_e8dc4411(I: Grid) -> Grid:\n    # Partition the input grid into foreground objects\n    x0 = fgpartition(I)\n    \n    # Find the largest object (main shape)\n    x1 = argmax(x0, size)\n    \n    # Find the other object (indicator cells)\n    x2 = other(x0, x1)\n    \n    # Get the diagonal neighbors of the origin (used for determining shift direction)\n    x3 = ineighbors(ORIGIN)\n    \n    # Get the height of the main shape\n    x4 = height(x1)\n    \n    # Increment the height (to include one more step in the search range)\n    x5 = increment(x4)\n    \n    # Create a range from 0 to the incremented height\n    x6 = interval(ZERO, x5, ONE)\n    \n    # Prepare a function to find intersection of main shape with shifted versions\n    x7 = lbind(intersection, x1)\n    \n    # Chain functions to check if shifted shape intersects with original and has positive size\n    x8 = chain(positive, size, x7)\n    \n    # Prepare a function to shift the main shape\n    x9 = lbind(shift, x1)\n    \n    # Prepare a function to multiply by unity (for creating shift vectors)\n    x10 = rbind(multiply, UNITY)\n    \n    # Chain functions to check if a shift results in a valid intersection\n    x11 = chain(x8, x9, x10)\n    \n    # Filter the range to find valid shift distances\n    x12 = sfilter(x6, x11)\n    \n    # Find the maximum valid shift distance\n    x13 = maximum(x12)\n    \n    # Increment the maximum shift distance (to get the actual shift amount)\n    x14 = increment(x13)\n    \n    # Get the indices of the indicator cells\n    x15 = toindices(x2)\n    \n    # Prepare a function to find intersection with indicator cells\n    x16 = lbind(intersection, x15)\n    \n    # Prepare a function to shift the main shape\n    x17 = lbind(shift, x1)\n    \n    # Prepare a function to multiply by the shift amount\n    x18 = rbind(multiply, x14)\n    \n    # Chain functions to get indices of shifted main shape\n    x19 = chain(toindices, x17, x18)\n    \n    # Chain functions to count intersections of shifted shape with indicators\n    x20 = chain(size, x16, x19)\n    \n    # Find the diagonal direction with maximum intersection (shift direction)\n    x21 = argmax(x3, x20)\n    \n    # Get the shape (dimensions) of the input grid\n    x22 = shape(I)\n    \n    # Find the maximum dimension of the input grid\n    x23 = maximum(x22)\n    \n    # Increment the maximum dimension (to include one more step in the range)\n    x24 = increment(x23)\n    \n    # Create a range from 1 to the incremented maximum dimension\n    x25 = interval(ONE, x24, ONE)\n    \n    # Prepare a function to shift the main shape\n    x26 = lbind(shift, x1)\n    \n    # Calculate the full shift vector\n    x27 = multiply(x14, x21)\n    \n    # Prepare a function to multiply by the full shift vector\n    x28 = lbind(multiply, x27)\n    \n    # Create pairs of coordinates for all possible shifts\n    x29 = pair(x25, x25)\n    \n    # Apply the shift vector multiplication to all coordinate pairs\n    x30 = apply(x28, x29)\n    \n    # Apply all possible shifts to the main shape\n    x31 = mapply(x26, x30)\n    \n    # Get the color of the indicator cells\n    x32 = color(x2)\n    \n    # Recolor all shifted shapes with the indicator color\n    x33 = recolor(x32, x31)\n    \n    # Paint the shifted and recolored shapes onto the input grid\n    x34 = paint(I, x33)\n    \n    # Return the final grid with the pattern extended\n    return x34\n"
  },
  "e9614598": {
    "original": "def verify_e9614598(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = merge(x0)\n    x2 = center(x1)\n    x3 = dneighbors(x2)\n    x4 = insert(x2, x3)\n    x5 = fill(I, THREE, x4)\n    return x5\n\n",
    "annotated": "def verify_e9614598(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Merge all the foreground objects into a single set of cells\n    x1 = merge(x0)\n    \n    # Find the center point of the merged foreground objects\n    # This will be the center of the pattern\n    x2 = center(x1)\n    \n    # Get the directly adjacent neighbors of the center point\n    # This creates the \"arms\" of the plus sign\n    x3 = dneighbors(x2)\n    \n    # Combine the center point with its neighbors\n    # This forms the complete plus sign shape\n    x4 = insert(x2, x3)\n    \n    # Fill the plus sign shape with the color green (3)\n    # This creates the final output by adding the green plus sign to the input grid\n    x5 = fill(I, THREE, x4)\n    \n    # Return the modified grid as the output\n    return x5\n"
  },
  "e98196ab": {
    "original": "def verify_e98196ab(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, vsplit, hsplit)\n    x5 = x4(I, TWO)\n    x6 = first(x5)\n    x7 = last(x5)\n    x8 = fgpartition(x7)\n    x9 = merge(x8)\n    x10 = paint(x6, x9)\n    return x10\n\n",
    "annotated": "def verify_e98196ab(I: Grid) -> Grid:\n    # Get all frontiers (continuous lines of the same color) in the input grid\n    x0 = frontiers(I)\n    \n    # Filter out horizontal lines from the frontiers\n    x1 = sfilter(x0, hline)\n    \n    # Count the number of horizontal lines\n    x2 = size(x1)\n    \n    # Check if there is at least one horizontal line\n    x3 = positive(x2)\n    \n    # If there's a horizontal line, use vsplit; otherwise, use hsplit\n    # This determines whether to split the grid vertically or horizontally\n    x4 = branch(x3, vsplit, hsplit)\n    \n    # Split the input grid into two parts using the chosen split function\n    # If vertical split: upper and lower parts; if horizontal split: left and right parts\n    x5 = x4(I, TWO)\n    \n    # Get the first part of the split (upper or left part)\n    x6 = first(x5)\n    \n    # Get the second part of the split (lower or right part)\n    x7 = last(x5)\n    \n    # Partition the second part into objects, excluding the background color\n    x8 = fgpartition(x7)\n    \n    # Merge all the partitioned objects into a single object\n    x9 = merge(x8)\n    \n    # Paint the merged object onto the first part of the split\n    # This effectively removes the dividing line and combines the colored regions\n    x10 = paint(x6, x9)\n    \n    # Return the final grid with the dividing line removed and regions combined\n    return x10\n"
  },
  "e9afcf9a": {
    "original": "def verify_e9afcf9a(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = height(I)\n    x2 = decrement(x1)\n    x3 = lbind(subtract, x2)\n    x4 = compose(double, halve)\n    x5 = fork(equality, identity, x4)\n    x6 = compose(last, last)\n    x7 = chain(flip, x5, x6)\n    x8 = sfilter(x0, x7)\n    x9 = chain(x3, first, last)\n    x10 = compose(last, last)\n    x11 = fork(astuple, x9, x10)\n    x12 = fork(astuple, first, x11)\n    x13 = apply(x12, x8)\n    x14 = paint(I, x13)\n    return x14\n\n",
    "annotated": "def verify_e9afcf9a(I: Grid) -> Grid:\n    # Convert the input grid to an object (set of (color, position) tuples)\n    x0 = asobject(I)\n    \n    # Get the height of the input grid\n    x1 = height(I)\n    \n    # Decrement the height by 1 (to get the last row index)\n    x2 = decrement(x1)\n    \n    # Create a function that subtracts from the last row index\n    x3 = lbind(subtract, x2)\n    \n    # Create a function that doubles a number and then halves it (effectively rounding to even)\n    x4 = compose(double, halve)\n    \n    # Create a function that checks if a number is equal to its rounded even value\n    x5 = fork(equality, identity, x4)\n    \n    # Create a function that gets the color of the bottom-right cell\n    x6 = compose(last, last)\n    \n    # Create a function that checks if a cell's row is odd relative to the bottom row\n    x7 = chain(flip, x5, x6)\n    \n    # Filter the grid object to keep only cells in odd rows relative to the bottom\n    x8 = sfilter(x0, x7)\n    \n    # Create a function that computes the row index relative to the bottom\n    x9 = chain(x3, first, last)\n    \n    # Create a function that gets the column index (last element of the position tuple)\n    x10 = compose(last, last)\n    \n    # Create a function that pairs the relative row index with the column index\n    x11 = fork(astuple, x9, x10)\n    \n    # Create a function that pairs the color with the new position\n    x12 = fork(astuple, first, x11)\n    \n    # Apply the color-position pairing function to all cells in odd rows\n    x13 = apply(x12, x8)\n    \n    # Paint the new positions of the odd-row cells onto the original grid\n    # This effectively flips the colors in odd rows, creating the alternating stripe pattern\n    x14 = paint(I, x13)\n    \n    # Return the modified grid\n    return x14\n"
  },
  "ea32f347": {
    "original": "def verify_ea32f347(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = merge(x0)\n    x2 = fill(I, FOUR, x1)\n    x3 = argmin(x0, size)\n    x4 = argmax(x0, size)\n    x5 = fill(x2, ONE, x4)\n    x6 = fill(x5, TWO, x3)\n    return x6\n\n",
    "annotated": "def verify_ea32f347(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and excluding the background\n    x0 = objects(I, T, F, T)\n    \n    # Merge all found objects into a single set of indices\n    x1 = merge(x0)\n    \n    # Fill the merged object area with color 4 (blue) in the input grid\n    # This effectively colors all non-background elements blue\n    x2 = fill(I, FOUR, x1)\n    \n    # Find the smallest object (by number of cells) from the set of objects\n    x3 = argmin(x0, size)\n    \n    # Find the largest object (by number of cells) from the set of objects\n    x4 = argmax(x0, size)\n    \n    # Fill the largest object area with color 1 (dark blue) in the previously modified grid\n    # This changes the largest non-background shape to dark blue\n    x5 = fill(x2, ONE, x4)\n    \n    # Fill the smallest object area with color 2 (red) in the previously modified grid\n    # This changes the smallest non-background shape to red\n    x6 = fill(x5, TWO, x3)\n    \n    # Return the final modified grid\n    # The result is a grid where the background is unchanged, the largest shape is dark blue,\n    # the smallest shape is red, and any other shapes (if present) are blue\n    return x6\n"
  },
  "ea786f4a": {
    "original": "def verify_ea786f4a(I: Grid) -> Grid:\n    x0 = shape(I)\n    x1 = halve(x0)\n    x2 = rbind(shoot, UP_RIGHT)\n    x3 = rbind(shoot, DOWN_LEFT)\n    x4 = fork(combine, x2, x3)\n    x5 = rbind(shoot, UNITY)\n    x6 = rbind(shoot, NEG_UNITY)\n    x7 = fork(combine, x5, x6)\n    x8 = fork(combine, x4, x7)\n    x9 = index(I, x1)\n    x10 = x8(x1)\n    x11 = fill(I, x9, x10)\n    return x11\n\n",
    "annotated": "def verify_ea786f4a(I: Grid) -> Grid:\n    # Get the shape (height, width) of the input grid\n    x0 = shape(I)\n    \n    # Calculate the midpoint of the grid by halving the dimensions\n    x1 = halve(x0)\n    \n    # Create a function that shoots a line from the midpoint to the top-right\n    x2 = rbind(shoot, UP_RIGHT)\n    \n    # Create a function that shoots a line from the midpoint to the bottom-left\n    x3 = rbind(shoot, DOWN_LEFT)\n    \n    # Combine the top-right and bottom-left shooting functions\n    # This creates the first diagonal of the X\n    x4 = fork(combine, x2, x3)\n    \n    # Create a function that shoots a line from the midpoint to the bottom-right\n    x5 = rbind(shoot, UNITY)\n    \n    # Create a function that shoots a line from the midpoint to the top-left\n    x6 = rbind(shoot, NEG_UNITY)\n    \n    # Combine the bottom-right and top-left shooting functions\n    # This creates the second diagonal of the X\n    x7 = fork(combine, x5, x6)\n    \n    # Combine both diagonals to create the full X pattern\n    x8 = fork(combine, x4, x7)\n    \n    # Get the color of the cell at the midpoint of the input grid\n    # This will be the color used for the X\n    x9 = index(I, x1)\n    \n    # Generate the indices for the X pattern starting from the midpoint\n    x10 = x8(x1)\n    \n    # Fill the X pattern with the color from the midpoint\n    # This overlays the X on top of the input grid\n    x11 = fill(I, x9, x10)\n    \n    # Return the modified grid with the X overlay\n    return x11\n"
  },
  "eb281b96": {
    "original": "def verify_eb281b96(I: Grid) -> Grid:\n    x0 = height(I)\n    x1 = width(I)\n    x2 = decrement(x0)\n    x3 = astuple(x2, x1)\n    x4 = crop(I, ORIGIN, x3)\n    x5 = hmirror(x4)\n    x6 = vconcat(I, x5)\n    x7 = double(x2)\n    x8 = astuple(x7, x1)\n    x9 = crop(x6, DOWN, x8)\n    x10 = vconcat(x6, x9)\n    return x10\n\n",
    "annotated": "def verify_eb281b96(I: Grid) -> Grid:\n    # Get the height of the input grid\n    x0 = height(I)\n    \n    # Get the width of the input grid\n    x1 = width(I)\n    \n    # Decrease the height by 1 (to exclude the last row for mirroring)\n    x2 = decrement(x0)\n    \n    # Create a tuple (height-1, width) to define the dimensions for cropping\n    x3 = astuple(x2, x1)\n    \n    # Crop the input grid from the origin (0,0) to (height-1, width)\n    # This removes the last row of the input grid\n    x4 = crop(I, ORIGIN, x3)\n    \n    # Create a horizontal mirror of the cropped grid\n    # This flips the grid left to right, excluding the last row\n    x5 = hmirror(x4)\n    \n    # Vertically concatenate the original input with its horizontal mirror\n    # This creates the top half of the final output\n    x6 = vconcat(I, x5)\n    \n    # Double the value of (height-1)\n    # This calculates the height of the bottom half of the final output\n    x7 = double(x2)\n    \n    # Create a tuple (2*(height-1), width) for the dimensions of the bottom half\n    x8 = astuple(x7, x1)\n    \n    # Crop the concatenated grid starting from the second row (DOWN = (1,0))\n    # This creates the bottom half of the final output\n    x9 = crop(x6, DOWN, x8)\n    \n    # Vertically concatenate the top half with the bottom half\n    # This creates the final symmetrical output, mirrored both vertically and horizontally\n    x10 = vconcat(x6, x9)\n    \n    # Return the final symmetrical grid\n    return x10\n"
  },
  "eb5a1d5d": {
    "original": "def verify_eb5a1d5d(I: Grid) -> Grid:\n    x0 = compose(dmirror, dedupe)\n    x1 = x0(I)\n    x2 = x0(x1)\n    x3 = fork(remove, last, identity)\n    x4 = compose(hmirror, x3)\n    x5 = fork(vconcat, identity, x4)\n    x6 = x5(x2)\n    x7 = dmirror(x6)\n    x8 = x5(x7)\n    return x8\n\n",
    "annotated": "def verify_eb5a1d5d(I: Grid) -> Grid:\n    # Compose diagonal mirror and deduplication functions\n    x0 = compose(dmirror, dedupe)\n    \n    # Apply diagonal mirror and deduplicate rows/columns\n    x1 = x0(I)\n    \n    # Apply diagonal mirror and deduplicate again (removes duplicates in both directions)\n    x2 = x0(x1)\n    \n    # Create a function that removes the last element while keeping the original\n    x3 = fork(remove, last, identity)\n    \n    # Compose horizontal mirror with the remove-last function\n    x4 = compose(hmirror, x3)\n    \n    # Create a function that concatenates vertically: original and horizontally mirrored with last removed\n    x5 = fork(vconcat, identity, x4)\n    \n    # Apply vertical concatenation to the deduplicated grid\n    x6 = x5(x2)\n    \n    # Apply diagonal mirror to the concatenated grid\n    x7 = dmirror(x6)\n    \n    # Apply vertical concatenation again to the diagonally mirrored grid\n    x8 = x5(x7)\n    \n    # Return the final processed grid\n    return x8\n\n# In more abstract terms, this function:\n# 1. Removes duplicate rows and columns\n# 2. Creates symmetry by mirroring and concatenating\n# 3. Repeats the process to ensure full symmetry\n# The result is a symmetric grid with no adjacent duplicates, centered around the diagonal\n"
  },
  "ec883f72": {
    "original": "def verify_ec883f72(I: Grid) -> Grid:\n    x0 = fork(multiply, height, width)\n    x1 = partition(I)\n    x2 = argmax(x1, x0)\n    x3 = remove(x2, x1)\n    x4 = argmax(x3, x0)\n    x5 = other(x3, x4)\n    x6 = palette(I)\n    x7 = lrcorner(x4)\n    x8 = add(x7, UNITY)\n    x9 = llcorner(x4)\n    x10 = add(x9, DOWN_LEFT)\n    x11 = urcorner(x4)\n    x12 = add(x11, UP_RIGHT)\n    x13 = ulcorner(x4)\n    x14 = add(x13, NEG_UNITY)\n    x15 = shoot(x8, UNITY)\n    x16 = shoot(x10, DOWN_LEFT)\n    x17 = shoot(x12, UP_RIGHT)\n    x18 = shoot(x14, NEG_UNITY)\n    x19 = combine(x15, x16)\n    x20 = combine(x17, x18)\n    x21 = combine(x19, x20)\n    x22 = color(x5)\n    x23 = fill(I, x22, x21)\n    return x23\n\n",
    "annotated": "def verify_ec883f72(I: Grid) -> Grid:\n    # Calculate the area (height * width) of each object in the grid\n    x0 = fork(multiply, height, width)\n    \n    # Partition the input grid into objects based on color\n    x1 = partition(I)\n    \n    # Find the largest object (background) based on area\n    x2 = argmax(x1, x0)\n    \n    # Remove the background object from the partitioned objects\n    x3 = remove(x2, x1)\n    \n    # Find the second largest object (inner rectangle) based on area\n    x4 = argmax(x3, x0)\n    \n    # Find the third largest object (outer box lines)\n    x5 = other(x3, x4)\n    \n    # Get the palette of colors used in the input grid\n    x6 = palette(I)\n    \n    # Find the lower right corner of the inner rectangle\n    x7 = lrcorner(x4)\n    \n    # Move one step down and right from the lower right corner\n    x8 = add(x7, UNITY)\n    \n    # Find the lower left corner of the inner rectangle\n    x9 = llcorner(x4)\n    \n    # Move one step down and left from the lower left corner\n    x10 = add(x9, DOWN_LEFT)\n    \n    # Find the upper right corner of the inner rectangle\n    x11 = urcorner(x4)\n    \n    # Move one step up and right from the upper right corner\n    x12 = add(x11, UP_RIGHT)\n    \n    # Find the upper left corner of the inner rectangle\n    x13 = ulcorner(x4)\n    \n    # Move one step up and left from the upper left corner\n    x14 = add(x13, NEG_UNITY)\n    \n    # Create a diagonal line from the lower right corner to the top right\n    x15 = shoot(x8, UNITY)\n    \n    # Create a diagonal line from the lower left corner to the bottom left\n    x16 = shoot(x10, DOWN_LEFT)\n    \n    # Create a diagonal line from the upper right corner to the top left\n    x17 = shoot(x12, UP_RIGHT)\n    \n    # Create a diagonal line from the upper left corner to the bottom right\n    x18 = shoot(x14, NEG_UNITY)\n    \n    # Combine the first two diagonal lines\n    x19 = combine(x15, x16)\n    \n    # Combine the other two diagonal lines\n    x20 = combine(x17, x18)\n    \n    # Combine all four diagonal lines\n    x21 = combine(x19, x20)\n    \n    # Get the color of the outer box lines\n    x22 = color(x5)\n    \n    # Fill the diagonal lines with the color of the outer box lines\n    # This creates the output grid by extending the inner rectangle to the corners\n    x23 = fill(I, x22, x21)\n    \n    # Return the modified grid as the output\n    return x23\n"
  },
  "ecdecbb3": {
    "original": "def verify_ecdecbb3(I: Grid) -> Grid:\n    x0 = leastcolor(I)\n    x1 = objects(I, T, F, T)\n    x2 = merge(x1)\n    x3 = palette(x2)\n    x4 = other(x3, x0)\n    x5 = ofcolor(I, x0)\n    x6 = frontiers(I)\n    x7 = colorfilter(x6, x4)\n    x8 = sfilter(x7, hline)\n    x9 = size(x8)\n    x10 = positive(x9)\n    x11 = height(I)\n    x12 = toivec(x11)\n    x13 = hfrontier(x12)\n    x14 = toivec(NEG_ONE)\n    x15 = hfrontier(x14)\n    x16 = insert(x15, x7)\n    x17 = insert(x13, x16)\n    x18 = width(I)\n    x19 = tojvec(x18)\n    x20 = vfrontier(x19)\n    x21 = tojvec(NEG_ONE)\n    x22 = vfrontier(x21)\n    x23 = insert(x22, x7)\n    x24 = insert(x20, x23)\n    x25 = branch(x10, x17, x24)\n    x26 = lbind(argmin, x25)\n    x27 = lbind(rbind, manhattan)\n    x28 = compose(x27, initset)\n    x29 = compose(x26, x28)\n    x30 = rbind(remove, x25)\n    x31 = compose(x30, x29)\n    x32 = fork(argmin, x31, x28)\n    x33 = fork(gravitate, initset, x29)\n    x34 = compose(crement, x33)\n    x35 = fork(add, identity, x34)\n    x36 = fork(gravitate, initset, x32)\n    x37 = compose(crement, x36)\n    x38 = fork(add, identity, x37)\n    x39 = ofcolor(I, x4)\n    x40 = backdrop(x39)\n    x41 = fork(connect, x35, x38)\n    x42 = rbind(contained, x40)\n    x43 = rbind(extract, x42)\n    x44 = fork(astuple, x35, x38)\n    x45 = compose(x43, x44)\n    x46 = fork(connect, identity, x45)\n    x47 = rbind(branch, x46)\n    x48 = rbind(x47, x41)\n    x49 = rbind(contained, x40)\n    x50 = compose(x48, x49)\n    x51 = compose(initset, x50)\n    x52 = fork(rapply, x51, identity)\n    x53 = compose(first, x52)\n    x54 = mapply(x53, x5)\n    x55 = fill(I, x0, x54)\n    x56 = intersection(x39, x54)\n    x57 = mapply(neighbors, x56)\n    x58 = fill(x55, x4, x57)\n    return x58\n\n",
    "annotated": "def verify_ecdecbb3(I: Grid) -> Grid:\n    # Find the least common color in the input grid (background color)\n    x0 = leastcolor(I)\n    \n    # Identify all objects in the grid, allowing diagonal connections and excluding the background\n    x1 = objects(I, T, F, T)\n    \n    # Merge all identified objects into a single set\n    x2 = merge(x1)\n    \n    # Get the set of unique colors used in the merged objects\n    x3 = palette(x2)\n    \n    # Find the color that is not the background color (dot/line color)\n    x4 = other(x3, x0)\n    \n    # Get all cells with the background color\n    x5 = ofcolor(I, x0)\n    \n    # Identify all frontiers (continuous lines of the same color) in the grid\n    x6 = frontiers(I)\n    \n    # Filter frontiers to keep only those of the dot/line color\n    x7 = colorfilter(x6, x4)\n    \n    # Keep only horizontal lines from the filtered frontiers\n    x8 = sfilter(x7, hline)\n    \n    # Count the number of horizontal lines\n    x9 = size(x8)\n    \n    # Check if there are any horizontal lines\n    x10 = positive(x9)\n    \n    # Get the height of the input grid\n    x11 = height(I)\n    \n    # Create a vertical vector with the grid height\n    x12 = toivec(x11)\n    \n    # Create a horizontal frontier at the bottom of the grid\n    x13 = hfrontier(x12)\n    \n    # Create a vertical vector pointing upwards\n    x14 = toivec(NEG_ONE)\n    \n    # Create a horizontal frontier at the top of the grid\n    x15 = hfrontier(x14)\n    \n    # Add the top frontier to the set of frontiers\n    x16 = insert(x15, x7)\n    \n    # Add the bottom frontier to the set of frontiers (including top and existing)\n    x17 = insert(x13, x16)\n    \n    # Get the width of the input grid\n    x18 = width(I)\n    \n    # Create a horizontal vector with the grid width\n    x19 = tojvec(x18)\n    \n    # Create a vertical frontier at the right edge of the grid\n    x20 = vfrontier(x19)\n    \n    # Create a horizontal vector pointing left\n    x21 = tojvec(NEG_ONE)\n    \n    # Create a vertical frontier at the left edge of the grid\n    x22 = vfrontier(x21)\n    \n    # Add the left frontier to the set of frontiers\n    x23 = insert(x22, x7)\n    \n    # Add the right frontier to the set of frontiers (including left and existing)\n    x24 = insert(x20, x23)\n    \n    # Choose horizontal or vertical frontiers based on presence of horizontal lines\n    x25 = branch(x10, x17, x24)\n    \n    # Prepare a function to find the nearest frontier to a given point\n    x26 = lbind(argmin, x25)\n    x27 = lbind(rbind, manhattan)\n    x28 = compose(x27, initset)\n    x29 = compose(x26, x28)\n    \n    # Prepare a function to remove the nearest frontier from the set\n    x30 = rbind(remove, x25)\n    x31 = compose(x30, x29)\n    \n    # Prepare a function to find the second nearest frontier\n    x32 = fork(argmin, x31, x28)\n    \n    # Calculate the direction to move towards the nearest frontier\n    x33 = fork(gravitate, initset, x29)\n    x34 = compose(crement, x33)\n    x35 = fork(add, identity, x34)\n    \n    # Calculate the direction to move towards the second nearest frontier\n    x36 = fork(gravitate, initset, x32)\n    x37 = compose(crement, x36)\n    x38 = fork(add, identity, x37)\n    \n    # Get all cells with the dot/line color\n    x39 = ofcolor(I, x4)\n    \n    # Get the bounding box of all dot/line colored cells\n    x40 = backdrop(x39)\n    \n    # Prepare a function to connect a point to the nearest and second nearest frontiers\n    x41 = fork(connect, x35, x38)\n    \n    # Prepare a function to check if a point is within the bounding box\n    x42 = rbind(contained, x40)\n    x43 = rbind(extract, x42)\n    \n    # Prepare a function to get the endpoints for connection\n    x44 = fork(astuple, x35, x38)\n    x45 = compose(x43, x44)\n    \n    # Prepare a function to connect a point to a valid endpoint\n    x46 = fork(connect, identity, x45)\n    x47 = rbind(branch, x46)\n    x48 = rbind(x47, x41)\n    \n    # Prepare a function to check if a connection is within the bounding box\n    x49 = rbind(contained, x40)\n    x50 = compose(x48, x49)\n    \n    # Prepare a function to create a set of valid connections for a point\n    x51 = compose(initset, x50)\n    x52 = fork(rapply, x51, identity)\n    x53 = compose(first, x52)\n    \n    # Create connections for all background-colored cells\n    x54 = mapply(x53, x5)\n    \n    # Fill the connected cells with the background color\n    x55 = fill(I, x0, x54)\n    \n    # Find the intersection of dot/line colored cells and newly connected cells\n    x56 = intersection(x39, x54)\n    \n    # Get the neighbors of the intersection cells\n    x57 = mapply(neighbors, x56)\n    \n    # Fill the neighbors with the dot/line color to create thicker connections\n    x58 = fill(x55, x4, x57)\n    \n    # Return the final grid with connections drawn\n    return x58\n"
  },
  "ed36ccf7": {
    "original": "def verify_ed36ccf7(I: Grid) -> Grid:\n    x0 = rot270(I)\n    return x0\n\n",
    "annotated": "def verify_ed36ccf7(I: Grid) -> Grid:\n    # Rotate the input grid 270 degrees counterclockwise\n    # This effectively rotates the grid 90 degrees clockwise\n    # Transforms the grid so that what was on the right is now on top,\n    # what was on top is now on the left, and so on\n    x0 = rot270(I)\n    \n    # Return the rotated grid as the output\n    # The solution to this ARC task is simply a 90-degree clockwise rotation of the input\n    return x0\n"
  },
  "ef135b50": {
    "original": "def verify_ef135b50(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = fork(multiply, height, width)\n    x2 = fork(equality, size, x1)\n    x3 = compose(flip, x2)\n    x4 = sfilter(x0, x3)\n    x5 = argmax(x4, x1)\n    x6 = color(x5)\n    x7 = ofcolor(I, x6)\n    x8 = asindices(I)\n    x9 = difference(x8, x7)\n    x10 = fill(I, NEG_ONE, x9)\n    x11 = lbind(recolor, NEG_ONE)\n    x12 = rbind(ofcolor, NEG_ONE)\n    x13 = chain(x11, backdrop, x12)\n    x14 = fork(paint, identity, x13)\n    x15 = height(x10)\n    x16 = vsplit(x10, x15)\n    x17 = mapply(x14, x16)\n    x18 = ofcolor(x17, NEG_ONE)\n    x19 = asindices(I)\n    x20 = box(x19)\n    x21 = difference(x18, x20)\n    x22 = intersection(x21, x7)\n    x23 = fill(I, NINE, x22)\n    return x23\n\n",
    "annotated": "def verify_ef135b50(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering all colors as foreground\n    x0 = objects(I, T, F, F)\n    # Create a function that multiplies the height and width of an object\n    x1 = fork(multiply, height, width)\n    # Create a function that checks if an object's size equals its area (height * width)\n    x2 = fork(equality, size, x1)\n    # Invert the boolean result of x2\n    x3 = compose(flip, x2)\n    # Filter objects that are not fully filled (have holes)\n    x4 = sfilter(x0, x3)\n    # Find the largest object with holes\n    x5 = argmax(x4, x1)\n    # Get the color of the largest object with holes (background color)\n    x6 = color(x5)\n    # Find all cells with the background color\n    x7 = ofcolor(I, x6)\n    # Get all indices of the input grid\n    x8 = asindices(I)\n    # Find all non-background cells\n    x9 = difference(x8, x7)\n    # Create a new grid, replacing non-background cells with -1\n    x10 = fill(I, NEG_ONE, x9)\n    # Create a function to recolor cells to -1\n    x11 = lbind(recolor, NEG_ONE)\n    # Create a function to find cells with color -1\n    x12 = rbind(ofcolor, NEG_ONE)\n    # Create a function to find the backdrop of -1 colored cells\n    x13 = chain(x11, backdrop, x12)\n    # Create a function to paint the backdrop of -1 colored cells\n    x14 = fork(paint, identity, x13)\n    # Get the height of the grid\n    x15 = height(x10)\n    # Split the grid vertically into individual rows\n    x16 = vsplit(x10, x15)\n    # Apply the painting function to each row, filling gaps between objects\n    x17 = mapply(x14, x16)\n    # Find all cells that are still -1 (gaps between objects)\n    x18 = ofcolor(x17, NEG_ONE)\n    # Get all indices of the input grid\n    x19 = asindices(I)\n    # Find the border of the grid\n    x20 = box(x19)\n    # Remove the border cells from the gaps\n    x21 = difference(x18, x20)\n    # Find the intersection of gaps and background cells\n    x22 = intersection(x21, x7)\n    # Fill the identified gaps with color 9 in the original input grid\n    x23 = fill(I, NINE, x22)\n    # Return the modified grid with gaps filled\n    return x23\n"
  },
  "f15e1fac": {
    "original": "def verify_f15e1fac(I: Grid) -> Grid:\n    x0 = rbind(ofcolor, TWO)\n    x1 = compose(lowermost, x0)\n    x2 = matcher(x1, ZERO)\n    x3 = astuple(identity, dmirror)\n    x4 = astuple(cmirror, hmirror)\n    x5 = combine(x3, x4)\n    x6 = rbind(rapply, I)\n    x7 = compose(first, x6)\n    x8 = chain(x2, x7, initset)\n    x9 = extract(x5, x8)\n    x10 = x9(I)\n    x11 = mostcolor(I)\n    x12 = palette(I)\n    x13 = remove(x11, x12)\n    x14 = other(x13, TWO)\n    x15 = ofcolor(x10, x14)\n    x16 = rightmost(x15)\n    x17 = equality(x16, ZERO)\n    x18 = branch(x17, identity, vmirror)\n    x19 = x18(x10)\n    x20 = ofcolor(x19, x14)\n    x21 = ofcolor(x19, TWO)\n    x22 = apply(last, x21)\n    x23 = insert(ZERO, x22)\n    x24 = width(x19)\n    x25 = insert(x24, x23)\n    x26 = order(x25, identity)\n    x27 = last(x26)\n    x28 = remove(x27, x26)\n    x29 = first(x26)\n    x30 = remove(x29, x26)\n    x31 = pair(x28, x30)\n    x32 = size(x28)\n    x33 = interval(ZERO, x32, ONE)\n    x34 = pair(x33, x31)\n    x35 = lbind(fork, connect)\n    x36 = compose(first, last)\n    x37 = chain(decrement, last, last)\n    x38 = lbind(lbind, add)\n    x39 = compose(x38, first)\n    x40 = lbind(rbind, astuple)\n    x41 = rbind(chain, first)\n    x42 = compose(x40, x36)\n    x43 = compose(x40, x37)\n    x44 = fork(x41, x42, x39)\n    x45 = fork(x41, x43, x39)\n    x46 = fork(x35, x44, x45)\n    x47 = rbind(mapply, x20)\n    x48 = compose(x47, x46)\n    x49 = mapply(x48, x34)\n    x50 = fill(x19, x14, x49)\n    x51 = x18(x50)\n    x52 = x9(x51)\n    return x52\n\n",
    "annotated": "def verify_f15e1fac(I: Grid) -> Grid:\n    # Create a function to find cells of color 2\n    x0 = rbind(ofcolor, TWO)\n    # Find the lowermost row containing color 2\n    x1 = compose(lowermost, x0)\n    # Create a function to check if the lowermost row with color 2 is 0\n    x2 = matcher(x1, ZERO)\n    # Create a tuple of identity and diagonal mirror functions\n    x3 = astuple(identity, dmirror)\n    # Create a tuple of counter-diagonal mirror and horizontal mirror functions\n    x4 = astuple(cmirror, hmirror)\n    # Combine the two tuples of mirror functions\n    x5 = combine(x3, x4)\n    # Create a function to apply a function to the input grid I\n    x6 = rbind(rapply, I)\n    # Create a function to get the first result of applying functions to I\n    x7 = compose(first, x6)\n    # Chain functions to check if color 2 is in the bottom row after transformations\n    x8 = chain(x2, x7, initset)\n    # Find the first transformation that puts color 2 in the bottom row\n    x9 = extract(x5, x8)\n    # Apply the found transformation to the input grid\n    x10 = x9(I)\n    # Find the most common color (background color)\n    x11 = mostcolor(I)\n    # Get the palette of colors used in the input grid\n    x12 = palette(I)\n    # Remove the background color from the palette\n    x13 = remove(x11, x12)\n    # Find the color that's not 2 (the line color)\n    x14 = other(x13, TWO)\n    # Find all cells of the line color in the transformed grid\n    x15 = ofcolor(x10, x14)\n    # Find the rightmost column containing the line color\n    x16 = rightmost(x15)\n    # Check if the rightmost column is 0 (left edge)\n    x17 = equality(x16, ZERO)\n    # If rightmost column is 0, keep as is; otherwise, vertically mirror\n    x18 = branch(x17, identity, vmirror)\n    # Apply the conditional vertical mirroring\n    x19 = x18(x10)\n    # Find all cells of the line color in the adjusted grid\n    x20 = ofcolor(x19, x14)\n    # Find all cells of color 2 in the adjusted grid\n    x21 = ofcolor(x19, TWO)\n    # Get the last (bottommost) row containing color 2\n    x22 = apply(last, x21)\n    # Insert 0 (top row) into the list of color 2 rows\n    x23 = insert(ZERO, x22)\n    # Get the width of the adjusted grid\n    x24 = width(x19)\n    # Insert the grid width (rightmost column) into the list of color 2 columns\n    x25 = insert(x24, x23)\n    # Sort the list of row/column indices\n    x26 = order(x25, identity)\n    # Get the last (largest) index\n    x27 = last(x26)\n    # Remove the largest index from the list\n    x28 = remove(x27, x26)\n    # Get the first (smallest) index\n    x29 = first(x26)\n    # Remove the smallest index from the list\n    x30 = remove(x29, x26)\n    # Pair up the remaining indices\n    x31 = pair(x28, x30)\n    # Count the number of pairs\n    x32 = size(x28)\n    # Create a range from 0 to the number of pairs\n    x33 = interval(ZERO, x32, ONE)\n    # Pair the range with the index pairs\n    x34 = pair(x33, x31)\n    # Create a function to connect points\n    x35 = lbind(fork, connect)\n    # Create a function to get the first coordinate of the second point\n    x36 = compose(first, last)\n    # Create a function to get the second coordinate of the second point minus 1\n    x37 = chain(decrement, last, last)\n    # Create a function to add an offset to a coordinate\n    x38 = lbind(lbind, add)\n    # Create a function to get the offset from the first element\n    x39 = compose(x38, first)\n    # Create a function to combine two values into a tuple\n    x40 = lbind(rbind, astuple)\n    # Create a function to get the first element of a pair\n    x41 = rbind(chain, first)\n    # Combine functions to create the start point of a line\n    x42 = compose(x40, x36)\n    # Combine functions to create the end point of a line\n    x43 = compose(x40, x37)\n    # Create a function to generate the start point with offset\n    x44 = fork(x41, x42, x39)\n    # Create a function to generate the end point with offset\n    x45 = fork(x41, x43, x39)\n    # Create a function to connect start and end points\n    x46 = fork(x35, x44, x45)\n    # Create a function to apply the line color to a set of indices\n    x47 = rbind(mapply, x20)\n    # Combine functions to create and color lines\n    x48 = compose(x47, x46)\n    # Apply the line creation and coloring to all pairs of indices\n    x49 = mapply(x48, x34)\n    # Fill the grid with the created lines\n    x50 = fill(x19, x14, x49)\n    # Apply the conditional vertical mirroring to the final grid\n    x51 = x18(x50)\n    # Apply the initial transformation to revert the grid to its original orientation\n    x52 = x9(x51)\n    return x52\n"
  },
  "f1cefba8": {
    "original": "def verify_f1cefba8(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmax(x0, x1)\n    x3 = argmin(x0, x1)\n    x4 = remove(x2, x0)\n    x5 = other(x4, x3)\n    x6 = color(x3)\n    x7 = color(x5)\n    x8 = toindices(x3)\n    x9 = inbox(x5)\n    x10 = intersection(x8, x9)\n    x11 = fork(combine, hfrontier, vfrontier)\n    x12 = mapply(x11, x10)\n    x13 = corners(x5)\n    x14 = inbox(x5)\n    x15 = corners(x14)\n    x16 = combine(x13, x15)\n    x17 = mapply(x11, x16)\n    x18 = difference(x12, x17)\n    x19 = toindices(x2)\n    x20 = intersection(x18, x19)\n    x21 = fill(I, x6, x20)\n    x22 = difference(x18, x20)\n    x23 = fill(x21, x7, x22)\n    x24 = inbox(x5)\n    x25 = fill(x23, x7, x24)\n    return x25\n\n",
    "annotated": "def verify_f1cefba8(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies height and width\n    x1 = fork(multiply, height, width)\n    \n    # Find the largest object (background) based on area\n    x2 = argmax(x0, x1)\n    \n    # Find the smallest object (likely the inner ring color)\n    x3 = argmin(x0, x1)\n    \n    # Remove the background object from the set of objects\n    x4 = remove(x2, x0)\n    \n    # Find the middle-sized object (likely the outer ring color)\n    x5 = other(x4, x3)\n    \n    # Get the color of the smallest object (inner ring color)\n    x6 = color(x3)\n    \n    # Get the color of the middle-sized object (outer ring color)\n    x7 = color(x5)\n    \n    # Get the indices of the smallest object (inner ring)\n    x8 = toindices(x3)\n    \n    # Get the inner box of the middle-sized object (outer ring)\n    x9 = inbox(x5)\n    \n    # Find the intersection of inner ring indices and inner box of outer ring\n    # This gives us the locations where inner ring touches outer ring\n    x10 = intersection(x8, x9)\n    \n    # Create a function that combines horizontal and vertical frontiers\n    x11 = fork(combine, hfrontier, vfrontier)\n    \n    # Apply the frontier function to the intersection points\n    # This creates lines from the intersection points\n    x12 = mapply(x11, x10)\n    \n    # Get the corners of the outer ring\n    x13 = corners(x5)\n    \n    # Get the inner box of the outer ring again\n    x14 = inbox(x5)\n    \n    # Get the corners of the inner box of the outer ring\n    x15 = corners(x14)\n    \n    # Combine all corner points\n    x16 = combine(x13, x15)\n    \n    # Apply the frontier function to all corner points\n    x17 = mapply(x11, x16)\n    \n    # Remove corner lines from the intersection lines\n    # This gives us the lines to be drawn\n    x18 = difference(x12, x17)\n    \n    # Get the indices of the background\n    x19 = toindices(x2)\n    \n    # Find the intersection of lines to be drawn and background\n    # This gives us the points where we need to draw with inner ring color\n    x20 = intersection(x18, x19)\n    \n    # Fill the points in background with inner ring color\n    x21 = fill(I, x6, x20)\n    \n    # Find the remaining points of lines to be drawn\n    # These are the points where we need to draw with outer ring color\n    x22 = difference(x18, x20)\n    \n    # Fill the remaining line points with outer ring color\n    x23 = fill(x21, x7, x22)\n    \n    # Get the inner box of the outer ring once more\n    x24 = inbox(x5)\n    \n    # Fill the inner box with outer ring color to complete the pattern\n    x25 = fill(x23, x7, x24)\n    \n    # Return the final modified grid\n    return x25\n"
  },
  "f25fbde4": {
    "original": "def verify_f25fbde4(I: Grid) -> Grid:\n    x0 = compress(I)\n    x1 = upscale(x0, TWO)\n    return x1\n\n",
    "annotated": "def verify_f25fbde4(I: Grid) -> Grid:\n    # Remove any single-color rows or columns from the input grid\n    # This effectively eliminates any uniform borders or internal lines\n    x0 = compress(I)\n    \n    # Double the size of the compressed grid in both dimensions\n    # This enlarges the remaining pattern while maintaining its structure\n    x1 = upscale(x0, TWO)\n    \n    # Return the enlarged grid as the final output\n    # The result is a scaled-up version of the original pattern without uniform rows/columns\n    return x1\n"
  },
  "f25ffba3": {
    "original": "def verify_f25ffba3(I: Grid) -> Grid:\n    x0 = tophalf(I)\n    x1 = numcolors(x0)\n    x2 = equality(x1, ONE)\n    x3 = bottomhalf(I)\n    x4 = numcolors(x3)\n    x5 = equality(x4, ONE)\n    x6 = either(x2, x5)\n    x7 = branch(x6, identity, dmirror)\n    x8 = x7(I)\n    x9 = asobject(x8)\n    x10 = hmirror(x9)\n    x11 = mostcolor(I)\n    x12 = matcher(first, x11)\n    x13 = compose(flip, x12)\n    x14 = sfilter(x10, x13)\n    x15 = paint(x8, x14)\n    x16 = x7(x15)\n    return x16\n\n",
    "annotated": "def verify_f25ffba3(I: Grid) -> Grid:\n    # Get the top half of the input grid\n    x0 = tophalf(I)\n    # Count the number of unique colors in the top half\n    x1 = numcolors(x0)\n    # Check if the top half has only one color\n    x2 = equality(x1, ONE)\n    # Get the bottom half of the input grid\n    x3 = bottomhalf(I)\n    # Count the number of unique colors in the bottom half\n    x4 = numcolors(x3)\n    # Check if the bottom half has only one color\n    x5 = equality(x4, ONE)\n    # Check if either the top or bottom half has only one color\n    x6 = either(x2, x5)\n    # If one half is monochrome, use identity function; otherwise, use diagonal mirror\n    # This determines whether to process the left or right half of the input\n    x7 = branch(x6, identity, dmirror)\n    # Apply the chosen function (identity or dmirror) to the input grid\n    x8 = x7(I)\n    # Convert the processed grid to an object representation\n    x9 = asobject(x8)\n    # Create a horizontal mirror of the object\n    x10 = hmirror(x9)\n    # Find the most common color in the input grid (background color)\n    x11 = mostcolor(I)\n    # Create a function that checks if a cell's color matches the background color\n    x12 = matcher(first, x11)\n    # Create a function that checks if a cell's color does NOT match the background color\n    x13 = compose(flip, x12)\n    # Filter the mirrored object to keep only non-background colored cells\n    x14 = sfilter(x10, x13)\n    # Paint the filtered cells onto the processed grid\n    x15 = paint(x8, x14)\n    # Apply the inverse of the initial transformation (identity or dmirror)\n    # This ensures the output matches the input's orientation\n    x16 = x7(x15)\n    # Return the final processed grid as the output\n    return x16\n"
  },
  "f2829549": {
    "original": "def verify_f2829549(I: Grid) -> Grid:\n    x0 = frontiers(I)\n    x1 = sfilter(x0, hline)\n    x2 = size(x1)\n    x3 = positive(x2)\n    x4 = branch(x3, vsplit, hsplit)\n    x5 = x4(I, TWO)\n    x6 = first(x5)\n    x7 = last(x5)\n    x8 = palette(x6)\n    x9 = palette(x7)\n    x10 = intersection(x8, x9)\n    x11 = first(x10)\n    x12 = shape(x6)\n    x13 = canvas(x11, x12)\n    x14 = ofcolor(x6, x11)\n    x15 = ofcolor(x7, x11)\n    x16 = intersection(x14, x15)\n    x17 = fill(x13, THREE, x16)\n    return x17\n\n",
    "annotated": "def verify_f2829549(I: Grid) -> Grid:\n    # Find all frontiers (horizontal and vertical lines of same color) in the input grid\n    x0 = frontiers(I)\n    # Filter out only the horizontal frontiers\n    x1 = sfilter(x0, hline)\n    # Count the number of horizontal frontiers\n    x2 = size(x1)\n    # Check if there are any horizontal frontiers\n    x3 = positive(x2)\n    # If there are horizontal frontiers, use vsplit; otherwise, use hsplit\n    # This determines if the grid should be split vertically or horizontally\n    x4 = branch(x3, vsplit, hsplit)\n    # Split the input grid into two parts\n    x5 = x4(I, TWO)\n    # Get the first part of the split grid (left or top)\n    x6 = first(x5)\n    # Get the second part of the split grid (right or bottom)\n    x7 = last(x5)\n    # Get the set of colors used in the first part\n    x8 = palette(x6)\n    # Get the set of colors used in the second part\n    x9 = palette(x7)\n    # Find the common colors between the two parts\n    x10 = intersection(x8, x9)\n    # Get the first (and likely only) common color, which is the background color\n    x11 = first(x10)\n    # Get the dimensions of the first part\n    x12 = shape(x6)\n    # Create a new grid with the background color and same dimensions as the first part\n    x13 = canvas(x11, x12)\n    # Find all cells in the first part that have the background color\n    x14 = ofcolor(x6, x11)\n    # Find all cells in the second part that have the background color\n    x15 = ofcolor(x7, x11)\n    # Find the cells that have the background color in both parts\n    x16 = intersection(x14, x15)\n    # Fill the new grid with color 3 at the positions where both parts had the background color\n    # This effectively finds the cells that were not colored in either part of the input\n    x17 = fill(x13, THREE, x16)\n    # Return the resulting grid, which represents the \"exclusive or\" of the two input parts\n    return x17\n"
  },
  "f35d900a": {
    "original": "def verify_f35d900a(I: Grid) -> Grid:\n    x0 = objects(I, T, F, T)\n    x1 = palette(I)\n    x2 = mostcolor(I)\n    x3 = remove(x2, x1)\n    x4 = lbind(other, x3)\n    x5 = compose(x4, color)\n    x6 = fork(recolor, x5, outbox)\n    x7 = mapply(x6, x0)\n    x8 = mapply(toindices, x0)\n    x9 = box(x8)\n    x10 = difference(x9, x8)\n    x11 = lbind(argmin, x8)\n    x12 = rbind(compose, initset)\n    x13 = lbind(rbind, manhattan)\n    x14 = chain(x12, x13, initset)\n    x15 = chain(initset, x11, x14)\n    x16 = fork(manhattan, initset, x15)\n    x17 = compose(even, x16)\n    x18 = sfilter(x10, x17)\n    x19 = paint(I, x7)\n    x20 = fill(x19, FIVE, x18)\n    return x20\n\n",
    "annotated": "def verify_f35d900a(I: Grid) -> Grid:\n    # Find all objects in the input grid, considering diagonal connections and excluding the background\n    x0 = objects(I, T, F, T)\n    \n    # Get the set of all colors used in the input grid\n    x1 = palette(I)\n    \n    # Find the most common color in the input grid (background color)\n    x2 = mostcolor(I)\n    \n    # Remove the background color from the palette\n    x3 = remove(x2, x1)\n    \n    # Create a function that finds the other color (not background) in a set of two colors\n    x4 = lbind(other, x3)\n    \n    # Create a function that gets the non-background color of an object\n    x5 = compose(x4, color)\n    \n    # Create a function that recolors the outbox of an object with its non-background color\n    x6 = fork(recolor, x5, outbox)\n    \n    # Apply the recoloring function to all objects, creating colored outboxes\n    x7 = mapply(x6, x0)\n    \n    # Convert all objects to their indices (positions)\n    x8 = mapply(toindices, x0)\n    \n    # Create a box (outline) around all object indices\n    x9 = box(x8)\n    \n    # Find the cells that are in the box but not part of any object\n    x10 = difference(x9, x8)\n    \n    # Create a function that finds the cell in an object closest to a given point\n    x11 = lbind(argmin, x8)\n    \n    # Create a function that initializes a set with a single element\n    x12 = rbind(compose, initset)\n    \n    # Create a function that calculates Manhattan distance from a fixed point\n    x13 = lbind(rbind, manhattan)\n    \n    # Chain functions to create a distance calculator from a single point\n    x14 = chain(x12, x13, initset)\n    \n    # Create a function that finds the closest object cell to a given point\n    x15 = chain(initset, x11, x14)\n    \n    # Create a function that calculates Manhattan distance to the closest object cell\n    x16 = fork(manhattan, initset, x15)\n    \n    # Create a function that checks if the distance to the closest object cell is even\n    x17 = compose(even, x16)\n    \n    # Filter the cells in the box outline, keeping only those with even distance to the closest object\n    x18 = sfilter(x10, x17)\n    \n    # Paint the colored outboxes onto the input grid\n    x19 = paint(I, x7)\n    \n    # Fill the selected cells (with even distance) with color 5\n    x20 = fill(x19, FIVE, x18)\n    \n    # Return the modified grid as the output\n    return x20\n"
  },
  "f5b8619d": {
    "original": "def verify_f5b8619d(I: Grid) -> Grid:\n    x0 = fgpartition(I)\n    x1 = mapply(toindices, x0)\n    x2 = mapply(vfrontier, x1)\n    x3 = underfill(I, EIGHT, x2)\n    x4 = hconcat(x3, x3)\n    x5 = vconcat(x4, x4)\n    return x5\n\n",
    "annotated": "def verify_f5b8619d(I: Grid) -> Grid:\n    # Partition the input grid into objects, excluding the background color\n    x0 = fgpartition(I)\n    \n    # Convert each object to a set of indices (locations) in the grid\n    x1 = mapply(toindices, x0)\n    \n    # For each set of indices, create a vertical frontier (column of cells)\n    x2 = mapply(vfrontier, x1)\n    \n    # Fill the vertical frontiers with color 8, but only in empty (background) cells\n    # This creates vertical lines of color 8 above and below each colored object\n    x3 = underfill(I, EIGHT, x2)\n    \n    # Double the width of the grid by concatenating it with itself horizontally\n    x4 = hconcat(x3, x3)\n    \n    # Double the height of the grid by concatenating it with itself vertically\n    # This creates a 2x2 tiled version of the processed input grid\n    x5 = vconcat(x4, x4)\n    \n    # Return the final processed and enlarged grid\n    return x5\n"
  },
  "f76d97a5": {
    "original": "def verify_f76d97a5(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = remove(FIVE, x0)\n    x2 = first(x1)\n    x3 = ofcolor(I, x2)\n    x4 = fill(I, ZERO, x3)\n    x5 = ofcolor(I, FIVE)\n    x6 = fill(x4, x2, x5)\n    return x6\n\n",
    "annotated": "def verify_f76d97a5(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Remove color 5 (light gray) from the set of colors\n    # This isolates the non-background color\n    x1 = remove(FIVE, x0)\n    \n    # Get the first (and only) color from the remaining set\n    # This is the color used for the pattern in the input\n    x2 = first(x1)\n    \n    # Find all cells in the input grid that have the pattern color\n    x3 = ofcolor(I, x2)\n    \n    # Create a new grid by filling all cells of the pattern color with 0 (black)\n    # This inverts the pattern, turning colored cells to black\n    x4 = fill(I, ZERO, x3)\n    \n    # Find all cells in the original input grid that were light gray (color 5)\n    x5 = ofcolor(I, FIVE)\n    \n    # Fill the cells that were originally light gray with the pattern color\n    # This completes the inversion, turning the background to the pattern color\n    x6 = fill(x4, x2, x5)\n    \n    # Return the final inverted grid\n    return x6\n"
  },
  "f8a8fe49": {
    "original": "def verify_f8a8fe49(I: Grid) -> Grid:\n    x0 = partition(I)\n    x1 = fork(multiply, height, width)\n    x2 = argmin(x0, x1)\n    x3 = argmax(x0, x1)\n    x4 = remove(x2, x0)\n    x5 = other(x4, x3)\n    x6 = subgrid(x5, I)\n    x7 = frontiers(x6)\n    x8 = sfilter(x7, hline)\n    x9 = size(x8)\n    x10 = positive(x9)\n    x11 = branch(x10, dmirror, identity)\n    x12 = x11(I)\n    x13 = color(x5)\n    x14 = ofcolor(x12, x13)\n    x15 = subgrid(x14, x12)\n    x16 = trim(x15)\n    x17 = lefthalf(x16)\n    x18 = vmirror(x17)\n    x19 = asobject(x18)\n    x20 = righthalf(x16)\n    x21 = vmirror(x20)\n    x22 = asobject(x21)\n    x23 = color(x3)\n    x24 = inbox(x14)\n    x25 = backdrop(x24)\n    x26 = fill(x12, x23, x25)\n    x27 = urcorner(x14)\n    x28 = add(x27, UNITY)\n    x29 = shift(x22, x28)\n    x30 = ulcorner(x14)\n    x31 = width(x19)\n    x32 = invert(x31)\n    x33 = tojvec(x32)\n    x34 = add(DOWN, x33)\n    x35 = add(x30, x34)\n    x36 = shift(x19, x35)\n    x37 = combine(x29, x36)\n    x38 = paint(x26, x37)\n    x39 = x11(x38)\n    return x39\n\n",
    "annotated": "def verify_f8a8fe49(I: Grid) -> Grid:\n    # Partition the input grid into objects based on color\n    x0 = partition(I)\n    \n    # Create a function that multiplies height and width\n    x1 = fork(multiply, height, width)\n    \n    # Find the smallest object in terms of area (height * width)\n    x2 = argmin(x0, x1)\n    \n    # Find the largest object in terms of area (height * width)\n    x3 = argmax(x0, x1)\n    \n    # Remove the smallest object from the set of objects\n    x4 = remove(x2, x0)\n    \n    # Find the medium-sized object (not the largest, not the smallest)\n    x5 = other(x4, x3)\n    \n    # Extract the subgrid containing the medium-sized object\n    x6 = subgrid(x5, I)\n    \n    # Find all frontiers (horizontal or vertical lines of same color) in the subgrid\n    x7 = frontiers(x6)\n    \n    # Filter out only the horizontal frontiers\n    x8 = sfilter(x7, hline)\n    \n    # Count the number of horizontal frontiers\n    x9 = size(x8)\n    \n    # Check if there are any horizontal frontiers\n    x10 = positive(x9)\n    \n    # If there are horizontal frontiers, use dmirror; otherwise, use identity\n    # This determines if we need to flip the grid diagonally\n    x11 = branch(x10, dmirror, identity)\n    \n    # Apply the chosen transformation (dmirror or identity) to the input grid\n    x12 = x11(I)\n    \n    # Get the color of the medium-sized object\n    x13 = color(x5)\n    \n    # Find all cells in the transformed grid that match the color of the medium-sized object\n    x14 = ofcolor(x12, x13)\n    \n    # Extract the subgrid containing only the cells of the medium-sized object's color\n    x15 = subgrid(x14, x12)\n    \n    # Remove the outer border of this subgrid\n    x16 = trim(x15)\n    \n    # Get the left half of the trimmed subgrid\n    x17 = lefthalf(x16)\n    \n    # Mirror the left half vertically\n    x18 = vmirror(x17)\n    \n    # Convert the mirrored left half to an object\n    x19 = asobject(x18)\n    \n    # Get the right half of the trimmed subgrid\n    x20 = righthalf(x16)\n    \n    # Mirror the right half vertically\n    x21 = vmirror(x20)\n    \n    # Convert the mirrored right half to an object\n    x22 = asobject(x21)\n    \n    # Get the color of the largest object (background color)\n    x23 = color(x3)\n    \n    # Find the inner box of the medium-sized object area\n    x24 = inbox(x14)\n    \n    # Get all cells within the bounding box of the inner box\n    x25 = backdrop(x24)\n    \n    # Fill the bounding box area with the background color\n    x26 = fill(x12, x23, x25)\n    \n    # Find the upper right corner of the medium-sized object area\n    x27 = urcorner(x14)\n    \n    # Move one step down and right from the upper right corner\n    x28 = add(x27, UNITY)\n    \n    # Shift the mirrored right half to this new position\n    x29 = shift(x22, x28)\n    \n    # Find the upper left corner of the medium-sized object area\n    x30 = ulcorner(x14)\n    \n    # Get the width of the mirrored left half\n    x31 = width(x19)\n    \n    # Invert the width (make it negative)\n    x32 = invert(x31)\n    \n    # Create a horizontal vector with this negative width\n    x33 = tojvec(x32)\n    \n    # Create a vector pointing down and left\n    x34 = add(DOWN, x33)\n    \n    # Calculate the new position for the mirrored left half\n    x35 = add(x30, x34)\n    \n    # Shift the mirrored left half to this new position\n    x36 = shift(x19, x35)\n    \n    # Combine the shifted right and left halves\n    x37 = combine(x29, x36)\n    \n    # Paint the combined halves onto the background\n    x38 = paint(x26, x37)\n    \n    # Apply the initial transformation (dmirror or identity) to the result\n    # This undoes the initial transformation if it was applied\n    x39 = x11(x38)\n    \n    # Return the final transformed grid\n    return x39\n"
  },
  "f8b3ba0a": {
    "original": "def verify_f8b3ba0a(I: Grid) -> Grid:\n    x0 = compress(I)\n    x1 = astuple(THREE, ONE)\n    x2 = palette(x0)\n    x3 = lbind(colorcount, x0)\n    x4 = compose(invert, x3)\n    x5 = order(x2, x4)\n    x6 = rbind(canvas, UNITY)\n    x7 = apply(x6, x5)\n    x8 = merge(x7)\n    x9 = size(x2)\n    x10 = decrement(x9)\n    x11 = astuple(x10, ONE)\n    x12 = crop(x8, DOWN, x11)\n    return x12\n\n",
    "annotated": "def verify_f8b3ba0a(I: Grid) -> Grid:\n    # Remove all frontiers (rows/columns with single color) from the input grid\n    x0 = compress(I)\n    \n    # Create a tuple (3, 1)\n    x1 = astuple(THREE, ONE)\n    \n    # Get the set of unique colors used in the compressed grid\n    x2 = palette(x0)\n    \n    # Create a function that counts occurrences of a color in the compressed grid\n    x3 = lbind(colorcount, x0)\n    \n    # Create a function that returns the inverse of the color count\n    # (used for sorting colors from most frequent to least frequent)\n    x4 = compose(invert, x3)\n    \n    # Sort the colors based on their frequency (most frequent first)\n    x5 = order(x2, x4)\n    \n    # Create a function that generates a 1x1 grid with a given color\n    x6 = rbind(canvas, UNITY)\n    \n    # Create a list of 1x1 grids, each with one of the sorted colors\n    x7 = apply(x6, x5)\n    \n    # Merge all 1x1 grids into a single row\n    x8 = merge(x7)\n    \n    # Count the number of unique colors\n    x9 = size(x2)\n    \n    # Subtract 1 from the color count\n    x10 = decrement(x9)\n    \n    # Create a tuple (color_count - 1, 1)\n    x11 = astuple(x10, ONE)\n    \n    # Crop the merged row to exclude the least frequent color\n    # This creates the final output: a row of colors sorted by frequency (excluding the least frequent)\n    x12 = crop(x8, DOWN, x11)\n    \n    # Return the final output grid\n    return x12\n"
  },
  "f8c80d96": {
    "original": "def verify_f8c80d96(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = compose(maximum, shape)\n    x2 = argmin(x0, x1)\n    x3 = color(x2)\n    x4 = palette(I)\n    x5 = other(x4, x3)\n    x6 = colorfilter(x0, x5)\n    x7 = argmin(x6, x1)\n    x8 = remove(x7, x6)\n    x9 = rbind(manhattan, x7)\n    x10 = argmin(x8, x9)\n    x11 = rightmost(x10)\n    x12 = rightmost(x7)\n    x13 = subtract(x11, x12)\n    x14 = leftmost(x7)\n    x15 = leftmost(x10)\n    x16 = subtract(x14, x15)\n    x17 = astuple(x13, x16)\n    x18 = maximum(x17)\n    x19 = lowermost(x10)\n    x20 = lowermost(x7)\n    x21 = subtract(x19, x20)\n    x22 = uppermost(x7)\n    x23 = uppermost(x10)\n    x24 = subtract(x22, x23)\n    x25 = astuple(x21, x24)\n    x26 = maximum(x25)\n    x27 = ulcorner(x7)\n    x28 = lrcorner(x7)\n    x29 = astuple(x26, x18)\n    x30 = double(EIGHT)\n    x31 = interval(ONE, x30, ONE)\n    x32 = lbind(subtract, x27)\n    x33 = rbind(multiply, x29)\n    x34 = compose(x32, x33)\n    x35 = lbind(add, x28)\n    x36 = rbind(multiply, x29)\n    x37 = chain(initset, x35, x36)\n    x38 = fork(insert, x34, x37)\n    x39 = compose(box, x38)\n    x40 = mapply(x39, x31)\n    x41 = fill(I, x5, x40)\n    x42 = replace(x41, x3, FIVE)\n    return x42\n\n",
    "annotated": "def verify_f8c80d96(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that finds the maximum dimension (height or width) of an object\n    x1 = compose(maximum, shape)\n    \n    # Find the smallest object (by maximum dimension) in the grid\n    x2 = argmin(x0, x1)\n    \n    # Get the color of the smallest object (background color)\n    x3 = color(x2)\n    \n    # Get all colors used in the input grid\n    x4 = palette(I)\n    \n    # Find the color that's not the background color (line color)\n    x5 = other(x4, x3)\n    \n    # Filter objects to keep only those of the line color\n    x6 = colorfilter(x0, x5)\n    \n    # Find the smallest line-colored object (innermost box)\n    x7 = argmin(x6, x1)\n    \n    # Remove the innermost box from the set of line-colored objects\n    x8 = remove(x7, x6)\n    \n    # Create a function to calculate Manhattan distance from the innermost box\n    x9 = rbind(manhattan, x7)\n    \n    # Find the line-colored object closest to the innermost box (second innermost box)\n    x10 = argmin(x8, x9)\n    \n    # Get the rightmost coordinate of the second innermost box\n    x11 = rightmost(x10)\n    \n    # Get the rightmost coordinate of the innermost box\n    x12 = rightmost(x7)\n    \n    # Calculate the horizontal distance between the two boxes on the right side\n    x13 = subtract(x11, x12)\n    \n    # Get the leftmost coordinate of the innermost box\n    x14 = leftmost(x7)\n    \n    # Get the leftmost coordinate of the second innermost box\n    x15 = leftmost(x10)\n    \n    # Calculate the horizontal distance between the two boxes on the left side\n    x16 = subtract(x14, x15)\n    \n    # Create a tuple of the horizontal distances\n    x17 = astuple(x13, x16)\n    \n    # Find the maximum horizontal distance (horizontal offset between boxes)\n    x18 = maximum(x17)\n    \n    # Get the lowermost coordinate of the second innermost box\n    x19 = lowermost(x10)\n    \n    # Get the lowermost coordinate of the innermost box\n    x20 = lowermost(x7)\n    \n    # Calculate the vertical distance between the two boxes on the bottom\n    x21 = subtract(x19, x20)\n    \n    # Get the uppermost coordinate of the innermost box\n    x22 = uppermost(x7)\n    \n    # Get the uppermost coordinate of the second innermost box\n    x23 = uppermost(x10)\n    \n    # Calculate the vertical distance between the two boxes on the top\n    x24 = subtract(x22, x23)\n    \n    # Create a tuple of the vertical distances\n    x25 = astuple(x21, x24)\n    \n    # Find the maximum vertical distance (vertical offset between boxes)\n    x26 = maximum(x25)\n    \n    # Get the upper-left corner of the innermost box\n    x27 = ulcorner(x7)\n    \n    # Get the lower-right corner of the innermost box\n    x28 = lrcorner(x7)\n    \n    # Create a tuple of the vertical and horizontal offsets\n    x29 = astuple(x26, x18)\n    \n    # Create the constant 16 (2 * 8)\n    x30 = double(EIGHT)\n    \n    # Create a range from 1 to 16\n    x31 = interval(ONE, x30, ONE)\n    \n    # Create a function to calculate the upper-left corner of each box\n    x32 = lbind(subtract, x27)\n    x33 = rbind(multiply, x29)\n    x34 = compose(x32, x33)\n    \n    # Create a function to calculate the lower-right corner of each box\n    x35 = lbind(add, x28)\n    x36 = rbind(multiply, x29)\n    x37 = chain(initset, x35, x36)\n    \n    # Create a function to generate a box from its corners\n    x38 = fork(insert, x34, x37)\n    x39 = compose(box, x38)\n    \n    # Generate all concentric boxes\n    x40 = mapply(x39, x31)\n    \n    # Draw all concentric boxes on the input grid using the line color\n    x41 = fill(I, x5, x40)\n    \n    # Replace the background color with 5 (as per the task description)\n    x42 = replace(x41, x3, FIVE)\n    \n    # Return the final grid with all concentric boxes drawn and background replaced\n    return x42\n"
  },
  "f8ff0b80": {
    "original": "def verify_f8ff0b80(I: Grid) -> Grid:\n    x0 = objects(I, T, T, T)\n    x1 = order(x0, size)\n    x2 = apply(color, x1)\n    x3 = rbind(canvas, UNITY)\n    x4 = apply(x3, x2)\n    x5 = merge(x4)\n    x6 = hmirror(x5)\n    return x6\n\n",
    "annotated": "def verify_f8ff0b80(I: Grid) -> Grid:\n    # Extract all objects from the input grid, including background and diagonally connected cells\n    x0 = objects(I, T, T, T)\n    \n    # Sort the objects based on their size (number of cells)\n    x1 = order(x0, size)\n    \n    # Extract the color of each object\n    x2 = apply(color, x1)\n    \n    # Create a function that generates a 1x1 canvas with a given color\n    x3 = rbind(canvas, UNITY)\n    \n    # Create a 1x1 grid for each color in x2\n    x4 = apply(x3, x2)\n    \n    # Merge all the 1x1 grids into a single row\n    x5 = merge(x4)\n    \n    # Mirror the row horizontally to create a 2x2 grid\n    # This creates a diagonal symmetry in the final output\n    x6 = hmirror(x5)\n    \n    # Return the final 2x2 grid representing the colors of objects in order of size\n    return x6\n"
  },
  "f9012d9b": {
    "original": "def verify_f9012d9b(I: Grid) -> Grid:\n    x0 = lbind(contained, ZERO)\n    x1 = compose(flip, x0)\n    x2 = sfilter(I, x1)\n    x3 = dmirror(I)\n    x4 = lbind(contained, ZERO)\n    x5 = compose(flip, x4)\n    x6 = sfilter(x3, x5)\n    x7 = compose(hperiod, asobject)\n    x8 = height(x2)\n    x9 = vsplit(x2, x8)\n    x10 = apply(x7, x9)\n    x11 = maximum(x10)\n    x12 = compose(hperiod, asobject)\n    x13 = height(x6)\n    x14 = vsplit(x6, x13)\n    x15 = apply(x12, x14)\n    x16 = maximum(x15)\n    x17 = ofcolor(I, ZERO)\n    x18 = asobject(I)\n    x19 = matcher(first, ZERO)\n    x20 = compose(flip, x19)\n    x21 = sfilter(x18, x20)\n    x22 = lbind(shift, x21)\n    x23 = height(I)\n    x24 = divide(x23, x16)\n    x25 = increment(x24)\n    x26 = width(I)\n    x27 = divide(x26, x11)\n    x28 = increment(x27)\n    x29 = invert(x25)\n    x30 = increment(x25)\n    x31 = interval(x29, x30, ONE)\n    x32 = invert(x28)\n    x33 = increment(x28)\n    x34 = interval(x32, x33, ONE)\n    x35 = product(x31, x34)\n    x36 = astuple(x16, x11)\n    x37 = lbind(multiply, x36)\n    x38 = apply(x37, x35)\n    x39 = mapply(x22, x38)\n    x40 = paint(I, x39)\n    x41 = subgrid(x17, x40)\n    return x41\n\n",
    "annotated": "def verify_f9012d9b(I: Grid) -> Grid:\n    # Create a function that checks if a value is not zero\n    x0 = lbind(contained, ZERO)\n    x1 = compose(flip, x0)\n    # Filter the input grid to keep only non-zero cells\n    x2 = sfilter(I, x1)\n    \n    # Create a diagonally mirrored version of the input grid\n    x3 = dmirror(I)\n    # Create another function that checks if a value is not zero\n    x4 = lbind(contained, ZERO)\n    x5 = compose(flip, x4)\n    # Filter the mirrored grid to keep only non-zero cells\n    x6 = sfilter(x3, x5)\n    \n    # Create a function to find the horizontal period of an object\n    x7 = compose(hperiod, asobject)\n    # Get the height of the filtered original grid\n    x8 = height(x2)\n    # Split the filtered original grid vertically into rows\n    x9 = vsplit(x2, x8)\n    # Find the horizontal period for each row\n    x10 = apply(x7, x9)\n    # Get the maximum horizontal period\n    x11 = maximum(x10)\n    \n    # Repeat the process for the mirrored grid\n    x12 = compose(hperiod, asobject)\n    x13 = height(x6)\n    x14 = vsplit(x6, x13)\n    x15 = apply(x12, x14)\n    # Get the maximum horizontal period of the mirrored grid (vertical period of original)\n    x16 = maximum(x15)\n    \n    # Find all zero-colored cells in the input grid\n    x17 = ofcolor(I, ZERO)\n    # Convert the input grid to an object\n    x18 = asobject(I)\n    # Create a function to check if the first element of a tuple is not zero\n    x19 = matcher(first, ZERO)\n    x20 = compose(flip, x19)\n    # Filter the grid object to keep only non-zero cells\n    x21 = sfilter(x18, x20)\n    # Create a function to shift the filtered grid object\n    x22 = lbind(shift, x21)\n    \n    # Calculate the number of vertical repetitions\n    x23 = height(I)\n    x24 = divide(x23, x16)\n    x25 = increment(x24)\n    # Calculate the number of horizontal repetitions\n    x26 = width(I)\n    x27 = divide(x26, x11)\n    x28 = increment(x27)\n    \n    # Create a range of vertical shifts\n    x29 = invert(x25)\n    x30 = increment(x25)\n    x31 = interval(x29, x30, ONE)\n    # Create a range of horizontal shifts\n    x32 = invert(x28)\n    x33 = increment(x28)\n    x34 = interval(x32, x33, ONE)\n    # Create all possible combinations of vertical and horizontal shifts\n    x35 = product(x31, x34)\n    \n    # Create a tuple of vertical and horizontal periods\n    x36 = astuple(x16, x11)\n    # Create a function to multiply shifts by periods\n    x37 = lbind(multiply, x36)\n    # Apply the multiplication to all shift combinations\n    x38 = apply(x37, x35)\n    # Shift the filtered grid object by all calculated offsets\n    x39 = mapply(x22, x38)\n    \n    # Paint the shifted objects onto the input grid\n    x40 = paint(I, x39)\n    # Extract the subgrid corresponding to the zero-colored cells from the painted grid\n    x41 = subgrid(x17, x40)\n    # Return the extracted subgrid as the output\n    return x41\n"
  },
  "fafffa47": {
    "original": "def verify_fafffa47(I: Grid) -> Grid:\n    x0 = tophalf(I)\n    x1 = numcolors(x0)\n    x2 = equality(x1, TWO)\n    x3 = bottomhalf(I)\n    x4 = numcolors(x3)\n    x5 = equality(x4, TWO)\n    x6 = both(x2, x5)\n    x7 = lefthalf(I)\n    x8 = numcolors(x7)\n    x9 = equality(x8, TWO)\n    x10 = righthalf(I)\n    x11 = numcolors(x10)\n    x12 = equality(x11, TWO)\n    x13 = both(x9, x12)\n    x14 = flip(x13)\n    x15 = both(x6, x14)\n    x16 = branch(x15, vsplit, hsplit)\n    x17 = x16(I, TWO)\n    x18 = first(x17)\n    x19 = last(x17)\n    x20 = palette(x18)\n    x21 = palette(x19)\n    x22 = intersection(x20, x21)\n    x23 = first(x22)\n    x24 = shape(x18)\n    x25 = canvas(x23, x24)\n    x26 = ofcolor(x18, x23)\n    x27 = ofcolor(x19, x23)\n    x28 = intersection(x26, x27)\n    x29 = fill(x25, TWO, x28)\n    return x29\n\n",
    "annotated": "def verify_fafffa47(I: Grid) -> Grid:\n    # Get the top half of the input grid\n    x0 = tophalf(I)\n    # Count the number of unique colors in the top half\n    x1 = numcolors(x0)\n    # Check if the number of colors in the top half is exactly 2\n    x2 = equality(x1, TWO)\n    # Get the bottom half of the input grid\n    x3 = bottomhalf(I)\n    # Count the number of unique colors in the bottom half\n    x4 = numcolors(x3)\n    # Check if the number of colors in the bottom half is exactly 2\n    x5 = equality(x4, TWO)\n    # Check if both top and bottom halves have exactly 2 colors\n    x6 = both(x2, x5)\n    # Get the left half of the input grid\n    x7 = lefthalf(I)\n    # Count the number of unique colors in the left half\n    x8 = numcolors(x7)\n    # Check if the number of colors in the left half is exactly 2\n    x9 = equality(x8, TWO)\n    # Get the right half of the input grid\n    x10 = righthalf(I)\n    # Count the number of unique colors in the right half\n    x11 = numcolors(x10)\n    # Check if the number of colors in the right half is exactly 2\n    x12 = equality(x11, TWO)\n    # Check if both left and right halves have exactly 2 colors\n    x13 = both(x9, x12)\n    # Invert the result of the left-right check (True becomes False, False becomes True)\n    x14 = flip(x13)\n    # Check if the grid has 2 colors in top-bottom halves but not in left-right halves\n    x15 = both(x6, x14)\n    # Choose vsplit if x15 is True (top-bottom split), otherwise use hsplit (left-right split)\n    x16 = branch(x15, vsplit, hsplit)\n    # Split the input grid into two parts based on the chosen split method\n    x17 = x16(I, TWO)\n    # Get the first part of the split grid\n    x18 = first(x17)\n    # Get the second part of the split grid\n    x19 = last(x17)\n    # Get the set of colors used in the first part\n    x20 = palette(x18)\n    # Get the set of colors used in the second part\n    x21 = palette(x19)\n    # Find the common color between the two parts\n    x22 = intersection(x20, x21)\n    # Get the common color (background color)\n    x23 = first(x22)\n    # Get the dimensions of the first part\n    x24 = shape(x18)\n    # Create a new grid with the background color and same dimensions as the first part\n    x25 = canvas(x23, x24)\n    # Get the indices of cells in the first part that have the background color\n    x26 = ofcolor(x18, x23)\n    # Get the indices of cells in the second part that have the background color\n    x27 = ofcolor(x19, x23)\n    # Find the common indices where both parts have the background color\n    x28 = intersection(x26, x27)\n    # Fill the new grid with color 2 at the common background color indices\n    # This effectively creates the output grid where overlapping background areas become color 2\n    x29 = fill(x25, TWO, x28)\n    # Return the final output grid\n    return x29\n"
  },
  "fcb5c309": {
    "original": "def verify_fcb5c309(I: Grid) -> Grid:\n    x0 = objects(I, T, F, F)\n    x1 = lbind(contained, F)\n    x2 = compose(flip, x1)\n    x3 = fork(equality, toindices, box)\n    x4 = lbind(apply, x3)\n    x5 = lbind(colorfilter, x0)\n    x6 = chain(x2, x4, x5)\n    x7 = rbind(greater, TWO)\n    x8 = compose(minimum, shape)\n    x9 = lbind(apply, x8)\n    x10 = chain(x7, minimum, x9)\n    x11 = lbind(colorfilter, x0)\n    x12 = compose(x10, x11)\n    x13 = fork(both, x6, x12)\n    x14 = palette(I)\n    x15 = extract(x14, x13)\n    x16 = palette(I)\n    x17 = remove(x15, x16)\n    x18 = lbind(colorcount, I)\n    x19 = argmin(x17, x18)\n    x20 = rbind(colorcount, x19)\n    x21 = rbind(toobject, I)\n    x22 = chain(x20, x21, backdrop)\n    x23 = colorfilter(x0, x15)\n    x24 = argmax(x23, x22)\n    x25 = subgrid(x24, I)\n    x26 = replace(x25, x15, x19)\n    return x26\n\n",
    "annotated": "def verify_fcb5c309(I: Grid) -> Grid:\n    # Get all objects in the input grid, considering diagonal connections\n    x0 = objects(I, T, F, F)\n    \n    # Create a function that checks if False is not contained in a set\n    x1 = lbind(contained, F)\n    x2 = compose(flip, x1)\n    \n    # Create a function that checks if an object's indices match its bounding box\n    x3 = fork(equality, toindices, box)\n    x4 = lbind(apply, x3)\n    \n    # Create a function to filter objects by color\n    x5 = lbind(colorfilter, x0)\n    \n    # Combine functions to check if an object is a filled rectangle\n    x6 = chain(x2, x4, x5)\n    \n    # Create a function to check if a number is greater than 2\n    x7 = rbind(greater, TWO)\n    \n    # Create a function to get the minimum dimension (height or width) of an object\n    x8 = compose(minimum, shape)\n    x9 = lbind(apply, x8)\n    \n    # Combine functions to check if the smallest dimension of an object is greater than 2\n    x10 = chain(x7, minimum, x9)\n    \n    # Create another function to filter objects by color\n    x11 = lbind(colorfilter, x0)\n    x12 = compose(x10, x11)\n    \n    # Combine functions to check if an object is a filled rectangle with dimensions > 2\n    x13 = fork(both, x6, x12)\n    \n    # Get the palette (unique colors) of the input grid\n    x14 = palette(I)\n    \n    # Extract the color of the filled rectangle (likely the square color)\n    x15 = extract(x14, x13)\n    \n    # Remove the square color from the palette\n    x16 = palette(I)\n    x17 = remove(x15, x16)\n    \n    # Create a function to count occurrences of a color in the input grid\n    x18 = lbind(colorcount, I)\n    \n    # Find the least common color among the remaining colors (likely the dot color)\n    x19 = argmin(x17, x18)\n    \n    # Create a function to count occurrences of the dot color\n    x20 = rbind(colorcount, x19)\n    \n    # Create a function to convert a patch to an object in the input grid\n    x21 = rbind(toobject, I)\n    \n    # Combine functions to count dot occurrences in the backdrop of an object\n    x22 = chain(x20, x21, backdrop)\n    \n    # Filter objects to get only the squares\n    x23 = colorfilter(x0, x15)\n    \n    # Find the square with the most dots\n    x24 = argmax(x23, x22)\n    \n    # Extract the subgrid containing the square with the most dots\n    x25 = subgrid(x24, I)\n    \n    # Replace the square color with the dot color in the extracted subgrid\n    x26 = replace(x25, x15, x19)\n    \n    # Return the modified subgrid as the output\n    return x26\n"
  },
  "fcc82909": {
    "original": "def verify_fcc82909(I: Grid) -> Grid:\n    x0 = objects(I, F, F, T)\n    x1 = lbind(add, DOWN)\n    x2 = compose(x1, llcorner)\n    x3 = rbind(add, RIGHT)\n    x4 = compose(x3, x2)\n    x5 = chain(toivec, decrement, numcolors)\n    x6 = fork(add, x4, x5)\n    x7 = compose(initset, x6)\n    x8 = fork(insert, x2, x7)\n    x9 = compose(backdrop, x8)\n    x10 = mapply(x9, x0)\n    x11 = fill(I, THREE, x10)\n    return x11\n\n",
    "annotated": "def verify_fcc82909(I: Grid) -> Grid:\n    # Find all objects in the input grid, excluding the background color\n    x0 = objects(I, F, F, T)\n    \n    # Create a function that adds the DOWN vector to a given point\n    x1 = lbind(add, DOWN)\n    \n    # Create a function that finds the lower-left corner of an object and moves one step down\n    x2 = compose(x1, llcorner)\n    \n    # Create a function that adds the RIGHT vector to a given point\n    x3 = rbind(add, RIGHT)\n    \n    # Create a function that moves one step down and right from the lower-left corner\n    x4 = compose(x3, x2)\n    \n    # Create a function chain that:\n    # 1. Counts the number of colors in an object\n    # 2. Decrements that count\n    # 3. Converts the result to a vertical vector\n    x5 = chain(toivec, decrement, numcolors)\n    \n    # Create a function that combines the results of x4 and x5\n    # This effectively calculates the bottom-right point of the area to be filled\n    x6 = fork(add, x4, x5)\n    \n    # Create a function that initializes a set with the result of x6\n    x7 = compose(initset, x6)\n    \n    # Create a function that combines the lower-left corner and the set from x7\n    # This defines the complete area to be filled below each object\n    x8 = fork(insert, x2, x7)\n    \n    # Create a function that generates the backdrop (all points) for the area defined by x8\n    x9 = compose(backdrop, x8)\n    \n    # Apply the x9 function to all objects, creating a set of all points to be filled\n    x10 = mapply(x9, x0)\n    \n    # Fill the input grid with color 3 (THREE) at all points defined by x10\n    # This adds the vertical bars below each object\n    x11 = fill(I, THREE, x10)\n    \n    # Return the modified grid\n    return x11\n"
  },
  "feca6190": {
    "original": "def verify_feca6190(I: Grid) -> Grid:\n    x0 = asobject(I)\n    x1 = matcher(first, ZERO)\n    x2 = compose(flip, x1)\n    x3 = sfilter(x0, x2)\n    x4 = size(x3)\n    x5 = width(I)\n    x6 = multiply(x5, x4)\n    x7 = multiply(UNITY, x6)\n    x8 = canvas(ZERO, x7)\n    x9 = multiply(x5, x4)\n    x10 = decrement(x9)\n    x11 = lbind(astuple, x10)\n    x12 = rbind(shoot, UP_RIGHT)\n    x13 = compose(last, last)\n    x14 = chain(x12, x11, x13)\n    x15 = fork(recolor, first, x14)\n    x16 = mapply(x15, x3)\n    x17 = paint(x8, x16)\n    return x17\n\n",
    "annotated": "def verify_feca6190(I: Grid) -> Grid:\n    # Convert the input grid to an object (set of (color, position) tuples)\n    x0 = asobject(I)\n    \n    # Create a function that checks if the first element of a tuple is zero\n    x1 = matcher(first, ZERO)\n    \n    # Invert the above function (checks if the first element is not zero)\n    x2 = compose(flip, x1)\n    \n    # Filter the object to keep only non-zero color cells\n    x3 = sfilter(x0, x2)\n    \n    # Count the number of non-zero color cells (number of colors used)\n    x4 = size(x3)\n    \n    # Get the width of the input grid\n    x5 = width(I)\n    \n    # Calculate the size of the output grid (width * number of colors)\n    x6 = multiply(x5, x4)\n    \n    # Create a tuple (size, size) for the output grid dimensions\n    x7 = multiply(UNITY, x6)\n    \n    # Create an empty output grid filled with zeros (black background)\n    x8 = canvas(ZERO, x7)\n    \n    # Calculate the starting row for diagonal lines (size - 1)\n    x9 = multiply(x5, x4)\n    x10 = decrement(x9)\n    \n    # Create a function to make a tuple with x10 as the first element\n    x11 = lbind(astuple, x10)\n    \n    # Create a function to shoot a diagonal line upwards and to the right\n    x12 = rbind(shoot, UP_RIGHT)\n    \n    # Create a function to get the column of a cell in the input grid\n    x13 = compose(last, last)\n    \n    # Chain functions to create diagonal line coordinates for each color\n    x14 = chain(x12, x11, x13)\n    \n    # Create a function to recolor the diagonal line with the original color\n    x15 = fork(recolor, first, x14)\n    \n    # Apply the recoloring function to all non-zero color cells\n    x16 = mapply(x15, x3)\n    \n    # Paint the diagonal lines onto the output grid\n    x17 = paint(x8, x16)\n    \n    # Return the final output grid\n    return x17\n"
  },
  "ff28f65a": {
    "original": "def verify_ff28f65a(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = remove(TWO, x0)\n    x2 = lbind(colorcount, I)\n    x3 = argmax(x1, x2)\n    x4 = shape(I)\n    x5 = canvas(x3, x4)\n    x6 = hconcat(I, x5)\n    x7 = objects(x6, T, F, T)\n    x8 = colorfilter(x7, TWO)\n    x9 = size(x8)\n    x10 = double(x9)\n    x11 = interval(ZERO, x10, TWO)\n    x12 = apply(tojvec, x11)\n    x13 = astuple(ONE, NINE)\n    x14 = canvas(x3, x13)\n    x15 = fill(x14, ONE, x12)\n    x16 = hsplit(x15, THREE)\n    x17 = merge(x16)\n    return x17\n\n",
    "annotated": "def verify_ff28f65a(I: Grid) -> Grid:\n    # Get the set of unique colors used in the input grid\n    x0 = palette(I)\n    \n    # Remove color 2 (red) from the set of colors\n    x1 = remove(TWO, x0)\n    \n    # Create a function that counts occurrences of a color in the input grid\n    x2 = lbind(colorcount, I)\n    \n    # Find the most common color in the grid, excluding red (background color)\n    x3 = argmax(x1, x2)\n    \n    # Get the dimensions of the input grid\n    x4 = shape(I)\n    \n    # Create a new grid with the same dimensions as input, filled with background color\n    x5 = canvas(x3, x4)\n    \n    # Concatenate the input grid and the background grid horizontally\n    x6 = hconcat(I, x5)\n    \n    # Find all objects in the combined grid, allowing diagonal connections\n    x7 = objects(x6, T, F, T)\n    \n    # Filter objects to keep only those of color 2 (red rectangles)\n    x8 = colorfilter(x7, TWO)\n    \n    # Count the number of red rectangles\n    x9 = size(x8)\n    \n    # Double the count of red rectangles\n    x10 = double(x9)\n    \n    # Create a sequence from 0 to twice the number of red rectangles, step 2\n    x11 = interval(ZERO, x10, TWO)\n    \n    # Convert each number in the sequence to a vertical vector (0, n)\n    x12 = apply(tojvec, x11)\n    \n    # Create a tuple representing dimensions (1, 9)\n    x13 = astuple(ONE, NINE)\n    \n    # Create a 1x9 grid filled with the background color\n    x14 = canvas(x3, x13)\n    \n    # Fill the 1x9 grid with blue (color 1) at positions determined by x12\n    x15 = fill(x14, ONE, x12)\n    \n    # Split the 1x9 grid into three 1x3 grids\n    x16 = hsplit(x15, THREE)\n    \n    # Merge the three 1x3 grids into a single 3x3 grid (the output)\n    x17 = merge(x16)\n    \n    # Return the final 3x3 grid as the output\n    return x17\n"
  },
  "ff805c23": {
    "original": "def verify_ff805c23(I: Grid) -> Grid:\n    x0 = palette(I)\n    x1 = lbind(rbind, sfilter)\n    x2 = lbind(compose, flip)\n    x3 = lbind(matcher, first)\n    x4 = chain(x1, x2, x3)\n    x5 = lbind(paint, I)\n    x6 = rbind(compose, asobject)\n    x7 = dmirror(I)\n    x8 = rbind(rapply, x7)\n    x9 = chain(first, x8, initset)\n    x10 = chain(x9, x6, x4)\n    x11 = compose(x5, x10)\n    x12 = compose(x6, x4)\n    x13 = compose(cmirror, x11)\n    x14 = compose(initset, x12)\n    x15 = fork(rapply, x14, x13)\n    x16 = compose(first, x15)\n    x17 = fork(paint, x11, x16)\n    x18 = chain(initset, x6, x4)\n    x19 = compose(hmirror, x17)\n    x20 = fork(rapply, x18, x19)\n    x21 = compose(first, x20)\n    x22 = fork(paint, x17, x21)\n    x23 = chain(initset, x6, x4)\n    x24 = compose(vmirror, x22)\n    x25 = fork(rapply, x23, x24)\n    x26 = compose(first, x25)\n    x27 = fork(paint, x22, x26)\n    x28 = fork(equality, identity, hmirror)\n    x29 = fork(equality, identity, vmirror)\n    x30 = fork(equality, identity, cmirror)\n    x31 = fork(equality, identity, dmirror)\n    x32 = fork(both, x28, x29)\n    x33 = fork(both, x30, x31)\n    x34 = fork(both, x32, x33)\n    x35 = compose(x34, x27)\n    x36 = sfilter(x0, x35)\n    x37 = lbind(colorcount, I)\n    x38 = argmin(x36, x37)\n    x39 = x27(x38)\n    x40 = ofcolor(I, x38)\n    x41 = subgrid(x40, x39)\n    return x41\n\n",
    "annotated": "def verify_ff805c23(I: Grid) -> Grid:\n    # Get the set of unique colors in the input grid\n    x0 = palette(I)\n    \n    # Create a function that filters a set based on a predicate\n    x1 = lbind(rbind, sfilter)\n    \n    # Create a function that composes two functions with the arguments flipped\n    x2 = lbind(compose, flip)\n    \n    # Create a function that matches the first element of a tuple\n    x3 = lbind(matcher, first)\n    \n    # Chain the above functions to create a complex filtering function\n    x4 = chain(x1, x2, x3)\n    \n    # Create a function that paints on the input grid\n    x5 = lbind(paint, I)\n    \n    # Create a function that converts to an object representation\n    x6 = rbind(compose, asobject)\n    \n    # Create a diagonal mirror of the input grid\n    x7 = dmirror(I)\n    \n    # Create a function that applies a function to x7\n    x8 = rbind(rapply, x7)\n    \n    # Chain functions to get the first element, apply to x7, and create a set\n    x9 = chain(first, x8, initset)\n    \n    # Further chain functions for complex object manipulation\n    x10 = chain(x9, x6, x4)\n    \n    # Compose functions to paint filtered objects on the input grid\n    x11 = compose(x5, x10)\n    \n    # Compose functions to convert filtered elements to objects\n    x12 = compose(x6, x4)\n    \n    # Compose functions to mirror and paint objects\n    x13 = compose(cmirror, x11)\n    \n    # Create a set from the filtered and converted objects\n    x14 = compose(initset, x12)\n    \n    # Fork to apply two different operations and combine results\n    x15 = fork(rapply, x14, x13)\n    \n    # Get the first element of the forked result\n    x16 = compose(first, x15)\n    \n    # Paint the result on the grid\n    x17 = fork(paint, x11, x16)\n    \n    # Create a set of filtered and converted objects\n    x18 = chain(initset, x6, x4)\n    \n    # Mirror the painted grid horizontally\n    x19 = compose(hmirror, x17)\n    \n    # Fork to apply operations on mirrored grid\n    x20 = fork(rapply, x18, x19)\n    \n    # Get the first element of the forked result\n    x21 = compose(first, x20)\n    \n    # Paint the result on the grid\n    x22 = fork(paint, x17, x21)\n    \n    # Create another set of filtered and converted objects\n    x23 = chain(initset, x6, x4)\n    \n    # Mirror the painted grid vertically\n    x24 = compose(vmirror, x22)\n    \n    # Fork to apply operations on mirrored grid\n    x25 = fork(rapply, x23, x24)\n    \n    # Get the first element of the forked result\n    x26 = compose(first, x25)\n    \n    # Paint the result on the grid\n    x27 = fork(paint, x22, x26)\n    \n    # Create functions to check if grid is equal to its horizontal mirror\n    x28 = fork(equality, identity, hmirror)\n    \n    # Create functions to check if grid is equal to its vertical mirror\n    x29 = fork(equality, identity, vmirror)\n    \n    # Create functions to check if grid is equal to its counter-diagonal mirror\n    x30 = fork(equality, identity, cmirror)\n    \n    # Create functions to check if grid is equal to its diagonal mirror\n    x31 = fork(equality, identity, dmirror)\n    \n    # Combine horizontal and vertical symmetry checks\n    x32 = fork(both, x28, x29)\n    \n    # Combine counter-diagonal and diagonal symmetry checks\n    x33 = fork(both, x30, x31)\n    \n    # Combine all symmetry checks\n    x34 = fork(both, x32, x33)\n    \n    # Apply all symmetry checks to the painted grid\n    x35 = compose(x34, x27)\n    \n    # Filter colors based on symmetry properties\n    x36 = sfilter(x0, x35)\n    \n    # Create a function to count occurrences of a color in the input grid\n    x37 = lbind(colorcount, I)\n    \n    # Find the color with minimum count among filtered colors\n    x38 = argmin(x36, x37)\n    \n    # Apply the painting process to the minimum color\n    x39 = x27(x38)\n    \n    # Get indices of cells with the minimum color in the input grid\n    x40 = ofcolor(I, x38)\n    \n    # Extract the subgrid defined by the minimum color cells from the painted grid\n    x41 = subgrid(x40, x39)\n    \n    # Return the extracted subgrid as the output\n    return x41\n"
  }
}
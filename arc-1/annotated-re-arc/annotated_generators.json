{
  "007bbfb7": {
    "original": "def generate_007bbfb7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    c = canvas(0, (h, w))\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numc = choice((numcd, h * w - numcd))\n    numc = min(max(1, numc), h * w - 1)\n    inds = totuple(asindices(c))\n    locs = sample(inds, numc)\n    fgc = choice(cols)\n    gi = fill(c, fgc, locs)\n    go = canvas(0, (h**2, w**2))\n    for loc in locs:\n        go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_007bbfb7(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 1 to 9 with step 1\n    cols = interval(1, 10, 1)\n    \n    # Randomly generate the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly generate the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Create an empty canvas (grid) filled with zeros of size h x w\n    c = canvas(0, (h, w))\n    \n    # Randomly determine the number of cells to potentially color (up to half the grid)\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly choose whether to use numcd or its complement for actual coloring\n    numc = choice((numcd, h * w - numcd))\n    \n    # Ensure at least 1 cell is colored and at least 1 cell remains uncolored\n    numc = min(max(1, numc), h * w - 1)\n    \n    # Get all possible indices of the input grid as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select 'numc' number of locations to color\n    locs = sample(inds, numc)\n    \n    # Choose a random foreground color from the 'cols' tuple\n    fgc = choice(cols)\n    \n    # Fill the selected locations in the input grid with the chosen color\n    gi = fill(c, fgc, locs)\n    \n    # Create an empty output canvas of size (h^2) x (w^2)\n    go = canvas(0, (h**2, w**2))\n    \n    # For each colored location in the input:\n    for loc in locs:\n        # Fill the corresponding h x w block in the output grid\n        # This effectively \"zooms in\" on each colored cell from the input\n        go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "00d62c1b": {
    "original": "def generate_00d62c1b(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    nblocks = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nblocks\n    inds = asindices(gi)\n    while succ < nblocks and tr < maxtr:\n        tr += 1\n        oh = randint(3, 8)\n        ow = randint(3, 8)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        bx = bx - set(sample(totuple(corners(bx)), randint(0, 4)))\n        if bx.issubset(inds) and len(inds - bx) > (h * w) // 2 + 1:\n            gi = fill(gi, fgc, bx)\n            succ += 1\n            inds = inds - bx\n    maxnnoise = max(0, (h * w) // 2 - 1 - colorcount(gi, fgc))\n    namt = unifint(diff_lb, diff_ub, (0, maxnnoise))\n    noise = sample(totuple(inds), namt)\n    gi = fill(gi, fgc, noise)\n    objs = objects(gi, T, F, F)\n    cands = colorfilter(objs, bgc)\n    res = mfilter(cands, compose(flip, rbind(bordering, gi)))\n    go = fill(gi, 4, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_00d62c1b(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 4 from the range 0-9, creating a list of available colors\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate a random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly select two colors: one for background and one for foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Calculate the number of blocks to add, between 1 and 5% of the grid area\n    nblocks = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Initialize counters for successful block placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * nblocks\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Loop to place blocks on the grid\n    while succ < nblocks and tr < maxtr:\n        tr += 1\n        \n        # Generate random block height between 3 and 8\n        oh = randint(3, 8)\n        \n        # Generate random block width between 3 and 8\n        ow = randint(3, 8)\n        \n        # Find valid locations where the block can be placed\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the block\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create a box outline for the block\n        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Randomly remove 0 to 4 corners from the box\n        bx = bx - set(sample(totuple(corners(bx)), randint(0, 4)))\n        \n        # Check if the box fits on the grid and doesn't cover more than half the area\n        if bx.issubset(inds) and len(inds - bx) > (h * w) // 2 + 1:\n            # Fill the box with the foreground color\n            gi = fill(gi, fgc, bx)\n            succ += 1\n            # Remove the filled indices from available indices\n            inds = inds - bx\n    \n    # Calculate maximum number of noise pixels\n    maxnnoise = max(0, (h * w) // 2 - 1 - colorcount(gi, fgc))\n    \n    # Determine number of noise pixels to add based on difficulty\n    namt = unifint(diff_lb, diff_ub, (0, maxnnoise))\n    \n    # Randomly select indices for noise\n    noise = sample(totuple(inds), namt)\n    \n    # Add noise pixels to the grid\n    gi = fill(gi, fgc, noise)\n    \n    # Identify all objects on the grid\n    objs = objects(gi, T, F, F)\n    \n    # Filter objects to get background color objects\n    cands = colorfilter(objs, bgc)\n    \n    # Find background objects that are not bordering the grid edge\n    res = mfilter(cands, compose(flip, rbind(bordering, gi)))\n    \n    # Create the output grid by filling non-bordering background objects with color 4\n    go = fill(gi, 4, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "017c7c7b": {
    "original": "def generate_017c7c7b(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (0, 2))\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    h += h\n    fgc = choice(cols)\n    go = canvas(0, (h + h // 2, w))\n    oh = unifint(diff_lb, diff_ub, (1, h//3*2))\n    ow = unifint(diff_lb, diff_ub, (1, w))\n    locj = randint(0, w - ow)\n    bounds = asindices(canvas(-1, (oh, ow)))\n    ncellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(1, ncells), oh * ow)\n    obj = sample(totuple(bounds), ncells)\n    for k in range((2*h)//oh):\n        go = fill(go, 2, shift(obj, (k*oh, 0)))\n    gi = replace(go[:h], 2, fgc)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_017c7c7b(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 0 and 2\n    cols = difference(interval(0, 10, 1), (0, 2))\n    \n    # Randomly determine the height of the input grid (between 3 and 10)\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    \n    # Randomly determine the width of the grid (between 2 and 30)\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Double the height for the output grid\n    h += h\n    \n    # Randomly choose a foreground color from the available colors\n    fgc = choice(cols)\n    \n    # Create an empty output grid with height 1.5 times the doubled input height\n    go = canvas(0, (h + h // 2, w))\n    \n    # Randomly determine the height of the object (between 1 and 2/3 of input height)\n    oh = unifint(diff_lb, diff_ub, (1, h//3*2))\n    \n    # Randomly determine the width of the object (between 1 and full width)\n    ow = unifint(diff_lb, diff_ub, (1, w))\n    \n    # Randomly position the object horizontally\n    locj = randint(0, w - ow)\n    \n    # Create a set of indices representing the object's bounding box\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Randomly determine the number of cells to fill in the object\n    ncellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(1, ncells), oh * ow)\n    \n    # Randomly select cells to fill within the object's bounds\n    obj = sample(totuple(bounds), ncells)\n    \n    # Fill the output grid with repeating objects (color 2)\n    for k in range((2*h)//oh):\n        go = fill(go, 2, shift(obj, (k*oh, 0)))\n    \n    # Create the input grid by taking the top half of the output and replacing color 2 with the chosen foreground color\n    gi = replace(go[:h], 2, fgc)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "025d127b": {
    "original": "def generate_025d127b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numcols)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(3, 6)\n        ow = randint(3, 6)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        topl = connect((0, 0), (0, ow - 1))\n        leftl = connect((1, 0), (oh - 2, oh - 3))\n        rightl = connect((1, ow), (oh - 2, ow + oh - 3))\n        botl = connect((oh - 1, oh - 2), (oh - 1, oh - 3 + ow))\n        inobj = topl | leftl | rightl | botl\n        outobj = shift(topl, (0, 1)) | botl | shift(leftl, (0, 1)) | connect((1, ow+1), (oh - 3, ow + oh - 3)) | {(oh - 2, ow + oh - 3)}\n        outobj = sfilter(outobj, lambda ij: ij[1] <= rightmost(inobj))\n        fullobj = inobj | outobj\n        inobj = shift(inobj, loc)\n        outobj = shift(outobj, loc)\n        fullobj = shift(fullobj, loc)\n        if fullobj.issubset(inds):\n            inds = (inds - fullobj) - mapply(neighbors, fullobj)\n            succ += 1\n            col = choice(ccols)\n            gi = fill(gi, col, inobj)\n            go = fill(go, col, outobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_025d127b(diff_lb: float, diff_ub: float) -> dict:\n    # Define possible color values (0-9)\n    cols = interval(0, 10, 1)\n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly choose a background color\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Randomly determine the number of colors to use (excluding background)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    # Randomly sample colors to use for objects\n    ccols = sample(remcols, numcols)\n    # Randomly determine the number of objects to place on the grid\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    # Initialize counter for successfully placed objects\n    succ = 0\n    # Initialize counter for placement attempts\n    tr = 0\n    # Set maximum number of placement attempts\n    maxtr = 5 * nobjs\n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    # Get all possible cell indices in the grid\n    inds = asindices(gi)\n    \n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        # Increment attempt counter\n        tr += 1\n        # Randomly determine object height (3-6)\n        oh = randint(3, 6)\n        # Randomly determine object width (3-6)\n        ow = randint(3, 6)\n        # Filter possible locations where object can fit\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        # Define top line of the object\n        topl = connect((0, 0), (0, ow - 1))\n        # Define left line of the object\n        leftl = connect((1, 0), (oh - 2, oh - 3))\n        # Define right line of the object\n        rightl = connect((1, ow), (oh - 2, ow + oh - 3))\n        # Define bottom line of the object\n        botl = connect((oh - 1, oh - 2), (oh - 1, oh - 3 + ow))\n        # Combine all lines to form the input object\n        inobj = topl | leftl | rightl | botl\n        # Create the output object by shifting and modifying the input object\n        outobj = shift(topl, (0, 1)) | botl | shift(leftl, (0, 1)) | connect((1, ow+1), (oh - 3, ow + oh - 3)) | {(oh - 2, ow + oh - 3)}\n        # Trim the output object to fit within the rightmost boundary of the input object\n        outobj = sfilter(outobj, lambda ij: ij[1] <= rightmost(inobj))\n        # Combine input and output objects\n        fullobj = inobj | outobj\n        # Shift the input object to its final position\n        inobj = shift(inobj, loc)\n        # Shift the output object to its final position\n        outobj = shift(outobj, loc)\n        # Shift the full object to its final position\n        fullobj = shift(fullobj, loc)\n        \n        # Check if the full object fits within the grid\n        if fullobj.issubset(inds):\n            # Remove the object and its neighboring cells from available indices\n            inds = (inds - fullobj) - mapply(neighbors, fullobj)\n            # Increment success counter\n            succ += 1\n            # Choose a random color for the object\n            col = choice(ccols)\n            # Fill the input grid with the object\n            gi = fill(gi, col, inobj)\n            # Fill the output grid with the transformed object\n            go = fill(go, col, outobj)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "045e512c": {
    "original": "def generate_045e512c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (11, 30))\n    w = unifint(diff_lb, diff_ub, (11, 30))\n    while True:\n        oh = unifint(diff_lb, diff_ub, (2, min(4, (h - 2) // 3)))\n        ow = unifint(diff_lb, diff_ub, (2, min(4, (w - 2) // 3)))\n        bounds = asindices(canvas(-1, (oh, ow)))\n        c1 = choice(totuple(connect((0, 0), (oh - 1, 0))))\n        c2 = choice(totuple(connect((0, 0), (0, ow - 1))))\n        c3 = choice(totuple(connect((oh - 1, ow - 1), (oh - 1, 0))))\n        c4 = choice(totuple(connect((oh - 1, ow - 1), (0, ow - 1))))\n        obj = {c1, c2, c3, c4}\n        remcands = totuple(bounds - obj)\n        ncells = unifint(diff_lb, diff_ub, (0, len(remcands)))\n        for k in range(ncells):\n            loc = choice(remcands)\n            obj.add(loc)\n            remcands = remove(loc, remcands)\n        objt = normalize(obj)\n        cc = canvas(0, shape(obj))\n        cc = fill(cc, 1, objt)\n        if len(colorfilter(objects(cc, T, T, F), 1)) == 1:\n            break\n    loci = randint(oh + 1, h - 2 * oh - 1)\n    locj = randint(ow + 1, w - 2 * ow - 1)\n    loc = (loci, locj)\n    bgc, objc = sample(cols, 2)\n    remcols = remove(bgc, remove(objc, cols))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    obj = shift(recolor(objc, obj), loc)\n    gi = paint(gi, obj)\n    go = paint(go, obj)\n    options = totuple(neighbors((0, 0)))\n    ndirs = unifint(diff_lb, diff_ub, (1, 8))\n    dirs = sample(options, ndirs)\n    dcols = [choice(ccols) for k in range(ndirs)]\n    hbars = hfrontier((loci - 2, 0)) | hfrontier((loci+oh+1, 0))\n    vbars = vfrontier((0, locj - 2)) | vfrontier((0, locj+ow+1))\n    bars = hbars | vbars\n    ofs = increment((oh, ow))\n    for direc, col in zip(dirs, dcols):\n        indicatorobj = shift(obj, multiply(direc, increment((oh, ow))))\n        indicatorobj = sfilter(indicatorobj, lambda cij: cij[1] in bars)\n        nindsd = unifint(diff_lb, diff_ub, (0, len(indicatorobj) - 1))\n        ninds = len(indicatorobj) - nindsd\n        indicatorobj = set(sample(totuple(indicatorobj), ninds))\n        if len(indicatorobj) > 0 and len(indicatorobj) < len(obj):\n            gi = fill(gi, col, indicatorobj)\n            for k in range(1, 10):\n                go = fill(go, col, shift(obj, multiply(multiply(k, direc), ofs)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_045e512c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly determine the height of the grid between 11 and 30\n    h = unifint(diff_lb, diff_ub, (11, 30))\n    # Randomly determine the width of the grid between 11 and 30\n    w = unifint(diff_lb, diff_ub, (11, 30))\n    while True:\n        # Randomly determine the height of the object, between 2 and min(4, (h-2)//3)\n        oh = unifint(diff_lb, diff_ub, (2, min(4, (h - 2) // 3)))\n        # Randomly determine the width of the object, between 2 and min(4, (w-2)//3)\n        ow = unifint(diff_lb, diff_ub, (2, min(4, (w - 2) // 3)))\n        # Create a set of all possible coordinates within the object's dimensions\n        bounds = asindices(canvas(-1, (oh, ow)))\n        # Randomly choose a point on the left edge of the object\n        c1 = choice(totuple(connect((0, 0), (oh - 1, 0))))\n        # Randomly choose a point on the top edge of the object\n        c2 = choice(totuple(connect((0, 0), (0, ow - 1))))\n        # Randomly choose a point on the right edge of the object\n        c3 = choice(totuple(connect((oh - 1, ow - 1), (oh - 1, 0))))\n        # Randomly choose a point on the bottom edge of the object\n        c4 = choice(totuple(connect((oh - 1, ow - 1), (0, ow - 1))))\n        # Create the initial object with the four chosen points\n        obj = {c1, c2, c3, c4}\n        # Get the remaining candidate points for the object\n        remcands = totuple(bounds - obj)\n        # Randomly determine how many additional cells to add to the object\n        ncells = unifint(diff_lb, diff_ub, (0, len(remcands)))\n        # Add random cells to the object\n        for k in range(ncells):\n            loc = choice(remcands)\n            obj.add(loc)\n            remcands = remove(loc, remcands)\n        # Normalize the object's position (move it to the origin)\n        objt = normalize(obj)\n        # Create a canvas with the object's dimensions\n        cc = canvas(0, shape(obj))\n        # Fill the canvas with the object\n        cc = fill(cc, 1, objt)\n        # Check if the object forms a single connected component\n        if len(colorfilter(objects(cc, T, T, F), 1)) == 1:\n            break\n    # Randomly determine the position of the object in the grid\n    loci = randint(oh + 1, h - 2 * oh - 1)\n    locj = randint(ow + 1, w - 2 * ow - 1)\n    loc = (loci, locj)\n    # Randomly choose background and object colors\n    bgc, objc = sample(cols, 2)\n    # Get the remaining colors\n    remcols = remove(bgc, remove(objc, cols))\n    # Randomly determine the number of additional colors to use\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly choose the additional colors\n    ccols = sample(remcols, ncols)\n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    # Place the object on the input and output grids\n    obj = shift(recolor(objc, obj), loc)\n    gi = paint(gi, obj)\n    go = paint(go, obj)\n    # Define possible directions for object replication\n    options = totuple(neighbors((0, 0)))\n    # Randomly determine the number of directions to use\n    ndirs = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly choose the directions\n    dirs = sample(options, ndirs)\n    # Randomly assign colors to each direction\n    dcols = [choice(ccols) for k in range(ndirs)]\n    # Define horizontal and vertical bars around the object\n    hbars = hfrontier((loci - 2, 0)) | hfrontier((loci+oh+1, 0))\n    vbars = vfrontier((0, locj - 2)) | vfrontier((0, locj+ow+1))\n    bars = hbars | vbars\n    # Calculate the offset for object replication\n    ofs = increment((oh, ow))\n    # For each direction and color\n    for direc, col in zip(dirs, dcols):\n        # Create an indicator object in the direction\n        indicatorobj = shift(obj, multiply(direc, increment((oh, ow))))\n        # Keep only the parts of the indicator object that intersect with the bars\n        indicatorobj = sfilter(indicatorobj, lambda cij: cij[1] in bars)\n        # Randomly determine how many cells to remove from the indicator\n        nindsd = unifint(diff_lb, diff_ub, (0, len(indicatorobj) - 1))\n        ninds = len(indicatorobj) - nindsd\n        # Randomly select cells for the indicator\n        indicatorobj = set(sample(totuple(indicatorobj), ninds))\n        # If the indicator is not empty and smaller than the original object\n        if len(indicatorobj) > 0 and len(indicatorobj) < len(obj):\n            # Add the indicator to the input grid\n            gi = fill(gi, col, indicatorobj)\n            # Add replicated objects to the output grid\n            for k in range(1, 10):\n                go = fill(go, col, shift(obj, multiply(multiply(k, direc), ofs)))\n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "0520fde7": {
    "original": "def generate_0520fde7(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    cola = choice(remcols)\n    colb = choice(remcols)\n    canv = canvas(bgc, (h, w))\n    inds = totuple(asindices(canv))\n    gbar = canvas(barcol, (h, 1))\n    mp = (h * w) // 2\n    devrng = (0, mp)\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    deva = sgna * deva\n    devb = sgnb * devb\n    numa = mp + deva\n    numb = mp + devb\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gi = hconcat(hconcat(gia, gbar), gib)\n    go = fill(canv, 2, set(a) & set(b))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0520fde7(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 2 from the range of colors 0 to 9\n    cols = remove(2, interval(0, 10, 1))\n    # Randomly generate height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    # Randomly generate width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    # Set background color to 0 (black)\n    bgc = 0\n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    # Randomly choose a color for the vertical bar\n    barcol = choice(remcols)\n    # Remove the bar color from remaining colors\n    remcols = remove(barcol, remcols)\n    # Randomly choose two colors for the two sets of points\n    cola = choice(remcols)\n    colb = choice(remcols)\n    # Create a canvas filled with background color\n    canv = canvas(bgc, (h, w))\n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    # Create a vertical bar with the chosen bar color\n    gbar = canvas(barcol, (h, 1))\n    # Calculate the midpoint of total cells\n    mp = (h * w) // 2\n    # Set the range for deviation from midpoint\n    devrng = (0, mp)\n    # Randomly generate deviations for both sets based on difficulty\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    # Randomly choose signs for deviations\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    # Apply signs to deviations\n    deva = sgna * deva\n    devb = sgnb * devb\n    # Calculate number of points for each set\n    numa = mp + deva\n    numb = mp + devb\n    # Ensure number of points is within valid range\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    # Randomly sample points for each set\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    # Fill the canvas with points of set A\n    gia = fill(canv, cola, a)\n    # Fill the canvas with points of set B\n    gib = fill(canv, colb, b)\n    # Concatenate the two filled canvases with the vertical bar in between\n    gi = hconcat(hconcat(gia, gbar), gib)\n    # Create output grid by filling intersection of sets A and B with color 2\n    go = fill(canv, 2, set(a) & set(b))\n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "05269061": {
    "original": "def generate_05269061(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (2, 30)\n    colopts = interval(1, 10, 1)\n    d = unifint(diff_lb, diff_ub, dim_bounds)\n    go = canvas(0, (d, d))\n    gi = canvas(0, (d, d))\n    if choice((True, False)):\n        period_bounds = (2, min(2*d-2, 9))\n        num = unifint(diff_lb, diff_ub, period_bounds)\n        cols = tuple(choice(colopts) for k in range(num))\n        keeps = [choice(interval(j, 2*d-1, num)) for j in range(num)]\n        for k, col in enumerate((cols * 30)[:2*d-1]):\n            lin = shoot(toivec(k), UP_RIGHT)\n            go = fill(go, col, lin)\n            if keeps[k % num] == k:\n                gi = fill(gi, col, lin)\n    else:\n        period_bounds = (2, min(d, 9))\n        num = unifint(diff_lb, diff_ub, period_bounds)\n        cols = tuple(choice(colopts) for k in range(num))\n        keeps = [choice(interval(j, d, num)) for j in range(num)]\n        for k, col in enumerate((cols * 30)[:d]):\n            lin = hfrontier(toivec(k))\n            go = fill(go, col, lin)\n            if keeps[k % num] == k:\n                gi = fill(gi, col, lin)\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_05269061(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (2, 30)\n    # Define color options from 1 to 9\n    colopts = interval(1, 10, 1)\n    # Randomly choose grid dimension based on difficulty\n    d = unifint(diff_lb, diff_ub, dim_bounds)\n    # Create empty output grid\n    go = canvas(0, (d, d))\n    # Create empty input grid\n    gi = canvas(0, (d, d))\n    # Randomly choose between diagonal or horizontal line pattern\n    if choice((True, False)):\n        # Diagonal line pattern\n        # Define bounds for number of colors in pattern\n        period_bounds = (2, min(2*d-2, 9))\n        # Randomly choose number of colors based on difficulty\n        num = unifint(diff_lb, diff_ub, period_bounds)\n        # Randomly choose colors for the pattern\n        cols = tuple(choice(colopts) for k in range(num))\n        # Randomly choose which lines to keep in input grid\n        keeps = [choice(interval(j, 2*d-1, num)) for j in range(num)]\n        # Iterate over diagonal lines\n        for k, col in enumerate((cols * 30)[:2*d-1]):\n            # Create diagonal line\n            lin = shoot(toivec(k), UP_RIGHT)\n            # Fill diagonal line in output grid\n            go = fill(go, col, lin)\n            # If this line should be kept, fill it in input grid\n            if keeps[k % num] == k:\n                gi = fill(gi, col, lin)\n    else:\n        # Horizontal line pattern\n        # Define bounds for number of colors in pattern\n        period_bounds = (2, min(d, 9))\n        # Randomly choose number of colors based on difficulty\n        num = unifint(diff_lb, diff_ub, period_bounds)\n        # Randomly choose colors for the pattern\n        cols = tuple(choice(colopts) for k in range(num))\n        # Randomly choose which lines to keep in input grid\n        keeps = [choice(interval(j, d, num)) for j in range(num)]\n        # Iterate over horizontal lines\n        for k, col in enumerate((cols * 30)[:d]):\n            # Create horizontal line\n            lin = hfrontier(toivec(k))\n            # Fill horizontal line in output grid\n            go = fill(go, col, lin)\n            # If this line should be kept, fill it in input grid\n            if keeps[k % num] == k:\n                gi = fill(gi, col, lin)\n    # Randomly decide whether to mirror grids vertically\n    if choice((True, False)):\n        # Mirror input grid vertically\n        gi = vmirror(gi)\n        # Mirror output grid vertically\n        go = vmirror(go)\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "05f2a901": {
    "original": "def generate_05f2a901(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    objh = unifint(diff_lb, diff_ub, (2, min(w//2, h//2)))\n    objw = unifint(diff_lb, diff_ub, (objh, w//2))\n    bb = asindices(canvas(-1, (objh, objw)))\n    sp = choice(totuple(bb))\n    obj = {sp}\n    bb = remove(sp, bb)\n    ncells = unifint(diff_lb, diff_ub, (objh + objw, objh * objw))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    if height(obj) * width(obj) == len(obj):\n        obj = remove(choice(totuple(obj)), obj)\n    obj = normalize(obj)\n    objh, objw = shape(obj)\n    loci = unifint(diff_lb, diff_ub, (3, h - objh))\n    locj = unifint(diff_lb, diff_ub, (0, w - objw))\n    loc = (loci, locj)\n    bgc, fgc, destc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    obj = shift(obj, loc)\n    gi = fill(gi, fgc, obj)\n    sqd = randint(1, min(w, loci - 1))\n    locisq = randint(0, loci-sqd-1)\n    locjsq = randint(locj-sqd+1, locj+objw-1)\n    locsq = (locisq, locjsq)\n    sq = backdrop({(locisq, locjsq), (locisq+sqd-1, locjsq+sqd-1)})\n    gi = fill(gi, destc, sq)\n    go = fill(go, destc, sq)\n    while len(obj & sq) == 0:\n        obj = shift(obj, (-1, 0))\n    obj = shift(obj, (1, 0))\n    go = fill(go, fgc, obj)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_05f2a901(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid (between 8 and 30)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the width of the grid (between 8 and 30)\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the height of the object (between 2 and half of the smaller dimension of the grid)\n    objh = unifint(diff_lb, diff_ub, (2, min(w//2, h//2)))\n    \n    # Randomly determine the width of the object (between object height and half of grid width)\n    objw = unifint(diff_lb, diff_ub, (objh, w//2))\n    \n    # Create a set of all possible coordinates for the object\n    bb = asindices(canvas(-1, (objh, objw)))\n    \n    # Choose a random starting point for the object\n    sp = choice(totuple(bb))\n    \n    # Initialize the object with the starting point\n    obj = {sp}\n    \n    # Remove the starting point from the set of possible coordinates\n    bb = remove(sp, bb)\n    \n    # Randomly determine the number of cells in the object\n    ncells = unifint(diff_lb, diff_ub, (objh + objw, objh * objw))\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    \n    # If the object is a rectangle, remove one cell to make it irregular\n    if height(obj) * width(obj) == len(obj):\n        obj = remove(choice(totuple(obj)), obj)\n    \n    # Normalize the object's position (move it to the top-left corner)\n    obj = normalize(obj)\n    \n    # Get the final dimensions of the object\n    objh, objw = shape(obj)\n    \n    # Randomly determine the vertical position of the object\n    loci = unifint(diff_lb, diff_ub, (3, h - objh))\n    \n    # Randomly determine the horizontal position of the object\n    locj = unifint(diff_lb, diff_ub, (0, w - objw))\n    \n    # Combine the vertical and horizontal positions\n    loc = (loci, locj)\n    \n    # Randomly select three different colors for background, foreground, and destination\n    bgc, fgc, destc = sample(cols, 3)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Move the object to its position on the grid\n    obj = shift(obj, loc)\n    \n    # Draw the object on the input grid\n    gi = fill(gi, fgc, obj)\n    \n    # Randomly determine the size of the square destination area\n    sqd = randint(1, min(w, loci - 1))\n    \n    # Randomly determine the vertical position of the square\n    locisq = randint(0, loci-sqd-1)\n    \n    # Randomly determine the horizontal position of the square\n    locjsq = randint(locj-sqd+1, locj+objw-1)\n    \n    # Combine the square's position\n    locsq = (locisq, locjsq)\n    \n    # Create the square destination area\n    sq = backdrop({(locisq, locjsq), (locisq+sqd-1, locjsq+sqd-1)})\n    \n    # Draw the square on the input grid\n    gi = fill(gi, destc, sq)\n    \n    # Draw the square on the output grid\n    go = fill(go, destc, sq)\n    \n    # Move the object down until it touches the square\n    while len(obj & sq) == 0:\n        obj = shift(obj, (-1, 0))\n    \n    # Move the object up one step to not overlap with the square\n    obj = shift(obj, (1, 0))\n    \n    # Draw the final position of the object on the output grid\n    go = fill(go, fgc, obj)\n    \n    # Define a list of possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Randomly choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen number of random transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "06df4c85": {
    "original": "def generate_06df4c85(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))\n    numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))\n    bgc, linc = sample(cols, 2)\n    remcols = difference(cols, (bgc, linc))\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))\n    ccols = sample(remcols, ncols)\n    fullh = numh * oh + numh - 1\n    fullw = numw * ow + numw - 1\n    gi = canvas(linc, (fullh, fullw))\n    sgi = asindices(canvas(bgc, (oh, ow)))\n    for a in range(numh):\n        for b in range(numw):\n            gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))\n    go = tuple(e for e in gi)\n    sinds = asindices(canvas(-1, (oh, ow)))\n    for col in ccols:\n        inds = occurrences(go, recolor(bgc, sinds))\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        narms = randint(1, 4)\n        armdirs = sample(totuple(dneighbors((0, 0))), narms)\n        succ = 0\n        for armdir in armdirs:\n            x, y = armdir\n            arm = []\n            for k in range(1, max(numh, numw)):\n                nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))\n                if nextloc not in inds:\n                    break\n                arm.append(nextloc)\n            if len(arm) < 2:\n                continue\n            aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))\n            endp = arm[aidx]\n            gi = fill(gi, col, shift(sinds, endp))\n            go = fill(go, col, mapply(lbind(shift, sinds), set(arm[:aidx+1])))\n            succ += 1\n        gi = fill(gi, col, shift(sinds, loc))\n        go = fill(go, col, shift(sinds, loc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_06df4c85(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of each object based on difficulty\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    # Randomly determine the width of each object based on difficulty\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # Determine the number of objects vertically, ensuring they fit in the grid\n    numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))\n    # Determine the number of objects horizontally, ensuring they fit in the grid\n    numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))\n    \n    # Randomly select two colors: one for background and one for grid lines\n    bgc, linc = sample(cols, 2)\n    # Remove the selected colors from the available colors\n    remcols = difference(cols, (bgc, linc))\n    \n    # Determine the number of colors to be used for objects\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))\n    # Randomly select colors for objects\n    ccols = sample(remcols, ncols)\n    \n    # Calculate the full height of the grid including spacing\n    fullh = numh * oh + numh - 1\n    # Calculate the full width of the grid including spacing\n    fullw = numw * ow + numw - 1\n    \n    # Create the initial input grid with grid lines\n    gi = canvas(linc, (fullh, fullw))\n    # Create a small grid representing a single object\n    sgi = asindices(canvas(bgc, (oh, ow)))\n    \n    # Fill the input grid with background-colored objects\n    for a in range(numh):\n        for b in range(numw):\n            gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))\n    \n    # Create the output grid, initially identical to the input grid\n    go = tuple(e for e in gi)\n    \n    # Create indices for a single object\n    sinds = asindices(canvas(-1, (oh, ow)))\n    \n    # For each color, create \"arms\" extending from random objects\n    for col in ccols:\n        # Find all possible locations for objects\n        inds = occurrences(go, recolor(bgc, sinds))\n        if len(inds) == 0:\n            break\n        # Choose a random location for the current color\n        loc = choice(totuple(inds))\n        # Determine the number of arms (1 to 4)\n        narms = randint(1, 4)\n        # Choose random directions for the arms\n        armdirs = sample(totuple(dneighbors((0, 0))), narms)\n        succ = 0\n        for armdir in armdirs:\n            x, y = armdir\n            arm = []\n            # Extend the arm as far as possible\n            for k in range(1, max(numh, numw)):\n                nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))\n                if nextloc not in inds:\n                    break\n                arm.append(nextloc)\n            if len(arm) < 2:\n                continue\n            # Choose a random endpoint for the arm\n            aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))\n            endp = arm[aidx]\n            # Color the endpoint in the input grid\n            gi = fill(gi, col, shift(sinds, endp))\n            # Color the entire arm in the output grid\n            go = fill(go, col, mapply(lbind(shift, sinds), set(arm[:aidx+1])))\n            succ += 1\n        # Color the starting point in both input and output grids\n        gi = fill(gi, col, shift(sinds, loc))\n        go = fill(go, col, shift(sinds, loc))\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "08ed6ac7": {
    "original": "def generate_08ed6ac7(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc = choice(difference(colopts, (1, 2, 3, 4)))\n    remcols = remove(bgc, colopts)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    barrange = (4, w)\n    locopts = interval(0, w, 1)\n    nbars = unifint(diff_lb, diff_ub, barrange)\n    barlocs = sample(locopts, nbars)\n    barhopts = interval(0, h, 1)\n    barhs = sample(barhopts, 4)\n    barcols = [choice(remcols) for j in range(nbars)]\n    barhsfx = [choice(barhs) for j in range(nbars - 4)] + list(barhs)\n    shuffle(barhsfx)\n    ordered = sorted(barhs)\n    colord = interval(1, 5, 1)\n    for col, (loci, locj) in zip(barcols, list(zip(barhsfx, barlocs))):\n        bar = connect((loci, locj), (h - 1, locj))\n        gi = fill(gi, col, bar)\n        go = fill(go, colord[ordered.index(loci)], bar)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_08ed6ac7(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly select height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Choose background color, excluding colors 1, 2, 3, and 4\n    bgc = choice(difference(colopts, (1, 2, 3, 4)))\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, colopts)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Define range for number of bars (4 to width of grid)\n    barrange = (4, w)\n    \n    # Create list of possible bar locations (0 to width-1)\n    locopts = interval(0, w, 1)\n    \n    # Randomly select number of bars based on difficulty\n    nbars = unifint(diff_lb, diff_ub, barrange)\n    \n    # Randomly select locations for bars\n    barlocs = sample(locopts, nbars)\n    \n    # Create list of possible bar heights (0 to height-1)\n    barhopts = interval(0, h, 1)\n    \n    # Randomly select 4 unique bar heights\n    barhs = sample(barhopts, 4)\n    \n    # Randomly select colors for each bar\n    barcols = [choice(remcols) for j in range(nbars)]\n    \n    # Create list of bar heights, ensuring the 4 unique heights are included\n    barhsfx = [choice(barhs) for j in range(nbars - 4)] + list(barhs)\n    # Shuffle the bar heights\n    shuffle(barhsfx)\n    \n    # Sort the unique bar heights\n    ordered = sorted(barhs)\n    \n    # Create a list of colors 1 to 4 for output\n    colord = interval(1, 5, 1)\n    \n    # Iterate over bar colors, heights, and locations\n    for col, (loci, locj) in zip(barcols, list(zip(barhsfx, barlocs))):\n        # Create a vertical bar from top to bottom of grid\n        bar = connect((loci, locj), (h - 1, locj))\n        \n        # Fill the bar with its color in the input grid\n        gi = fill(gi, col, bar)\n        \n        # Fill the bar in the output grid with a color based on its height rank\n        go = fill(go, colord[ordered.index(loci)], bar)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "09629e4f": {
    "original": "def generate_09629e4f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nrows, ncolumns = h, w\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    ncols = unifint(diff_lb, diff_ub, (2, min(7, (h * w) - 2)))\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    fullh, fullw = h * nrows + nrows - 1, w * ncolumns + ncolumns - 1\n    gi = canvas(barcol, (fullh, fullw))\n    locs = totuple(product(interval(0, fullh, h + 1), interval(0, fullw, w + 1)))\n    trgloc = choice(locs)\n    remlocs = remove(trgloc, locs)\n    colssf = sample(remcols, ncols)\n    colsss = remove(choice(colssf), colssf)\n    trgssf = sample(inds, ncols - 1)\n    gi = fill(gi, bgc, shift(inds, trgloc))\n    for ij, cl in zip(trgssf, colsss):\n        gi = fill(gi, cl, {add(trgloc, ij)})\n    for rl in remlocs:\n        trgss = sample(inds, ncols)\n        tmpg = tuple(e for e in c)\n        for ij, cl in zip(trgss, colssf):\n            tmpg = fill(tmpg, cl, {ij})\n        gi = paint(gi, shift(asobject(tmpg), rl))\n    go = canvas(bgc, (fullh, fullw))\n    go = fill(go, barcol, ofcolor(gi, barcol))\n    for ij, cl in zip(trgssf, colsss):\n        go = fill(go, cl, shift(inds, multiply(ij, (h+1, w+1))))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_09629e4f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly select height between 2 and 5 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly select width between 2 and 5 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Assign height and width to nrows and ncolumns\n    nrows, ncolumns = h, w\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the bars (grid lines) from the remaining colors\n    barcol = choice(remcols)\n    \n    # Remove the bar color from the remaining colors\n    remcols = remove(barcol, remcols)\n    \n    # Choose number of colors to use, between 2 and min(7, (h*w)-2)\n    ncols = unifint(diff_lb, diff_ub, (2, min(7, (h * w) - 2)))\n    \n    # Create a canvas (grid) with the background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Calculate full height and width of the final grid, including separating bars\n    fullh, fullw = h * nrows + nrows - 1, w * ncolumns + ncolumns - 1\n    \n    # Create the input grid with bar color\n    gi = canvas(barcol, (fullh, fullw))\n    \n    # Generate locations for subgrids\n    locs = totuple(product(interval(0, fullh, h + 1), interval(0, fullw, w + 1)))\n    \n    # Choose a random location for the target subgrid\n    trgloc = choice(locs)\n    \n    # Remove the chosen location from available locations\n    remlocs = remove(trgloc, locs)\n    \n    # Randomly sample colors for subgrids\n    colssf = sample(remcols, ncols)\n    \n    # Remove one random color from colssf to create colsss\n    colsss = remove(choice(colssf), colssf)\n    \n    # Sample indices for the target subgrid\n    trgssf = sample(inds, ncols - 1)\n    \n    # Fill the target location in the input grid with background color\n    gi = fill(gi, bgc, shift(inds, trgloc))\n    \n    # Fill the target subgrid with chosen colors\n    for ij, cl in zip(trgssf, colsss):\n        gi = fill(gi, cl, {add(trgloc, ij)})\n    \n    # Fill the remaining subgrids\n    for rl in remlocs:\n        # Sample indices for current subgrid\n        trgss = sample(inds, ncols)\n        # Create a temporary grid\n        tmpg = tuple(e for e in c)\n        # Fill the temporary grid with chosen colors\n        for ij, cl in zip(trgss, colssf):\n            tmpg = fill(tmpg, cl, {ij})\n        # Paint the temporary grid onto the input grid at the current location\n        gi = paint(gi, shift(asobject(tmpg), rl))\n    \n    # Create the output grid with background color\n    go = canvas(bgc, (fullh, fullw))\n    \n    # Fill the output grid with bar color where input grid has bar color\n    go = fill(go, barcol, ofcolor(gi, barcol))\n    \n    # Fill the output grid with the target subgrid colors, but enlarged\n    for ij, cl in zip(trgssf, colsss):\n        go = fill(go, cl, shift(inds, multiply(ij, (h+1, w+1))))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "0962bcdd": {
    "original": "def generate_0962bcdd(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3, 4))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (2, 7))\n    ccols = sample(remcols, numc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    oh, ow = 5, 5\n    subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + 4, locj + 4)})\n        bd = backdrop(obj)\n        col = choice(ccols)\n        if bd.issubset(indss):\n            ca, cb = sample(ccols, 2)\n            cp = (loci + 2, locj + 2)\n            lins1 = connect((loci, locj), (loci + 4, locj + 4))\n            lins2 = connect((loci + 4, locj), (loci, locj + 4))\n            lins12 = lins1 | lins2\n            lins3 = connect((loci + 2, locj), (loci + 2, locj + 4))\n            lins4 = connect((loci, locj + 2), (loci + 4, locj + 2))\n            lins34 = lins3 | lins4\n            go = fill(go, cb, lins34)\n            go = fill(go, ca, lins12)\n            gi = fill(gi, ca, {cp})\n            gi = fill(gi, cb, dneighbors(cp))\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0962bcdd(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of color indices 0-9, excluding 3 and 4\n    cols = difference(interval(0, 10, 1), (3, 4))    \n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (between 2 and 7)\n    numc = unifint(diff_lb, diff_ub, (2, 7))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine the number of objects to place (between 1 and h*w/25)\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set the maximum number of attempts to place objects\n    maxtrials = 4 * num\n    \n    # Initialize counters for trials and successful placements\n    tr = 0\n    succ = 0\n    \n    # Set the size of the objects to be placed (5x5)\n    oh, ow = 5, 5\n    \n    # Filter valid starting positions for object placement\n    subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n    \n    # Main loop for placing objects\n    while succ < num and tr <= maxtrials:\n        # Break if no more valid indices are available\n        if len(indss) == 0:\n            break\n        \n        # Skip this iteration if no valid starting positions are left\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position for the object\n        loci, locj = choice(subs)\n        \n        # Define the object as two opposite corners of a 5x5 square\n        obj = frozenset({(loci, locj), (loci + 4, locj + 4)})\n        \n        # Get all cells within the object's bounding box\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(ccols)\n        \n        # Check if the object can be placed without overlapping\n        if bd.issubset(indss):\n            # Choose two random colors for the object's components\n            ca, cb = sample(ccols, 2)\n            \n            # Define the center point of the object\n            cp = (loci + 2, locj + 2)\n            \n            # Create diagonal lines for the object\n            lins1 = connect((loci, locj), (loci + 4, locj + 4))\n            lins2 = connect((loci + 4, locj), (loci, locj + 4))\n            lins12 = lins1 | lins2\n            \n            # Create horizontal and vertical lines for the object\n            lins3 = connect((loci + 2, locj), (loci + 2, locj + 4))\n            lins4 = connect((loci, locj + 2), (loci + 4, locj + 2))\n            lins34 = lins3 | lins4\n            \n            # Fill the output grid with the object's pattern\n            go = fill(go, cb, lins34)\n            go = fill(go, ca, lins12)\n            \n            # Fill the input grid with a simplified version of the object\n            gi = fill(gi, ca, {cp})\n            gi = fill(gi, cb, dneighbors(cp))\n            \n            # Increment the success counter\n            succ += 1\n            \n            # Remove the used indices from the available set\n            indss = indss - bd\n        \n        # Increment the trial counter\n        tr += 1\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "0a938d79": {
    "original": "def generate_0a938d79(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 29))\n    w = unifint(diff_lb, diff_ub, (h+1, 30))\n    bgc, cola, colb = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    locja = unifint(diff_lb, diff_ub, (3, w - 2))\n    locjb = unifint(diff_lb, diff_ub, (1, locja - 2))\n    locia = choice((0, h-1))\n    locib = choice((0, h-1))\n    gi = fill(gi, cola, {(locia, locja)})\n    gi = fill(gi, colb, {(locib, locjb)})\n    ofs = -2 * (locja-locjb)\n    for aa in range(locja, -1, ofs):\n        go = fill(go, cola, connect((0, aa), (h-1, aa)))\n    for bb in range(locjb, -1, ofs):    \n        go = fill(go, colb, connect((0, bb), (h-1, bb)))\n    rotf = choice((rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0a938d79(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 4 and 29\n    h = unifint(diff_lb, diff_ub, (4, 29))\n    \n    # Randomly determine the width of the grid, ensuring it's larger than the height\n    w = unifint(diff_lb, diff_ub, (h+1, 30))\n    \n    # Randomly select three distinct colors: background, color A, and color B\n    bgc, cola, colb = sample(cols, 3)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly choose the column for color A, ensuring it's not too close to the right edge\n    locja = unifint(diff_lb, diff_ub, (3, w - 2))\n    \n    # Randomly choose the column for color B, ensuring it's to the left of color A\n    locjb = unifint(diff_lb, diff_ub, (1, locja - 2))\n    \n    # Randomly choose whether color A is in the top or bottom row\n    locia = choice((0, h-1))\n    \n    # Randomly choose whether color B is in the top or bottom row\n    locib = choice((0, h-1))\n    \n    # Place a single cell of color A in the input grid\n    gi = fill(gi, cola, {(locia, locja)})\n    \n    # Place a single cell of color B in the input grid\n    gi = fill(gi, colb, {(locib, locjb)})\n    \n    # Calculate the offset for creating stripes (negative to move leftwards)\n    ofs = -2 * (locja-locjb)\n    \n    # Create vertical stripes of color A in the output grid\n    for aa in range(locja, -1, ofs):\n        go = fill(go, cola, connect((0, aa), (h-1, aa)))\n    \n    # Create vertical stripes of color B in the output grid\n    for bb in range(locjb, -1, ofs):    \n        go = fill(go, colb, connect((0, bb), (h-1, bb)))\n    \n    # Randomly choose between 180 and 270 degree rotation\n    rotf = choice((rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "0b148d64": {
    "original": "def generate_0b148d64(diff_lb: float, diff_ub: float) -> dict:\n    itv = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    bgc = choice(itv)\n    remitv = remove(bgc, itv)\n    g = canvas(bgc, (h, w))\n    x = randint(3, h - 3)\n    y = randint(3, w - 3)\n    di = randint(2, h - x - 1)\n    dj = randint(2, w - y - 1)\n    A = backdrop(frozenset({(0, 0), (x, y)}))\n    B = backdrop(frozenset({(x + di, 0), (h - 1, y)}))\n    C = backdrop(frozenset({(0, y + dj), (x, w - 1)}))\n    D = backdrop(frozenset({(x + di, y + dj), (h - 1, w - 1)}))\n    cola = choice(remitv)\n    colb = choice(remove(cola, remitv))\n    trg = choice((A, B, C, D))\n    rem = remove(trg, (A, B, C, D))\n    def subf(bx):\n        return {\n            choice(totuple(connect(ulcorner(bx), urcorner(bx)))),\n            choice(totuple(connect(ulcorner(bx), llcorner(bx)))),\n            choice(totuple(connect(urcorner(bx), lrcorner(bx)))),\n            choice(totuple(connect(llcorner(bx), lrcorner(bx)))),\n        }\n    def sampler(bx):\n        return set(sample(\n            totuple(bx),\n            len(bx) - unifint(diff_lb, diff_ub, (0, len(bx) - 1))\n        ))\n    gi = fill(g, cola, sampler(trg) | subf(trg))\n    for r in rem:\n        gi = fill(gi, colb, sampler(r) | subf(r))\n    go = subgrid(frozenset(trg), gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0b148d64(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    itv = interval(0, 10, 1)\n    \n    # Generate a random height between 7 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Generate a random width between 7 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Choose a random background color from the interval\n    bgc = choice(itv)\n    \n    # Create a new interval without the background color\n    remitv = remove(bgc, itv)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    g = canvas(bgc, (h, w))\n    \n    # Choose a random x-coordinate between 3 and h-3\n    x = randint(3, h - 3)\n    \n    # Choose a random y-coordinate between 3 and w-3\n    y = randint(3, w - 3)\n    \n    # Calculate a random vertical offset\n    di = randint(2, h - x - 1)\n    \n    # Calculate a random horizontal offset\n    dj = randint(2, w - y - 1)\n    \n    # Define the top-left quadrant of the grid\n    A = backdrop(frozenset({(0, 0), (x, y)}))\n    \n    # Define the bottom-left quadrant of the grid\n    B = backdrop(frozenset({(x + di, 0), (h - 1, y)}))\n    \n    # Define the top-right quadrant of the grid\n    C = backdrop(frozenset({(0, y + dj), (x, w - 1)}))\n    \n    # Define the bottom-right quadrant of the grid\n    D = backdrop(frozenset({(x + di, y + dj), (h - 1, w - 1)}))\n    \n    # Choose a random color for the target quadrant\n    cola = choice(remitv)\n    \n    # Choose a different random color for the other quadrants\n    colb = choice(remove(cola, remitv))\n    \n    # Randomly select one of the quadrants as the target\n    trg = choice((A, B, C, D))\n    \n    # Create a tuple of the remaining (non-target) quadrants\n    rem = remove(trg, (A, B, C, D))\n    \n    # Define a function to create a subset of the border of a quadrant\n    def subf(bx):\n        return {\n            # Choose a random point on the top border\n            choice(totuple(connect(ulcorner(bx), urcorner(bx)))),\n            # Choose a random point on the left border\n            choice(totuple(connect(ulcorner(bx), llcorner(bx)))),\n            # Choose a random point on the right border\n            choice(totuple(connect(urcorner(bx), lrcorner(bx)))),\n            # Choose a random point on the bottom border\n            choice(totuple(connect(llcorner(bx), lrcorner(bx)))),\n        }\n    \n    # Define a function to randomly sample points from a quadrant\n    def sampler(bx):\n        return set(sample(\n            totuple(bx),\n            # Number of points to sample, based on difficulty\n            len(bx) - unifint(diff_lb, diff_ub, (0, len(bx) - 1))\n        ))\n    \n    # Fill the target quadrant with cola color, including border points\n    gi = fill(g, cola, sampler(trg) | subf(trg))\n    \n    # Fill the remaining quadrants with colb color, including border points\n    for r in rem:\n        gi = fill(gi, colb, sampler(r) | subf(r))\n    \n    # Extract the subgrid corresponding to the target quadrant\n    go = subgrid(frozenset(trg), gi)\n    \n    # Return a dictionary with the input grid and the output (target quadrant)\n    return {'input': gi, 'output': go}\n"
  },
  "0ca9ddb6": {
    "original": "def generate_0ca9ddb6(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 4, 6, 7, 8))\n    xi = {(8, (0, 0))}\n    xo = {(8, (0, 0))}\n    ai = {(6, (0, 0))}\n    ao = {(6, (0, 0))}\n    bi = {(2, (1, 1))}\n    bo = {(2, (1, 1))} | recolor(4, ineighbors((1, 1)))\n    ci = {(1, (1, 1))}\n    co = {(1, (1, 1))} | recolor(7, dneighbors((1, 1)))\n    arr = ((ai, ao), (bi, bo), (ci, co), (xi, xo))    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 4))\n    maxtr = 5 * nobjs\n    tr = 0\n    succ = 0\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        ino, outo = choice(arr)\n        loc = choice(totuple(inds))\n        oplcd = shift(outo, loc)\n        oplcdi = toindices(oplcd)\n        if oplcdi.issubset(inds):\n            succ += 1\n            gi = paint(gi, shift(ino, loc))\n            go = paint(go, oplcd)\n            inds = inds - oplcdi\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0ca9ddb6(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors, excluding 1, 2, 4, 6, 7, 8\n    cols = difference(interval(0, 10, 1), (1, 2, 4, 6, 7, 8))\n    \n    # Define input and output for 'x' object (single pixel, color 8)\n    xi = {(8, (0, 0))}\n    xo = {(8, (0, 0))}\n    \n    # Define input and output for 'a' object (single pixel, color 6)\n    ai = {(6, (0, 0))}\n    ao = {(6, (0, 0))}\n    \n    # Define input for 'b' object (single pixel, color 2)\n    bi = {(2, (1, 1))}\n    # Define output for 'b' object (center pixel 2, surrounded by color 4 diagonally)\n    bo = {(2, (1, 1))} | recolor(4, ineighbors((1, 1)))\n    \n    # Define input for 'c' object (single pixel, color 1)\n    ci = {(1, (1, 1))}\n    # Define output for 'c' object (center pixel 1, surrounded by color 7 orthogonally)\n    co = {(1, (1, 1))} | recolor(7, dneighbors((1, 1)))\n    \n    # Create an array of all object types\n    arr = ((ai, ao), (bi, bo), (ci, co), (xi, xo))    \n    \n    # Randomly determine height of the grid (between 4 and 30)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Randomly determine width of the grid (between 4 and 30)\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine number of objects to place (between 1 and 1/4 of grid area)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 4))\n    \n    # Set maximum number of placement attempts\n    maxtr = 5 * nobjs\n    # Initialize counters for attempts and successful placements\n    tr = 0\n    succ = 0\n    \n    # Randomly choose background color\n    bgc = choice(cols)\n    \n    # Create input grid with chosen background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid with chosen background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        # Randomly choose an object type\n        ino, outo = choice(arr)\n        # Randomly choose a location on the grid\n        loc = choice(totuple(inds))\n        # Shift the output object to the chosen location\n        oplcd = shift(outo, loc)\n        # Get indices of the shifted output object\n        oplcdi = toindices(oplcd)\n        \n        # Check if the object fits within the grid\n        if oplcdi.issubset(inds):\n            # Increment successful placement counter\n            succ += 1\n            # Paint the input object on the input grid\n            gi = paint(gi, shift(ino, loc))\n            # Paint the output object on the output grid\n            go = paint(go, oplcd)\n            # Remove the used indices from available indices\n            inds = inds - oplcdi\n        \n        # Increment attempt counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "0d3d703e": {
    "original": "def generate_0d3d703e(diff_lb: float, diff_ub: float) -> dict:\n    incols = (1, 2, 3, 4, 5, 6, 8, 9)\n    outcols = (5, 6, 4, 3, 1, 2, 9, 8)\n    k = len(incols)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    gi = canvas(-1, (h, w))\n    go = canvas(-1, (h, w))\n    inds = asindices(gi)\n    numc = unifint(diff_lb, diff_ub, (1, k))\n    idxes = sample(interval(0, k, 1), numc)\n    for ij in inds:\n        idx = choice(idxes)\n        gi = fill(gi, incols[idx], {ij})\n        go = fill(go, outcols[idx], {ij})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0d3d703e(diff_lb: float, diff_ub: float) -> dict:\n    # Define input and output color mappings\n    incols = (1, 2, 3, 4, 5, 6, 8, 9)  # Input colors\n    outcols = (5, 6, 4, 3, 1, 2, 9, 8)  # Corresponding output colors\n    k = len(incols)  # Number of color pairs\n\n    # Generate random height and width based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))  # Random height between 4 and 30\n    w = unifint(diff_lb, diff_ub, (4, 30))  # Random width between 4 and 30\n\n    # Create empty input and output grids filled with -1\n    gi = canvas(-1, (h, w))  # Initialize input grid\n    go = canvas(-1, (h, w))  # Initialize output grid\n\n    # Get all indices of the grid\n    inds = asindices(gi)  # All possible (row, column) coordinates\n\n    # Determine number of colors to use and select them\n    numc = unifint(diff_lb, diff_ub, (1, k))  # Random number of colors to use\n    idxes = sample(interval(0, k, 1), numc)  # Randomly select color indices\n\n    # Fill each cell of the grid with a randomly chosen color\n    for ij in inds:\n        # Choose a random color index from the selected ones\n        idx = choice(idxes)\n        # Fill the cell in the input grid with the chosen input color\n        gi = fill(gi, incols[idx], {ij})\n        # Fill the corresponding cell in the output grid with the mapped output color\n        go = fill(go, outcols[idx], {ij})\n\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "0dfd9992": {
    "original": "def generate_0dfd9992(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    pinds = asindices(canvas(-1, (hp, wp)))\n    bgc, noisec = sample(cols, 2)\n    remcols = remove(noisec, cols)\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, numc)\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    go = canvas(bgc, (h, w))\n    locs = set()\n    for a in range(h//hp+1):\n        for b in range(w//wp+1):\n            loci = hp * a\n            locj = wp * b\n            locs.add((loci, locj))\n            mf1 = identity if a % 2 == 0 else hmirror\n            mf2 = identity if b % 2 == 0 else vmirror\n            mf = compose(mf1, mf2)\n            go = paint(go, shift(mf(pobj), (loci, locj)))\n    numpatches = unifint(diff_lb, diff_ub, (1, int((h * w) ** 0.5 // 2)))\n    gi = tuple(e for e in go)\n    places = apply(lbind(shift, pinds), locs)\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        gi2 = fill(gi, noisec, ptch)\n        candset = apply(normalize, apply(rbind(toobject, gi2), places))\n        if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2 and (pobj in candset or hmirror(pobj) in candset or vmirror(pobj) in candset or hmirror(vmirror(pobj)) in candset):\n            succ += 1\n            gi = gi2\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0dfd9992(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the height of the pattern, between 2 and half the grid height\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    \n    # Randomly determine the width of the pattern, between 2 and half the grid width\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    \n    # Create a set of indices for the pattern\n    pinds = asindices(canvas(-1, (hp, wp)))\n    \n    # Randomly choose two colors: one for background and one for noise\n    bgc, noisec = sample(cols, 2)\n    \n    # Remove the noise color from the list of available colors\n    remcols = remove(noisec, cols)\n    \n    # Randomly choose the number of colors to use in the pattern (between 2 and 9)\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly select colors for the pattern\n    ccols = sample(remcols, numc)\n    \n    # Create the pattern object by randomly assigning colors to the pattern indices\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    \n    # Create the initial grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Initialize a set to store the locations where patterns will be placed\n    locs = set()\n    \n    # Iterate over the grid, placing patterns\n    for a in range(h//hp+1):\n        for b in range(w//wp+1):\n            # Calculate the location for this pattern\n            loci = hp * a\n            locj = wp * b\n            \n            # Add this location to the set of pattern locations\n            locs.add((loci, locj))\n            \n            # Determine if the pattern should be mirrored horizontally\n            mf1 = identity if a % 2 == 0 else hmirror\n            \n            # Determine if the pattern should be mirrored vertically\n            mf2 = identity if b % 2 == 0 else vmirror\n            \n            # Combine the mirroring functions\n            mf = compose(mf1, mf2)\n            \n            # Apply the pattern to the grid at this location, with appropriate mirroring\n            go = paint(go, shift(mf(pobj), (loci, locj)))\n    \n    # Determine the number of noise patches to add\n    numpatches = unifint(diff_lb, diff_ub, (1, int((h * w) ** 0.5 // 2)))\n    \n    # Convert the grid to a tuple for easier manipulation\n    gi = tuple(e for e in go)\n    \n    # Create a list of all possible pattern locations\n    places = apply(lbind(shift, pinds), locs)\n    \n    # Initialize counters for successful noise patches and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    \n    # Add noise patches to the grid\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        \n        # Randomly determine the size of this noise patch\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        \n        # Randomly determine the location of this noise patch\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        \n        # Create the noise patch\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        \n        # Apply the noise patch to a copy of the grid\n        gi2 = fill(gi, noisec, ptch)\n        \n        # Check if the original pattern can still be found in the grid with the noise patch\n        candset = apply(normalize, apply(rbind(toobject, gi2), places))\n        \n        # If the noise patch doesn't completely obscure the pattern, accept it\n        if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2 and (pobj in candset or hmirror(pobj) in candset or vmirror(pobj) in candset or hmirror(vmirror(pobj)) in candset):\n            succ += 1\n            gi = gi2\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the rotation to both the input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input (with noise) and output (without noise) grids\n    return {'input': gi, 'output': go}\n"
  },
  "0e206a2e": {
    "original": "def generate_0e206a2e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, acol, bcol, ccol, Dcol = sample(cols, 5)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    nsrcs = unifint(diff_lb, diff_ub, (1, min(h, w) // 5))\n    srcs = []\n    abclist = []\n    maxtrforsrc = 5 * nsrcs\n    trforsrc = 0\n    srcsucc = 0\n    while trforsrc < maxtrforsrc and srcsucc < nsrcs:\n        trforsrc += 1\n        objsize = unifint(diff_lb, diff_ub, (5, 20))\n        bb = asindices(canvas(-1, (7, 7)))\n        sp = choice(totuple(bb))\n        bb = remove(sp, bb)\n        shp = {sp}\n        for k in range(objsize - 1):\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        while 1 in shape(shp):\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        while len(set([x - y for x, y in shp])) == 1 or len(set([x + y for x, y in shp])) == 1:\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        shp = normalize(shp)\n        shp = list(shp)\n        shuffle(shp)\n        a, b, c = shp[:3]\n        while 1 in shape({a, b, c}) or (len(set([x - y for x, y in {a, b, c}])) == 1 or len(set([x + y for x, y in {a, b, c}])) == 1):\n            shuffle(shp)\n            a, b, c = shp[:3]\n        if sorted(shape({a, b, c})) in abclist:\n            continue\n        D = shp[3:]\n        markers = {(acol, a), (bcol, b), (ccol, c)}\n        obj = markers | {(Dcol, ij) for ij in D}\n        obj = frozenset(obj)\n        oh, ow = shape(obj)\n        opts = sfilter(inds, lambda ij: shift(set(shp), ij).issubset(inds))\n        if len(opts) == 0:\n            continue\n        loc = choice(totuple(opts))\n        srcsucc += 1\n        gi = paint(gi, shift(obj, loc))\n        shpplcd = shift(set(shp), loc)\n        go = fill(go, -1, shpplcd)\n        inds = (inds - shpplcd) - mapply(neighbors, shpplcd)\n        srcs.append((obj, markers))\n        abclist.append(sorted(shape({a, b, c})))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    maxtrials = 10 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr < maxtrials:\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n        fn = choice(mfs)\n        gi = fn(gi)\n        go = fn(go)\n        aigo = asindices(go)\n        fullinds = ofcolor(go, bgc) - mapply(neighbors, aigo - ofcolor(go, bgc))\n        obj, markers = choice(srcs)\n        shp = toindices(obj)\n        if len(fullinds) == 0:\n            break\n        loctr = choice(totuple(fullinds))\n        xx = shift(shp, loctr)\n        if xx.issubset(fullinds):\n            succ += 1\n            gi = paint(gi, shift(markers, loctr))\n            go = paint(go, shift(obj, loctr))\n        tr += 1\n    go = replace(go, -1, bgc)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_0e206a2e(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly generate width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select 5 unique colors from the color range\n    bgc, acol, bcol, ccol, Dcol = sample(cols, 5)\n    \n    # Create an input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Randomly determine number of source objects (1 to 1/5 of min(height, width))\n    nsrcs = unifint(diff_lb, diff_ub, (1, min(h, w) // 5))\n    \n    # Initialize lists and variables for source object generation\n    srcs = []\n    abclist = []\n    maxtrforsrc = 5 * nsrcs\n    trforsrc = 0\n    srcsucc = 0\n    \n    # Loop to generate source objects\n    while trforsrc < maxtrforsrc and srcsucc < nsrcs:\n        trforsrc += 1\n        # Randomly determine object size (5 to 20 cells)\n        objsize = unifint(diff_lb, diff_ub, (5, 20))\n        \n        # Create a 7x7 bounding box for object generation\n        bb = asindices(canvas(-1, (7, 7)))\n        # Choose a random starting point in the bounding box\n        sp = choice(totuple(bb))\n        # Remove the starting point from available cells\n        bb = remove(sp, bb)\n        # Initialize the shape with the starting point\n        shp = {sp}\n        \n        # Grow the shape to the desired size\n        for k in range(objsize - 1):\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        \n        # Ensure the shape is not a single row or column\n        while 1 in shape(shp):\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        \n        # Ensure the shape is not diagonal\n        while len(set([x - y for x, y in shp])) == 1 or len(set([x + y for x, y in shp])) == 1:\n            shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))\n        \n        # Normalize the shape to start at (0,0)\n        shp = normalize(shp)\n        # Convert shape to list and shuffle\n        shp = list(shp)\n        shuffle(shp)\n        \n        # Select first three points for A, B, C markers\n        a, b, c = shp[:3]\n        \n        # Ensure A, B, C are not in a line or diagonal\n        while 1 in shape({a, b, c}) or (len(set([x - y for x, y in {a, b, c}])) == 1 or len(set([x + y for x, y in {a, b, c}])) == 1):\n            shuffle(shp)\n            a, b, c = shp[:3]\n        \n        # Check if this ABC configuration has been used before\n        if sorted(shape({a, b, c})) in abclist:\n            continue\n        \n        # Remaining points become D\n        D = shp[3:]\n        \n        # Create colored markers for A, B, C\n        markers = {(acol, a), (bcol, b), (ccol, c)}\n        # Create full object including D points\n        obj = markers | {(Dcol, ij) for ij in D}\n        obj = frozenset(obj)\n        \n        # Get object dimensions\n        oh, ow = shape(obj)\n        \n        # Find valid positions to place the object\n        opts = sfilter(inds, lambda ij: shift(set(shp), ij).issubset(inds))\n        if len(opts) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(opts))\n        srcsucc += 1\n        \n        # Place the object on the input grid\n        gi = paint(gi, shift(obj, loc))\n        \n        # Mark the object's position on the output grid\n        shpplcd = shift(set(shp), loc)\n        go = fill(go, -1, shpplcd)\n        \n        # Remove used indices and their neighbors\n        inds = (inds - shpplcd) - mapply(neighbors, shpplcd)\n        \n        # Store the source object and its markers\n        srcs.append((obj, markers))\n        abclist.append(sorted(shape({a, b, c})))\n    \n    # Randomly determine number of additional objects to place\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    maxtrials = 10 * num\n    tr = 0\n    succ = 0\n    \n    # Loop to place additional objects\n    while succ < num and tr < maxtrials:\n        # List of possible transformations\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n        # Choose a random transformation\n        fn = choice(mfs)\n        \n        # Apply transformation to input and output grids\n        gi = fn(gi)\n        go = fn(go)\n        \n        # Get indices of output grid\n        aigo = asindices(go)\n        # Find valid placement locations\n        fullinds = ofcolor(go, bgc) - mapply(neighbors, aigo - ofcolor(go, bgc))\n        \n        # Choose a random source object\n        obj, markers = choice(srcs)\n        shp = toindices(obj)\n        \n        # Break if no valid placement locations\n        if len(fullinds) == 0:\n            break\n        \n        # Choose a random location to try placing the object\n        loctr = choice(totuple(fullinds))\n        xx = shift(shp, loctr)\n        \n        # If placement is valid, add object to grids\n        if xx.issubset(fullinds):\n            succ += 1\n            gi = paint(gi, shift(markers, loctr))\n            go = paint(go, shift(obj, loctr))\n        tr += 1\n    \n    # Replace temporary marker in output grid with background color\n    go = replace(go, -1, bgc)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "10fcaaa3": {
    "original": "def generate_10fcaaa3(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 6)))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, ncols)\n    c = canvas(bgc, (h, w))\n    inds = asindices(c)\n    locs = frozenset(sample(totuple(inds), ncells))\n    obj = frozenset({(choice(ccols), ij) for ij in locs})\n    gi = paint(c, obj)\n    go = hconcat(gi, gi)\n    go = vconcat(go, go)\n    fullocs = locs | shift(locs, (0, w)) | shift(locs, (h, 0)) | shift(locs, (h, w))\n    nbhs = mapply(ineighbors, fullocs)\n    topaint = nbhs & ofcolor(go, bgc)\n    go = fill(go, 8, topaint)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_10fcaaa3(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 8 from the range of colors 0-9\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 15 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Generate a random width between 2 and 15 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Calculate number of cells to color, between 1 and 1/6th of total cells\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 6)))\n    \n    # Choose number of colors to use, between 1 and 8\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select colors to use for the objects\n    ccols = sample(remcols, ncols)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the canvas\n    inds = asindices(c)\n    \n    # Randomly select locations for colored cells\n    locs = frozenset(sample(totuple(inds), ncells))\n    \n    # Create an object by assigning random colors to the selected locations\n    obj = frozenset({(choice(ccols), ij) for ij in locs})\n    \n    # Paint the object onto the canvas to create the input grid\n    gi = paint(c, obj)\n    \n    # Create the output grid by concatenating the input horizontally and vertically\n    # This effectively creates a 2x2 tiled version of the input\n    go = hconcat(gi, gi)\n    go = vconcat(go, go)\n    \n    # Calculate all object locations in the 2x2 tiled output\n    fullocs = locs | shift(locs, (0, w)) | shift(locs, (h, 0)) | shift(locs, (h, w))\n    \n    # Get the diagonal neighbors of all object locations\n    nbhs = mapply(ineighbors, fullocs)\n    \n    # Find the background-colored cells among these neighbors\n    topaint = nbhs & ofcolor(go, bgc)\n    \n    # Fill these cells with color 8 to create the final output\n    go = fill(go, 8, topaint)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "11852cab": {
    "original": "def generate_11852cab(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    r1 = ((0, 0), (0, 4), (4, 0), (4, 4))\n    r2 = ((2, 0), (0, 2), (4, 2), (2, 4))\n    r3 = ((1, 1), (3, 1), (1, 3), (3, 3))\n    r4 = ((2, 2),)\n    rings = [r4, r3, r2, r1]\n    bx = backdrop(frozenset(r1))\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = shift(asindices(trim(gi)), UNITY)\n    nobjs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 36)))\n    succ = 0\n    tr = 0\n    maxtr = 10 * nobjs\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        cands = sfilter(inds, lambda ij: ij[0] <= h - 5 and ij[0] <= w - 5)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        plcd = shift(bx, loc)\n        if plcd.issubset(inds):\n            inds = (inds - plcd) - outbox(plcd)\n            ringcols = [choice(ccols) for k in range(4)]\n            plcdrings = [shift(r, loc) for r in rings]\n            gi = fill(gi, ringcols[0], plcdrings[0])\n            go = fill(go, ringcols[0], plcdrings[0])\n            idx = randint(1, 3)\n            gi = fill(gi, ringcols[idx], plcdrings[idx])\n            go = fill(go, ringcols[idx], plcdrings[idx])\n            remrings = plcdrings[1:idx] + plcdrings[idx+1:]\n            remringcols = ringcols[1:idx] + ringcols[idx+1:]\n            numrs = unifint(diff_lb, diff_ub, (1, 2))\n            locs = sample((0, 1), numrs)\n            remrings = [rr for j, rr in enumerate(remrings) if j in locs]\n            remringcols = [rr for j, rr in enumerate(remringcols) if j in locs]\n            tofillgi = merge(frozenset(\n                recolor(col, frozenset(sample(totuple(remring), 4 - unifint(diff_lb, diff_ub, (0, 3))))) for remring, col in zip(remrings, remringcols)\n            ))\n            tofillgo = merge(frozenset(\n                recolor(col, remring) for remring, col in zip(remrings, remringcols)\n            ))\n            if min(shape(tofillgi)) == 5:\n                succ += 1\n                gi = paint(gi, tofillgi)\n                go = paint(go, tofillgo)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_11852cab(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define four rings of different sizes\n    r1 = ((0, 0), (0, 4), (4, 0), (4, 4))  # Outer ring\n    r2 = ((2, 0), (0, 2), (4, 2), (2, 4))  # Middle-outer ring\n    r3 = ((1, 1), (3, 1), (1, 3), (3, 3))  # Middle-inner ring\n    r4 = ((2, 2),)  # Center point\n    \n    # Combine rings into a list, ordered from innermost to outermost\n    rings = [r4, r3, r2, r1]\n    \n    # Create a bounding box for the largest ring\n    bx = backdrop(frozenset(r1))\n    \n    # Randomly determine grid height and width based on difficulty\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1-9)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select colors to use for the rings\n    ccols = sample(remcols, numc)\n    \n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Create a set of valid indices for placing objects, excluding the outermost border\n    inds = shift(asindices(trim(gi)), UNITY)\n    \n    # Determine the number of objects to place based on grid size and difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 36)))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 10 * nobjs\n\n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        # Filter valid locations for placing objects\n        cands = sfilter(inds, lambda ij: ij[0] <= h - 5 and ij[0] <= w - 5)\n        \n        # Break if no valid locations remain\n        if len(cands) == 0:\n            break\n        \n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        \n        # Shift the bounding box to the chosen location\n        plcd = shift(bx, loc)\n        \n        # Check if the object fits within the valid indices\n        if plcd.issubset(inds):\n            # Remove the object area and its outbox from valid indices\n            inds = (inds - plcd) - outbox(plcd)\n            \n            # Randomly choose colors for the rings\n            ringcols = [choice(ccols) for k in range(4)]\n            \n            # Shift all rings to the chosen location\n            plcdrings = [shift(r, loc) for r in rings]\n            \n            # Fill the center point in both input and output grids\n            gi = fill(gi, ringcols[0], plcdrings[0])\n            go = fill(go, ringcols[0], plcdrings[0])\n            \n            # Randomly choose one of the outer rings to fill completely\n            idx = randint(1, 3)\n            gi = fill(gi, ringcols[idx], plcdrings[idx])\n            go = fill(go, ringcols[idx], plcdrings[idx])\n            \n            # Prepare the remaining rings for partial filling\n            remrings = plcdrings[1:idx] + plcdrings[idx+1:]\n            remringcols = ringcols[1:idx] + ringcols[idx+1:]\n            \n            # Randomly decide how many of the remaining rings to use (1 or 2)\n            numrs = unifint(diff_lb, diff_ub, (1, 2))\n            locs = sample((0, 1), numrs)\n            remrings = [rr for j, rr in enumerate(remrings) if j in locs]\n            remringcols = [rr for j, rr in enumerate(remringcols) if j in locs]\n            \n            # Create partially filled rings for the input grid\n            tofillgi = merge(frozenset(\n                recolor(col, frozenset(sample(totuple(remring), 4 - unifint(diff_lb, diff_ub, (0, 3))))) for remring, col in zip(remrings, remringcols)\n            ))\n            \n            # Create fully filled rings for the output grid\n            tofillgo = merge(frozenset(\n                recolor(col, remring) for remring, col in zip(remrings, remringcols)\n            ))\n            \n            # If the object is valid (5x5), add it to the grids\n            if min(shape(tofillgi)) == 5:\n                succ += 1\n                gi = paint(gi, tofillgi)\n                go = paint(go, tofillgo)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1190e5a7": {
    "original": "def generate_1190e5a7(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    bgc = choice(colopts)\n    c = canvas(bgc, (h, w))\n    nhf_bounds = (1, h // 3)\n    nvf_bounds = (1, w // 3)\n    nhf = unifint(diff_lb, diff_ub, nhf_bounds)\n    nvf = unifint(diff_lb, diff_ub, nvf_bounds)\n    hf_options = interval(1, h - 1, 1)\n    vf_options = interval(1, w - 1, 1)\n    hf_selection = []\n    for k in range(nhf):\n        hf = choice(hf_options)\n        hf_selection.append(hf)\n        hf_options = difference(hf_options, (hf - 1, hf, hf + 1))\n    vf_selection = []\n    for k in range(nvf):\n        vf = choice(vf_options)\n        vf_selection.append(vf)\n        vf_options = difference(vf_options, (vf - 1, vf, vf + 1))\n    remcols = remove(bgc, colopts)\n    rcf = lambda x: recolor(choice(remcols), x)\n    hfs = mapply(chain(rcf, hfrontier, toivec), tuple(hf_selection))\n    vfs = mapply(chain(rcf, vfrontier, tojvec), tuple(vf_selection))\n    gi = paint(c, combine(hfs, vfs))\n    go = canvas(bgc, (nhf + 1, nvf + 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1190e5a7(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Define color options (integers from 0 to 9)\n    colopts = interval(0, 10, 1)\n    # Randomly choose height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose background color\n    bgc = choice(colopts)\n    # Create a canvas (grid) with chosen dimensions and background color\n    c = canvas(bgc, (h, w))\n    # Define bounds for number of horizontal frontiers (1 to 1/3 of height)\n    nhf_bounds = (1, h // 3)\n    # Define bounds for number of vertical frontiers (1 to 1/3 of width)\n    nvf_bounds = (1, w // 3)\n    # Randomly choose number of horizontal frontiers based on difficulty\n    nhf = unifint(diff_lb, diff_ub, nhf_bounds)\n    # Randomly choose number of vertical frontiers based on difficulty\n    nvf = unifint(diff_lb, diff_ub, nvf_bounds)\n    # Define options for horizontal frontier positions\n    hf_options = interval(1, h - 1, 1)\n    # Define options for vertical frontier positions\n    vf_options = interval(1, w - 1, 1)\n    # Initialize list to store selected horizontal frontier positions\n    hf_selection = []\n    # Select positions for horizontal frontiers\n    for k in range(nhf):\n        # Randomly choose a position for horizontal frontier\n        hf = choice(hf_options)\n        # Add chosen position to selection\n        hf_selection.append(hf)\n        # Remove chosen position and adjacent positions from options\n        hf_options = difference(hf_options, (hf - 1, hf, hf + 1))\n    # Initialize list to store selected vertical frontier positions\n    vf_selection = []\n    # Select positions for vertical frontiers\n    for k in range(nvf):\n        # Randomly choose a position for vertical frontier\n        vf = choice(vf_options)\n        # Add chosen position to selection\n        vf_selection.append(vf)\n        # Remove chosen position and adjacent positions from options\n        vf_options = difference(vf_options, (vf - 1, vf, vf + 1))\n    # Get list of colors excluding background color\n    remcols = remove(bgc, colopts)\n    # Define function to recolor a frontier with a random non-background color\n    rcf = lambda x: recolor(choice(remcols), x)\n    # Create horizontal frontiers, recolor them, and convert to objects\n    hfs = mapply(chain(rcf, hfrontier, toivec), tuple(hf_selection))\n    # Create vertical frontiers, recolor them, and convert to objects\n    vfs = mapply(chain(rcf, vfrontier, tojvec), tuple(vf_selection))\n    # Paint the frontiers onto the canvas to create input grid\n    gi = paint(c, combine(hfs, vfs))\n    # Create output grid with dimensions based on number of frontiers\n    go = canvas(bgc, (nhf + 1, nvf + 1))\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "137eaa0f": {
    "original": "def generate_137eaa0f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 4))\n    w = unifint(diff_lb, diff_ub, (2, 4))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    dotc = choice(remcols)\n    remcols = remove(dotc, remcols)\n    go = canvas(dotc, (h, w))\n    inds = totuple(asindices(go))\n    loc = choice(inds)\n    reminds = remove(loc, inds)\n    nc = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))\n    choscols = sample(remcols, nc)\n    cd = {c: set() for c in choscols}\n    for c in choscols:\n        ij = choice(reminds)\n        cd[c].add(ij)\n        reminds = remove(ij, reminds)\n    for ri in reminds:\n        cd[choice(choscols)].add(ri)\n    for c, idxes in cd.items():\n        go = fill(go, c, idxes)\n    gih = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))\n    giw = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))\n    objs = tuple(\n        normalize(insert((dotc, loc), frozenset({(c, ij) for ij in cd[c]}))) \\\n            for c in choscols\n    )\n    maxtr = min(h, w) * 2\n    maxtrtot = 1000\n    while True:\n        succ = True\n        gi = canvas(bgc, (gih, giw))\n        inds = asindices(gi)\n        for obj in objs:\n            oh, ow = shape(obj)\n            succ2 = False\n            tr = 0\n            while tr < maxtr and not succ2:\n                loci = randint(0, gih - oh)\n                locj = randint(0, giw - ow)\n                plcd = shift(obj, (loci, locj))\n                tr += 1\n                if toindices(plcd).issubset(inds):\n                    succ2 = True\n            if succ2:\n                gi = paint(gi, plcd)\n                inds = difference(inds, toindices(plcd))\n                inds = difference(inds, mapply(neighbors, toindices(plcd)))\n            else:\n                succ = False\n                break\n        if succ:\n            break\n        maxtrtot += 1\n        if maxtrtot < 1000:\n            break\n        maxtr = int(maxtr * 1.5)\n        gih = randint(gih, 30)\n        giw = randint(giw, 30)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_137eaa0f(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the output grid between 2 and 4\n    h = unifint(diff_lb, diff_ub, (2, 4))\n    \n    # Randomly choose the width of the output grid between 2 and 4\n    w = unifint(diff_lb, diff_ub, (2, 4))\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the dot (central element)\n    dotc = choice(remcols)\n    \n    # Remove the dot color from the remaining colors\n    remcols = remove(dotc, remcols)\n    \n    # Create the output grid filled with the dot color\n    go = canvas(dotc, (h, w))\n    \n    # Get all indices of the output grid as a tuple\n    inds = totuple(asindices(go))\n    \n    # Choose a random location for the central dot\n    loc = choice(inds)\n    \n    # Remove the chosen location from the available indices\n    reminds = remove(loc, inds)\n    \n    # Determine the number of colors to use (between 1 and min(h*w-1, 8))\n    nc = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))\n    \n    # Randomly select colors to use\n    choscols = sample(remcols, nc)\n    \n    # Initialize a dictionary to store color-index mappings\n    cd = {c: set() for c in choscols}\n    \n    # For each chosen color, select a random location\n    for c in choscols:\n        ij = choice(reminds)\n        cd[c].add(ij)\n        reminds = remove(ij, reminds)\n    \n    # Distribute remaining locations among chosen colors\n    for ri in reminds:\n        cd[choice(choscols)].add(ri)\n    \n    # Fill the output grid with chosen colors at their respective locations\n    for c, idxes in cd.items():\n        go = fill(go, c, idxes)\n    \n    # Determine the height of the input grid (between 2*min(h,w) and 30)\n    gih = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))\n    \n    # Determine the width of the input grid (between 2*min(h,w) and 30)\n    giw = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))\n    \n    # Create objects for each color, normalized and including the central dot\n    objs = tuple(\n        normalize(insert((dotc, loc), frozenset({(c, ij) for ij in cd[c]}))) \\\n            for c in choscols\n    )\n    \n    # Set maximum number of placement attempts per object\n    maxtr = min(h, w) * 2\n    \n    # Set maximum total number of placement attempts\n    maxtrtot = 1000\n    \n    # Loop to create the input grid\n    while True:\n        succ = True\n        # Create an empty input grid with the background color\n        gi = canvas(bgc, (gih, giw))\n        # Get all indices of the input grid\n        inds = asindices(gi)\n        \n        # Try to place each object on the input grid\n        for obj in objs:\n            oh, ow = shape(obj)\n            succ2 = False\n            tr = 0\n            # Attempt to place the object\n            while tr < maxtr and not succ2:\n                # Choose a random location for the object\n                loci = randint(0, gih - oh)\n                locj = randint(0, giw - ow)\n                # Shift the object to the chosen location\n                plcd = shift(obj, (loci, locj))\n                tr += 1\n                # Check if the placed object fits within the grid\n                if toindices(plcd).issubset(inds):\n                    succ2 = True\n            \n            # If placement was successful, update the input grid\n            if succ2:\n                gi = paint(gi, plcd)\n                # Remove the used indices and their neighbors from available indices\n                inds = difference(inds, toindices(plcd))\n                inds = difference(inds, mapply(neighbors, toindices(plcd)))\n            else:\n                # If placement failed, mark the attempt as unsuccessful\n                succ = False\n                break\n        \n        # If all objects were placed successfully, break the loop\n        if succ:\n            break\n        \n        # Increment the total attempts counter\n        maxtrtot += 1\n        \n        # If maximum total attempts reached, break the loop\n        if maxtrtot < 1000:\n            break\n        \n        # Increase the maximum attempts per object\n        maxtr = int(maxtr * 1.5)\n        \n        # Increase the input grid dimensions\n        gih = randint(gih, 30)\n        giw = randint(giw, 30)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "150deff5": {
    "original": "def generate_150deff5(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 8))\n    bo = {(0, 0), (0, 1), (1, 0), (1, 1)}\n    ro1 = {(0, 0), (0, 1), (0, 2)}\n    ro2 = {(0, 0), (1, 0), (2, 0)}\n    boforb = set()\n    reforb = set()\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    noccs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))\n    inds = asindices(gi)\n    needsbgc = []\n    for k in range(noccs):\n        obj, col = choice(((bo, 8), (choice((ro1, ro2)), 2)))\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and shift(obj, ij).issubset(inds))\n        if col == 8:\n            cands = sfilter(cands, lambda ij: ij not in boforb)\n        else:\n            cands = sfilter(cands, lambda ij: ij not in reforb)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        if col == 8:\n            boforb.add(add(loc, (-2, 0)))\n            boforb.add(add(loc, (2, 0)))\n            boforb.add(add(loc, (0, 2)))\n            boforb.add(add(loc, (0, -2)))\n        if col == 2:\n            if obj == ro1:\n                reforb.add(add(loc, (0, 3)))\n                reforb.add(add(loc, (0, -3)))\n            else:\n                reforb.add(add(loc, (1, 0)))\n                reforb.add(add(loc, (-1, 0)))\n        plcd = shift(obj, loc)\n        gi = fill(gi, fgc, plcd)\n        go = fill(go, col, plcd)\n        inds = inds - plcd\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_150deff5(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 2 and 8\n    cols = difference(interval(0, 10, 1), (2, 8))\n    \n    # Define a 2x2 square shape\n    bo = {(0, 0), (0, 1), (1, 0), (1, 1)}\n    \n    # Define a horizontal 1x3 rectangle shape\n    ro1 = {(0, 0), (0, 1), (0, 2)}\n    \n    # Define a vertical 3x1 rectangle shape\n    ro2 = {(0, 0), (1, 0), (2, 0)}\n    \n    # Initialize sets to keep track of forbidden positions for blue objects and red objects\n    boforb = set()\n    reforb = set()\n    \n    # Generate a random height between 8 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Generate a random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly choose two colors: one for background and one for foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Generate a random number of objects to place, between 2 and 10% of grid area\n    noccs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Initialize an empty list (unused in this function)\n    needsbgc = []\n    \n    # Loop to place objects on the grid\n    for k in range(noccs):\n        # Randomly choose between blue square (8) and red rectangle (2)\n        obj, col = choice(((bo, 8), (choice((ro1, ro2)), 2)))\n        \n        # Get the shape (height and width) of the chosen object\n        oh, ow = shape(obj)\n        \n        # Find all valid positions where the object can be placed\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and shift(obj, ij).issubset(inds))\n        \n        # If placing a blue square, filter out forbidden positions\n        if col == 8:\n            cands = sfilter(cands, lambda ij: ij not in boforb)\n        # If placing a red rectangle, filter out forbidden positions\n        else:\n            cands = sfilter(cands, lambda ij: ij not in reforb)\n        \n        # If no valid positions left, end the loop\n        if len(cands) == 0:\n            break\n        \n        # Choose a random position from valid candidates\n        loc = choice(totuple(cands))\n        \n        # If placing a blue square, update forbidden positions for future blue squares\n        if col == 8:\n            boforb.add(add(loc, (-2, 0)))\n            boforb.add(add(loc, (2, 0)))\n            boforb.add(add(loc, (0, 2)))\n            boforb.add(add(loc, (0, -2)))\n        \n        # If placing a red rectangle, update forbidden positions for future red rectangles\n        if col == 2:\n            if obj == ro1:\n                reforb.add(add(loc, (0, 3)))\n                reforb.add(add(loc, (0, -3)))\n            else:\n                reforb.add(add(loc, (1, 0)))\n                reforb.add(add(loc, (-1, 0)))\n        \n        # Shift the object to its chosen position\n        plcd = shift(obj, loc)\n        \n        # Place the object on the input grid with the foreground color\n        gi = fill(gi, fgc, plcd)\n        \n        # Place the object on the output grid with its designated color (8 or 2)\n        go = fill(go, col, plcd)\n        \n        # Remove the placed object's positions from available indices\n        inds = inds - plcd\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "178fcbfb": {
    "original": "def generate_178fcbfb(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = totuple(asindices(gi))\n    iforb = set()\n    jforb = set()\n    mp = (h * w) // 3\n    for col in (2, 1, 3):\n        bnd = unifint(diff_lb, diff_ub, (1, w if col == 2 else h // 2))\n        for ndots in range(bnd):\n            if col == 2:\n                ij = choice(sfilter(inds, lambda ij: last(ij) not in jforb))\n                jforb.add(last(ij))\n            if col == 1 or col == 3:\n                ij = choice(sfilter(inds, lambda ij: first(ij) not in iforb))\n                iforb.add(first(ij))\n            gi = fill(gi, col, initset(ij))\n            go = fill(go, col, (vfrontier if col == 2 else hfrontier)(ij))\n            inds = remove(ij, inds)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_178fcbfb(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1, 2, and 3\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    \n    # Randomly generate the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly generate the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Initialize sets to keep track of forbidden rows and columns\n    iforb = set()\n    jforb = set()\n    \n    # Calculate the maximum number of points to be placed (1/3 of the grid size)\n    mp = (h * w) // 3\n    \n    # Iterate through colors 2, 1, and 3 in this order\n    for col in (2, 1, 3):\n        # Determine the bound for the number of dots to place\n        # For color 2, it's between 1 and w; for colors 1 and 3, it's between 1 and h/2\n        bnd = unifint(diff_lb, diff_ub, (1, w if col == 2 else h // 2))\n        \n        # Place dots of the current color\n        for ndots in range(bnd):\n            if col == 2:\n                # For color 2, choose a random cell in a column that hasn't been used yet\n                ij = choice(sfilter(inds, lambda ij: last(ij) not in jforb))\n                # Mark this column as used\n                jforb.add(last(ij))\n            if col == 1 or col == 3:\n                # For colors 1 and 3, choose a random cell in a row that hasn't been used yet\n                ij = choice(sfilter(inds, lambda ij: first(ij) not in iforb))\n                # Mark this row as used\n                iforb.add(first(ij))\n            \n            # Place the dot in the input grid\n            gi = fill(gi, col, initset(ij))\n            \n            # For the output grid:\n            # If color is 2, fill the entire column\n            # If color is 1 or 3, fill the entire row\n            go = fill(go, col, (vfrontier if col == 2 else hfrontier)(ij))\n            \n            # Remove the used cell from the available indices\n            inds = remove(ij, inds)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1a07d186": {
    "original": "def generate_1a07d186(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nlines = unifint(diff_lb, diff_ub, (1, w // 5))\n    linecols = sample(remcols, nlines)\n    remcols = difference(remcols, linecols)\n    nnoisecols = unifint(diff_lb, diff_ub, (0, len(remcols)))\n    noisecols = sample(remcols, nnoisecols)\n    locopts = interval(0, w, 1)\n    locs = []\n    for k in range(nlines):\n        if len(locopts) == 0:\n            break\n        loc = choice(locopts)\n        locopts = difference(locopts, interval(loc - 2, loc + 3, 1))\n        locs.append(loc)\n    locs = sorted(locs)\n    nlines = len(locs)\n    linecols = linecols[:nlines]\n    gi = canvas(bgc, (h, w))\n    for loc, col in zip(locs, linecols):\n        gi = fill(gi, col, connect((0, loc), (h - 1, loc)))\n    go = tuple(e for e in gi)\n    nilocs = unifint(diff_lb, diff_ub, (1, h))\n    ilocs = sample(interval(0, h, 1), nilocs)\n    dotlocopts = difference(interval(0, w, 1), locs)\n    for ii in ilocs:\n        ndots = unifint(diff_lb, diff_ub, (1, min(nlines + nnoisecols, (w - nlines) // 2 - 1)))\n        dotlocs = sample(dotlocopts, ndots)\n        dotcols = sample(totuple(set(linecols) | set(noisecols)), ndots)\n        for dotlocj, col in zip(dotlocs, dotcols):\n            gi = fill(gi, col, {(ii, dotlocj)})\n            if col in linecols:\n                idx = linecols.index(col)\n                linelocj = locs[idx]\n                if dotlocj > linelocj:\n                    go = fill(go, col, {(ii, linelocj + 1)})\n                else:\n                    go = fill(go, col, {(ii, linelocj - 1)})\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1a07d186(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 8 and 30\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the width of the grid between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of vertical lines to draw (between 1 and 1/5 of the width)\n    nlines = unifint(diff_lb, diff_ub, (1, w // 5))\n    \n    # Randomly select colors for the vertical lines\n    linecols = sample(remcols, nlines)\n    \n    # Remove the line colors from the remaining colors\n    remcols = difference(remcols, linecols)\n    \n    # Determine the number of noise colors to use (between 0 and the number of remaining colors)\n    nnoisecols = unifint(diff_lb, diff_ub, (0, len(remcols)))\n    \n    # Randomly select colors for noise\n    noisecols = sample(remcols, nnoisecols)\n    \n    # Create a list of possible x-coordinates for the vertical lines\n    locopts = interval(0, w, 1)\n    \n    # Initialize an empty list to store the x-coordinates of the vertical lines\n    locs = []\n    \n    # Loop to determine the positions of the vertical lines\n    for k in range(nlines):\n        # If no more positions are available, break the loop\n        if len(locopts) == 0:\n            break\n        \n        # Randomly choose a position for the line\n        loc = choice(locopts)\n        \n        # Remove nearby positions to ensure lines aren't too close\n        locopts = difference(locopts, interval(loc - 2, loc + 3, 1))\n        \n        # Add the chosen position to the list\n        locs.append(loc)\n    \n    # Sort the line positions\n    locs = sorted(locs)\n    \n    # Update the number of lines based on the actual number of positions chosen\n    nlines = len(locs)\n    \n    # Adjust the number of line colors to match the number of lines\n    linecols = linecols[:nlines]\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Draw the vertical lines on the input grid\n    for loc, col in zip(locs, linecols):\n        gi = fill(gi, col, connect((0, loc), (h - 1, loc)))\n    \n    # Create a copy of the input grid to serve as the base for the output grid\n    go = tuple(e for e in gi)\n    \n    # Determine the number of rows that will contain dots\n    nilocs = unifint(diff_lb, diff_ub, (1, h))\n    \n    # Randomly select which rows will contain dots\n    ilocs = sample(interval(0, h, 1), nilocs)\n    \n    # Determine possible x-coordinates for dots (excluding line positions)\n    dotlocopts = difference(interval(0, w, 1), locs)\n    \n    # Loop through each row that will contain dots\n    for ii in ilocs:\n        # Determine the number of dots for this row\n        ndots = unifint(diff_lb, diff_ub, (1, min(nlines + nnoisecols, (w - nlines) // 2 - 1)))\n        \n        # Randomly select x-coordinates for the dots\n        dotlocs = sample(dotlocopts, ndots)\n        \n        # Randomly select colors for the dots\n        dotcols = sample(totuple(set(linecols) | set(noisecols)), ndots)\n        \n        # Place the dots on the input grid and update the output grid\n        for dotlocj, col in zip(dotlocs, dotcols):\n            # Place the dot on the input grid\n            gi = fill(gi, col, {(ii, dotlocj)})\n            \n            # If the dot color matches a line color, update the output grid\n            if col in linecols:\n                # Find the index of the matching line color\n                idx = linecols.index(col)\n                \n                # Get the x-coordinate of the corresponding line\n                linelocj = locs[idx]\n                \n                # Place a dot next to the line in the output grid\n                if dotlocj > linelocj:\n                    go = fill(go, col, {(ii, linelocj + 1)})\n                else:\n                    go = fill(go, col, {(ii, linelocj - 1)})\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1b2d62fb": {
    "original": "def generate_1b2d62fb(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    cola = choice(remcols)\n    colb = choice(remcols)\n    canv = canvas(0, (h, w))\n    inds = totuple(asindices(canv))\n    gbar = canvas(barcol, (h, 1))\n    mp = (h * w) // 2\n    devrng = (0, mp)\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    deva = sgna * deva\n    devb = sgnb * devb\n    numa = mp + deva\n    numb = mp + devb\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gi = hconcat(hconcat(gia, gbar), gib)\n    go = fill(canv, 8, ofcolor(gia, 0) & ofcolor(gib, 0))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1b2d62fb(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (2-30)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid (2-14)\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Set background color to 0 (black)\n    bgc = 0\n    \n    # Remove background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a color for the separating bar\n    barcol = choice(remcols)\n    \n    # Remove the bar color from the remaining colors\n    remcols = remove(barcol, remcols)\n    \n    # Randomly choose two colors for the two sides of the grid\n    cola = choice(remcols)\n    colb = choice(remcols)\n    \n    # Create a blank canvas with background color\n    canv = canvas(0, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    \n    # Create a vertical bar of height h and width 1 with the bar color\n    gbar = canvas(barcol, (h, 1))\n    \n    # Calculate the midpoint of the total number of cells\n    mp = (h * w) // 2\n    \n    # Set the range for deviation from the midpoint\n    devrng = (0, mp)\n    \n    # Randomly determine deviations for both sides\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    \n    # Randomly choose signs for the deviations\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    \n    # Apply signs to the deviations\n    deva = sgna * deva\n    devb = sgnb * devb\n    \n    # Calculate the number of cells to fill for each side\n    numa = mp + deva\n    numb = mp + devb\n    \n    # Ensure the numbers are within valid range (1 to total cells - 1)\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    \n    # Randomly sample indices for each side\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    \n    # Fill the sampled indices with respective colors\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    \n    # Concatenate the two sides with the separating bar in between\n    gi = hconcat(hconcat(gia, gbar), gib)\n    \n    # Create the output grid: fill with color 8 where both input sides are background color\n    go = fill(canv, 8, ofcolor(gia, 0) & ofcolor(gib, 0))\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1b60fb0c": {
    "original": "def generate_1b60fb0c(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    odh = unifint(diff_lb, diff_ub, (2, min(h, w)//2))\n    loci = randint(0, h - 2 * odh)\n    locj = randint(0, w - 2 * odh)\n    loc = (loci, locj)\n    bgc, objc = sample(cols, 2)\n    quad = canvas(bgc, (odh, odh))\n    ncellsd = unifint(diff_lb, diff_ub, (0, odh ** 2 // 2))\n    ncells = choice((ncellsd, odh ** 2 - ncellsd))\n    ncells = min(max(1, ncells), odh ** 2 - 1)\n    cells = sample(totuple(asindices(canvas(-1, (odh, odh)))), ncells)\n    g1 = fill(quad, objc, cells)\n    g2 = rot90(g1)\n    g3 = rot90(g2)\n    g4 = rot90(g3)\n    c1 = shift(ofcolor(g1, objc), (0, 0))\n    c2 = shift(ofcolor(g2, objc), (0, odh))\n    c3 = shift(ofcolor(g3, objc), (odh, odh))\n    c4 = shift(ofcolor(g4, objc), (odh, 0))\n    shftamt = randint(0, odh)\n    c1 = shift(c1, (0, shftamt))\n    c2 = shift(c2, (shftamt, 0))\n    c3 = shift(c3, (0, -shftamt))\n    c4 = shift(c4, (-shftamt, 0))\n    cs = (c1, c2, c3, c4)\n    rempart = choice(cs)\n    inobjparts = remove(rempart, cs)\n    inobj = merge(set(inobjparts))\n    rempart = rempart - inobj\n    inobj = shift(inobj, loc)\n    rempart = shift(rempart, loc)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, objc, inobj)\n    go = fill(gi, 2, rempart)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1b60fb0c(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random size for each quadrant (between 2 and half of min(h,w))\n    odh = unifint(diff_lb, diff_ub, (2, min(h, w)//2))\n    \n    # Generate random vertical position for the object\n    loci = randint(0, h - 2 * odh)\n    \n    # Generate random horizontal position for the object\n    locj = randint(0, w - 2 * odh)\n    \n    # Combine vertical and horizontal positions\n    loc = (loci, locj)\n    \n    # Choose two random colors: one for background, one for object\n    bgc, objc = sample(cols, 2)\n    \n    # Create a square canvas of size odh x odh with background color\n    quad = canvas(bgc, (odh, odh))\n    \n    # Generate random number of cells to fill (up to half of quadrant area)\n    ncellsd = unifint(diff_lb, diff_ub, (0, odh ** 2 // 2))\n    \n    # Randomly choose between ncellsd and its complement\n    ncells = choice((ncellsd, odh ** 2 - ncellsd))\n    \n    # Ensure at least 1 cell and at most all but 1 cell are filled\n    ncells = min(max(1, ncells), odh ** 2 - 1)\n    \n    # Randomly select cells to fill in the quadrant\n    cells = sample(totuple(asindices(canvas(-1, (odh, odh)))), ncells)\n    \n    # Fill the selected cells with the object color\n    g1 = fill(quad, objc, cells)\n    \n    # Create three more quadrants by rotating the first one\n    g2 = rot90(g1)\n    g3 = rot90(g2)\n    g4 = rot90(g3)\n    \n    # Extract colored cells from each quadrant and position them\n    c1 = shift(ofcolor(g1, objc), (0, 0))\n    c2 = shift(ofcolor(g2, objc), (0, odh))\n    c3 = shift(ofcolor(g3, objc), (odh, odh))\n    c4 = shift(ofcolor(g4, objc), (odh, 0))\n    \n    # Generate a random shift amount\n    shftamt = randint(0, odh)\n    \n    # Apply the shift to each quadrant's cells\n    c1 = shift(c1, (0, shftamt))\n    c2 = shift(c2, (shftamt, 0))\n    c3 = shift(c3, (0, -shftamt))\n    c4 = shift(c4, (-shftamt, 0))\n    \n    # Combine all quadrants into a tuple\n    cs = (c1, c2, c3, c4)\n    \n    # Randomly choose one quadrant to remove\n    rempart = choice(cs)\n    \n    # Keep the other three quadrants\n    inobjparts = remove(rempart, cs)\n    \n    # Merge the remaining quadrants into a single object\n    inobj = merge(set(inobjparts))\n    \n    # Remove any overlapping cells between rempart and inobj\n    rempart = rempart - inobj\n    \n    # Shift the main object and the removed part to their final position\n    inobj = shift(inobj, loc)\n    rempart = shift(rempart, loc)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Add the main object to the input grid\n    gi = fill(gi, objc, inobj)\n    \n    # Create the output grid by adding the removed part with color 2\n    go = fill(gi, 2, rempart)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1bfc4729": {
    "original": "def generate_1bfc4729(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    if h % 2 == 1:\n        h = choice((max(4, h - 1), min(30, h + 1)))\n    alocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))\n    if choice((True, False)):\n        alocj = max(min(w // 2, alocj - w // 2), 1)\n    aloci = randint(1, h // 2 - 1)\n    blocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))\n    if choice((True, False)):\n        blocj = max(min(w // 2, blocj - w // 2), 1)\n    bloci = randint(h // 2, h - 2)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    aloc = (aloci, alocj)\n    bloc = (bloci, blocj)\n    gi = fill(gi, acol, {aloc})\n    gi = fill(gi, bcol, {bloc})\n    go = fill(gi, acol, hfrontier(aloc))\n    go = fill(go, bcol, hfrontier(bloc))\n    go = fill(go, acol, connect((0, 0), (0, w - 1)))\n    go = fill(go, bcol, connect((h - 1, 0), (h - 1, w - 1)))\n    go = fill(go, acol, connect((0, 0), (h // 2 - 1, 0)))\n    go = fill(go, acol, connect((0, w - 1), (h // 2 - 1, w - 1)))\n    go = fill(go, bcol, connect((h // 2, 0), (h - 1, 0)))\n    go = fill(go, bcol, connect((h // 2, w - 1), (h - 1, w - 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1bfc4729(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Ensure the height is even\n    if h % 2 == 1:\n        # If odd, adjust to nearest even number within bounds\n        h = choice((max(4, h - 1), min(30, h + 1)))\n    \n    # Generate a random column for the first point (A) in the right half of the grid\n    alocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))\n    if choice((True, False)):\n        # 50% chance to move A to the left half\n        alocj = max(min(w // 2, alocj - w // 2), 1)\n    # Set a random row for A in the top half of the grid\n    aloci = randint(1, h // 2 - 1)\n    \n    # Generate a random column for the second point (B) in the right half of the grid\n    blocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))\n    if choice((True, False)):\n        # 50% chance to move B to the left half\n        blocj = max(min(w // 2, blocj - w // 2), 1)\n    # Set a random row for B in the bottom half of the grid\n    bloci = randint(h // 2, h - 2)\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    # Choose a color for point A\n    acol = choice(remcols)\n    # Remove A's color from the remaining colors\n    remcols = remove(acol, remcols)\n    # Choose a color for point B\n    bcol = choice(remcols)\n    \n    # Create a grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Define the locations of points A and B\n    aloc = (aloci, alocj)\n    bloc = (bloci, blocj)\n    # Place point A on the input grid\n    gi = fill(gi, acol, {aloc})\n    # Place point B on the input grid\n    gi = fill(gi, bcol, {bloc})\n    \n    # Start creating the output grid\n    # Fill A's horizontal line\n    go = fill(gi, acol, hfrontier(aloc))\n    # Fill B's horizontal line\n    go = fill(go, bcol, hfrontier(bloc))\n    # Draw top border with A's color\n    go = fill(go, acol, connect((0, 0), (0, w - 1)))\n    # Draw bottom border with B's color\n    go = fill(go, bcol, connect((h - 1, 0), (h - 1, w - 1)))\n    # Draw left half of left border with A's color\n    go = fill(go, acol, connect((0, 0), (h // 2 - 1, 0)))\n    # Draw right half of left border with A's color\n    go = fill(go, acol, connect((0, w - 1), (h // 2 - 1, w - 1)))\n    # Draw left half of right border with B's color\n    go = fill(go, bcol, connect((h // 2, 0), (h - 1, 0)))\n    # Draw right half of right border with B's color\n    go = fill(go, bcol, connect((h // 2, w - 1), (h - 1, w - 1)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1c786137": {
    "original": "def generate_1c786137(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    num_cols_card_bounds = (1, 8)\n    colopts = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    noise_card_bounds = (0, h * w)\n    c = canvas(0, (h, w))\n    inds = totuple(asindices(c))\n    num_noise = unifint(diff_lb, diff_ub, noise_card_bounds)\n    num_cols = unifint(diff_lb, diff_ub, num_cols_card_bounds)\n    noiseinds = sample(inds, num_noise)\n    colset = sample(colopts, num_cols)\n    trgcol = choice(difference(colopts, colset))\n    noise = frozenset((choice(colset), ij) for ij in noiseinds)\n    gi = paint(c, noise)\n    boxhrng = (3, max(3, h//2))\n    boxwrng = (3, max(3, w//2))\n    boxh = unifint(diff_lb, diff_ub, boxhrng)\n    boxw = unifint(diff_lb, diff_ub, boxwrng)\n    boxi = choice(interval(0, h - boxh + 1, 1))\n    boxj = choice(interval(0, w - boxw + 1, 1))\n    loc = (boxi, boxj)\n    llc = add(loc, toivec(boxh - 1))\n    urc = add(loc, tojvec(boxw - 1))\n    lrc = add(loc, (boxh - 1, boxw - 1))\n    l1 = connect(loc, llc)\n    l2 = connect(loc, urc)\n    l3 = connect(urc, lrc)\n    l4 = connect(llc, lrc)\n    l = l1 | l2 | l3 | l4\n    gi = fill(gi, trgcol, l)\n    go = crop(gi, increment(loc), (boxh - 2, boxw - 2))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1c786137(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions (3x3 to 30x30)\n    dim_bounds = (3, 30)\n    # Define bounds for number of colors (1 to 8)\n    num_cols_card_bounds = (1, 8)\n    # Create a range of color options (1 to 9)\n    colopts = interval(1, 10, 1)\n    # Randomly choose grid height based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose grid width based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Define bounds for number of noise cells (0 to total grid cells)\n    noise_card_bounds = (0, h * w)\n    # Create an empty canvas filled with 0s\n    c = canvas(0, (h, w))\n    # Get all grid indices as a tuple\n    inds = totuple(asindices(c))\n    # Randomly choose number of noise cells based on difficulty\n    num_noise = unifint(diff_lb, diff_ub, noise_card_bounds)\n    # Randomly choose number of colors to use for noise based on difficulty\n    num_cols = unifint(diff_lb, diff_ub, num_cols_card_bounds)\n    # Randomly select indices for noise cells\n    noiseinds = sample(inds, num_noise)\n    # Randomly select colors for noise\n    colset = sample(colopts, num_cols)\n    # Choose a target color different from noise colors\n    trgcol = choice(difference(colopts, colset))\n    # Create noise by assigning random colors to selected indices\n    noise = frozenset((choice(colset), ij) for ij in noiseinds)\n    # Paint the noise onto the canvas\n    gi = paint(c, noise)\n    # Define bounds for box height (3 to half of grid height, minimum 3)\n    boxhrng = (3, max(3, h//2))\n    # Define bounds for box width (3 to half of grid width, minimum 3)\n    boxwrng = (3, max(3, w//2))\n    # Randomly choose box height\n    boxh = unifint(diff_lb, diff_ub, boxhrng)\n    # Randomly choose box width\n    boxw = unifint(diff_lb, diff_ub, boxwrng)\n    # Randomly choose box's top-left corner row\n    boxi = choice(interval(0, h - boxh + 1, 1))\n    # Randomly choose box's top-left corner column\n    boxj = choice(interval(0, w - boxw + 1, 1))\n    # Create tuple for box's top-left corner location\n    loc = (boxi, boxj)\n    # Calculate lower-left corner of the box\n    llc = add(loc, toivec(boxh - 1))\n    # Calculate upper-right corner of the box\n    urc = add(loc, tojvec(boxw - 1))\n    # Calculate lower-right corner of the box\n    lrc = add(loc, (boxh - 1, boxw - 1))\n    # Create line from top-left to lower-left corner\n    l1 = connect(loc, llc)\n    # Create line from top-left to upper-right corner\n    l2 = connect(loc, urc)\n    # Create line from upper-right to lower-right corner\n    l3 = connect(urc, lrc)\n    # Create line from lower-left to lower-right corner\n    l4 = connect(llc, lrc)\n    # Combine all lines to form the box outline\n    l = l1 | l2 | l3 | l4\n    # Fill the box outline with the target color\n    gi = fill(gi, trgcol, l)\n    # Crop the inside of the box to create the output\n    go = crop(gi, increment(loc), (boxh - 2, boxw - 2))\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1caeab9d": {
    "original": "def generate_1caeab9d(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1,))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    oh = unifint(diff_lb, diff_ub, (1, h//2))\n    ow = unifint(diff_lb, diff_ub, (1, w//3))\n    bb = asindices(canvas(-1, (oh, ow)))\n    sp = choice(totuple(bb))\n    obj = {sp}\n    bb = remove(sp, bb)\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(0, ncells), oh * ow - 1)\n    for k in range(ncells):\n        obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    loci = randint(0, h - oh)\n    numo = unifint(diff_lb, diff_ub, (2, min(8, w // ow))) - 1\n    itv = interval(0, w, 1)\n    locj = randint(0, w - ow)\n    objp = shift(obj, (loci, locj))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c = canvas(bgc, (h, w))\n    gi = fill(c, 1, objp)\n    go = fill(c, 1, objp)\n    itv = difference(itv, interval(locj, locj + ow, 1))\n    for k in range(numo):\n        cands = sfilter(itv, lambda j: set(interval(j, j + ow, 1)).issubset(set(itv)))\n        if len(cands) == 0:\n            break\n        locj = choice(cands)\n        col = choice(remcols)\n        remcols = remove(col, remcols)\n        gi = fill(gi, col, shift(obj, (randint(0, h - oh), locj)))\n        go = fill(go, col, shift(obj, (loci, locj)))\n        itv = difference(itv, interval(locj, locj + ow, 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1caeab9d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1\n    cols = difference(interval(0, 10, 1), (1,))\n    \n    # Randomly determine the height of the grid\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly determine the height of the object\n    oh = unifint(diff_lb, diff_ub, (1, h//2))\n    \n    # Randomly determine the width of the object\n    ow = unifint(diff_lb, diff_ub, (1, w//3))\n    \n    # Create a bounding box for the object\n    bb = asindices(canvas(-1, (oh, ow)))\n    \n    # Choose a random starting point for the object\n    sp = choice(totuple(bb))\n    \n    # Initialize the object with the starting point\n    obj = {sp}\n    \n    # Remove the starting point from the bounding box\n    bb = remove(sp, bb)\n    \n    # Determine the number of cells to add to the object\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(0, ncells), oh * ow - 1)\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells):\n        obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))\n    \n    # Normalize the object's position\n    obj = normalize(obj)\n    \n    # Get the final shape of the object\n    oh, ow = shape(obj)\n    \n    # Choose a random vertical position for the object in the output\n    loci = randint(0, h - oh)\n    \n    # Determine the number of object copies to create\n    numo = unifint(diff_lb, diff_ub, (2, min(8, w // ow))) - 1\n    \n    # Create an interval for possible horizontal positions\n    itv = interval(0, w, 1)\n    \n    # Choose a random horizontal position for the first object\n    locj = randint(0, w - ow)\n    \n    # Shift the object to its position in the grid\n    objp = shift(obj, (loci, locj))\n    \n    # Choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from available colors\n    remcols = remove(bgc, cols)\n    \n    # Create the background canvas\n    c = canvas(bgc, (h, w))\n    \n    # Place the first object in the input grid\n    gi = fill(c, 1, objp)\n    \n    # Place the first object in the output grid\n    go = fill(c, 1, objp)\n    \n    # Update the interval of available positions\n    itv = difference(itv, interval(locj, locj + ow, 1))\n    \n    # Place additional objects in the grids\n    for k in range(numo):\n        # Find valid positions for the next object\n        cands = sfilter(itv, lambda j: set(interval(j, j + ow, 1)).issubset(set(itv)))\n        \n        # Break if no valid positions are left\n        if len(cands) == 0:\n            break\n        \n        # Choose a random position for the next object\n        locj = choice(cands)\n        \n        # Choose a color for the next object\n        col = choice(remcols)\n        \n        # Remove the chosen color from available colors\n        remcols = remove(col, remcols)\n        \n        # Place the object in the input grid at a random vertical position\n        gi = fill(gi, col, shift(obj, (randint(0, h - oh), locj)))\n        \n        # Place the object in the output grid at the fixed vertical position\n        go = fill(go, col, shift(obj, (loci, locj)))\n        \n        # Update the interval of available positions\n        itv = difference(itv, interval(locj, locj + ow, 1))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1cf80156": {
    "original": "def generate_1cf80156(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(colopts)\n    fgc = choice(remove(bgc, colopts))\n    gi = canvas(bgc, (h, w))\n    hb = unifint(diff_lb, diff_ub, (1, min(15, h - 1)))\n    wb = unifint(diff_lb, diff_ub, (1, min(15, w - 1)))\n    bounds = asindices(canvas(0, (hb, wb)))\n    shp = {choice(totuple(corners(bounds)))}\n    mp = (hb * wb) // 2\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    nc = choice((dev, hb * wb - dev))\n    nc = max(0, min(hb * wb - 1, nc))\n    for j in range(nc):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    di = randint(0, h - height(shp))\n    dj = randint(0, w - width(shp))\n    shpp = shift(shp, (di, dj))\n    gi = fill(gi, fgc, shpp)\n    go = fill(canvas(bgc, shape(shp)), fgc, shp)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1cf80156(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly choose the height of the input grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose the width of the input grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select a background color from the color options\n    bgc = choice(colopts)\n    \n    # Randomly select a foreground color, ensuring it's different from the background\n    fgc = choice(remove(bgc, colopts))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly choose the height of the shape's bounding box (1 to 15 or h-1, whichever is smaller)\n    hb = unifint(diff_lb, diff_ub, (1, min(15, h - 1)))\n    \n    # Randomly choose the width of the shape's bounding box (1 to 15 or w-1, whichever is smaller)\n    wb = unifint(diff_lb, diff_ub, (1, min(15, w - 1)))\n    \n    # Create a set of all possible coordinates within the bounding box\n    bounds = asindices(canvas(0, (hb, wb)))\n    \n    # Start the shape with a randomly chosen corner of the bounding box\n    shp = {choice(totuple(corners(bounds)))}\n    \n    # Calculate the midpoint of the bounding box area\n    mp = (hb * wb) // 2\n    \n    # Randomly choose a deviation from the midpoint\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    \n    # Decide on the number of cells for the shape, either above or below the midpoint\n    nc = choice((dev, hb * wb - dev))\n    \n    # Ensure the number of cells is within valid bounds\n    nc = max(0, min(hb * wb - 1, nc))\n    \n    # Grow the shape by adding adjacent cells until reaching the desired number of cells\n    for j in range(nc):\n        # Choose a new cell adjacent to the current shape, but within the bounds\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Randomly choose a vertical offset for placing the shape in the input grid\n    di = randint(0, h - height(shp))\n    \n    # Randomly choose a horizontal offset for placing the shape in the input grid\n    dj = randint(0, w - width(shp))\n    \n    # Shift the shape to its final position in the input grid\n    shpp = shift(shp, (di, dj))\n    \n    # Fill the shape area in the input grid with the foreground color\n    gi = fill(gi, fgc, shpp)\n    \n    # Create the output grid: a canvas of the shape's size, filled with background color\n    # Then fill the normalized shape with the foreground color\n    go = fill(canvas(bgc, shape(shp)), fgc, shp)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1e0a9b12": {
    "original": "def generate_1e0a9b12(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    ff = chain(dmirror, lbind(apply, rbind(order, identity)), dmirror)\n    while True:\n        h = unifint(diff_lb, diff_ub, (3, 30))\n        w = unifint(diff_lb, diff_ub, (3, 30))\n        nc = unifint(diff_lb, diff_ub, (1, w))\n        bgc = choice(cols)\n        gi = canvas(bgc, (h, w))\n        remcols = remove(bgc, cols)\n        scols = [choice(remcols) for j in range(nc)]\n        slocs = sample(interval(0, w, 1), nc)\n        inds = totuple(connect(ORIGIN, (h - 1, 0)))\n        for c, l in zip(scols, slocs):\n            nc2 = randint(1, h - 1)\n            sel = sample(inds, nc2)\n            gi = fill(gi, c, shift(sel, tojvec(l)))\n        go = replace(ff(replace(gi, bgc, -1)), -1, bgc)\n        if colorcount(gi, bgc) > argmax(remove(bgc, palette(gi)), lbind(colorcount, gi)):\n            break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1e0a9b12(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color indices from 0 to 9\n    cols = interval(0, 10, 1)\n    # Create a composite function: mirror diagonally, order elements, then mirror diagonally again\n    ff = chain(dmirror, lbind(apply, rbind(order, identity)), dmirror)\n    while True:\n        # Randomly generate height within [3, 30] based on difficulty\n        h = unifint(diff_lb, diff_ub, (3, 30))\n        # Randomly generate width within [3, 30] based on difficulty\n        w = unifint(diff_lb, diff_ub, (3, 30))\n        # Randomly choose number of columns to fill, between 1 and width\n        nc = unifint(diff_lb, diff_ub, (1, w))\n        # Randomly select a background color\n        bgc = choice(cols)\n        # Create an empty grid filled with the background color\n        gi = canvas(bgc, (h, w))\n        # Remove the background color from the list of available colors\n        remcols = remove(bgc, cols)\n        # Randomly select colors for each column to be filled\n        scols = [choice(remcols) for j in range(nc)]\n        # Randomly select column indices to be filled\n        slocs = sample(interval(0, w, 1), nc)\n        # Create a tuple of indices for the leftmost column\n        inds = totuple(connect(ORIGIN, (h - 1, 0)))\n        # For each selected color and column location\n        for c, l in zip(scols, slocs):\n            # Randomly choose number of cells to fill in this column\n            nc2 = randint(1, h - 1)\n            # Randomly select cells in this column to fill\n            sel = sample(inds, nc2)\n            # Fill the selected cells with the chosen color\n            gi = fill(gi, c, shift(sel, tojvec(l)))\n        # Apply the composite function to create the output grid\n        # This sorts each column, then mirrors the grid diagonally\n        go = replace(ff(replace(gi, bgc, -1)), -1, bgc)\n        # Ensure the background color is the most common in the input grid\n        if colorcount(gi, bgc) > argmax(remove(bgc, palette(gi)), lbind(colorcount, gi)):\n            break\n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1e32b0e9": {
    "original": "def generate_1e32b0e9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 6))\n    w = unifint(diff_lb, diff_ub, (4, 6))\n    nh = unifint(diff_lb, diff_ub, (1, 4))\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))\n    bgc, linc, fgc = sample(cols, 3)\n    fullh = h * nh + (nh - 1)\n    fullw = w * nw + (nw - 1)\n    c = canvas(linc, (fullh, fullw))\n    smallc = canvas(bgc, (h, w))\n    llocs = set()\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    srcloc = choice(llocs)\n    remlocs = remove(srcloc, llocs)\n    ncells = unifint(diff_lb, diff_ub, (0, (h - 2) * (w - 2) - 1))\n    smallc2 = canvas(bgc, (h-2, w - 2))\n    inds = asindices(smallc2)\n    sp = choice(totuple(inds))\n    inds = remove(sp, inds)\n    shp = {sp}\n    for j in range(ncells):\n        ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    shp = shift(shp, (1, 1))\n    gg = asobject(fill(smallc, fgc, shp))\n    gg2 = asobject(fill(smallc, linc, shp))\n    gi = paint(c, shift(gg, srcloc))\n    go = tuple(e for e in gi)\n    ncc = ncells + 1\n    for rl in remlocs:\n        nleft = randint(0, ncc)\n        subobj = sample(totuple(shp), nleft)\n        sg2 = asobject(fill(smallc, fgc, subobj))\n        gi = paint(gi, shift(sg2, rl))\n        go = paint(go, shift(gg2, rl))\n        go = fill(go, fgc, shift(subobj, rl))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1e32b0e9(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of each sub-grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 6))\n    # Randomly determine the width of each sub-grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 6))\n    \n    # Determine the number of sub-grids vertically\n    nh = unifint(diff_lb, diff_ub, (1, 4))\n    # Determine the number of sub-grids horizontally (ensuring at least 2 if only 1 vertically)\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))\n    \n    # Randomly select three distinct colors for background, lines, and foreground\n    bgc, linc, fgc = sample(cols, 3)\n    \n    # Calculate the full height of the grid, including spacing between sub-grids\n    fullh = h * nh + (nh - 1)\n    # Calculate the full width of the grid, including spacing between sub-grids\n    fullw = w * nw + (nw - 1)\n    \n    # Create the initial canvas filled with the line color\n    c = canvas(linc, (fullh, fullw))\n    # Create a smaller canvas for each sub-grid, filled with the background color\n    smallc = canvas(bgc, (h, w))\n    \n    # Generate locations for the top-left corners of each sub-grid\n    llocs = set()\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    \n    # Choose a random location for the source sub-grid\n    srcloc = choice(llocs)\n    # Remove the chosen location from the list of available locations\n    remlocs = remove(srcloc, llocs)\n    \n    # Determine the number of cells to fill in each sub-grid\n    ncells = unifint(diff_lb, diff_ub, (0, (h - 2) * (w - 2) - 1))\n    \n    # Create a smaller canvas for the inner part of each sub-grid\n    smallc2 = canvas(bgc, (h-2, w - 2))\n    # Get all indices of the smaller canvas\n    inds = asindices(smallc2)\n    \n    # Choose a random starting point for the shape\n    sp = choice(totuple(inds))\n    # Remove the starting point from available indices\n    inds = remove(sp, inds)\n    # Initialize the shape with the starting point\n    shp = {sp}\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(ncells):\n        ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    \n    # Shift the shape to fit in the sub-grid\n    shp = shift(shp, (1, 1))\n    \n    # Create objects representing the filled shape\n    gg = asobject(fill(smallc, fgc, shp))\n    gg2 = asobject(fill(smallc, linc, shp))\n    \n    # Paint the source sub-grid onto the main canvas\n    gi = paint(c, shift(gg, srcloc))\n    go = tuple(e for e in gi)\n    \n    # Total number of cells in the shape\n    ncc = ncells + 1\n    \n    # For each remaining location, create a partially filled sub-grid\n    for rl in remlocs:\n        # Determine how many cells to fill in this sub-grid\n        nleft = randint(0, ncc)\n        # Randomly select cells to fill\n        subobj = sample(totuple(shp), nleft)\n        # Create an object representing the partially filled sub-grid\n        sg2 = asobject(fill(smallc, fgc, subobj))\n        # Paint the partially filled sub-grid onto the input grid\n        gi = paint(gi, shift(sg2, rl))\n        # Paint the full shape outline onto the output grid\n        go = paint(go, shift(gg2, rl))\n        # Fill the selected cells in the output grid\n        go = fill(go, fgc, shift(subobj, rl))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1f0c79e5": {
    "original": "def generate_1f0c79e5(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, objc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 24))\n    inds = asindices(gi)\n    obj = ((0, 0), (0, 1), (1, 0), (1, 1))\n    for k in range(nobjs):\n        cands = sfilter(inds, lambda ij: shift(set(obj), ij).issubset(inds))\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        nred = unifint(diff_lb, diff_ub, (1, 3))\n        reds = sample(totuple(plcd), nred)\n        gi = fill(gi, objc, plcd)\n        gi = fill(gi, 2, reds)\n        for idx in reds:\n            direc = decrement(multiply(2, add(idx, invert(loc))))\n            go = fill(go, objc, mapply(rbind(shoot, direc), frozenset(plcd)))\n        inds = (inds - plcd) - mapply(dneighbors, set(plcd))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1f0c79e5(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 2 from the range 0-9, creating a list of available colors\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly generate the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly generate the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly select two colors: one for background and one for objects\n    bgc, objc = sample(cols, 2)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine the number of objects to place based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 24))\n    \n    # Get all possible indices in the input grid\n    inds = asindices(gi)\n    \n    # Define the shape of the object (2x2 square)\n    obj = ((0, 0), (0, 1), (1, 0), (1, 1))\n    \n    # Loop to place objects on the grid\n    for k in range(nobjs):\n        # Find valid locations where the object can be placed\n        cands = sfilter(inds, lambda ij: shift(set(obj), ij).issubset(inds))\n        \n        # If no valid locations remain, stop placing objects\n        if len(cands) == 0:\n            break\n        \n        # Randomly choose a location for the object\n        loc = choice(totuple(cands))\n        \n        # Place the object at the chosen location\n        plcd = shift(obj, loc)\n        \n        # Determine how many cells of the object will be \"red\" (color 2)\n        nred = unifint(diff_lb, diff_ub, (1, 3))\n        \n        # Randomly select which cells of the object will be \"red\"\n        reds = sample(totuple(plcd), nred)\n        \n        # Fill the object area with the object color in the input grid\n        gi = fill(gi, objc, plcd)\n        \n        # Fill the \"red\" cells with color 2 in the input grid\n        gi = fill(gi, 2, reds)\n        \n        # For each \"red\" cell, create a line in the output grid\n        for idx in reds:\n            # Calculate the direction of the line\n            direc = decrement(multiply(2, add(idx, invert(loc))))\n            \n            # Draw the line in the output grid\n            go = fill(go, objc, mapply(rbind(shoot, direc), frozenset(plcd)))\n        \n        # Remove the placed object and its neighbors from available indices\n        inds = (inds - plcd) - mapply(dneighbors, set(plcd))\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1f642eb9": {
    "original": "def generate_1f642eb9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    ih = unifint(diff_lb, diff_ub, (2, min(h - 4, 2 * (h // 3))))\n    iw = unifint(diff_lb, diff_ub, (2, min(w - 4, 2 * (w // 3))))\n    loci = randint(2, h - ih - 2)\n    locj = randint(2, w - iw - 2)\n    bgc, sqc = sample(cols, 2)\n    remcols = difference(cols, (bgc, sqc))\n    numcells = unifint(diff_lb, diff_ub, (1, 2 * ih + 2 * iw - 4))\n    outs = []\n    ins = []\n    c1 = choice((True, False))\n    c2 = choice((True, False))\n    c3 = choice((True, False))\n    c4 = choice((True, False))\n    for a in range(loci + (not c1), loci + ih - (not c2)):\n        outs.append((a, 0))\n        ins.append((a, locj))\n    for a in range(loci + (not c3), loci + ih - (not c4)):\n        outs.append((a, w - 1))\n        ins.append((a, locj + iw - 1))\n    for b in range(locj + c1, locj + iw - (c3)):\n        outs.append((0, b))\n        ins.append((loci, b))\n    for b in range(locj + (c2), locj + iw - (c4)):\n        outs.append((h - 1, b))\n        ins.append((loci + ih - 1, b))\n    inds = interval(0, 2 * ih + 2 * iw - 4, 1)\n    locs = sample(inds, numcells)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    outs = [e for j, e in enumerate(outs) if j in locs]\n    ins = [e for j, e in enumerate(ins) if j in locs]\n    c = canvas(bgc, (h, w))\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    gi = fill(c, sqc, bd)\n    seq = [choice(ccols) for k in range(numcells)]\n    for c, loc in zip(seq, outs):\n        gi = fill(gi, c, {loc})\n    go = tuple(e for e in gi)\n    for c, loc in zip(seq, ins):\n        go = fill(go, c, {loc})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1f642eb9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (6, 30))  # Generate a random height between 6 and 30\n    w = unifint(diff_lb, diff_ub, (6, 30))  # Generate a random width between 6 and 30\n    ih = unifint(diff_lb, diff_ub, (2, min(h - 4, 2 * (h // 3))))  # Generate inner height, at least 2 and at most 2/3 of total height minus 4\n    iw = unifint(diff_lb, diff_ub, (2, min(w - 4, 2 * (w // 3))))  # Generate inner width, at least 2 and at most 2/3 of total width minus 4\n    loci = randint(2, h - ih - 2)  # Random vertical position for inner rectangle, leaving at least 2 cells margin\n    locj = randint(2, w - iw - 2)  # Random horizontal position for inner rectangle, leaving at least 2 cells margin\n    bgc, sqc = sample(cols, 2)  # Randomly choose two colors: one for background, one for inner rectangle\n    remcols = difference(cols, (bgc, sqc))  # Get remaining colors not used for background or inner rectangle\n    numcells = unifint(diff_lb, diff_ub, (1, 2 * ih + 2 * iw - 4))  # Random number of cells to be colored, max is perimeter of inner rectangle\n    outs = []  # List to store output positions (on the border)\n    ins = []   # List to store input positions (on the inner rectangle)\n    c1 = choice((True, False))  # Random boolean for top-left corner of inner rectangle\n    c2 = choice((True, False))  # Random boolean for top-right corner of inner rectangle\n    c3 = choice((True, False))  # Random boolean for bottom-left corner of inner rectangle\n    c4 = choice((True, False))  # Random boolean for bottom-right corner of inner rectangle\n    \n    # Generate vertical positions on left border and corresponding positions on inner rectangle\n    for a in range(loci + (not c1), loci + ih - (not c2)):\n        outs.append((a, 0))  # Add position on left border\n        ins.append((a, locj))  # Add corresponding position on left side of inner rectangle\n    \n    # Generate vertical positions on right border and corresponding positions on inner rectangle\n    for a in range(loci + (not c3), loci + ih - (not c4)):\n        outs.append((a, w - 1))  # Add position on right border\n        ins.append((a, locj + iw - 1))  # Add corresponding position on right side of inner rectangle\n    \n    # Generate horizontal positions on top border and corresponding positions on inner rectangle\n    for b in range(locj + c1, locj + iw - (c3)):\n        outs.append((0, b))  # Add position on top border\n        ins.append((loci, b))  # Add corresponding position on top side of inner rectangle\n    \n    # Generate horizontal positions on bottom border and corresponding positions on inner rectangle\n    for b in range(locj + (c2), locj + iw - (c4)):\n        outs.append((h - 1, b))  # Add position on bottom border\n        ins.append((loci + ih - 1, b))  # Add corresponding position on bottom side of inner rectangle\n    \n    inds = interval(0, 2 * ih + 2 * iw - 4, 1)  # Create a range of indices for all possible positions\n    locs = sample(inds, numcells)  # Randomly select indices for cells to be colored\n    numc = unifint(diff_lb, diff_ub, (1, 8))  # Random number of colors to use, between 1 and 8\n    ccols = sample(remcols, numc)  # Randomly select colors to use\n    outs = [e for j, e in enumerate(outs) if j in locs]  # Filter output positions based on selected indices\n    ins = [e for j, e in enumerate(ins) if j in locs]  # Filter input positions based on selected indices\n    c = canvas(bgc, (h, w))  # Create a background canvas with the chosen background color\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))  # Create a backdrop for the inner rectangle\n    gi = fill(c, sqc, bd)  # Fill the inner rectangle with the chosen color\n    seq = [choice(ccols) for k in range(numcells)]  # Generate a random sequence of colors for the cells\n    \n    # Color the cells on the border for the input grid\n    for c, loc in zip(seq, outs):\n        gi = fill(gi, c, {loc})  # Fill each selected position on the border with a color\n    \n    go = tuple(e for e in gi)  # Create a copy of the input grid for the output\n    \n    # Color the cells on the inner rectangle for the output grid\n    for c, loc in zip(seq, ins):\n        go = fill(go, c, {loc})  # Fill each selected position on the inner rectangle with a color\n    \n    return {'input': gi, 'output': go}  # Return the input and output grids as a dictionary\n"
  },
  "1f85a75f": {
    "original": "def generate_1f85a75f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = randint(3, min(8, h // 2))\n    ow = randint(3, min(8, w // 2))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    ncells = randint(max(oh, ow), oh * ow)\n    sp = choice(totuple(bounds))\n    obj = {sp}\n    cands = remove(sp, bounds)\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    bgc, objc = sample(cols, 2)\n    remcols = remove(bgc, remove(objc, cols))\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, ((h * w) - len(backdrop(obj))) // 4)))\n    gi = canvas(bgc, (h, w))\n    obj = shift(obj, (loci, locj))\n    gi = fill(gi, objc, obj)\n    inds = asindices(gi)\n    noisecells = sample(totuple(inds - backdrop(obj)), nnoise)\n    noiseobj = frozenset({(choice(ccols), ij) for ij in noisecells})\n    gi = paint(gi, noiseobj)\n    go = fill(canvas(bgc, (oh, ow)), objc, normalize(obj))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1f85a75f(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the input grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Set the height of the object, between 3 and 8 or half the grid height\n    oh = randint(3, min(8, h // 2))\n    \n    # Set the width of the object, between 3 and 8 or half the grid width\n    ow = randint(3, min(8, w // 2))\n    \n    # Create a set of all possible coordinates within the object's dimensions\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Determine the number of cells in the object\n    ncells = randint(max(oh, ow), oh * ow)\n    \n    # Choose a random starting point for the object\n    sp = choice(totuple(bounds))\n    \n    # Initialize the object with the starting point\n    obj = {sp}\n    \n    # Remove the starting point from the available coordinates\n    cands = remove(sp, bounds)\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        # Add a random cell that's adjacent to the existing object and within bounds\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    \n    # Normalize the object's position (move it to the top-left corner)\n    obj = normalize(obj)\n    \n    # Get the final dimensions of the object\n    oh, ow = shape(obj)\n    \n    # Choose a random location for the object in the input grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Select two different colors for background and object\n    bgc, objc = sample(cols, 2)\n    \n    # Get the remaining colors (excluding background and object colors)\n    remcols = remove(bgc, remove(objc, cols))\n    \n    # Determine the number of colors to use for noise (between 1 and 8)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Select colors for noise\n    ccols = sample(remcols, numc)\n    \n    # Determine the number of noise cells to add\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, ((h * w) - len(backdrop(obj))) // 4)))\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Shift the object to its final position in the input grid\n    obj = shift(obj, (loci, locj))\n    \n    # Add the object to the input grid\n    gi = fill(gi, objc, obj)\n    \n    # Get all cell indices in the input grid\n    inds = asindices(gi)\n    \n    # Select random cells for noise (excluding the object area)\n    noisecells = sample(totuple(inds - backdrop(obj)), nnoise)\n    \n    # Create noise objects with random colors\n    noiseobj = frozenset({(choice(ccols), ij) for ij in noisecells})\n    \n    # Add noise to the input grid\n    gi = paint(gi, noiseobj)\n    \n    # Create the output grid (normalized object without noise)\n    go = fill(canvas(bgc, (oh, ow)), objc, normalize(obj))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "1f876c06": {
    "original": "def generate_1f876c06(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    nlns = unifint(diff_lb, diff_ub, (1, min(min(h, w), 9)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, nlns)\n    succ = 0\n    tr = 0\n    maxtr = 10 * nlns\n    direcs = ineighbors((0, 0))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nlns and tr < maxtr:\n        tr += 1\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        lns = []\n        for direc in direcs:\n            ln = [loc]\n            ofs = 1\n            while True:\n                nextpix = add(loc, multiply(ofs, direc))\n                ofs += 1\n                if nextpix not in inds:\n                    break\n                ln.append(nextpix)\n            if len(ln) > 2:\n                lns.append(ln)\n        if len(lns) > 0:\n            succ += 1\n            lns = sorted(lns, key=len)\n            idx = unifint(diff_lb, diff_ub, (0, len(lns) - 1))\n            ln = lns[idx]\n            col = ccols[0]\n            ccols = ccols[1:]\n            gi = fill(gi, col, {ln[0], ln[-1]})\n            go = fill(go, col, set(ln))\n            inds = inds - set(ln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1f876c06(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the number of lines to draw, capped by min(h,w) and 9\n    nlns = unifint(diff_lb, diff_ub, (1, min(min(h, w), 9)))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select colors for the lines\n    ccols = sample(remcols, nlns)\n    \n    # Initialize counters for successful line placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 10 * nlns\n    \n    # Define diagonal directions for line drawing\n    direcs = ineighbors((0, 0))\n    \n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing lines\n    while succ < nlns and tr < maxtr:\n        tr += 1\n        # Break if no more available indices\n        if len(inds) == 0:\n            break\n        \n        # Choose a random starting point for a line\n        loc = choice(totuple(inds))\n        \n        # Initialize list to store potential lines\n        lns = []\n        \n        # Try drawing lines in all diagonal directions\n        for direc in direcs:\n            ln = [loc]\n            ofs = 1\n            # Extend the line until it reaches the grid boundary\n            while True:\n                nextpix = add(loc, multiply(ofs, direc))\n                ofs += 1\n                if nextpix not in inds:\n                    break\n                ln.append(nextpix)\n            # If line is longer than 2 pixels, add it to potential lines\n            if len(ln) > 2:\n                lns.append(ln)\n        \n        # If valid lines were found\n        if len(lns) > 0:\n            succ += 1\n            # Sort lines by length\n            lns = sorted(lns, key=len)\n            # Choose a line based on difficulty\n            idx = unifint(diff_lb, diff_ub, (0, len(lns) - 1))\n            ln = lns[idx]\n            \n            # Get the next color for the line\n            col = ccols[0]\n            ccols = ccols[1:]\n            \n            # In the input grid, color only the endpoints of the line\n            gi = fill(gi, col, {ln[0], ln[-1]})\n            \n            # In the output grid, color the entire line\n            go = fill(go, col, set(ln))\n            \n            # Remove the used indices from available indices\n            inds = inds - set(ln)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "1fad071e": {
    "original": "def generate_1fad071e(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nbl = randint(0, 5)\n    nobjs = unifint(diff_lb, diff_ub, (nbl, max(nbl, (h * w) // 10)))\n    bgc, otherc = sample(cols, 2)\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    bcount = 0\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    ofcfrbinds = {1: set(), otherc: set()}\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        col = choice((1, otherc))\n        oh = randint(1, 3)\n        ow = randint(1, 3)\n        if bcount < nbl:\n            col = 1\n            oh, ow = 2, 2\n        else:\n            while col == 1 and oh == ow == 2:\n                col = choice((1, otherc))\n                oh = randint(1, 3)\n                ow = randint(1, 3)\n        bd = backdrop(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bd = shift(bd, loc)\n        if bd.issubset(inds) and len(mapply(dneighbors, bd) & ofcfrbinds[col]) == 0:\n            succ += 1\n            inds = inds - bd\n            ofcfrbinds[col] = ofcfrbinds[col] | mapply(dneighbors, bd) | bd\n            gi = fill(gi, col, bd)\n            if col == 1 and oh == ow == 2:\n                bcount += 1\n    go = (repeat(1, bcount) + repeat(bgc, 5 - bcount),)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_1fad071e(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose number of blue squares (0 to 5)\n    nbl = randint(0, 5)\n    \n    # Calculate number of objects based on difficulty and board size\n    nobjs = unifint(diff_lb, diff_ub, (nbl, max(nbl, (h * w) // 10)))\n    \n    # Randomly choose background color and another color\n    bgc, otherc = sample(cols, 2)\n    \n    # Initialize counters and variables\n    succ = 0  # Successfully placed objects\n    tr = 0  # Number of attempts\n    maxtr = 5 * nobjs  # Maximum number of attempts\n    bcount = 0  # Count of blue squares\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Initialize sets to track occupied and neighboring cells for each color\n    ofcfrbinds = {1: set(), otherc: set()}\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        # Randomly choose color (blue or other)\n        col = choice((1, otherc))\n        \n        # Randomly choose object height and width\n        oh = randint(1, 3)\n        ow = randint(1, 3)\n        \n        # Ensure blue squares are 2x2 if count is less than nbl\n        if bcount < nbl:\n            col = 1\n            oh, ow = 2, 2\n        else:\n            # Avoid 2x2 blue squares if blue count is met\n            while col == 1 and oh == ow == 2:\n                col = choice((1, otherc))\n                oh = randint(1, 3)\n                ow = randint(1, 3)\n        \n        # Create backdrop for the object\n        bd = backdrop(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        \n        # Find valid positions for placing the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Shift the backdrop to the chosen location\n        bd = shift(bd, loc)\n        \n        # Check if object can be placed without overlapping or touching same color\n        if bd.issubset(inds) and len(mapply(dneighbors, bd) & ofcfrbinds[col]) == 0:\n            succ += 1\n            # Update available indices\n            inds = inds - bd\n            # Update occupied and neighboring cells\n            ofcfrbinds[col] = ofcfrbinds[col] | mapply(dneighbors, bd) | bd\n            # Place the object on the grid\n            gi = fill(gi, col, bd)\n            # Increment blue count if a 2x2 blue square is placed\n            if col == 1 and oh == ow == 2:\n                bcount += 1\n    \n    # Create output grid: blue squares followed by background color\n    go = (repeat(1, bcount) + repeat(bgc, 5 - bcount),)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "2013d3e2": {
    "original": "def generate_2013d3e2(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    w = h\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 1))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    gi1 = hconcat(gi, rot90(gi))\n    gi2 = hconcat(rot270(gi), rot180(gi))\n    gi = vconcat(gi1, gi2)\n    fullh = unifint(diff_lb, diff_ub, (2*h, 30))\n    fullw = unifint(diff_lb, diff_ub, (2*w, 30))\n    gio = asobject(gi)\n    gic = canvas(bgc, (fullh, fullw))\n    loci = randint(0, fullh - 2*h)\n    locj = randint(0, fullw - 2*w)\n    gi = paint(gic, shift(gio, (loci, locj)))\n    reminds = difference(asindices(gi), ofcolor(gi, bgc))\n    go = lefthalf(tophalf(subgrid(reminds, gi)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2013d3e2(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly select a height (and width) between 3 and 10 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    w = h  # Set width equal to height for a square grid\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select the number of colors to use (1 to 8) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample colors from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly select the number of cells to color (2 to h*w-1) based on difficulty\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 1))\n    \n    # Get all indices of the canvas\n    bx = asindices(canv)\n    \n    # Initialize the object with a random color at a random position\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Iteratively add adjacent cells to the object\n    for kk in range(nc - 1):\n        # Get all neighbors of the current object\n        dns = mapply(neighbors, toindices(obj))\n        \n        # Choose a random cell from the intersection of available cells and neighbors\n        ch = choice(totuple(bx & dns))\n        \n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        \n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Paint the object onto the canvas\n    gi = paint(canv, obj)\n    \n    # Create a 2x2 grid by rotating and concatenating the original grid\n    gi1 = hconcat(gi, rot90(gi))  # Concatenate original and 90\u00b0 rotation horizontally\n    gi2 = hconcat(rot270(gi), rot180(gi))  # Concatenate 270\u00b0 and 180\u00b0 rotations horizontally\n    gi = vconcat(gi1, gi2)  # Concatenate the two horizontal concatenations vertically\n    \n    # Randomly select full height and width for the final grid\n    fullh = unifint(diff_lb, diff_ub, (2*h, 30))\n    fullw = unifint(diff_lb, diff_ub, (2*w, 30))\n    \n    # Convert the 2x2 grid to an object\n    gio = asobject(gi)\n    \n    # Create a new canvas with the full dimensions\n    gic = canvas(bgc, (fullh, fullw))\n    \n    # Randomly select a position to place the 2x2 grid\n    loci = randint(0, fullh - 2*h)\n    locj = randint(0, fullw - 2*w)\n    \n    # Paint the 2x2 grid onto the full canvas at the selected position\n    gi = paint(gic, shift(gio, (loci, locj)))\n    \n    # Get all non-background colored cells\n    reminds = difference(asindices(gi), ofcolor(gi, bgc))\n    \n    # Extract the top-left quarter of the colored region as the output\n    go = lefthalf(tophalf(subgrid(reminds, gi)))\n    \n    # Return the input grid and the output grid\n    return {'input': gi, 'output': go}\n"
  },
  "2204b7a8": {
    "original": "def generate_2204b7a8(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (4, 30)\n    colopts = interval(0, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, dim_bounds)\n        w = unifint(diff_lb, diff_ub, dim_bounds)\n        bgc = choice(colopts)\n        remcols = remove(bgc, colopts)\n        c = canvas(bgc, (h, w))\n        inds = totuple(shift(asindices(canvas(0, (h, w - 2))), RIGHT))\n        ccol = choice(remcols)\n        remcols2 = remove(ccol, remcols)\n        c1 = choice(remcols2)\n        c2 = choice(remove(c1, remcols2))\n        nc_bounds = (1, (h * (w - 2)) // 2 - 1)\n        nc = unifint(diff_lb, diff_ub, nc_bounds)\n        locs = sample(inds, nc)\n        if w % 2 == 1:\n            locs = difference(locs, vfrontier(tojvec(w // 2)))\n        gi = fill(c, c1, vfrontier(ORIGIN))\n        gi = fill(gi, c2, vfrontier(tojvec(w - 1)))\n        gi = fill(gi, ccol, locs)\n        a = sfilter(locs, lambda ij: last(ij) < w // 2)\n        b = difference(locs, a)\n        go = fill(gi, c1, a)\n        go = fill(go, c2, b)\n        if len(palette(gi)) == 4:\n            break\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2204b7a8(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (4, 30)\n    # Create a tuple of color options from 0 to 9\n    colopts = interval(0, 10, 1)\n    while True:\n        # Randomly choose height within bounds based on difficulty\n        h = unifint(diff_lb, diff_ub, dim_bounds)\n        # Randomly choose width within bounds based on difficulty\n        w = unifint(diff_lb, diff_ub, dim_bounds)\n        # Randomly choose background color\n        bgc = choice(colopts)\n        # Remove background color from color options\n        remcols = remove(bgc, colopts)\n        # Create a canvas with chosen background color and dimensions\n        c = canvas(bgc, (h, w))\n        # Create indices for all cells except the leftmost and rightmost columns\n        inds = totuple(shift(asindices(canvas(0, (h, w - 2))), RIGHT))\n        # Choose a color for the center cells\n        ccol = choice(remcols)\n        # Remove center color from remaining colors\n        remcols2 = remove(ccol, remcols)\n        # Choose color for left column\n        c1 = choice(remcols2)\n        # Choose color for right column, different from left column\n        c2 = choice(remove(c1, remcols2))\n        # Define bounds for number of center cells to color\n        nc_bounds = (1, (h * (w - 2)) // 2 - 1)\n        # Randomly choose number of center cells to color based on difficulty\n        nc = unifint(diff_lb, diff_ub, nc_bounds)\n        # Randomly sample locations for center cells\n        locs = sample(inds, nc)\n        # If width is odd, remove cells from the middle column\n        if w % 2 == 1:\n            locs = difference(locs, vfrontier(tojvec(w // 2)))\n        # Fill left column with c1 color\n        gi = fill(c, c1, vfrontier(ORIGIN))\n        # Fill right column with c2 color\n        gi = fill(gi, c2, vfrontier(tojvec(w - 1)))\n        # Fill chosen center locations with ccol color\n        gi = fill(gi, ccol, locs)\n        # Separate center locations into left and right halves\n        a = sfilter(locs, lambda ij: last(ij) < w // 2)\n        b = difference(locs, a)\n        # Create output grid: fill left half center cells with c1\n        go = fill(gi, c1, a)\n        # Fill right half center cells with c2\n        go = fill(go, c2, b)\n        # Ensure the input grid has exactly 4 colors\n        if len(palette(gi)) == 4:\n            break\n    # 50% chance to diagonally mirror both input and output grids\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "22168020": {
    "original": "def generate_22168020(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    num = unifint(diff_lb, diff_ub, (1, min(9, (h * w) // 10)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    succ = 0\n    tr = 0\n    maxtr = 6 * num\n    inds = asindices(gi)\n    while tr < maxtr and succ < num:\n        d = unifint(diff_lb, diff_ub, (2, 5))\n        oh = d + 1\n        ow = 2 * d\n        if len(inds) == 0:\n            tr += 1\n            continue\n        loc = choice(totuple(inds))\n        loci, locj = loc\n        io1 = connect(loc, (loci + d - 1, locj + d - 1))\n        io2 = connect((loci, locj + ow - 1), (loci + d - 1, locj + d))\n        io = io1 | io2 | {(loci + d, locj + d - 1), (loci + d, locj + d)}\n        oo = merge(sfilter(prapply(connect, io, io), hline))\n        mf = choice((identity, dmirror, cmirror, hmirror, vmirror))\n        io = mf(io)\n        oo = mf(oo)\n        col = choice(remcols)\n        if oo.issubset(inds):\n            gi = fill(gi, col, io)\n            go = fill(go, col, oo)\n            succ += 1\n            inds = inds - oo\n            remcols = remove(col, remcols)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_22168020(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly determine the height of the grid between 6 and 30\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    # Randomly determine the width of the grid between 6 and 30\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    # Determine the number of shapes to draw, between 1 and min(9, 10% of grid area)\n    num = unifint(diff_lb, diff_ub, (1, min(9, (h * w) // 10)))\n    # Choose a random background color\n    bgc = choice(cols)\n    # Create a list of remaining colors (all colors except the background color)\n    remcols = remove(bgc, cols)\n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    # Initialize success counter (number of shapes successfully drawn)\n    succ = 0\n    # Initialize try counter\n    tr = 0\n    # Set maximum number of tries to 6 times the number of shapes to draw\n    maxtr = 6 * num\n    # Get all indices of the input grid\n    inds = asindices(gi)\n    # Main loop for drawing shapes\n    while tr < maxtr and succ < num:\n        # Randomly determine the size of the shape (2 to 5)\n        d = unifint(diff_lb, diff_ub, (2, 5))\n        # Calculate shape height (d + 1)\n        oh = d + 1\n        # Calculate shape width (2 * d)\n        ow = 2 * d\n        # If no more indices available, increment try counter and continue\n        if len(inds) == 0:\n            tr += 1\n            continue\n        # Choose a random location from available indices\n        loc = choice(totuple(inds))\n        # Unpack the chosen location into i and j coordinates\n        loci, locj = loc\n        # Create the first diagonal line of the shape\n        io1 = connect(loc, (loci + d - 1, locj + d - 1))\n        # Create the second diagonal line of the shape\n        io2 = connect((loci, locj + ow - 1), (loci + d - 1, locj + d))\n        # Combine the diagonal lines and add two extra points to form input shape\n        io = io1 | io2 | {(loci + d, locj + d - 1), (loci + d, locj + d)}\n        # Create output shape by connecting points in input shape that form horizontal lines\n        oo = merge(sfilter(prapply(connect, io, io), hline))\n        # Choose a random mirror function (or identity) to transform the shape\n        mf = choice((identity, dmirror, cmirror, hmirror, vmirror))\n        # Apply chosen mirror function to input shape\n        io = mf(io)\n        # Apply chosen mirror function to output shape\n        oo = mf(oo)\n        # Choose a random color for the shape\n        col = choice(remcols)\n        # If the output shape fits within the grid\n        if oo.issubset(inds):\n            # Draw the input shape on the input grid\n            gi = fill(gi, col, io)\n            # Draw the output shape on the output grid\n            go = fill(go, col, oo)\n            # Increment success counter\n            succ += 1\n            # Remove used indices from available indices\n            inds = inds - oo\n            # Remove used color from available colors\n            remcols = remove(col, remcols)\n        # Increment try counter\n        tr += 1\n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "22233c11": {
    "original": "def generate_22233c11(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    succ = 0\n    tr = 0\n    maxtr = 10 * nobjs\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    while succ < nobjs and tr < maxtr:\n        if len(inds) == 0:\n            break\n        tr += 1\n        od = randint(1, 3)\n        fulld = 4 * od\n        g = canvas(bgc, (4, 4))\n        g = fill(g, 8, {(0, 3), (3, 0)})\n        col = choice(ccols)\n        g = fill(g, col, {(1, 1), (2, 2)})\n        if choice((True, False)):\n            g = hmirror(g)\n        g = upscale(g, od)\n        inobj = recolor(col, ofcolor(g, col))\n        outobj = inobj | recolor(8, ofcolor(g, 8))\n        loc = choice(totuple(inds))\n        outobj = shift(outobj, loc)\n        inobj = shift(inobj, loc)\n        outobji = toindices(outobj)\n        if toindices(inobj).issubset(inds) and (outobji & fullinds).issubset(inds):\n            succ += 1\n            inds = (inds - outobji) - mapply(neighbors, outobji)\n            gi = paint(gi, inobj)\n            go = paint(go, outobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_22233c11(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Determine the number of objects to place based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    \n    # Initialize counter for successfully placed objects\n    succ = 0\n    \n    # Initialize counter for placement attempts\n    tr = 0\n    \n    # Set maximum number of placement attempts\n    maxtr = 10 * nobjs\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Create a copy of all indices (used for checking object placement)\n    fullinds = asindices(gi)\n    \n    # Randomly determine the number of colors to use for objects\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors for objects\n    ccols = sample(remcols, ncols)\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        # Break if no more valid positions are available\n        if len(inds) == 0:\n            break\n        \n        # Increment attempt counter\n        tr += 1\n        \n        # Randomly choose object dimension (1, 2, or 3)\n        od = randint(1, 3)\n        \n        # Calculate full dimension of object (including outline)\n        fulld = 4 * od\n        \n        # Create a 4x4 grid with background color\n        g = canvas(bgc, (4, 4))\n        \n        # Add outline corners to the grid (color 8)\n        g = fill(g, 8, {(0, 3), (3, 0)})\n        \n        # Randomly choose a color for the object\n        col = choice(ccols)\n        \n        # Add the object's core to the grid\n        g = fill(g, col, {(1, 1), (2, 2)})\n        \n        # Randomly mirror the object horizontally (50% chance)\n        if choice((True, False)):\n            g = hmirror(g)\n        \n        # Scale up the object based on the chosen dimension\n        g = upscale(g, od)\n        \n        # Create the input object (core only)\n        inobj = recolor(col, ofcolor(g, col))\n        \n        # Create the output object (core + outline)\n        outobj = inobj | recolor(8, ofcolor(g, 8))\n        \n        # Choose a random location for the object\n        loc = choice(totuple(inds))\n        \n        # Shift the output object to the chosen location\n        outobj = shift(outobj, loc)\n        \n        # Shift the input object to the chosen location\n        inobj = shift(inobj, loc)\n        \n        # Get indices of the output object\n        outobji = toindices(outobj)\n        \n        # Check if the object can be placed without overlapping\n        if toindices(inobj).issubset(inds) and (outobji & fullinds).issubset(inds):\n            # Increment success counter\n            succ += 1\n            \n            # Remove placed object and its neighbors from available indices\n            inds = (inds - outobji) - mapply(neighbors, outobji)\n            \n            # Add the input object to the input grid\n            gi = paint(gi, inobj)\n            \n            # Add the output object to the output grid\n            go = paint(go, outobj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "2281f1f4": {
    "original": "def generate_2281f1f4(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    card_h_bounds = (1, h // 2 + 1)\n    card_w_bounds = (1, w // 2 + 1)\n    numtop = unifint(diff_lb, diff_ub, card_w_bounds)\n    numright = unifint(diff_lb, diff_ub, card_h_bounds)\n    if numtop == numright == 1:\n        numtop, numright = sample([1, 2], 2)\n    tp = sample(interval(0, w - 1, 1), numtop)\n    rp = sample(interval(1, h, 1), numright)\n    res = combine(apply(lbind(astuple, 0), tp), apply(rbind(astuple, w - 1), rp))\n    bgc = choice(colopts)\n    dc = choice(remove(bgc, colopts))\n    gi = fill(canvas(bgc, (h, w)), dc, res)\n    go = fill(gi, 2, product(rp, tp))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2281f1f4(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Create a list of color options (0-9) excluding 2\n    colopts = remove(2, interval(0, 10, 1))\n    # Randomly generate height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly generate width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Define bounds for number of horizontal markers (1 to half of height + 1)\n    card_h_bounds = (1, h // 2 + 1)\n    # Define bounds for number of vertical markers (1 to half of width + 1)\n    card_w_bounds = (1, w // 2 + 1)\n    # Randomly generate number of top markers based on difficulty\n    numtop = unifint(diff_lb, diff_ub, card_w_bounds)\n    # Randomly generate number of right markers based on difficulty\n    numright = unifint(diff_lb, diff_ub, card_h_bounds)\n    # Ensure at least one of numtop or numright is greater than 1\n    if numtop == numright == 1:\n        numtop, numright = sample([1, 2], 2)\n    # Randomly select positions for top markers\n    tp = sample(interval(0, w - 1, 1), numtop)\n    # Randomly select positions for right markers (excluding top row)\n    rp = sample(interval(1, h, 1), numright)\n    # Combine top and right marker positions\n    res = combine(apply(lbind(astuple, 0), tp), apply(rbind(astuple, w - 1), rp))\n    # Randomly select background color\n    bgc = choice(colopts)\n    # Randomly select dot color (different from background)\n    dc = choice(remove(bgc, colopts))\n    # Create input grid with background color and markers\n    gi = fill(canvas(bgc, (h, w)), dc, res)\n    # Create output grid by filling intersection points with color 2\n    go = fill(gi, 2, product(rp, tp))\n    # Randomly select a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply rotation to input grid\n    gi = rotf(gi)\n    # Apply same rotation to output grid\n    go = rotf(go)\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "228f6490": {
    "original": "def generate_228f6490(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 50))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nsq\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    sqc = choice(remcols)\n    remcols = remove(sqc, remcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    forbidden = []\n    while tr < maxtr and succ < nsq:\n        tr += 1\n        oh = randint(3, 6)\n        ow = randint(3, 6)\n        bd = asindices(canvas(-1, (oh, ow)))\n        bounds = shift(asindices(canvas(-1, (oh-2, ow-2))), (1, 1))\n        obj = {choice(totuple(bounds))}\n        ncells = randint(1, (oh-2) * (ow-2))\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        sqcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(sqcands) == 0:\n            continue\n        loc = choice(totuple(sqcands))\n        bdplcd = shift(bd, loc)\n        if bdplcd.issubset(inds):\n            tmpinds = inds - bdplcd\n            inobjn = normalize(obj)\n            oh, ow = shape(obj)\n            inobjcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(inobjcands) == 0:\n                continue\n            loc2 = choice(totuple(inobjcands))\n            inobjplcd = shift(inobjn, loc2)\n            bdnorm = bd - obj\n            if inobjplcd.issubset(tmpinds) and bdnorm not in forbidden and inobjn not in forbidden:\n                forbidden.append(bdnorm)\n                forbidden.append(inobjn)\n                succ += 1\n                inds = (inds - (bdplcd | inobjplcd)) - mapply(dneighbors, inobjplcd)\n                col = choice(remcols)\n                oplcd = shift(obj, loc)\n                gi = fill(gi, sqc, bdplcd - oplcd)\n                go = fill(go, sqc, bdplcd)\n                go = fill(go, col, oplcd)\n                gi = fill(gi, col, inobjplcd)\n    nremobjs = unifint(diff_lb, diff_ub, (0, len(inds) // 25))\n    succ = 0\n    tr = 0\n    maxtr = 10 * nremobjs\n    while tr < maxtr and succ < nremobjs:\n        tr += 1\n        oh = randint(1, 4)\n        ow = randint(1, 4)\n        bounds = asindices(canvas(-1, (oh, ow)))\n        obj = {choice(totuple(bounds))}\n        ncells = randint(1, oh * ow)\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        obj = normalize(obj)\n        if obj in forbidden:\n            continue\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds):\n            succ += 1\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            col = choice(remcols)\n            gi = fill(gi, col, plcd)\n            go = fill(go, col, plcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_228f6490(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly choose width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Determine number of squares to place, between 1 and 1/50th of total area\n    nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 50))\n    # Initialize success counter for placed squares\n    succ = 0\n    # Initialize try counter\n    tr = 0\n    # Set maximum number of tries to 5 times the number of squares\n    maxtr = 5 * nsq\n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    # Choose a random color for squares\n    sqc = choice(remcols)\n    # Remove square color from remaining colors\n    remcols = remove(sqc, remcols)\n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    # Get all indices of the grid\n    inds = asindices(gi)\n    # Initialize list to track forbidden shapes\n    forbidden = []\n\n    # Main loop for placing squares and their corresponding inner objects\n    while tr < maxtr and succ < nsq:\n        # Increment try counter\n        tr += 1\n        # Choose random height for outer square (3 to 6)\n        oh = randint(3, 6)\n        # Choose random width for outer square (3 to 6)\n        ow = randint(3, 6)\n        # Create indices for the outer square\n        bd = asindices(canvas(-1, (oh, ow)))\n        # Create indices for the inner area of the square\n        bounds = shift(asindices(canvas(-1, (oh-2, ow-2))), (1, 1))\n        # Choose a random starting cell for the inner object\n        obj = {choice(totuple(bounds))}\n        # Determine number of cells for inner object\n        ncells = randint(1, (oh-2) * (ow-2))\n        # Grow the inner object\n        for k in range(ncells - 1):\n            # Add a neighboring cell to the object\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        # Find possible locations to place the square\n        sqcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # If no valid locations, continue to next iteration\n        if len(sqcands) == 0:\n            continue\n        # Choose a random location for the square\n        loc = choice(totuple(sqcands))\n        # Shift the outer square to the chosen location\n        bdplcd = shift(bd, loc)\n        # Check if the placed square fits within the grid\n        if bdplcd.issubset(inds):\n            # Remove square area from available indices\n            tmpinds = inds - bdplcd\n            # Normalize the inner object (shift to origin)\n            inobjn = normalize(obj)\n            # Get dimensions of inner object\n            oh, ow = shape(obj)\n            # Find possible locations for inner object\n            inobjcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            # If no valid locations, continue to next iteration\n            if len(inobjcands) == 0:\n                continue\n            # Choose a random location for inner object\n            loc2 = choice(totuple(inobjcands))\n            # Place the inner object\n            inobjplcd = shift(inobjn, loc2)\n            # Get the normalized outer square shape\n            bdnorm = bd - obj\n            # Check if shapes are not forbidden and inner object fits\n            if inobjplcd.issubset(tmpinds) and bdnorm not in forbidden and inobjn not in forbidden:\n                # Add shapes to forbidden list\n                forbidden.append(bdnorm)\n                forbidden.append(inobjn)\n                # Increment success counter\n                succ += 1\n                # Update available indices\n                inds = (inds - (bdplcd | inobjplcd)) - mapply(dneighbors, inobjplcd)\n                # Choose a random color for inner object\n                col = choice(remcols)\n                # Place the outer square on the input grid\n                oplcd = shift(obj, loc)\n                gi = fill(gi, sqc, bdplcd - oplcd)\n                # Place the full square on the output grid\n                go = fill(go, sqc, bdplcd)\n                # Place the inner object on the output grid\n                go = fill(go, col, oplcd)\n                # Place the inner object on the input grid\n                gi = fill(gi, col, inobjplcd)\n\n    # Determine number of additional objects to place\n    nremobjs = unifint(diff_lb, diff_ub, (0, len(inds) // 25))\n    # Reset success and try counters\n    succ = 0\n    tr = 0\n    # Set maximum tries for additional objects\n    maxtr = 10 * nremobjs\n\n    # Loop for placing additional objects\n    while tr < maxtr and succ < nremobjs:\n        # Increment try counter\n        tr += 1\n        # Choose random height for object (1 to 4)\n        oh = randint(1, 4)\n        # Choose random width for object (1 to 4)\n        ow = randint(1, 4)\n        # Create indices for the object\n        bounds = asindices(canvas(-1, (oh, ow)))\n        # Choose a random starting cell for the object\n        obj = {choice(totuple(bounds))}\n        # Determine number of cells for object\n        ncells = randint(1, oh * ow)\n        # Grow the object\n        for k in range(ncells - 1):\n            # Add a neighboring cell to the object\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        # Normalize the object (shift to origin)\n        obj = normalize(obj)\n        # If object shape is forbidden, continue to next iteration\n        if obj in forbidden:\n            continue\n        # Find possible locations to place the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # If no valid locations, continue to next iteration\n        if len(cands) == 0:\n            continue\n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        # Place the object\n        plcd = shift(obj, loc)\n        # Check if the placed object fits within the grid\n        if plcd.issubset(inds):\n            # Increment success counter\n            succ += 1\n            # Update available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            # Choose a random color for the object\n            col = choice(remcols)\n            # Place the object on both input and output grids\n            gi = fill(gi, col, plcd)\n            go = fill(go, col, plcd)\n\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "22eb0ac0": {
    "original": "def generate_22eb0ac0(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    gi = canvas(0, (1, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nlocs = unifint(diff_lb, diff_ub, (1, h))\n    locs = sample(interval(0, h, 1), nlocs)\n    while set(locs).issubset({0, h - 1}):\n        locs = sample(interval(0, h, 1), nlocs)\n    mp = nlocs // 2\n    nbarsdev = unifint(diff_lb, diff_ub, (0, mp))\n    nbars = choice((nbarsdev, h - nbarsdev))\n    nbars = max(0, min(nbars, nlocs))\n    barlocs = sample(locs, nbars)\n    nonbarlocs = difference(locs, barlocs)\n    barcols = [choice(remcols) for j in range(nbars)]\n    acols = [choice(remcols) for j in range(len(nonbarlocs))]\n    bcols = [choice(remove(acols[j], remcols)) for j in range(len(nonbarlocs))]\n    for bc, bl in zip(barcols, barlocs):\n        gi = fill(gi, bc, ((bl, 0), (bl, w - 1)))\n        go = fill(go, bc, connect((bl, 0), (bl, w - 1)))\n    for (a, b), loc in zip(zip(acols, bcols), nonbarlocs):\n        gi = fill(gi, a, {(loc, 0)})\n        go = fill(go, a, {(loc, 0)})\n        gi = fill(gi, b, {(loc, w - 1)})\n        go = fill(go, b, {(loc, w - 1)})\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_22eb0ac0(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Initialize a 1x1 grid with color 0\n    gi = canvas(0, (1, 1))\n    \n    # Randomly choose height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(colopts)\n    \n    # Create a list of colors excluding the background color\n    remcols = remove(bgc, colopts)\n    \n    # Create input grid with chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with same background color and dimensions\n    go = canvas(bgc, (h, w))\n    \n    # Choose number of locations to modify, between 1 and height\n    nlocs = unifint(diff_lb, diff_ub, (1, h))\n    \n    # Randomly select row indices to modify\n    locs = sample(interval(0, h, 1), nlocs)\n    \n    # Ensure not all selected locations are on the top and bottom edges\n    while set(locs).issubset({0, h - 1}):\n        locs = sample(interval(0, h, 1), nlocs)\n    \n    # Calculate midpoint of number of locations\n    mp = nlocs // 2\n    \n    # Choose a deviation for number of bars\n    nbarsdev = unifint(diff_lb, diff_ub, (0, mp))\n    \n    # Decide number of bars, either close to 0 or close to nlocs\n    nbars = choice((nbarsdev, h - nbarsdev))\n    \n    # Ensure number of bars is between 0 and nlocs\n    nbars = max(0, min(nbars, nlocs))\n    \n    # Randomly select which locations will have bars\n    barlocs = sample(locs, nbars)\n    \n    # Determine locations without bars\n    nonbarlocs = difference(locs, barlocs)\n    \n    # Choose colors for bars\n    barcols = [choice(remcols) for j in range(nbars)]\n    \n    # Choose colors for left side of non-bar locations\n    acols = [choice(remcols) for j in range(len(nonbarlocs))]\n    \n    # Choose different colors for right side of non-bar locations\n    bcols = [choice(remove(acols[j], remcols)) for j in range(len(nonbarlocs))]\n    \n    # Fill in bars on input and output grids\n    for bc, bl in zip(barcols, barlocs):\n        # Add bar endpoints to input grid\n        gi = fill(gi, bc, ((bl, 0), (bl, w - 1)))\n        # Add full bar to output grid\n        go = fill(go, bc, connect((bl, 0), (bl, w - 1)))\n    \n    # Fill in non-bar locations on input and output grids\n    for (a, b), loc in zip(zip(acols, bcols), nonbarlocs):\n        # Add left endpoint to input and output grids\n        gi = fill(gi, a, {(loc, 0)})\n        go = fill(go, a, {(loc, 0)})\n        # Add right endpoint to input and output grids\n        gi = fill(gi, b, {(loc, w - 1)})\n        go = fill(go, b, {(loc, w - 1)})\n    \n    # 50% chance to mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "234bbc79": {
    "original": "def generate_234bbc79(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        w = unifint(diff_lb, diff_ub, (6, 20))\n        bgc, dotc = sample(cols, 2)\n        remcols = difference(cols, (bgc, dotc))\n        go = canvas(bgc, (h, 30))\n        ncols = unifint(diff_lb, diff_ub, (1, 8))\n        ccols = sample(remcols, ncols)\n        spi = randint(0, h - 1)\n        snek = [(spi, 0)]\n        gi = fill(go, dotc, {(spi, 0)})\n        while True:\n            previ, prevj = snek[-1]\n            if prevj == w - 1:\n                if choice((True, False, False)):\n                    break\n            options = []\n            if previ < h - 1:\n                if go[previ+1][prevj] == bgc:\n                    options.append((previ+1, prevj))\n            if previ > 0:\n                if go[previ-1][prevj] == bgc:\n                    options.append((previ-1, prevj))\n            if prevj < w - 1:\n                options.append((previ, prevj+1))\n            if len(options) == 0:\n                break\n            loc = choice(options)\n            snek.append(loc)\n            go = fill(go, dotc, {loc})\n        objs = []\n        cobj = []\n        for idx, cel in enumerate(snek):\n            if len(cobj) > 2 and width(frozenset(cobj)) > 1 and snek[idx-1] == add(cel, (0, -1)):\n                objs.append(cobj)\n                cobj = [cel]\n            else:\n                cobj.append(cel)\n        objs[-1] += cobj\n        nobjs = len(objs)\n        if nobjs < 2:\n            continue\n        ntokeep = unifint(diff_lb, diff_ub, (2, nobjs))\n        ntorem = nobjs - ntokeep\n        for k in range(ntorem):\n            idx = randint(0, len(objs) - 2)\n            objs = objs[:idx] + [objs[idx] + objs[idx+1]] + objs[idx+2:]\n        inobjs = []\n        for idx, obj in enumerate(objs):\n            col = choice(ccols)\n            go = fill(go, col, set(obj))\n            centerpart = recolor(col, set(obj[1:-1]))\n            leftpart = {(dotc if idx > 0 else col, obj[0])}\n            rightpart = {(dotc if idx < len(objs) - 1 else col, obj[-1])}\n            inobj = centerpart | leftpart | rightpart\n            inobjs.append(inobj)\n        spacings = [1 for idx in range(len(inobjs) - 1)]\n        fullw = unifint(diff_lb, diff_ub, (w, 30))\n        for k in range(fullw - w - len(inobjs) - 1):\n            idx = randint(0, len(spacings) - 1)\n            spacings[idx] += 1\n        lspacings = [0] + spacings\n        gi = canvas(bgc, (h, fullw))\n        ofs = 0\n        for i, (lsp, obj) in enumerate(zip(lspacings, inobjs)):\n            obj = set(obj)\n            if i == 0:\n                ulc = ulcorner(obj)\n            else:\n                ulci = randint(0, h - height(obj))\n                ulcj = ofs + lsp\n                ulc = (ulci, ulcj)\n            ofs += width(obj) + lsp\n            plcd = shift(normalize(obj), ulc)\n            gi = paint(gi, plcd)\n        break\n    ins = size(merge(fgpartition(gi)))\n    while True:\n        go2 = dmirror(dmirror(go)[:-1])\n        if size(sfilter(asobject(go2), lambda cij: cij[0] != bgc)) < ins:\n            break\n        else:\n            go = go2\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_234bbc79(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    while True:\n        # Randomly generate height and width within specified ranges based on difficulty\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        w = unifint(diff_lb, diff_ub, (6, 20))\n        # Randomly select background and dot colors\n        bgc, dotc = sample(cols, 2)\n        # Get remaining colors after removing background and dot colors\n        remcols = difference(cols, (bgc, dotc))\n        # Create initial output grid with background color\n        go = canvas(bgc, (h, 30))\n        # Randomly select number of colors to use for the snake\n        ncols = unifint(diff_lb, diff_ub, (1, 8))\n        # Randomly select colors for the snake\n        ccols = sample(remcols, ncols)\n        # Randomly select starting position for the snake\n        spi = randint(0, h - 1)\n        # Initialize snake with starting position\n        snek = [(spi, 0)]\n        # Place dot at starting position in the input grid\n        gi = fill(go, dotc, {(spi, 0)})\n        \n        while True:\n            # Get previous position of snake\n            previ, prevj = snek[-1]\n            # Check if snake has reached the right edge\n            if prevj == w - 1:\n                # 1/3 chance to end the snake\n                if choice((True, False, False)):\n                    break\n            options = []\n            # Check if snake can move down\n            if previ < h - 1:\n                if go[previ+1][prevj] == bgc:\n                    options.append((previ+1, prevj))\n            # Check if snake can move up\n            if previ > 0:\n                if go[previ-1][prevj] == bgc:\n                    options.append((previ-1, prevj))\n            # Snake can always move right if not at edge\n            if prevj < w - 1:\n                options.append((previ, prevj+1))\n            # If no options, end snake\n            if len(options) == 0:\n                break\n            # Randomly choose next position\n            loc = choice(options)\n            # Add new position to snake\n            snek.append(loc)\n            # Fill new position with dot color in output grid\n            go = fill(go, dotc, {loc})\n        \n        objs = []\n        cobj = []\n        # Segment snake into objects\n        for idx, cel in enumerate(snek):\n            # Start new object if current object is wide enough and previous cell was to the left\n            if len(cobj) > 2 and width(frozenset(cobj)) > 1 and snek[idx-1] == add(cel, (0, -1)):\n                objs.append(cobj)\n                cobj = [cel]\n            else:\n                cobj.append(cel)\n        # Add last object\n        objs[-1] += cobj\n        \n        nobjs = len(objs)\n        # Ensure at least 2 objects\n        if nobjs < 2:\n            continue\n        # Randomly determine number of objects to keep\n        ntokeep = unifint(diff_lb, diff_ub, (2, nobjs))\n        ntorem = nobjs - ntokeep\n        # Merge random adjacent objects\n        for k in range(ntorem):\n            idx = randint(0, len(objs) - 2)\n            objs = objs[:idx] + [objs[idx] + objs[idx+1]] + objs[idx+2:]\n        \n        inobjs = []\n        # Color objects and create input objects\n        for idx, obj in enumerate(objs):\n            col = choice(ccols)\n            # Fill object with chosen color in output grid\n            go = fill(go, col, set(obj))\n            # Create center part of input object\n            centerpart = recolor(col, set(obj[1:-1]))\n            # Create left part of input object (dot color if not first, chosen color if first)\n            leftpart = {(dotc if idx > 0 else col, obj[0])}\n            # Create right part of input object (dot color if not last, chosen color if last)\n            rightpart = {(dotc if idx < len(objs) - 1 else col, obj[-1])}\n            # Combine parts to create input object\n            inobj = centerpart | leftpart | rightpart\n            inobjs.append(inobj)\n        \n        # Initialize spacings between objects\n        spacings = [1 for idx in range(len(inobjs) - 1)]\n        # Randomly determine full width of input grid\n        fullw = unifint(diff_lb, diff_ub, (w, 30))\n        # Randomly increase spacings\n        for k in range(fullw - w - len(inobjs) - 1):\n            idx = randint(0, len(spacings) - 1)\n            spacings[idx] += 1\n        # Add initial spacing\n        lspacings = [0] + spacings\n        \n        # Create input grid with background color\n        gi = canvas(bgc, (h, fullw))\n        ofs = 0\n        # Place objects in input grid\n        for i, (lsp, obj) in enumerate(zip(lspacings, inobjs)):\n            obj = set(obj)\n            if i == 0:\n                # Place first object at original vertical position\n                ulc = ulcorner(obj)\n            else:\n                # Randomly determine vertical position for other objects\n                ulci = randint(0, h - height(obj))\n                ulcj = ofs + lsp\n                ulc = (ulci, ulcj)\n            ofs += width(obj) + lsp\n            # Shift object to new position\n            plcd = shift(normalize(obj), ulc)\n            # Paint object onto input grid\n            gi = paint(gi, plcd)\n        break\n    \n    # Count non-background cells in input grid\n    ins = size(merge(fgpartition(gi)))\n    while True:\n        # Rotate output grid and remove last row\n        go2 = dmirror(dmirror(go)[:-1])\n        # Check if rotated grid has fewer non-background cells than input\n        if size(sfilter(asobject(go2), lambda cij: cij[0] != bgc)) < ins:\n            break\n        else:\n            # If not, update output grid and continue rotating\n            go = go2\n    \n    # Return input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "23581191": {
    "original": "def generate_23581191(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = remove(2, interval(0, 10, 1))\n    f = fork(combine, hfrontier, vfrontier)\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    bgcol = choice(colopts)\n    remcols = remove(bgcol, colopts)\n    c = canvas(bgcol, (h, w))\n    inds = totuple(asindices(c))\n    acol = choice(remcols)\n    bcol = choice(remove(acol, remcols))\n    card_bounds = (1, (h * w) // 4)\n    na = unifint(diff_lb, diff_ub, card_bounds)\n    nb = unifint(diff_lb, diff_ub, card_bounds)\n    a = sample(inds, na)\n    b = sample(difference(inds, a), nb)\n    gi = fill(c, acol, a)\n    gi = fill(gi, bcol, b)\n    fa = apply(first, a)\n    la = apply(last, a)\n    fb = apply(first, b)\n    lb = apply(last, b)\n    alins = sfilter(inds, lambda ij: first(ij) in fa or last(ij) in la)\n    blins = sfilter(inds, lambda ij: first(ij) in fb or last(ij) in lb)\n    go = fill(c, acol, alins)\n    go = fill(go, bcol, blins)\n    go = fill(go, 2, intersection(set(alins), set(blins)))\n    go = fill(go, acol, a)\n    go = fill(go, bcol, b)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_23581191(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Create a list of color options, excluding 2\n    colopts = remove(2, interval(0, 10, 1))\n    # Create a function that combines horizontal and vertical frontiers\n    f = fork(combine, hfrontier, vfrontier)\n    # Randomly choose height within difficulty bounds\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose width within difficulty bounds\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly select background color\n    bgcol = choice(colopts)\n    # Create list of remaining colors, excluding background color\n    remcols = remove(bgcol, colopts)\n    # Create a canvas (grid) with chosen background color and dimensions\n    c = canvas(bgcol, (h, w))\n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    # Randomly select first object color\n    acol = choice(remcols)\n    # Randomly select second object color, different from first\n    bcol = choice(remove(acol, remcols))\n    # Define bounds for number of cells per object\n    card_bounds = (1, (h * w) // 4)\n    # Randomly choose number of cells for first object\n    na = unifint(diff_lb, diff_ub, card_bounds)\n    # Randomly choose number of cells for second object\n    nb = unifint(diff_lb, diff_ub, card_bounds)\n    # Randomly select indices for first object\n    a = sample(inds, na)\n    # Randomly select indices for second object, ensuring no overlap with first\n    b = sample(difference(inds, a), nb)\n    # Create input grid by filling first object cells\n    gi = fill(c, acol, a)\n    # Fill second object cells in input grid\n    gi = fill(gi, bcol, b)\n    # Get first row indices of first object\n    fa = apply(first, a)\n    # Get last row indices of first object\n    la = apply(last, a)\n    # Get first row indices of second object\n    fb = apply(first, b)\n    # Get last row indices of second object\n    lb = apply(last, b)\n    # Select all cells in rows containing first object\n    alins = sfilter(inds, lambda ij: first(ij) in fa or last(ij) in la)\n    # Select all cells in rows containing second object\n    blins = sfilter(inds, lambda ij: first(ij) in fb or last(ij) in lb)\n    # Create output grid by filling rows containing first object\n    go = fill(c, acol, alins)\n    # Fill rows containing second object in output grid\n    go = fill(go, bcol, blins)\n    # Fill intersecting cells with color 2 (creates cross pattern)\n    go = fill(go, 2, intersection(set(alins), set(blins)))\n    # Restore original first object cells in output grid\n    go = fill(go, acol, a)\n    # Restore original second object cells in output grid\n    go = fill(go, bcol, b)\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "239be575": {
    "original": "def generate_239be575(diff_lb: float, diff_ub: float) -> dict:\n    sq = {(0, 0), (1, 1), (0, 1), (1, 0)}\n    cols = interval(1, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, (6, 30))\n        w = unifint(diff_lb, diff_ub, (6, 30))\n        c = canvas(0, (h, w))\n        fullcands = totuple(asindices(canvas(0, (h - 1, w - 1))))\n        a = choice(fullcands)\n        b = choice(remove(a, fullcands))\n        mindist = unifint(diff_lb, diff_ub, (3, min(h, w) - 3))\n        while not manhattan({a}, {b}) > mindist:\n            a = choice(fullcands)\n            b = choice(remove(a, fullcands))\n        markcol, sqcol = sample(cols, 2)\n        aset = shift(sq, a)\n        bset = shift(sq, b)\n        gi = fill(c, sqcol, aset | bset)\n        cands = totuple(ofcolor(gi, 0))\n        num = unifint(diff_lb, diff_ub, (int(0.25 * len(cands)), int(0.75 * len(cands))))\n        mc = sample(cands, num)\n        gi = fill(gi, markcol, mc)\n        bobjs = colorfilter(objects(gi, T, F, F), markcol)\n        ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        shoudlhaveconn = choice((True, False))\n        if shoudlhaveconn and len(ss) == 0:\n            while len(ss) == 0:\n                opts2 = totuple(ofcolor(gi, 0))\n                if len(opts2) == 0:\n                    break\n                gi = fill(gi, markcol, {choice(opts2)})\n                bobjs = colorfilter(objects(gi, T, F, F), markcol)\n                ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        elif not shoudlhaveconn and len(ss) > 0:\n            while len(ss) > 0:\n                opts2 = totuple(ofcolor(gi, markcol))\n                if len(opts2) == 0:\n                    break\n                gi = fill(gi, 0, {choice(opts2)})\n                bobjs = colorfilter(objects(gi, T, F, F), markcol)\n                ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        if len(palette(gi)) == 3:\n            break\n    oc = markcol if shoudlhaveconn else 0\n    go = canvas(oc, (1, 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_239be575(diff_lb: float, diff_ub: float) -> dict:\n    # Define a 2x2 square shape\n    sq = {(0, 0), (1, 1), (0, 1), (1, 0)}\n    # Create a range of colors from 1 to 9\n    cols = interval(1, 10, 1)\n    while True:\n        # Randomly generate height between 6 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (6, 30))\n        # Randomly generate width between 6 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (6, 30))\n        # Create an empty canvas filled with 0s\n        c = canvas(0, (h, w))\n        # Generate all possible cell coordinates for the grid\n        fullcands = totuple(asindices(canvas(0, (h - 1, w - 1))))\n        # Randomly select a coordinate for the first square\n        a = choice(fullcands)\n        # Randomly select a different coordinate for the second square\n        b = choice(remove(a, fullcands))\n        # Generate a minimum distance between squares based on difficulty\n        mindist = unifint(diff_lb, diff_ub, (3, min(h, w) - 3))\n        # Ensure the two squares are far enough apart\n        while not manhattan({a}, {b}) > mindist:\n            a = choice(fullcands)\n            b = choice(remove(a, fullcands))\n        # Randomly select two different colors for marking and squares\n        markcol, sqcol = sample(cols, 2)\n        # Create the first square at position 'a'\n        aset = shift(sq, a)\n        # Create the second square at position 'b'\n        bset = shift(sq, b)\n        # Draw both squares on the grid\n        gi = fill(c, sqcol, aset | bset)\n        # Find all empty cells in the grid\n        cands = totuple(ofcolor(gi, 0))\n        # Determine number of cells to mark based on difficulty\n        num = unifint(diff_lb, diff_ub, (int(0.25 * len(cands)), int(0.75 * len(cands))))\n        # Randomly select cells to mark\n        mc = sample(cands, num)\n        # Mark the selected cells with the marking color\n        gi = fill(gi, markcol, mc)\n        # Find all objects of the marking color\n        bobjs = colorfilter(objects(gi, T, F, F), markcol)\n        # Find objects that are adjacent to both squares\n        ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        # Randomly decide if there should be a connecting object\n        shoudlhaveconn = choice((True, False))\n        # If there should be a connection but isn't, add marks until there is\n        if shoudlhaveconn and len(ss) == 0:\n            while len(ss) == 0:\n                opts2 = totuple(ofcolor(gi, 0))\n                if len(opts2) == 0:\n                    break\n                # Add a random mark\n                gi = fill(gi, markcol, {choice(opts2)})\n                bobjs = colorfilter(objects(gi, T, F, F), markcol)\n                ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        # If there shouldn't be a connection but there is, remove marks until there isn't\n        elif not shoudlhaveconn and len(ss) > 0:\n            while len(ss) > 0:\n                opts2 = totuple(ofcolor(gi, markcol))\n                if len(opts2) == 0:\n                    break\n                # Remove a random mark\n                gi = fill(gi, 0, {choice(opts2)})\n                bobjs = colorfilter(objects(gi, T, F, F), markcol)\n                ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))\n        # Ensure the grid has exactly 3 colors (background, square, and mark)\n        if len(palette(gi)) == 3:\n            break\n    # Determine the output color based on whether there should be a connection\n    oc = markcol if shoudlhaveconn else 0\n    # Create a 1x1 grid with the output color\n    go = canvas(oc, (1, 1))\n    # Return the input grid and output grid as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "23b5c85d": {
    "original": "def generate_23b5c85d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    colopts = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    oh = unifint(diff_lb, diff_ub, (2, h - 1))\n    ow = unifint(diff_lb, diff_ub, (2, w - 1))\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    cnt = 0\n    while cnt < num:\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        col = choice(colopts)\n        colopts = remove(col, colopts)\n        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        gi2 = fill(gi, col, obj)\n        if color(argmin(sfilter(partition(gi2), fork(equality, size, fork(multiply, height, width))), fork(multiply, height, width))) != col:\n            break\n        else:\n            gi = gi2\n            go = canvas(col, shape(obj))\n        oh = unifint(diff_lb, diff_ub, (max(0, oh - 4), oh - 1))\n        ow = unifint(diff_lb, diff_ub, (max(0, ow - 4), ow - 1))\n        if oh < 1 or ow < 1:\n            break\n        cnt += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_23b5c85d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of colors excluding the background color\n    colopts = remove(bgc, cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly determine the initial height of objects to be placed\n    oh = unifint(diff_lb, diff_ub, (2, h - 1))\n    \n    # Randomly determine the initial width of objects to be placed\n    ow = unifint(diff_lb, diff_ub, (2, w - 1))\n    \n    # Randomly determine the number of objects to attempt to place\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Initialize a counter for successfully placed objects\n    cnt = 0\n    \n    # Start a loop to place objects\n    while cnt < num:\n        # Randomly choose the top-left corner's row for the new object\n        loci = randint(0, h - oh)\n        \n        # Randomly choose the top-left corner's column for the new object\n        locj = randint(0, w - ow)\n        \n        # Randomly choose a color for the new object\n        col = choice(colopts)\n        \n        # Remove the chosen color from available options to ensure uniqueness\n        colopts = remove(col, colopts)\n        \n        # Create a rectangular area for the new object\n        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Fill the rectangular area with the chosen color\n        gi2 = fill(gi, col, obj)\n        \n        # Check if the newly placed object is the smallest on the grid\n        if color(argmin(sfilter(partition(gi2), fork(equality, size, fork(multiply, height, width))), fork(multiply, height, width))) != col:\n            # If not the smallest, end the loop (object not placed)\n            break\n        else:\n            # If it's the smallest, update the input grid and create the output grid\n            gi = gi2\n            go = canvas(col, shape(obj))\n        \n        # Decrease the height of the next object to be placed\n        oh = unifint(diff_lb, diff_ub, (max(0, oh - 4), oh - 1))\n        \n        # Decrease the width of the next object to be placed\n        ow = unifint(diff_lb, diff_ub, (max(0, ow - 4), ow - 1))\n        \n        # If either dimension becomes less than 1, end the loop\n        if oh < 1 or ow < 1:\n            break\n        \n        # Increment the counter of successfully placed objects\n        cnt += 1\n    \n    # Return a dictionary containing the input grid and the output grid (smallest object)\n    return {'input': gi, 'output': go}\n"
  },
  "253bf280": {
    "original": "def generate_253bf280(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    bgc = choice(colopts)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    card_bounds = (0, max(1, (h * w) // 4))\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    s = sample(inds, num)\n    fgcol = choice(remove(bgc, colopts))\n    gi = fill(c, fgcol, s)\n    resh = frozenset()\n    for x, r in enumerate(gi):\n        if r.count(fgcol) > 1:\n            resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))\n    go = fill(c, 3, resh)\n    resv = frozenset()\n    for x, r in enumerate(dmirror(gi)):\n        if r.count(fgcol) > 1:\n            resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))\n    go = dmirror(fill(dmirror(go), 3, resv))\n    go = fill(go, fgcol, s)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_253bf280(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Create a list of color options, excluding color 3\n    colopts = remove(3, interval(0, 10, 1))\n    # Randomly choose height within difficulty bounds\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose width within difficulty bounds\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly select background color\n    bgc = choice(colopts)\n    # Create a canvas with chosen background color and dimensions\n    c = canvas(bgc, (h, w))\n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    # Set bounds for number of foreground cells\n    card_bounds = (0, max(1, (h * w) // 4))\n    # Randomly choose number of foreground cells within difficulty bounds\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    # Randomly sample indices for foreground cells\n    s = sample(inds, num)\n    # Choose a foreground color different from background color\n    fgcol = choice(remove(bgc, colopts))\n    # Create input grid by filling sampled indices with foreground color\n    gi = fill(c, fgcol, s)\n    # Initialize an empty set for horizontal lines\n    resh = frozenset()\n    # Iterate over rows of the input grid\n    for x, r in enumerate(gi):\n        # If a row has more than one foreground cell\n        if r.count(fgcol) > 1:\n            # Add a horizontal line connecting the leftmost and rightmost foreground cells\n            resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))\n    # Create output grid by filling horizontal lines with color 3\n    go = fill(c, 3, resh)\n    # Initialize an empty set for vertical lines\n    resv = frozenset()\n    # Iterate over columns of the input grid (by using dmirror)\n    for x, r in enumerate(dmirror(gi)):\n        # If a column has more than one foreground cell\n        if r.count(fgcol) > 1:\n            # Add a vertical line connecting the topmost and bottommost foreground cells\n            resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))\n    # Add vertical lines to the output grid\n    go = dmirror(fill(dmirror(go), 3, resv))\n    # Add original foreground cells to the output grid\n    go = fill(go, fgcol, s)\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "25d487eb": {
    "original": "def generate_25d487eb(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 8))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    succ = 0\n    tr = 0\n    maxtr = 10 * nobjs\n    inds = asindices(go)\n    while tr < maxtr and succ < nobjs:\n        if len(inds) == 0:\n            break\n        tr += 1\n        dim = randint(1, 3)\n        obj = backdrop(frozenset({(0, 0), (dim, dim)}))\n        obj = sfilter(obj, lambda ij: ij[0] <= ij[1])\n        obj = obj | shift(vmirror(obj), (0, dim))\n        mp = {(0, dim)}\n        tric, linc = sample(ccols, 2)\n        inobj = recolor(tric, obj - mp) | recolor(linc, mp)\n        loc = choice(totuple(inds))\n        iplcd = shift(inobj, loc)\n        loci, locj = loc\n        oplcd = iplcd | recolor(linc, connect((loci, locj + dim), (h - 1, locj + dim)) - toindices(iplcd))\n        fullinds = asindices(gi)\n        oplcdi = toindices(oplcd)\n        if oplcdi.issubset(inds):\n            succ += 1\n            gi = paint(gi, iplcd)\n            go = paint(go, oplcd)\n        rotf = choice((identity, rot90, rot180, rot270))\n        gi = rotf(gi)\n        go = rotf(go)\n        h, w = shape(gi)\n        ofc = ofcolor(go, bgc)\n        inds = ofc - mapply(dneighbors, asindices(go) - ofc)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_25d487eb(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    # Choose a random number of colors to use (between 2 and 8) based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (2, 8))\n    # Sample the chosen number of colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Calculate the number of objects to place (1 to 1/30th of the grid area) based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    # Initialize a counter for successfully placed objects\n    succ = 0\n    # Initialize a counter for placement attempts\n    tr = 0\n    # Set the maximum number of attempts to 10 times the number of objects\n    maxtr = 10 * nobjs\n    # Get all indices of the output grid\n    inds = asindices(go)\n    \n    # Main loop for placing objects\n    while tr < maxtr and succ < nobjs:\n        # Break if there are no more available indices\n        if len(inds) == 0:\n            break\n        # Increment the attempt counter\n        tr += 1\n        # Choose a random dimension for the object (1 to 3)\n        dim = randint(1, 3)\n        # Create a triangular shape\n        obj = backdrop(frozenset({(0, 0), (dim, dim)}))\n        obj = sfilter(obj, lambda ij: ij[0] <= ij[1])\n        # Mirror the triangle to create a diamond shape\n        obj = obj | shift(vmirror(obj), (0, dim))\n        # Define the middle point of the diamond\n        mp = {(0, dim)}\n        # Choose two colors for the object\n        tric, linc = sample(ccols, 2)\n        # Color the object: one color for the diamond, another for the middle point\n        inobj = recolor(tric, obj - mp) | recolor(linc, mp)\n        # Choose a random location on the grid\n        loc = choice(totuple(inds))\n        # Shift the object to the chosen location\n        iplcd = shift(inobj, loc)\n        loci, locj = loc\n        # Create a line from the middle point of the diamond to the bottom of the grid\n        oplcd = iplcd | recolor(linc, connect((loci, locj + dim), (h - 1, locj + dim)) - toindices(iplcd))\n        # Get all indices of the input grid\n        fullinds = asindices(gi)\n        oplcdi = toindices(oplcd)\n        # If the object fits on the grid, place it\n        if oplcdi.issubset(inds):\n            # Increment the success counter\n            succ += 1\n            # Paint the object on the input grid\n            gi = paint(gi, iplcd)\n            # Paint the object and its line on the output grid\n            go = paint(go, oplcd)\n        # Choose a random rotation function\n        rotf = choice((identity, rot90, rot180, rot270))\n        # Apply the rotation to both input and output grids\n        gi = rotf(gi)\n        go = rotf(go)\n        # Update the height and width after rotation\n        h, w = shape(gi)\n        # Find all background color cells in the output grid\n        ofc = ofcolor(go, bgc)\n        # Update available indices, excluding those adjacent to non-background cells\n        inds = ofc - mapply(dneighbors, asindices(go) - ofc)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "25d8a9c8": {
    "original": "def generate_25d8a9c8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    gi = []\n    go = []\n    ncols = unifint(diff_lb, diff_ub, (2, 10))\n    ccols = sample(cols, ncols)\n    for k in range(h):\n        singlecol = choice((True, False))\n        col = choice(ccols)\n        row = repeat(col, w)\n        if singlecol:\n            gi.append(row)\n            go.append(repeat(5, w))\n        else:\n            remcols = remove(col, ccols)\n            nothercinv = unifint(diff_lb, diff_ub, (1, w - 1))\n            notherc = w - 1 - nothercinv\n            notherc = min(max(1, notherc), w - 1)\n            row = list(row)\n            indss = interval(0, w, 1)\n            for j in sample(indss, notherc):\n                row[j] = choice(remcols)\n            gi.append(tuple(row))\n            go.append(repeat(0, w))\n    gi = tuple(gi)\n    go = tuple(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_25d8a9c8(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)    \n    # Randomly choose the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    # Randomly choose the width of the grid between 2 and 30\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    # Initialize empty lists for input and output grids\n    gi = []\n    go = []\n    # Randomly choose the number of colors to use (between 2 and 10)\n    ncols = unifint(diff_lb, diff_ub, (2, 10))\n    # Randomly sample 'ncols' colors from the 'cols' tuple\n    ccols = sample(cols, ncols)\n    # Iterate over each row of the grid\n    for k in range(h):\n        # Randomly decide if this row will be a single color or mixed\n        singlecol = choice((True, False))\n        # Randomly choose a color for this row\n        col = choice(ccols)\n        # Create a row of the chosen color\n        row = repeat(col, w)\n        # If it's a single color row\n        if singlecol:\n            # Add the single color row to the input grid\n            gi.append(row)\n            # Add a row of 5's to the output grid (indicating a single color row in input)\n            go.append(repeat(5, w))\n        else:\n            # Remove the chosen color from the available colors\n            remcols = remove(col, ccols)\n            # Randomly choose how many cells to change color (inverse)\n            nothercinv = unifint(diff_lb, diff_ub, (1, w - 1))\n            # Calculate how many cells to change color\n            notherc = w - 1 - nothercinv\n            # Ensure at least 1 and at most w-1 cells are changed\n            notherc = min(max(1, notherc), w - 1)\n            # Convert the row tuple to a list for modification\n            row = list(row)\n            # Create a list of indices for the row\n            indss = interval(0, w, 1)\n            # Randomly change 'notherc' cells to different colors\n            for j in sample(indss, notherc):\n                row[j] = choice(remcols)\n            # Add the mixed color row to the input grid\n            gi.append(tuple(row))\n            # Add a row of 0's to the output grid (indicating a mixed color row in input)\n            go.append(repeat(0, w))\n    # Convert the input and output grids to tuples\n    gi = tuple(gi)\n    go = tuple(go)\n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "25ff71a9": {
    "original": "def generate_25ff71a9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(c)\n    ch = choice(totuple(bounds))\n    shp = {ch}\n    bounds = remove(ch, bounds)\n    for j in range(nc-1):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    plcd = shift(shp, loc)\n    gi = fill(c, fgc, plcd)\n    go = fill(c, fgc, shift(plcd, (1, 0)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_25ff71a9(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Determine the number of cells for the shape, up to half the grid size\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible cell coordinates in the grid\n    bounds = asindices(c)\n    \n    # Choose a random starting cell for the shape\n    ch = choice(totuple(bounds))\n    \n    # Initialize the shape with the chosen starting cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available coordinates\n    bounds = remove(ch, bounds)\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc-1):\n        # Find neighbors of the current shape that are within bounds\n        # Choose one randomly and add it to the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the normalized shape\n    oh, ow = shape(shp)\n    \n    # Choose a random location to place the shape in the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    \n    # Shift the shape to the chosen location\n    plcd = shift(shp, loc)\n    \n    # Create the input grid by filling the shape with the foreground color\n    gi = fill(c, fgc, plcd)\n    \n    # Create the output grid by shifting the shape down by one cell\n    go = fill(c, fgc, shift(plcd, (1, 0)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "264363fd": {
    "original": "def generate_264363fd(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    cp = (2, 2)\n    neighs = neighbors(cp)\n    o1 = shift(frozenset({(0, 1), (-1, 1)}), (1, 1))\n    o2 = shift(frozenset({(1, 0), (1, -1)}), (1, 1))\n    o3 = shift(frozenset({(2, 1), (3, 1)}), (1, 1))\n    o4 = shift(frozenset({(1, 2), (1, 3)}), (1, 1))\n    mpr = {o1: (-1, 0), o2: (0, -1), o3: (1, 0), o4: (0, 1)}\n    h = unifint(diff_lb, diff_ub, (15, 30))\n    w = unifint(diff_lb, diff_ub, (15, 30))\n    bgc, sqc, linc = sample(cols, 3)\n    remcols = difference(cols, (bgc, sqc, linc))\n    cpcol = choice(remcols)\n    nbhcol = choice(remcols)\n    nspikes = randint(1, 4)\n    spikes = sample((o1, o2, o3, o4), nspikes)\n    lns = merge(set(spikes))\n    obj = {(cpcol, cp)} | recolor(linc, lns) | recolor(nbhcol, neighs - lns)\n    loci = randint(0, h - 5)\n    locj = randint(0, w - 5)\n    loc = (loci, locj)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    gi = paint(gi, shift(obj, loc))\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 100))\n    succ = 0\n    tr = 0\n    maxtr = 10 * numsq\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(shift(obj, loc)))\n    while succ < numsq and tr < maxtr:\n        tr += 1\n        gh = randint(5, h//2+1)\n        gw = randint(5, w//2+1)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - gh and ij[1] <= w - gw)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        g1 = canvas(sqc, (gh, gw))\n        g2 = canvas(sqc, (gh, gw))\n        ginds = asindices(g1)\n        gindsfull = asindices(g1)\n        bck = shift(ginds, loc)\n        if bck.issubset(inds):\n            noccs = unifint(diff_lb, diff_ub, (1, (gh * gw) // 25))\n            succ2 = 0\n            tr2 = 0\n            maxtr2 = 5 * noccs\n            while succ2 < noccs and tr2 < maxtr2:\n                tr2 += 1\n                cands2 = sfilter(ginds, lambda ij: ij[0] <= gh - 5 and ij[1] <= gw - 5)\n                if len(cands2) == 0:\n                    break\n                loc2 = choice(totuple(cands2))\n                lns2 = merge(frozenset({shoot(add(cp, add(loc2, mpr[spike])), mpr[spike]) for spike in spikes}))\n                lns2 = lns2 & gindsfull\n                plcd2 = shift(obj, loc2)\n                plcd2i = toindices(plcd2)\n                if plcd2i.issubset(ginds) and lns2.issubset(ginds | ofcolor(g2, linc)) and len(lns2 - plcd2i) > 0:\n                    succ2 += 1\n                    ginds = ((ginds - plcd2i) - mapply(neighbors, plcd2i)) - lns2\n                    g1 = fill(g1, cpcol, {add(cp, loc2)})\n                    g2 = paint(g2, plcd2)\n                    g2 = fill(g2, linc, lns2)\n            if succ2 > 0:\n                succ += 1\n                inds = (inds - bck) - outbox(bck)\n                objfull1 = shift(asobject(g1), loc)\n                objfull2 = shift(asobject(g2), loc)\n                gi = paint(gi, objfull1)\n                go = paint(go, objfull2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_264363fd(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a central point (2,2)\n    cp = (2, 2)\n    \n    # Get the neighboring cells of the central point\n    neighs = neighbors(cp)\n    \n    # Define four objects (shapes) by shifting coordinates\n    o1 = shift(frozenset({(0, 1), (-1, 1)}), (1, 1))  # L-shape pointing up\n    o2 = shift(frozenset({(1, 0), (1, -1)}), (1, 1))  # L-shape pointing left\n    o3 = shift(frozenset({(2, 1), (3, 1)}), (1, 1))  # Horizontal line\n    o4 = shift(frozenset({(1, 2), (1, 3)}), (1, 1))  # Vertical line\n    \n    # Map each object to a direction\n    mpr = {o1: (-1, 0), o2: (0, -1), o3: (1, 0), o4: (0, 1)}\n    \n    # Generate random height and width based on difficulty\n    h = unifint(diff_lb, diff_ub, (15, 30))\n    w = unifint(diff_lb, diff_ub, (15, 30))\n    \n    # Randomly select colors for background, squares, and lines\n    bgc, sqc, linc = sample(cols, 3)\n    \n    # Get remaining colors\n    remcols = difference(cols, (bgc, sqc, linc))\n    \n    # Randomly choose colors for central point and neighbors\n    cpcol = choice(remcols)\n    nbhcol = choice(remcols)\n    \n    # Randomly decide number of spikes (1 to 4)\n    nspikes = randint(1, 4)\n    \n    # Randomly select which objects will be spikes\n    spikes = sample((o1, o2, o3, o4), nspikes)\n    \n    # Merge all spike objects into one set\n    lns = merge(set(spikes))\n    \n    # Create the main object with central point, lines, and neighbors\n    obj = {(cpcol, cp)} | recolor(linc, lns) | recolor(nbhcol, neighs - lns)\n    \n    # Choose random location for the object\n    loci = randint(0, h - 5)\n    locj = randint(0, w - 5)\n    loc = (loci, locj)\n    \n    # Create input and output grids with background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Paint the object onto the input grid\n    gi = paint(gi, shift(obj, loc))\n    \n    # Determine number of squares to add based on difficulty\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 100))\n    \n    # Initialize counters\n    succ = 0  # Successful placements\n    tr = 0    # Attempts\n    maxtr = 10 * numsq  # Maximum attempts\n    \n    # Get available positions for new squares\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(shift(obj, loc)))\n    \n    # Main loop for adding squares\n    while succ < numsq and tr < maxtr:\n        tr += 1\n        # Choose random height and width for new square\n        gh = randint(5, h//2+1)\n        gw = randint(5, w//2+1)\n        \n        # Find valid positions for the new square\n        cands = sfilter(inds, lambda ij: ij[0] <= h - gh and ij[1] <= w - gw)\n        \n        # If no valid positions, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose random position for the new square\n        loc = choice(totuple(cands))\n        \n        # Create input and output versions of the new square\n        g1 = canvas(sqc, (gh, gw))\n        g2 = canvas(sqc, (gh, gw))\n        \n        # Get indices of the new square\n        ginds = asindices(g1)\n        gindsfull = asindices(g1)\n        \n        # Shift indices to actual position on the grid\n        bck = shift(ginds, loc)\n        \n        # Check if the new square fits in the available space\n        if bck.issubset(inds):\n            # Determine number of objects to place in the square\n            noccs = unifint(diff_lb, diff_ub, (1, (gh * gw) // 25))\n            \n            # Initialize counters for object placement\n            succ2 = 0\n            tr2 = 0\n            maxtr2 = 5 * noccs\n            \n            # Loop for placing objects in the new square\n            while succ2 < noccs and tr2 < maxtr2:\n                tr2 += 1\n                \n                # Find valid positions for new object\n                cands2 = sfilter(ginds, lambda ij: ij[0] <= gh - 5 and ij[1] <= gw - 5)\n                \n                # If no valid positions, break\n                if len(cands2) == 0:\n                    break\n                \n                # Choose random position for new object\n                loc2 = choice(totuple(cands2))\n                \n                # Create lines for the spikes\n                lns2 = merge(frozenset({shoot(add(cp, add(loc2, mpr[spike])), mpr[spike]) for spike in spikes}))\n                lns2 = lns2 & gindsfull\n                \n                # Place the object\n                plcd2 = shift(obj, loc2)\n                plcd2i = toindices(plcd2)\n                \n                # Check if object placement is valid\n                if plcd2i.issubset(ginds) and lns2.issubset(ginds | ofcolor(g2, linc)) and len(lns2 - plcd2i) > 0:\n                    succ2 += 1\n                    \n                    # Update available positions\n                    ginds = ((ginds - plcd2i) - mapply(neighbors, plcd2i)) - lns2\n                    \n                    # Update input and output squares\n                    g1 = fill(g1, cpcol, {add(cp, loc2)})\n                    g2 = paint(g2, plcd2)\n                    g2 = fill(g2, linc, lns2)\n            \n            # If objects were successfully placed\n            if succ2 > 0:\n                succ += 1\n                \n                # Update available positions on main grid\n                inds = (inds - bck) - outbox(bck)\n                \n                # Create full objects for input and output\n                objfull1 = shift(asobject(g1), loc)\n                objfull2 = shift(asobject(g2), loc)\n                \n                # Paint objects onto input and output grids\n                gi = paint(gi, objfull1)\n                go = paint(go, objfull2)\n    \n    # Return the completed input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "272f95fa": {
    "original": "def generate_272f95fa(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6))    \n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, linc = sample(cols, 2)\n    c = canvas(bgc, (5, 5))\n    l1 = connect((1, 0), (1, 4))\n    l2 = connect((3, 0), (3, 4))\n    lns = l1 | l2\n    gi = fill(dmirror(fill(c, linc, lns)), linc, lns)\n    hdist = [0, 0, 0]\n    wdist = [0, 0, 0]\n    idx = 0\n    for k in range(h - 2):\n        hdist[idx] += 1\n        idx = (idx + 1) % 3\n    for k in range(w - 2):\n        wdist[idx] += 1\n        idx = (idx + 1) % 3\n    shuffle(hdist)\n    shuffle(wdist)\n    hdelt1 = unifint(diff_lb, diff_ub, (0, hdist[0] - 1))\n    hdist[0] -= hdelt1\n    hdist[1] += hdelt1\n    hdelt2 = unifint(diff_lb, diff_ub, (0, min(hdist[1], hdist[2]) - 1))\n    hdelt2 = choice((+hdelt2, -hdelt2))\n    hdist[1] += hdelt2\n    hdist[2] -= hdelt2\n    wdelt1 = unifint(diff_lb, diff_ub, (0, wdist[0] - 1))\n    wdist[0] -= wdelt1\n    wdist[1] += wdelt1\n    wdelt2 = unifint(diff_lb, diff_ub, (0, min(wdist[1], wdist[2]) - 1))\n    wdelt2 = choice((+wdelt2, -wdelt2))\n    wdist[1] += wdelt2\n    wdist[2] -= wdelt2\n    gi = gi[:1] * hdist[0] + gi[1:2] + gi[2:3] * hdist[1] + gi[3:4] + gi[4:5] * hdist[2]\n    gi = dmirror(gi)\n    gi = gi[:1] * wdist[0] + gi[1:2] + gi[2:3] * wdist[1] + gi[3:4] + gi[4:5] * wdist[2]\n    gi = dmirror(gi)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n    objs = objects(gi, T, T, F)\n    bgobjs = colorfilter(objs, bgc)\n    cnrs = corners(asindices(gi))\n    bgobjs = sfilter(bgobjs, lambda o: len(toindices(o) & cnrs) == 0)\n    pinkobj = extract(bgobjs, lambda o: not bordering(o, gi))\n    yellobj = argmin(bgobjs, leftmost)\n    greenobj = argmax(bgobjs, rightmost)\n    redobj = argmin(bgobjs, uppermost)\n    blueobj = argmax(bgobjs, lowermost)\n    go = fill(gi, 6, pinkobj)\n    go = fill(go, 4, yellobj)\n    go = fill(go, 3, greenobj)\n    go = fill(go, 2, redobj)\n    go = fill(go, 1, blueobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_272f95fa(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1, 2, 3, 4, and 6\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6))    \n    # Randomly generate the height of the grid between 5 and 30\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly generate the width of the grid between 5 and 30\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly select two colors from cols for background and lines\n    bgc, linc = sample(cols, 2)\n    # Create a 5x5 canvas with the background color\n    c = canvas(bgc, (5, 5))\n    # Define a vertical line from (1,0) to (1,4)\n    l1 = connect((1, 0), (1, 4))\n    # Define another vertical line from (3,0) to (3,4)\n    l2 = connect((3, 0), (3, 4))\n    # Combine the two lines\n    lns = l1 | l2\n    # Fill the lines with the line color and mirror diagonally\n    # This creates a 5x5 grid with an X pattern\n    gi = fill(dmirror(fill(c, linc, lns)), linc, lns)\n    # Initialize lists to store height and width distributions\n    hdist = [0, 0, 0]\n    wdist = [0, 0, 0]\n    idx = 0\n    # Distribute extra height among the three sections\n    for k in range(h - 2):\n        hdist[idx] += 1\n        idx = (idx + 1) % 3\n    # Distribute extra width among the three sections\n    for k in range(w - 2):\n        wdist[idx] += 1\n        idx = (idx + 1) % 3\n    # Randomize the order of height and width distributions\n    shuffle(hdist)\n    shuffle(wdist)\n    # Adjust height distribution randomly\n    hdelt1 = unifint(diff_lb, diff_ub, (0, hdist[0] - 1))\n    hdist[0] -= hdelt1\n    hdist[1] += hdelt1\n    hdelt2 = unifint(diff_lb, diff_ub, (0, min(hdist[1], hdist[2]) - 1))\n    hdelt2 = choice((+hdelt2, -hdelt2))\n    hdist[1] += hdelt2\n    hdist[2] -= hdelt2\n    # Adjust width distribution randomly\n    wdelt1 = unifint(diff_lb, diff_ub, (0, wdist[0] - 1))\n    wdist[0] -= wdelt1\n    wdist[1] += wdelt1\n    wdelt2 = unifint(diff_lb, diff_ub, (0, min(wdist[1], wdist[2]) - 1))\n    wdelt2 = choice((+wdelt2, -wdelt2))\n    wdist[1] += wdelt2\n    wdist[2] -= wdelt2\n    # Expand the grid vertically according to height distribution\n    gi = gi[:1] * hdist[0] + gi[1:2] + gi[2:3] * hdist[1] + gi[3:4] + gi[4:5] * hdist[2]\n    # Mirror the grid diagonally\n    gi = dmirror(gi)\n    # Expand the grid horizontally according to width distribution\n    gi = gi[:1] * wdist[0] + gi[1:2] + gi[2:3] * wdist[1] + gi[3:4] + gi[4:5] * wdist[2]\n    # Mirror the grid diagonally again\n    gi = dmirror(gi)\n    # Define a list of possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    # Apply the chosen number of random transformations to the grid\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n    # Identify all objects in the grid\n    objs = objects(gi, T, T, F)\n    # Filter objects with the background color\n    bgobjs = colorfilter(objs, bgc)\n    # Get the corners of the grid\n    cnrs = corners(asindices(gi))\n    # Filter out background objects that touch the corners\n    bgobjs = sfilter(bgobjs, lambda o: len(toindices(o) & cnrs) == 0)\n    # Find the 'pink' object (not bordering the grid)\n    pinkobj = extract(bgobjs, lambda o: not bordering(o, gi))\n    # Find the leftmost object (yellow)\n    yellobj = argmin(bgobjs, leftmost)\n    # Find the rightmost object (green)\n    greenobj = argmax(bgobjs, rightmost)\n    # Find the topmost object (red)\n    redobj = argmin(bgobjs, uppermost)\n    # Find the bottommost object (blue)\n    blueobj = argmax(bgobjs, lowermost)\n    # Color the identified objects in the output grid\n    go = fill(gi, 6, pinkobj)  # Pink\n    go = fill(go, 4, yellobj)  # Yellow\n    go = fill(go, 3, greenobj)  # Green\n    go = fill(go, 2, redobj)  # Red\n    go = fill(go, 1, blueobj)  # Blue\n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "27a28665": {
    "original": "def generate_27a28665(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    mapping = [\n    (1, {(0, 0), (0, 1), (1, 0), (1, 2), (2, 1)}),\n    (2, {(0, 0), (1, 1), (2, 0), (0, 2), (2, 2)}),\n    (3, {(2, 0), (0, 1), (0, 2), (1, 1), (1, 2)}),\n    (6, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})\n    ]\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    col, obj = choice(mapping)\n    bgc, objc = sample(cols, 2)\n    fac = unifint(diff_lb, diff_ub, (1, min(h, w) // 3))\n    go = canvas(col, (1, 1))\n    gi = canvas(bgc, (h, w))\n    canv = canvas(bgc, (3, 3))\n    canv = fill(canv, objc, obj)\n    canv = upscale(canv, fac)\n    obj = asobject(canv)\n    loci = randint(0, h - 3 * fac)\n    locj = randint(0, w - 3 * fac)\n    loc = (loci, locj)\n    gi = paint(gi, shift(obj, loc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_27a28665(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a mapping of colors to specific shapes (represented as sets of coordinates)\n    mapping = [\n    (1, {(0, 0), (0, 1), (1, 0), (1, 2), (2, 1)}),  # Cross shape\n    (2, {(0, 0), (1, 1), (2, 0), (0, 2), (2, 2)}),  # X shape\n    (3, {(2, 0), (0, 1), (0, 2), (1, 1), (1, 2)}),  # L shape\n    (6, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})   # Plus shape\n    ]\n    \n    # Randomly determine the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a color and its associated shape from the mapping\n    col, obj = choice(mapping)\n    \n    # Randomly select two distinct colors: one for background, one for the object\n    bgc, objc = sample(cols, 2)\n    \n    # Determine the scaling factor for the shape, based on difficulty and grid size\n    fac = unifint(diff_lb, diff_ub, (1, min(h, w) // 3))\n    \n    # Create a 1x1 grid with the chosen shape color (this will be the output)\n    go = canvas(col, (1, 1))\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create a 3x3 canvas with the background color\n    canv = canvas(bgc, (3, 3))\n    \n    # Fill the 3x3 canvas with the object shape using the object color\n    canv = fill(canv, objc, obj)\n    \n    # Upscale the 3x3 canvas by the scaling factor\n    canv = upscale(canv, fac)\n    \n    # Convert the upscaled canvas to an object representation\n    obj = asobject(canv)\n    \n    # Randomly determine the vertical position of the shape in the input grid\n    loci = randint(0, h - 3 * fac)\n    \n    # Randomly determine the horizontal position of the shape in the input grid\n    locj = randint(0, w - 3 * fac)\n    \n    # Combine the vertical and horizontal positions into a tuple\n    loc = (loci, locj)\n    \n    # Paint the scaled and positioned shape onto the input grid\n    gi = paint(gi, shift(obj, loc))\n    \n    # Return a dictionary with the input grid and the output grid (1x1 with shape color)\n    return {'input': gi, 'output': go}\n"
  },
  "28bf18c6": {
    "original": "def generate_28bf18c6(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(colopts)\n    fgc = choice(remove(bgc, colopts))\n    gi = canvas(bgc, (h, w))\n    hb = unifint(diff_lb, diff_ub, (1, min(14, h - 1)))\n    wb = unifint(diff_lb, diff_ub, (1, min(14, w - 1)))\n    bounds = asindices(canvas(0, (hb, wb)))\n    shp = {choice(totuple(corners(bounds)))}\n    mp = (hb * wb) // 2\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    nc = choice((dev, hb * wb - dev))\n    nc = max(0, min(hb * wb - 1, nc))\n    for j in range(nc):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    di = randint(0, h - height(shp))\n    dj = randint(0, w - width(shp))\n    shpp = shift(shp, (di, dj))\n    gi = fill(gi, fgc, shpp)\n    go = fill(canvas(bgc, shape(shp)), fgc, shp)\n    go = hconcat(go, go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_28bf18c6(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly determine height of the input grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine width of the input grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random background color\n    bgc = choice(colopts)\n    \n    # Choose a random foreground color different from the background color\n    fgc = choice(remove(bgc, colopts))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine height of the shape's bounding box (between 1 and min(14, h-1))\n    hb = unifint(diff_lb, diff_ub, (1, min(14, h - 1)))\n    \n    # Determine width of the shape's bounding box (between 1 and min(14, w-1))\n    wb = unifint(diff_lb, diff_ub, (1, min(14, w - 1)))\n    \n    # Create a set of all possible indices within the bounding box\n    bounds = asindices(canvas(0, (hb, wb)))\n    \n    # Start the shape with a random corner of the bounding box\n    shp = {choice(totuple(corners(bounds)))}\n    \n    # Calculate half the area of the bounding box\n    mp = (hb * wb) // 2\n    \n    # Determine a random deviation for the shape's size\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    \n    # Choose whether to add or subtract the deviation from half the area\n    nc = choice((dev, hb * wb - dev))\n    \n    # Ensure the number of cells is within valid bounds\n    nc = max(0, min(hb * wb - 1, nc))\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc):\n        # Add a random neighboring cell that's within bounds and not already part of the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape to start at (0,0)\n    shp = normalize(shp)\n    \n    # Randomly determine the displacement for the shape in the input grid\n    di = randint(0, h - height(shp))\n    dj = randint(0, w - width(shp))\n    \n    # Shift the shape to its final position in the input grid\n    shpp = shift(shp, (di, dj))\n    \n    # Draw the shape on the input grid with the foreground color\n    gi = fill(gi, fgc, shpp)\n    \n    # Create the output grid: draw the normalized shape on a background-colored canvas\n    go = fill(canvas(bgc, shape(shp)), fgc, shp)\n    \n    # Duplicate the output horizontally\n    go = hconcat(go, go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "28e73c20": {
    "original": "def generate_28e73c20(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3,))\n    direcmapper = {(0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0), (-1, 0): (0, 1)}\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    sp = (0, w - 1)\n    direc = (1, 0)\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(cols, ncols)\n    gi = canvas(-1, (h, w))\n    inds = asindices(gi)\n    obj = {(choice(ccols), ij) for ij in inds}\n    gi = paint(gi, obj)\n    go = fill(gi, 3, connect((0, 0), sp))\n    lw = w\n    lh = h\n    ld = h\n    isverti = False\n    while ld > 0:\n        lw -= 1\n        lh -= 1\n        ep = add(sp, multiply(direc, ld - 1))\n        ln = connect(sp, ep)\n        go = fill(go, 3, ln)\n        direc = direcmapper[direc]\n        if isverti:\n            ld = lh\n        else:\n            ld = lw\n        isverti = not isverti\n        sp = ep\n    gi = dmirror(dmirror(gi)[1:])\n    go = dmirror(dmirror(go)[1:])\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_28e73c20(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors, excluding 3\n    cols = difference(interval(0, 10, 1), (3,))\n    \n    # Define a dictionary mapping directions to their next clockwise direction\n    direcmapper = {(0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0), (-1, 0): (0, 1)}\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Set the starting point at the top-right corner\n    sp = (0, w - 1)\n    \n    # Set initial direction downwards\n    direc = (1, 0)\n    \n    # Choose a random number of colors to use (between 1 and 9)\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample colors from the color set\n    ccols = sample(cols, ncols)\n    \n    # Create an empty grid filled with -1\n    gi = canvas(-1, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Create an object by assigning random colors to all grid cells\n    obj = {(choice(ccols), ij) for ij in inds}\n    \n    # Paint the input grid with the created object\n    gi = paint(gi, obj)\n    \n    # Create the output grid by drawing a line from top-left to top-right with color 3\n    go = fill(gi, 3, connect((0, 0), sp))\n    \n    # Initialize variables for the spiral drawing\n    lw = w  # Current width\n    lh = h  # Current height\n    ld = h  # Current line distance\n    isverti = False  # Flag to alternate between vertical and horizontal lines\n\n    # Start drawing the spiral\n    while ld > 0:\n        lw -= 1  # Decrease width\n        lh -= 1  # Decrease height\n        \n        # Calculate end point of current line\n        ep = add(sp, multiply(direc, ld - 1))\n        \n        # Draw the line\n        ln = connect(sp, ep)\n        go = fill(go, 3, ln)\n        \n        # Change direction clockwise\n        direc = direcmapper[direc]\n        \n        # Update line distance based on whether it's vertical or horizontal\n        if isverti:\n            ld = lh\n        else:\n            ld = lw\n        \n        # Toggle between vertical and horizontal\n        isverti = not isverti\n        \n        # Update starting point for next iteration\n        sp = ep\n\n    # Remove the top row and flip the input grid diagonally twice\n    gi = dmirror(dmirror(gi)[1:])\n    \n    # Remove the top row and flip the output grid diagonally twice\n    go = dmirror(dmirror(go)[1:])\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "29623171": {
    "original": "def generate_29623171(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 6))\n    w = unifint(diff_lb, diff_ub, (2, 6))\n    nh = unifint(diff_lb, diff_ub, (2, 4))\n    nw = unifint(diff_lb, diff_ub, (2, 4))\n    bgc, linc, fgc = sample(cols, 3)\n    fullh = h * nh + (nh - 1)\n    fullw = w * nw + (nw - 1)\n    c = canvas(linc, (fullh, fullw))\n    smallc = canvas(bgc, (h, w))\n    inds = totuple(asindices(smallc))\n    llocs = set()\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    srcloc = choice(llocs)\n    nmostc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    mostc = sample(inds, nmostc)\n    srcg = fill(smallc, fgc, mostc)\n    obj = asobject(srcg)\n    shftd = shift(obj, srcloc)\n    gi = paint(c, shftd)\n    go = fill(c, fgc, shftd)\n    remlocs = remove(srcloc, llocs)\n    gg = asobject(fill(smallc, bgc, inds))\n    for rl in remlocs:\n        noth = unifint(diff_lb, diff_ub, (0, nmostc))\n        otherg = fill(smallc, fgc, sample(inds, noth))\n        gi = paint(gi, shift(asobject(otherg), rl))\n        if noth == nmostc:\n            go = fill(go, fgc, shift(obj, rl))\n        else:\n            go = paint(go, shift(gg, rl))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_29623171(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly select height of small grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 6))\n    # Randomly select width of small grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Randomly select number of rows in the final grid based on difficulty\n    nh = unifint(diff_lb, diff_ub, (2, 4))\n    # Randomly select number of columns in the final grid based on difficulty\n    nw = unifint(diff_lb, diff_ub, (2, 4))\n    \n    # Randomly select 3 colors: background, line, and foreground\n    bgc, linc, fgc = sample(cols, 3)\n    \n    # Calculate full height of the final grid (including separator lines)\n    fullh = h * nh + (nh - 1)\n    # Calculate full width of the final grid (including separator lines)\n    fullw = w * nw + (nw - 1)\n    \n    # Create a canvas filled with the line color\n    c = canvas(linc, (fullh, fullw))\n    # Create a small canvas filled with the background color\n    smallc = canvas(bgc, (h, w))\n    \n    # Get all indices of the small canvas as a tuple\n    inds = totuple(asindices(smallc))\n    \n    # Initialize a set to store locations for small grids\n    llocs = set()\n    # Generate locations for small grids in the full grid\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    # Convert locations set to a tuple\n    llocs = tuple(llocs)\n    \n    # Randomly choose a source location from the generated locations\n    srcloc = choice(llocs)\n    \n    # Randomly select number of foreground cells in the source grid\n    nmostc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    # Randomly select indices for foreground cells\n    mostc = sample(inds, nmostc)\n    \n    # Create the source grid by filling selected indices with foreground color\n    srcg = fill(smallc, fgc, mostc)\n    # Convert the source grid to an object\n    obj = asobject(srcg)\n    # Shift the object to the chosen source location\n    shftd = shift(obj, srcloc)\n    \n    # Paint the shifted object onto the input grid\n    gi = paint(c, shftd)\n    # Fill the shifted object area with foreground color in the output grid\n    go = fill(c, fgc, shftd)\n    \n    # Remove the source location from the list of locations\n    remlocs = remove(srcloc, llocs)\n    # Create a background object from the small canvas\n    gg = asobject(fill(smallc, bgc, inds))\n    \n    # For each remaining location:\n    for rl in remlocs:\n        # Randomly select number of foreground cells for this location\n        noth = unifint(diff_lb, diff_ub, (0, nmostc))\n        # Create a grid with randomly selected foreground cells\n        otherg = fill(smallc, fgc, sample(inds, noth))\n        # Paint this grid onto the input grid at the current location\n        gi = paint(gi, shift(asobject(otherg), rl))\n        \n        # If the number of foreground cells matches the source grid:\n        if noth == nmostc:\n            # Fill the area in the output grid with foreground color\n            go = fill(go, fgc, shift(obj, rl))\n        else:\n            # Otherwise, paint the background object onto the output grid\n            go = paint(go, shift(gg, rl))\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "29c11459": {
    "original": "def generate_29c11459(diff_lb: float, diff_ub: float) -> dict:\n    colopts = remove(5, interval(0, 10, 1))\n    gi = canvas(0, (1, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 29))\n    if w % 2 == 0:\n        w = choice((max(5, w - 1), min(29, w + 1)))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    ncols = unifint(diff_lb, diff_ub, (2, len(remcols)))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nlocs = unifint(diff_lb, diff_ub, (1, h))\n    locs = sample(interval(0, h, 1), nlocs)\n    while set(locs).issubset({0, h - 1}):\n        locs = sample(interval(0, h, 1), nlocs)\n    acols = []\n    bcols = []\n    aforb = -1\n    bforb = -1\n    for k in range(nlocs):\n        ac = choice(remove(aforb, ccols))\n        acols.append(ac)\n        aforb = ac\n        bc = choice(remove(bforb, ccols))\n        bcols.append(bc)\n        bforb = bc\n    for (a, b), loc in zip(zip(acols, bcols), sorted(locs)):\n        gi = fill(gi, a, {(loc, 0)})\n        gi = fill(gi, b, {(loc, w - 1)})\n        go = fill(go, a, connect((loc, 0), (loc, w // 2 - 1)))\n        go = fill(go, b, connect((loc, w // 2 + 1), (loc, w - 1)))\n        go = fill(go, 5, {(loc, w // 2)})\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_29c11459(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color options, excluding 5\n    colopts = remove(5, interval(0, 10, 1))\n    \n    # Initialize a 1x1 grid with color 0\n    gi = canvas(0, (1, 1))\n    \n    # Generate a random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 29 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 29))\n    \n    # Ensure the width is odd\n    if w % 2 == 0:\n        # If width is even, adjust it by +1 or -1 to make it odd\n        w = choice((max(5, w - 1), min(29, w + 1)))\n    \n    # Choose a random background color\n    bgc = choice(colopts)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, colopts)\n    \n    # Choose a random number of colors to use (between 2 and the number of remaining colors)\n    ncols = unifint(diff_lb, diff_ub, (2, len(remcols)))\n    \n    # Randomly select the colors to be used\n    ccols = sample(remcols, ncols)\n    \n    # Create the input grid with the chosen background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the same background color\n    go = canvas(bgc, (h, w))\n    \n    # Choose a random number of locations to place colors\n    nlocs = unifint(diff_lb, diff_ub, (1, h))\n    \n    # Randomly select the row indices for color placement\n    locs = sample(interval(0, h, 1), nlocs)\n    \n    # Ensure not all selected locations are on the top and bottom edges\n    while set(locs).issubset({0, h - 1}):\n        locs = sample(interval(0, h, 1), nlocs)\n    \n    # Initialize lists for left and right side colors\n    acols = []\n    bcols = []\n    \n    # Initialize variables to track previously used colors\n    aforb = -1\n    bforb = -1\n    \n    # Choose colors for each location, ensuring adjacent colors are different\n    for k in range(nlocs):\n        # Choose a color for the left side, different from the previous left color\n        ac = choice(remove(aforb, ccols))\n        acols.append(ac)\n        aforb = ac\n        \n        # Choose a color for the right side, different from the previous right color\n        bc = choice(remove(bforb, ccols))\n        bcols.append(bc)\n        bforb = bc\n    \n    # Place colors on the input and output grids\n    for (a, b), loc in zip(zip(acols, bcols), sorted(locs)):\n        # Place left color on the leftmost cell of the input grid\n        gi = fill(gi, a, {(loc, 0)})\n        \n        # Place right color on the rightmost cell of the input grid\n        gi = fill(gi, b, {(loc, w - 1)})\n        \n        # Fill left half of the output grid with the left color\n        go = fill(go, a, connect((loc, 0), (loc, w // 2 - 1)))\n        \n        # Fill right half of the output grid with the right color\n        go = fill(go, b, connect((loc, w // 2 + 1), (loc, w - 1)))\n        \n        # Place color 5 in the middle column of the output grid\n        go = fill(go, 5, {(loc, w // 2)})\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "29ec7d0e": {
    "original": "def generate_29ec7d0e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    pinds = asindices(canvas(-1, (hp, wp)))\n    bgc, noisec = sample(cols, 2)\n    remcols = remove(noisec, cols)\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, numc)\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    go = canvas(bgc, (h, w))\n    locs = set()\n    for a in range(h//hp+1):\n        for b in range(w//wp+1):\n            loci = (a+1) + hp * a\n            locj = (b+1) + wp * b\n            locs.add((loci, locj))\n            go = paint(go, shift(pobj, (loci, locj)))\n    numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    gi = tuple(e for e in go)\n    places = apply(lbind(shift, pinds), locs)\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        gi2 = fill(gi, noisec, ptch)\n        if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):\n            if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:\n                succ += 1\n                gi = gi2\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_29ec7d0e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random height of pattern, between 2 and half of total height\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    \n    # Generate random width of pattern, between 2 and half of total width\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    \n    # Create indices for the pattern grid\n    pinds = asindices(canvas(-1, (hp, wp)))\n    \n    # Choose background color and noise color randomly\n    bgc, noisec = sample(cols, 2)\n    \n    # Remove noise color from available colors\n    remcols = remove(noisec, cols)\n    \n    # Choose number of colors for the pattern, between 2 and 9\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Choose colors for the pattern\n    ccols = sample(remcols, numc)\n    \n    # Create the pattern object with random colors\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    \n    # Create the initial output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Initialize set to store locations of pattern placements\n    locs = set()\n    \n    # Place patterns in a grid-like manner\n    for a in range(h//hp+1):\n        for b in range(w//wp+1):\n            # Calculate location for each pattern\n            loci = (a+1) + hp * a\n            locj = (b+1) + wp * b\n            # Add location to set\n            locs.add((loci, locj))\n            # Paint the pattern onto the output grid\n            go = paint(go, shift(pobj, (loci, locj)))\n    \n    # Determine number of noise patches to add\n    numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Convert output grid to tuple for manipulation\n    gi = tuple(e for e in go)\n    \n    # Generate all possible placements of the pattern\n    places = apply(lbind(shift, pinds), locs)\n    \n    # Initialize counters for successful noise additions and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    \n    # Add noise patches while preserving at least one complete pattern\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        # Generate random patch dimensions\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        # Generate random patch location\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        # Create patch area\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        # Apply noise color to patch area\n        gi2 = fill(gi, noisec, ptch)\n        # Check if original pattern still exists after adding noise\n        if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):\n            # Ensure noise doesn't cover entire rows or columns\n            if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:\n                succ += 1\n                gi = gi2\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply rotation to input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "2bcee788": {
    "original": "def generate_2bcee788(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 20))\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    bgc, sepc, objc = sample(cols, 3)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    spi = randint(0, h - 1)\n    sp = (spi, w - 1)\n    shp = {sp}\n    numcellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numc = choice((numcellsd, h * w - numcellsd))\n    numc = min(max(2, numc), h * w - 1)\n    reminds = set(remove(sp, inds))\n    for k in range(numc):\n        shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n    while width(shp) == 1:\n        shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n    c2 = fill(c, objc, shp)\n    borderinds = sfilter(shp, lambda ij: ij[1] == w - 1)\n    c3 = fill(c, sepc, borderinds)\n    gimini = asobject(hconcat(c2, vmirror(c3)))\n    gomini = asobject(hconcat(c2, vmirror(c2)))\n    fullh = unifint(diff_lb, diff_ub, (h+1, 30))\n    fullw = unifint(diff_lb, diff_ub, (2*w+1, 30))\n    fullg = canvas(bgc, (fullh, fullw))\n    loci = randint(0, fullh - h)\n    locj = randint(0, fullw - 2 * w)\n    loc = (loci, locj)\n    gi = paint(fullg, gimini)\n    go = paint(fullg, gomini)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    go = replace(go, bgc, 3)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2bcee788(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range 0-9, creating a list of available colors\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the initial grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 20))\n    \n    # Randomly determine the width of the initial grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Randomly select three colors: background, separator, and object\n    bgc, sepc, objc = sample(cols, 3)\n    \n    # Create a canvas (grid) with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Choose a random starting point on the rightmost column\n    spi = randint(0, h - 1)\n    sp = (spi, w - 1)\n    \n    # Initialize the shape set with the starting point\n    shp = {sp}\n    \n    # Determine the number of cells to fill based on difficulty\n    numcellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose between filling numcellsd or its complement\n    numc = choice((numcellsd, h * w - numcellsd))\n    \n    # Ensure at least 2 cells are filled and at least 1 cell is empty\n    numc = min(max(2, numc), h * w - 1)\n    \n    # Remove the starting point from available indices\n    reminds = set(remove(sp, inds))\n    \n    # Grow the shape by adding neighboring cells\n    for k in range(numc):\n        shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n    \n    # Ensure the shape is not just a vertical line\n    while width(shp) == 1:\n        shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n    \n    # Fill the shape with the object color\n    c2 = fill(c, objc, shp)\n    \n    # Identify cells on the rightmost border of the shape\n    borderinds = sfilter(shp, lambda ij: ij[1] == w - 1)\n    \n    # Fill the border cells with the separator color\n    c3 = fill(c, sepc, borderinds)\n    \n    # Create the input grid by concatenating c2 and mirrored c3\n    gimini = asobject(hconcat(c2, vmirror(c3)))\n    \n    # Create the output grid by concatenating c2 and mirrored c2\n    gomini = asobject(hconcat(c2, vmirror(c2)))\n    \n    # Determine the full height of the final grid\n    fullh = unifint(diff_lb, diff_ub, (h+1, 30))\n    \n    # Determine the full width of the final grid\n    fullw = unifint(diff_lb, diff_ub, (2*w+1, 30))\n    \n    # Create the full background grid\n    fullg = canvas(bgc, (fullh, fullw))\n    \n    # Choose random location to place the mini grids\n    loci = randint(0, fullh - h)\n    locj = randint(0, fullw - 2 * w)\n    loc = (loci, locj)\n    \n    # Paint the input mini grid onto the full grid\n    gi = paint(fullg, gimini)\n    \n    # Paint the output mini grid onto the full grid\n    go = paint(fullg, gomini)\n    \n    # Define a list of possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen number of random transformations to both input and output\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # In the output, replace the background color with color 3\n    go = replace(go, bgc, 3)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "2bee17df": {
    "original": "def generate_2bee17df(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c = canvas(bgc, (h, w))\n    indord1 = apply(tojvec, interval(0, w, 1))\n    indord2 = apply(rbind(astuple, w - 1), interval(1, h - 1, 1))\n    indord3 = apply(lbind(astuple, h - 1), interval(w - 1, 0, -1))\n    indord4 = apply(toivec, interval(h - 1, 0, -1))\n    indord = indord1 + indord2 + indord3 + indord4\n    k = len(indord)\n    sp = randint(0, k)\n    arr = indord[sp:] + indord[:sp]\n    ep = randint(k // 2 - 3, k // 2 + 1)\n    a = arr[:ep]\n    b = arr[ep:]\n    cola = choice(remcols)\n    remcols = remove(cola, remcols)\n    colb = choice(remcols)\n    gi = fill(c, cola, a)\n    gi = fill(gi, colb, b)\n    nr = unifint(diff_lb, diff_ub, (1, min(4, min(h, w) // 2)))\n    for kk in range(nr):\n        ring = box(frozenset({(1 + kk, 1 + kk), (h - 1 - kk, w - 1 - kk)}))\n        for br in (cola, colb):\n            blacks = ofcolor(gi, br)\n            bcands = totuple(ring & ofcolor(gi, bgc) & mapply(dneighbors, ofcolor(gi, br)))\n            jj = len(bcands)\n            jj2 = randint(max(0, jj // 2 - 2), min(jj, jj // 2 + 1))\n            ss = sample(bcands, jj2)\n            gi = fill(gi, br, ss)\n    res = shift(merge(frontiers(trim(gi))), (1, 1))\n    go = fill(gi, 3, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2bee17df(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    # Remove the chosen background color from the list of remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Create lists of coordinates for the four sides of the grid\n    # Top edge: left to right\n    indord1 = apply(tojvec, interval(0, w, 1))\n    # Right edge: top to bottom (excluding corners)\n    indord2 = apply(rbind(astuple, w - 1), interval(1, h - 1, 1))\n    # Bottom edge: right to left (excluding corners)\n    indord3 = apply(lbind(astuple, h - 1), interval(w - 1, 0, -1))\n    # Left edge: bottom to top (excluding corners)\n    indord4 = apply(toivec, interval(h - 1, 0, -1))\n    \n    # Combine all edge coordinates into a single list\n    indord = indord1 + indord2 + indord3 + indord4\n    \n    # Get the total number of edge cells\n    k = len(indord)\n    # Choose a random starting point for the \"snake\"\n    sp = randint(0, k)\n    # Rearrange the edge coordinates to start from the chosen point\n    arr = indord[sp:] + indord[:sp]\n    \n    # Choose a random endpoint for the first part of the \"snake\"\n    ep = randint(k // 2 - 3, k // 2 + 1)\n    # Split the \"snake\" into two parts\n    a = arr[:ep]\n    b = arr[ep:]\n    \n    # Choose a color for the first part of the \"snake\"\n    cola = choice(remcols)\n    # Remove the chosen color from the remaining colors\n    remcols = remove(cola, remcols)\n    # Choose a color for the second part of the \"snake\"\n    colb = choice(remcols)\n    \n    # Fill the first part of the \"snake\" with its color\n    gi = fill(c, cola, a)\n    # Fill the second part of the \"snake\" with its color\n    gi = fill(gi, colb, b)\n    \n    # Determine the number of \"rings\" to add based on difficulty\n    nr = unifint(diff_lb, diff_ub, (1, min(4, min(h, w) // 2)))\n    \n    # For each ring:\n    for kk in range(nr):\n        # Create a box (outline) for the current ring\n        ring = box(frozenset({(1 + kk, 1 + kk), (h - 1 - kk, w - 1 - kk)}))\n        \n        # For each color of the \"snake\":\n        for br in (cola, colb):\n            # Get all cells of the current color\n            blacks = ofcolor(gi, br)\n            # Find candidate cells for expansion (adjacent to current color and on the ring)\n            bcands = totuple(ring & ofcolor(gi, bgc) & mapply(dneighbors, ofcolor(gi, br)))\n            \n            # Get the number of candidate cells\n            jj = len(bcands)\n            # Choose a random number of cells to fill\n            jj2 = randint(max(0, jj // 2 - 2), min(jj, jj // 2 + 1))\n            # Randomly sample the cells to fill\n            ss = sample(bcands, jj2)\n            # Fill the chosen cells with the current color\n            gi = fill(gi, br, ss)\n    \n    # Find the frontiers (edges) of the filled areas, trim the grid, and shift it\n    res = shift(merge(frontiers(trim(gi))), (1, 1))\n    # Create the output grid by filling the frontier cells with color 3\n    go = fill(gi, 3, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "2c608aff": {
    "original": "def generate_2c608aff(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    boxh = unifint(diff_lb, diff_ub, (2, h // 2))\n    boxw = unifint(diff_lb, diff_ub, (2, w // 2))\n    loci = randint(0, h - boxh)\n    locj = randint(0, w - boxw)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccol = choice(remcols)\n    remcols = remove(ccol, remcols)\n    dcol = choice(remcols)\n    bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, ccol, bd)\n    reminds = totuple(asindices(gi) - backdrop(outbox(bd)))\n    noiseb = max(1, len(reminds) // 4)\n    nnoise = unifint(diff_lb, diff_ub, (0, noiseb))\n    noise = sample(reminds, nnoise)\n    gi = fill(gi, dcol, noise)\n    go = tuple(e for e in gi)\n    hs = interval(loci, loci + boxh, 1)\n    ws = interval(locj, locj + boxw, 1)\n    for ij in noise:\n        a, b = ij\n        if a in hs:\n            go = fill(go, dcol, connect(ij, (a, locj)))\n        elif b in ws:\n            go = fill(go, dcol, connect(ij, (loci, b)))\n    go = fill(go, ccol, bd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2c608aff(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a tuple of integers from 0 to 9 (possible colors)\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random height between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random width between 10 and 30 based on difficulty\n    boxh = unifint(diff_lb, diff_ub, (2, h // 2))  # Generate a random box height between 2 and half the grid height\n    boxw = unifint(diff_lb, diff_ub, (2, w // 2))  # Generate a random box width between 2 and half the grid width\n    loci = randint(0, h - boxh)  # Generate a random vertical position for the box\n    locj = randint(0, w - boxw)  # Generate a random horizontal position for the box\n    bgc = choice(cols)  # Randomly select a background color\n    remcols = remove(bgc, cols)  # Remove the background color from the list of available colors\n    ccol = choice(remcols)  # Randomly select a color for the box (contrasting color)\n    remcols = remove(ccol, remcols)  # Remove the box color from the remaining colors\n    dcol = choice(remcols)  # Randomly select a color for the noise dots\n    bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))  # Create the indices for the box area\n    gi = canvas(bgc, (h, w))  # Create the initial grid with the background color\n    gi = fill(gi, ccol, bd)  # Fill the box area with the contrasting color\n    reminds = totuple(asindices(gi) - backdrop(outbox(bd)))  # Get indices outside the box and its outline\n    noiseb = max(1, len(reminds) // 4)  # Calculate the maximum number of noise dots (25% of available space)\n    nnoise = unifint(diff_lb, diff_ub, (0, noiseb))  # Generate a random number of noise dots based on difficulty\n    noise = sample(reminds, nnoise)  # Randomly select positions for the noise dots\n    gi = fill(gi, dcol, noise)  # Add the noise dots to the input grid\n    go = tuple(e for e in gi)  # Create a copy of the input grid for the output\n    hs = interval(loci, loci + boxh, 1)  # Create a range of vertical indices for the box\n    ws = interval(locj, locj + boxw, 1)  # Create a range of horizontal indices for the box\n    for ij in noise:  # Iterate through each noise dot\n        a, b = ij  # Unpack the coordinates of the noise dot\n        if a in hs:  # If the dot is in the same row as the box\n            go = fill(go, dcol, connect(ij, (a, locj)))  # Draw a horizontal line to the box\n        elif b in ws:  # If the dot is in the same column as the box\n            go = fill(go, dcol, connect(ij, (loci, b)))  # Draw a vertical line to the box\n    go = fill(go, ccol, bd)  # Refill the box area with the contrasting color (to cover any lines)\n    return {'input': gi, 'output': go}  # Return the input and output grids as a dictionary\n\n# This function generates an ARC task where a box is drawn on a grid, and noise dots outside the box\n# are connected to the box with lines if they align horizontally or vertically with the box.\n"
  },
  "2dc579da": {
    "original": "def generate_2dc579da(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    dotc = choice(remcols)\n    hdev = unifint(diff_lb, diff_ub, (0, (h - 2) // 2))\n    lineh = choice((hdev, h - 2 - hdev))\n    lineh = max(min(h - 2, lineh), 1)\n    wdev = unifint(diff_lb, diff_ub, (0, (w - 2) // 2))\n    linew = choice((wdev, w - 2 - wdev))\n    linew = max(min(w - 2, linew), 1)\n    locidev = unifint(diff_lb, diff_ub, (1, h // 2))\n    loci = choice((h // 2 - locidev, h // 2 + locidev))\n    loci = min(max(1, loci), h - lineh - 1)\n    locjdev = unifint(diff_lb, diff_ub, (1, w // 2))\n    locj = choice((w // 2 - locjdev, w // 2 + locjdev))\n    locj = min(max(1, locj), w - linew - 1)\n    gi = canvas(bgc, (h, w))\n    for a in range(loci, loci + lineh):\n        gi = fill(gi, linc, connect((a, 0), (a, w - 1)))\n    for b in range(locj, locj + linew):\n        gi = fill(gi, linc, connect((0, b), (h - 1, b)))\n    doth = randint(1, loci)\n    dotw = randint(1, locj)\n    dotloci = randint(0, loci - doth)\n    dotlocj = randint(0, locj - dotw)\n    dot = backdrop(frozenset({(dotloci, dotlocj), (dotloci + doth - 1, dotlocj + dotw - 1)}))\n    gi = fill(gi, dotc, dot)\n    go = crop(gi, (0, 0), (loci, locj))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2dc579da(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 3 and 30, based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a width between 3 and 30, based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the lines from the remaining colors\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a color for the dot from the remaining colors\n    dotc = choice(remcols)\n    \n    # Calculate a random vertical deviation for the line, based on difficulty\n    hdev = unifint(diff_lb, diff_ub, (0, (h - 2) // 2))\n    \n    # Choose the line height, either above or below the center\n    lineh = choice((hdev, h - 2 - hdev))\n    \n    # Ensure the line height is within valid bounds\n    lineh = max(min(h - 2, lineh), 1)\n    \n    # Calculate a random horizontal deviation for the line, based on difficulty\n    wdev = unifint(diff_lb, diff_ub, (0, (w - 2) // 2))\n    \n    # Choose the line width, either to the left or right of center\n    linew = choice((wdev, w - 2 - wdev))\n    \n    # Ensure the line width is within valid bounds\n    linew = max(min(w - 2, linew), 1)\n    \n    # Calculate a random vertical deviation for the line position, based on difficulty\n    locidev = unifint(diff_lb, diff_ub, (1, h // 2))\n    \n    # Choose the vertical position of the line, either above or below center\n    loci = choice((h // 2 - locidev, h // 2 + locidev))\n    \n    # Ensure the vertical position is within valid bounds\n    loci = min(max(1, loci), h - lineh - 1)\n    \n    # Calculate a random horizontal deviation for the line position, based on difficulty\n    locjdev = unifint(diff_lb, diff_ub, (1, w // 2))\n    \n    # Choose the horizontal position of the line, either left or right of center\n    locj = choice((w // 2 - locjdev, w // 2 + locjdev))\n    \n    # Ensure the horizontal position is within valid bounds\n    locj = min(max(1, locj), w - linew - 1)\n    \n    # Create a canvas with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Draw horizontal lines on the canvas\n    for a in range(loci, loci + lineh):\n        gi = fill(gi, linc, connect((a, 0), (a, w - 1)))\n    \n    # Draw vertical lines on the canvas\n    for b in range(locj, locj + linew):\n        gi = fill(gi, linc, connect((0, b), (h - 1, b)))\n    \n    # Choose a random height for the dot\n    doth = randint(1, loci)\n    \n    # Choose a random width for the dot\n    dotw = randint(1, locj)\n    \n    # Choose a random vertical position for the dot\n    dotloci = randint(0, loci - doth)\n    \n    # Choose a random horizontal position for the dot\n    dotlocj = randint(0, locj - dotw)\n    \n    # Create the dot shape\n    dot = backdrop(frozenset({(dotloci, dotlocj), (dotloci + doth - 1, dotlocj + dotw - 1)}))\n    \n    # Draw the dot on the canvas\n    gi = fill(gi, dotc, dot)\n    \n    # Create the output by cropping the input to the top-left quadrant\n    go = crop(gi, (0, 0), (loci, locj))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the rotation to the input\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output\n    go = rotf(go)\n    \n    # Return the input and output as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "2dd70a9a": {
    "original": "def generate_2dd70a9a(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 3))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    if choice((True, False)):\n        oh = unifint(diff_lb, diff_ub, (5, h - 2))\n        ow = unifint(diff_lb, diff_ub, (3, w - 2))\n        loci = randint(1, h - oh - 1)\n        locj = randint(1, w - ow - 1)\n        hli = randint(loci+2, loci+oh-3)\n        sp = {(loci+oh-1, locj), (loci+oh-2, locj)}\n        ep = {(loci, locj+ow-1), (loci+1, locj+ow-1)}\n        bp1 = (hli-1, locj)\n        bp2 = (hli, locj+ow)\n        ln1 = connect((loci+oh-1, locj), (hli, locj))\n        ln2 = connect((hli, locj), (hli, locj+ow-1))\n        ln3 = connect((hli, locj+ow-1), (loci+2, locj+ow-1))\n    else:\n        oh = unifint(diff_lb, diff_ub, (3, h-2))\n        ow = unifint(diff_lb, diff_ub, (3, w-2))\n        loci = randint(1, h - oh - 1)\n        locj = randint(1, w - ow - 1)\n        if choice((True, False)):\n            sp1j = randint(locj, locj+ow-3)\n            ep1j = locj\n        else:\n            ep1j = randint(locj, locj+ow-3)\n            sp1j = locj\n        sp = {(loci, sp1j), (loci, sp1j+1)}\n        ep = {(loci+oh-1, ep1j), (loci+oh-1, ep1j+1)}\n        bp1 = (loci, locj+ow)\n        bp2 = (loci+oh, locj+ow-1)\n        ln1 = connect((loci, sp1j+2), (loci, locj+ow-1))\n        ln2 = connect((loci, locj+ow-1), (loci+oh-1, locj+ow-1))\n        ln3 = connect((loci+oh-1, ep1j+2), (loci+oh-1, locj+ow-1))\n    gi = fill(gi, 3, sp)\n    gi = fill(gi, 2, ep)\n    go = fill(go, 3, sp)\n    go = fill(go, 2, ep)\n    lns = ln1 | ln2 | ln3\n    bps = {bp1, bp2}\n    gi = fill(gi, fgc, bps)\n    go = fill(go, fgc, bps)\n    go = fill(go, 3, lns)\n    inds = ofcolor(go, bgc)\n    namt = unifint(diff_lb, diff_ub, (0, len(inds) // 2))\n    noise = sample(totuple(inds), namt)\n    gi = fill(gi, fgc, noise)\n    go = fill(go, fgc, noise)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2dd70a9a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 2 and 3\n    cols = difference(interval(0, 10, 1), (2, 3))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select two colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly choose between two shape generation methods\n    if choice((True, False)):\n        # Generate a rectangular shape with a line inside\n        \n        # Define object height between 5 and h-2\n        oh = unifint(diff_lb, diff_ub, (5, h - 2))\n        # Define object width between 3 and w-2\n        ow = unifint(diff_lb, diff_ub, (3, w - 2))\n        \n        # Random vertical position for the object\n        loci = randint(1, h - oh - 1)\n        # Random horizontal position for the object\n        locj = randint(1, w - ow - 1)\n        \n        # Random vertical position for the horizontal line\n        hli = randint(loci+2, loci+oh-3)\n        \n        # Define start points of the shape (color 3)\n        sp = {(loci+oh-1, locj), (loci+oh-2, locj)}\n        # Define end points of the shape (color 2)\n        ep = {(loci, locj+ow-1), (loci+1, locj+ow-1)}\n        \n        # Define bend points of the line\n        bp1 = (hli-1, locj)\n        bp2 = (hli, locj+ow)\n        \n        # Generate three line segments\n        ln1 = connect((loci+oh-1, locj), (hli, locj))\n        ln2 = connect((hli, locj), (hli, locj+ow-1))\n        ln3 = connect((hli, locj+ow-1), (loci+2, locj+ow-1))\n    else:\n        # Generate a rectangular shape with a U-shaped line inside\n        \n        # Define object height between 3 and h-2\n        oh = unifint(diff_lb, diff_ub, (3, h-2))\n        # Define object width between 3 and w-2\n        ow = unifint(diff_lb, diff_ub, (3, w-2))\n        \n        # Random vertical position for the object\n        loci = randint(1, h - oh - 1)\n        # Random horizontal position for the object\n        locj = randint(1, w - ow - 1)\n        \n        # Randomly choose between left or right opening U-shape\n        if choice((True, False)):\n            # Left opening U-shape\n            sp1j = randint(locj, locj+ow-3)\n            ep1j = locj\n        else:\n            # Right opening U-shape\n            ep1j = randint(locj, locj+ow-3)\n            sp1j = locj\n        \n        # Define start points of the shape (color 3)\n        sp = {(loci, sp1j), (loci, sp1j+1)}\n        # Define end points of the shape (color 2)\n        ep = {(loci+oh-1, ep1j), (loci+oh-1, ep1j+1)}\n        \n        # Define bend points of the line\n        bp1 = (loci, locj+ow)\n        bp2 = (loci+oh, locj+ow-1)\n        \n        # Generate three line segments for U-shape\n        ln1 = connect((loci, sp1j+2), (loci, locj+ow-1))\n        ln2 = connect((loci, locj+ow-1), (loci+oh-1, locj+ow-1))\n        ln3 = connect((loci+oh-1, ep1j+2), (loci+oh-1, locj+ow-1))\n    \n    # Add start points to input grid\n    gi = fill(gi, 3, sp)\n    # Add end points to input grid\n    gi = fill(gi, 2, ep)\n    # Add start points to output grid\n    go = fill(go, 3, sp)\n    # Add end points to output grid\n    go = fill(go, 2, ep)\n    \n    # Combine all line segments\n    lns = ln1 | ln2 | ln3\n    # Combine bend points\n    bps = {bp1, bp2}\n    \n    # Add bend points to input grid\n    gi = fill(gi, fgc, bps)\n    # Add bend points to output grid\n    go = fill(go, fgc, bps)\n    \n    # Add line segments to output grid\n    go = fill(go, 3, lns)\n    \n    # Get all background color cells in output grid\n    inds = ofcolor(go, bgc)\n    \n    # Generate random number of noise points\n    namt = unifint(diff_lb, diff_ub, (0, len(inds) // 2))\n    # Randomly select noise points\n    noise = sample(totuple(inds), namt)\n    \n    # Add noise to input grid\n    gi = fill(gi, fgc, noise)\n    # Add noise to output grid\n    go = fill(go, fgc, noise)\n    \n    # Define possible mirror and rotation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    # Choose 1 or 2 transformation functions\n    nmfs = choice((1, 2))\n    \n    # Apply chosen transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "2dee498d": {
    "original": "def generate_2dee498d(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 10))\n    bgc = choice(cols)\n    go = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(go))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        go = fill(go, col, chos)\n        inds = difference(inds, chos)\n    gi = hconcat(go, hconcat(go, go))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_2dee498d(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for dimensions (1 to 30)\n    dim_bounds = (1, 30)\n    # Create a tuple of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose a height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    # Randomly choose a width between 1 and 10 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 10))\n    # Randomly select a background color\n    bgc = choice(cols)\n    # Create a canvas of size h x w filled with the background color\n    go = canvas(bgc, (h, w))\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Choose a random number of colors to use (between 1 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))\n    # Randomly select 'numc' colors from the remaining colors\n    colsch = sample(remcols, numc)\n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(go))\n    # For each chosen color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        # Randomly select 'num' indices from the available indices\n        chos = sample(inds, num)\n        # Fill the chosen indices with the current color\n        go = fill(go, col, chos)\n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    # Create the input grid by horizontally concatenating the output grid three times\n    gi = hconcat(go, hconcat(go, go))\n    # Return a dictionary with 'input' (the concatenated grid) and 'output' (the original grid)\n    return {'input': gi, 'output': go}\n"
  },
  "31aa019c": {
    "original": "def generate_31aa019c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        w = unifint(diff_lb, diff_ub, (5, 30))\n        bgc = choice(cols)\n        remcols = remove(bgc, cols)\n        canv = canvas(bgc, (h, w))\n        inds = totuple(asindices(canv))\n        mp = (h * w) // 2 - 1\n        ncols = unifint(diff_lb, diff_ub, (2, min(9, mp // 2 - 1)))\n        chcols = sample(cols, ncols)\n        trgcol = chcols[0]\n        chcols = chcols[1:]\n        dic = {c: set() for c in chcols}\n        nnoise = unifint(diff_lb, diff_ub, (2 * (ncols - 1), mp))\n        locc = choice(inds)\n        inds = remove(locc, inds)\n        noise = sample(inds, nnoise)\n        for c in chcols:\n            ij = choice(inds)\n            dic[c].add(ij)\n            inds = remove(ij, inds)\n        for c in chcols:\n            ij = choice(inds)\n            dic[c].add(ij)\n            inds = remove(ij, inds)\n        for ij in noise:\n            c = choice(chcols)\n            dic[c].add(ij)\n            inds = remove(ij, inds)\n        gi = fill(canv, trgcol, {locc})\n        for c, ss in dic.items():\n            gi = fill(gi, c, ss)\n        gi = fill(gi, trgcol, {locc})\n        if len(sfilter(palette(gi), lambda c: colorcount(gi, c) == 1)) == 1:\n            break\n    lc = leastcolor(gi)\n    locc = ofcolor(gi, lc)\n    go = fill(canv, lc, locc)\n    go = fill(go, 2, neighbors(first(locc)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_31aa019c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    while True:\n        # Randomly generate height between 5 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        # Randomly generate width between 5 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (5, 30))\n        # Randomly choose a background color\n        bgc = choice(cols)\n        # Remove the background color from the list of available colors\n        remcols = remove(bgc, cols)\n        # Create a canvas filled with the background color\n        canv = canvas(bgc, (h, w))\n        # Get all indices of the canvas as a tuple\n        inds = totuple(asindices(canv))\n        # Calculate half the number of pixels minus 1\n        mp = (h * w) // 2 - 1\n        # Randomly choose number of colors to use (between 2 and 9, or less if limited by canvas size)\n        ncols = unifint(diff_lb, diff_ub, (2, min(9, mp // 2 - 1)))\n        # Randomly sample colors from the available colors\n        chcols = sample(cols, ncols)\n        # Set the target color as the first chosen color\n        trgcol = chcols[0]\n        # Remove the target color from the list of chosen colors\n        chcols = chcols[1:]\n        # Create a dictionary to store indices for each color\n        dic = {c: set() for c in chcols}\n        # Randomly determine the number of noise pixels\n        nnoise = unifint(diff_lb, diff_ub, (2 * (ncols - 1), mp))\n        # Choose a random location for the target color\n        locc = choice(inds)\n        # Remove the target color location from available indices\n        inds = remove(locc, inds)\n        # Sample random locations for noise\n        noise = sample(inds, nnoise)\n        for c in chcols:\n            # Choose a random location for each color\n            ij = choice(inds)\n            # Add the location to the color's set\n            dic[c].add(ij)\n            # Remove the chosen location from available indices\n            inds = remove(ij, inds)\n        for c in chcols:\n            # Choose another random location for each color\n            ij = choice(inds)\n            # Add the location to the color's set\n            dic[c].add(ij)\n            # Remove the chosen location from available indices\n            inds = remove(ij, inds)\n        for ij in noise:\n            # Choose a random color for each noise pixel\n            c = choice(chcols)\n            # Add the noise pixel to the color's set\n            dic[c].add(ij)\n            # Remove the noise pixel from available indices\n            inds = remove(ij, inds)\n        # Fill the canvas with the target color at its chosen location\n        gi = fill(canv, trgcol, {locc})\n        for c, ss in dic.items():\n            # Fill the canvas with each color at its chosen locations\n            gi = fill(gi, c, ss)\n        # Ensure the target color is on top by filling it again\n        gi = fill(gi, trgcol, {locc})\n        # Check if there's only one color that appears once in the grid\n        if len(sfilter(palette(gi), lambda c: colorcount(gi, c) == 1)) == 1:\n            break\n    # Find the least common color in the input grid\n    lc = leastcolor(gi)\n    # Get the location of the least common color\n    locc = ofcolor(gi, lc)\n    # Create the output grid with the least common color at its location\n    go = fill(canv, lc, locc)\n    # Fill the neighbors of the least common color with color 2\n    go = fill(go, 2, neighbors(first(locc)))\n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "321b1fc6": {
    "original": "def generate_321b1fc6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    objh = unifint(diff_lb, diff_ub, (2, 5))\n    objw = unifint(diff_lb, diff_ub, (2, 5))\n    bounds = asindices(canvas(0, (objh, objw)))\n    shp = {choice(totuple(bounds))}\n    nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))\n    for j in range(nc):\n        ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))\n        shp.add(ij)\n    shp = normalize(shp)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    dmyc = choice(remcols)\n    remcols = remove(dmyc, remcols)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    shpp = shift(shp, (loci, locj))\n    numco = unifint(diff_lb, diff_ub, (2, 8))\n    colll = sample(remcols, numco)\n    shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    while numcolors(shppc) == 1:\n        shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    shppcn = normalize(shppc)\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, shppc)\n    go = tuple(e for e in gi)\n    ub = ((h * w) / (oh * ow)) // 2\n    ub = max(1, ub)\n    numlocs = unifint(diff_lb, diff_ub, (1, ub))\n    cnt = 0\n    fails = 0\n    maxfails = 5 * numlocs\n    idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)\n    idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n    while cnt < numlocs and fails < maxfails:\n        if len(idns) == 0:\n            break\n        loc = choice(totuple(idns))\n        plcd = shift(shppcn, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(idns):\n            go = paint(go, plcd)\n            gi = fill(gi, dmyc, plcdi)\n            cnt += 1\n            idns = (idns - plcdi) - mapply(dneighbors, plcdi)\n        else:\n            fails += 1\n    go = fill(go, bgc, shpp)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_321b1fc6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (8, 30))  # Randomly choose grid height between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))  # Randomly choose grid width between 8 and 30\n    objh = unifint(diff_lb, diff_ub, (2, 5))  # Randomly choose object height between 2 and 5\n    objw = unifint(diff_lb, diff_ub, (2, 5))  # Randomly choose object width between 2 and 5\n    bounds = asindices(canvas(0, (objh, objw)))  # Create a set of all possible indices for the object\n    shp = {choice(totuple(bounds))}  # Start the shape with a random cell\n    nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))  # Choose number of cells to add to the shape\n    for j in range(nc):\n        # Add neighboring cells to the shape until we reach the chosen number\n        ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))\n        shp.add(ij)\n    shp = normalize(shp)  # Move the shape to the origin\n    bgc = choice(cols)  # Choose a background color\n    remcols = remove(bgc, cols)  # Remove background color from available colors\n    dmyc = choice(remcols)  # Choose a dummy color\n    remcols = remove(dmyc, remcols)  # Remove dummy color from available colors\n    oh, ow = shape(shp)  # Get the dimensions of the shape\n    loci = randint(0, h - oh)  # Choose a random vertical position for the shape\n    locj = randint(0, w - ow)  # Choose a random horizontal position for the shape\n    shpp = shift(shp, (loci, locj))  # Move the shape to its position on the grid\n    numco = unifint(diff_lb, diff_ub, (2, 8))  # Choose number of colors for the shape\n    colll = sample(remcols, numco)  # Sample colors for the shape\n    shppc = frozenset({(choice(colll), ij) for ij in shpp})  # Assign random colors to the shape\n    while numcolors(shppc) == 1:\n        # Ensure the shape has more than one color\n        shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    shppcn = normalize(shppc)  # Normalize the colored shape\n    gi = canvas(bgc, (h, w))  # Create the input grid with background color\n    gi = paint(gi, shppc)  # Paint the shape onto the input grid\n    go = tuple(e for e in gi)  # Create the output grid as a copy of the input\n    ub = ((h * w) / (oh * ow)) // 2  # Calculate upper bound for number of shape placements\n    ub = max(1, ub)  # Ensure at least one shape is placed\n    numlocs = unifint(diff_lb, diff_ub, (1, ub))  # Choose number of additional shape placements\n    cnt = 0  # Initialize counter for successful placements\n    fails = 0  # Initialize counter for failed placement attempts\n    maxfails = 5 * numlocs  # Set maximum number of failed attempts\n    idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)  # Find valid placement locations\n    idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)  # Ensure shapes fit within grid\n    while cnt < numlocs and fails < maxfails:\n        if len(idns) == 0:\n            break  # Stop if no valid locations remain\n        loc = choice(totuple(idns))  # Choose a random location\n        plcd = shift(shppcn, loc)  # Place the shape at the chosen location\n        plcdi = toindices(plcd)  # Get indices of the placed shape\n        if plcdi.issubset(idns):\n            # If placement is valid:\n            go = paint(go, plcd)  # Paint the shape onto the output grid\n            gi = fill(gi, dmyc, plcdi)  # Fill the shape area with dummy color on input grid\n            cnt += 1  # Increment successful placement counter\n            idns = (idns - plcdi) - mapply(dneighbors, plcdi)  # Update valid placement locations\n        else:\n            fails += 1  # Increment failed attempt counter\n    go = fill(go, bgc, shpp)  # Remove the original shape from the output grid\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "32597951": {
    "original": "def generate_32597951(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    ih = unifint(diff_lb, diff_ub, (2, h // 2))\n    iw = unifint(diff_lb, diff_ub, (2, w // 2))\n    bgc, noisec, fgc = sample(cols, 3)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    ndev = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    num = choice((ndev, h * w - ndev))\n    num = min(max(num, 0), h * w)\n    ofc = sample(inds, num)\n    c = fill(c, noisec, ofc)\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    tofillfc = bd & ofcolor(c, bgc)\n    gi = fill(c, fgc, tofillfc)\n    if len(tofillfc) > 0:\n        go = fill(gi, 3, backdrop(tofillfc) & ofcolor(gi, noisec))\n    else:\n        go = gi\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_32597951(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of integers from 0 to 9, excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random inner height between 2 and half of h\n    ih = unifint(diff_lb, diff_ub, (2, h // 2))\n    \n    # Generate a random inner width between 2 and half of w\n    iw = unifint(diff_lb, diff_ub, (2, w // 2))\n    \n    # Randomly select 3 distinct colors from cols for background, noise, and foreground\n    bgc, noisec, fgc = sample(cols, 3)\n    \n    # Create a canvas of size h x w filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Generate a random number for noise deviation\n    ndev = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    \n    # Choose either ndev or (total cells - ndev) for the number of noise cells\n    num = choice((ndev, h * w - ndev))\n    \n    # Ensure num is within valid range (0 to total number of cells)\n    num = min(max(num, 0), h * w)\n    \n    # Randomly select 'num' indices from the canvas for noise\n    ofc = sample(inds, num)\n    \n    # Fill the selected indices with the noise color\n    c = fill(c, noisec, ofc)\n    \n    # Generate random top-left corner coordinates for the inner rectangle\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    \n    # Create a set of indices for the inner rectangle\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    \n    # Find the intersection of the inner rectangle and background color cells\n    tofillfc = bd & ofcolor(c, bgc)\n    \n    # Fill the intersection with the foreground color (creates the inner rectangle)\n    gi = fill(c, fgc, tofillfc)\n    \n    # If there are cells to fill in the inner rectangle:\n    if len(tofillfc) > 0:\n        # Fill the noise-colored cells adjacent to the inner rectangle with color 3\n        go = fill(gi, 3, backdrop(tofillfc) & ofcolor(gi, noisec))\n    else:\n        # If no cells to fill, output is same as input\n        go = gi\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3345333e": {
    "original": "def generate_3345333e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = unifint(diff_lb, diff_ub, (4, h - 2))\n    ow = unifint(diff_lb, diff_ub, (4, (w - 2) // 2))\n    nc = unifint(diff_lb, diff_ub, (min(oh, ow), (oh * ow) // 3 * 2))\n    shp = {(0, 0)}\n    bounds = asindices(canvas(-1, (oh, ow)))\n    for j in range(nc):\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    while height(shp) < 3 or width(shp) < 3:\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    vmshp = vmirror(shp)\n    if choice((True, False)):\n        vmshp = sfilter(vmshp, lambda ij: ij[1] != width(shp) - 1)\n    shp = normalize(combine(shp, shift(vmshp, (0, -width(vmshp)))))\n    oh, ow = shape(shp)\n    bgc, objc, occcol = sample(cols, 3)\n    loci = randint(1, h - oh - 1)\n    locj = randint(1, w - ow - 1)\n    loc = (loci, locj)\n    shp = shift(shp, loc)\n    c = canvas(bgc, (h, w))\n    go = fill(c, objc, shp)\n    boxh = unifint(diff_lb, diff_ub, (2, oh - 1))\n    boxw = unifint(diff_lb, diff_ub, (2, ow//2))\n    ulci = randint(loci - 1, loci + oh - boxh + 1)\n    ulcj = randint(locj + ow//2 + 1, locj + ow - boxw + 1)\n    bx = backdrop(frozenset({(ulci, ulcj), (ulci + boxh - 1, ulcj + boxw - 1)}))\n    gi = fill(go, occcol, bx)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3345333e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid (between 10 and 30)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid (between 10 and 30)\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the height of the object (between 4 and h-2)\n    oh = unifint(diff_lb, diff_ub, (4, h - 2))\n    \n    # Randomly determine the width of the object (between 4 and (w-2)/2)\n    ow = unifint(diff_lb, diff_ub, (4, (w - 2) // 2))\n    \n    # Randomly determine the number of cells in the object (between min(oh,ow) and 2/3 of oh*ow)\n    nc = unifint(diff_lb, diff_ub, (min(oh, ow), (oh * ow) // 3 * 2))\n    \n    # Initialize the shape with the top-left corner\n    shp = {(0, 0)}\n    \n    # Create a set of all possible indices within the object's dimensions\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Grow the shape by adding adjacent cells until we reach the desired number of cells\n    for j in range(nc):\n        # Choose a random cell adjacent to the current shape but within bounds\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    \n    # Ensure the shape is at least 3x3 by adding more cells if necessary\n    while height(shp) < 3 or width(shp) < 3:\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    \n    # Create a vertical mirror of the shape\n    vmshp = vmirror(shp)\n    \n    # Randomly decide whether to remove the rightmost column of the mirrored shape\n    if choice((True, False)):\n        vmshp = sfilter(vmshp, lambda ij: ij[1] != width(shp) - 1)\n    \n    # Combine the original shape with its (possibly modified) mirror, normalize, and update dimensions\n    shp = normalize(combine(shp, shift(vmshp, (0, -width(vmshp)))))\n    oh, ow = shape(shp)\n    \n    # Choose three distinct colors for background, object, and occluding box\n    bgc, objc, occcol = sample(cols, 3)\n    \n    # Randomly determine the location of the object within the grid\n    loci = randint(1, h - oh - 1)\n    locj = randint(1, w - ow - 1)\n    loc = (loci, locj)\n    \n    # Shift the shape to its final position\n    shp = shift(shp, loc)\n    \n    # Create the background grid\n    c = canvas(bgc, (h, w))\n    \n    # Place the object on the grid\n    go = fill(c, objc, shp)\n    \n    # Determine the size of the occluding box\n    boxh = unifint(diff_lb, diff_ub, (2, oh - 1))\n    boxw = unifint(diff_lb, diff_ub, (2, ow//2))\n    \n    # Determine the position of the occluding box\n    ulci = randint(loci - 1, loci + oh - boxh + 1)\n    ulcj = randint(locj + ow//2 + 1, locj + ow - boxw + 1)\n    \n    # Create the occluding box\n    bx = backdrop(frozenset({(ulci, ulcj), (ulci + boxh - 1, ulcj + boxw - 1)}))\n    \n    # Apply the occluding box to the grid\n    gi = fill(go, occcol, bx)\n    \n    # Define a list of possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose how many transformations to apply (1 or 2)\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen number of random transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the input (with occluding box) and output (without occluding box) grids\n    return {'input': gi, 'output': go}\n"
  },
  "3428a4f5": {
    "original": "def generate_3428a4f5(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    cola = choice(remcols)\n    colb = choice(remcols)\n    canv = canvas(bgc, (h, w))\n    inds = totuple(asindices(canv))\n    gbar = canvas(barcol, (h, 1))\n    mp = (h * w) // 2\n    devrng = (0, mp)\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    deva = sgna * deva\n    devb = sgnb * devb\n    numa = mp + deva\n    numb = mp + devb\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gi = hconcat(hconcat(gia, gbar), gib)\n    go = fill(canv, 3, (set(a) | set(b)) - (set(a) & set(b)))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3428a4f5(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-9, excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (1-30)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly determine the width of the grid (1-14)\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Set background color to 0\n    bgc = 0\n    \n    # Remove background color from color list\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a color for the separating bar\n    barcol = choice(remcols)\n    \n    # Remove bar color from remaining colors\n    remcols = remove(barcol, remcols)\n    \n    # Randomly choose two colors for the two sets\n    cola = choice(remcols)\n    colb = choice(remcols)\n    \n    # Create a canvas (grid) filled with background color\n    canv = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    \n    # Create a vertical bar grid with the bar color\n    gbar = canvas(barcol, (h, 1))\n    \n    # Calculate the midpoint (half of total cells)\n    mp = (h * w) // 2\n    \n    # Set deviation range from 0 to midpoint\n    devrng = (0, mp)\n    \n    # Randomly determine deviations for set A and B\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    \n    # Randomly choose signs for deviations\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    \n    # Apply signs to deviations\n    deva = sgna * deva\n    devb = sgnb * devb\n    \n    # Calculate number of cells for set A and B\n    numa = mp + deva\n    numb = mp + devb\n    \n    # Ensure number of cells is within valid range\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    \n    # Randomly sample indices for set A and B\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    \n    # Fill canvas with color A for set A\n    gia = fill(canv, cola, a)\n    \n    # Fill canvas with color B for set B\n    gib = fill(canv, colb, b)\n    \n    # Concatenate input grids horizontally with separating bar\n    gi = hconcat(hconcat(gia, gbar), gib)\n    \n    # Create output grid: fill with color 3 where A and B don't overlap\n    go = fill(canv, 3, (set(a) | set(b)) - (set(a) & set(b)))\n    \n    # 50% chance to mirror input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "3618c87e": {
    "original": "def generate_3618c87e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, linc, dotc = sample(cols, 3)\n    c = canvas(bgc, (h, w))\n    ln = connect((0, 0), (0, w - 1))\n    nlocs = unifint(diff_lb, diff_ub, (1, w//2))\n    locs = []\n    opts = interval(0, w, 1)\n    for k in range(nlocs):\n        if len(opts) == 0:\n            break\n        ch = choice(opts)\n        locs.append(ch)\n        opts = remove(ch, opts)\n        opts = remove(ch-1, opts)\n        opts = remove(ch+1, opts)\n    nlocs = len(opts)\n    gi = fill(c, linc, ln)\n    go = fill(c, linc, ln)\n    for j in locs:\n        hh = randint(1, h - 3)\n        lnx = connect((0, j), (hh, j))\n        gi = fill(gi, linc, lnx)\n        go = fill(go, linc, lnx)\n        gi = fill(gi, dotc, {(hh+1, j)})\n        go = fill(go, dotc, {(0, j)})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3618c87e(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select three distinct colors for background, lines, and dots\n    bgc, linc, dotc = sample(cols, 3)\n    \n    # Create a blank canvas with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Define a horizontal line at the top of the grid\n    ln = connect((0, 0), (0, w - 1))\n    \n    # Determine the number of vertical lines to be drawn (1 to half the width)\n    nlocs = unifint(diff_lb, diff_ub, (1, w//2))\n    \n    # Initialize an empty list to store the positions of vertical lines\n    locs = []\n    \n    # Create a list of all possible horizontal positions\n    opts = interval(0, w, 1)\n    \n    # Loop to select positions for vertical lines\n    for k in range(nlocs):\n        # Break if no more options are available\n        if len(opts) == 0:\n            break\n        \n        # Randomly choose a position for the vertical line\n        ch = choice(opts)\n        \n        # Add the chosen position to the list of line positions\n        locs.append(ch)\n        \n        # Remove the chosen position and adjacent positions from options\n        opts = remove(ch, opts)\n        opts = remove(ch-1, opts)\n        opts = remove(ch+1, opts)\n    \n    # Update the number of locations based on remaining options\n    nlocs = len(opts)\n    \n    # Create the input grid by drawing the horizontal line\n    gi = fill(c, linc, ln)\n    \n    # Create the output grid by drawing the horizontal line\n    go = fill(c, linc, ln)\n    \n    # Loop through each selected vertical line position\n    for j in locs:\n        # Randomly determine the height of the vertical line\n        hh = randint(1, h - 3)\n        \n        # Define the vertical line\n        lnx = connect((0, j), (hh, j))\n        \n        # Draw the vertical line on the input grid\n        gi = fill(gi, linc, lnx)\n        \n        # Draw the vertical line on the output grid\n        go = fill(go, linc, lnx)\n        \n        # Place a dot at the bottom of the vertical line in the input grid\n        gi = fill(gi, dotc, {(hh+1, j)})\n        \n        # Place a dot at the top of the vertical line in the output grid\n        go = fill(go, dotc, {(0, j)})\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3631a71a": {
    "original": "def generate_3631a71a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 15))\n    w = h\n    bgc, patchcol = sample(cols, 2)\n    patchcol = choice(cols)\n    bgc = choice(remove(patchcol, cols))\n    remcols = difference(cols, (bgc, patchcol))\n    c = canvas(bgc, (h, w))\n    inds = sfilter(asindices(c), lambda ij: ij[0] >= ij[1])\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    ncells = unifint(diff_lb, diff_ub, (1, len(inds)))\n    cells = set(sample(totuple(inds), ncells))\n    obj = {(choice(ccols), ij) for ij in cells}\n    c = paint(dmirror(paint(c, obj)), obj)\n    c = hconcat(c, vmirror(c))\n    c = vconcat(c, hmirror(c))\n    cutoff = 2\n    go = dmirror(dmirror(c[:-cutoff])[:-cutoff])\n    gi = tuple(e for e in go)\n    forbidden = asindices(canvas(-1, (cutoff, cutoff)))\n    dmirrareaL = shift(asindices(canvas(-1, (h*2-2*cutoff, cutoff))), (cutoff, 0))\n    dmirrareaT = shift(asindices(canvas(-1, (cutoff, 2*w-2*cutoff))), (0, cutoff))\n    inds1 = sfilter(asindices(gi), lambda ij: cutoff <= ij[0] < h and cutoff <= ij[1] < w and ij[0] >= ij[1])\n    inds2 = dmirror(inds1)\n    inds3 = shift(hmirror(inds1), (h-cutoff, 0))\n    inds4 = shift(hmirror(inds2), (h-cutoff, 0))\n    inds5 = shift(vmirror(inds1), (0, w-cutoff))\n    inds6 = shift(vmirror(inds2), (0, w-cutoff))\n    inds7 = shift(hmirror(vmirror(inds1)), (h-cutoff, w-cutoff))\n    inds8 = shift(hmirror(vmirror(inds2)), (h-cutoff, w-cutoff))\n    f1 = identity\n    f2 = dmirror\n    f3 = lambda x: hmirror(shift(x, invert((h-cutoff, 0))))\n    f4 = lambda x: dmirror(hmirror(shift(x, invert((h-cutoff, 0)))))\n    f5 = lambda x: vmirror(shift(x, invert((0, w-cutoff))))\n    f6 = lambda x: dmirror(vmirror(shift(x, invert((0, w-cutoff)))))\n    f7 = lambda x: vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff)))))\n    f8 = lambda x: dmirror(vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff))))))\n    indsarr = [inds1, inds2, inds3, inds4, inds5, inds6, inds7, inds8]\n    farr = [f1, f2, f3, f4, f5, f6, f7, f8]\n    ndist = unifint(diff_lb, diff_ub, (1, int((2*h*2*w) ** 0.5)))\n    succ = 0\n    tr = 0\n    maxtr = 10 * ndist\n    fullh, fullw = shape(gi)\n    while succ < ndist and tr < maxtr:\n        tr += 1\n        oh = randint(2, h//2+1)\n        ow = randint(2, w//2+1)\n        loci = randint(0, fullh - oh)\n        locj = randint(0, fullw - ow)\n        bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        isleft = set()\n        gi2 = fill(gi, patchcol, bd)\n        if patchcol in palette(toobject(forbidden, gi2)):\n            continue\n        oo1 = toindices(sfilter(toobject(dmirrareaL, gi2), lambda cij: cij[0] != patchcol))\n        oo2 = toindices(sfilter(toobject(dmirrareaT, gi2), lambda cij: cij[0] != patchcol))\n        oo2 = frozenset({(ij[1], ij[0]) for ij in oo2})\n        if oo1 | oo2 != dmirrareaL:\n            continue\n        for ii, ff in zip(indsarr, farr):\n            oo = toobject(ii, gi2)\n            rem = toindices(sfilter(oo, lambda cij: cij[0] != patchcol))\n            if len(rem) > 0:\n                isleft = isleft | ff(rem)\n        if isleft != inds1:\n            continue\n        succ += 1\n        gi = gi2\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3631a71a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height (and width) between 6 and 15 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 15))\n    w = h  # Set width equal to height\n    \n    # Randomly select two colors from the range\n    bgc, patchcol = sample(cols, 2)\n    \n    # Randomly choose a color for the patch\n    patchcol = choice(cols)\n    \n    # Choose a background color different from the patch color\n    bgc = choice(remove(patchcol, cols))\n    \n    # Get the remaining colors not used for background or patch\n    remcols = difference(cols, (bgc, patchcol))\n    \n    # Create a canvas with the background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Select indices where row index is greater than or equal to column index\n    inds = sfilter(asindices(c), lambda ij: ij[0] >= ij[1])\n    \n    # Randomly choose number of colors to use (between 1 and 8)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Randomly choose number of cells to color (between 1 and len(inds))\n    ncells = unifint(diff_lb, diff_ub, (1, len(inds)))\n    \n    # Randomly select cells to color\n    cells = set(sample(totuple(inds), ncells))\n    \n    # Create an object by assigning random colors to the selected cells\n    obj = {(choice(ccols), ij) for ij in cells}\n    \n    # Paint the object on the canvas and its diagonal mirror\n    c = paint(dmirror(paint(c, obj)), obj)\n    \n    # Concatenate the canvas with its vertical mirror horizontally\n    c = hconcat(c, vmirror(c))\n    \n    # Concatenate the result with its horizontal mirror vertically\n    c = vconcat(c, hmirror(c))\n    \n    # Define a cutoff value\n    cutoff = 2\n    \n    # Create output grid by applying diagonal mirror twice and removing cutoff rows/columns\n    go = dmirror(dmirror(c[:-cutoff])[:-cutoff])\n    \n    # Convert output grid to a tuple\n    gi = tuple(e for e in go)\n    \n    # Create a set of forbidden indices\n    forbidden = asindices(canvas(-1, (cutoff, cutoff)))\n    \n    # Create areas for diagonal mirroring on left and top\n    dmirrareaL = shift(asindices(canvas(-1, (h*2-2*cutoff, cutoff))), (cutoff, 0))\n    dmirrareaT = shift(asindices(canvas(-1, (cutoff, 2*w-2*cutoff))), (0, cutoff))\n    \n    # Select indices for different quadrants of the grid\n    inds1 = sfilter(asindices(gi), lambda ij: cutoff <= ij[0] < h and cutoff <= ij[1] < w and ij[0] >= ij[1])\n    inds2 = dmirror(inds1)\n    inds3 = shift(hmirror(inds1), (h-cutoff, 0))\n    inds4 = shift(hmirror(inds2), (h-cutoff, 0))\n    inds5 = shift(vmirror(inds1), (0, w-cutoff))\n    inds6 = shift(vmirror(inds2), (0, w-cutoff))\n    inds7 = shift(hmirror(vmirror(inds1)), (h-cutoff, w-cutoff))\n    inds8 = shift(hmirror(vmirror(inds2)), (h-cutoff, w-cutoff))\n    \n    # Define functions for different transformations\n    f1 = identity\n    f2 = dmirror\n    f3 = lambda x: hmirror(shift(x, invert((h-cutoff, 0))))\n    f4 = lambda x: dmirror(hmirror(shift(x, invert((h-cutoff, 0)))))\n    f5 = lambda x: vmirror(shift(x, invert((0, w-cutoff))))\n    f6 = lambda x: dmirror(vmirror(shift(x, invert((0, w-cutoff)))))\n    f7 = lambda x: vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff)))))\n    f8 = lambda x: dmirror(vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff))))))\n    \n    # Create arrays of indices and functions\n    indsarr = [inds1, inds2, inds3, inds4, inds5, inds6, inds7, inds8]\n    farr = [f1, f2, f3, f4, f5, f6, f7, f8]\n    \n    # Randomly choose number of distortions to apply\n    ndist = unifint(diff_lb, diff_ub, (1, int((2*h*2*w) ** 0.5)))\n    \n    succ = 0  # Counter for successful distortions\n    tr = 0    # Counter for attempts\n    maxtr = 10 * ndist  # Maximum number of attempts\n    \n    # Get full height and width of the input grid\n    fullh, fullw = shape(gi)\n    \n    # Loop to apply distortions\n    while succ < ndist and tr < maxtr:\n        tr += 1\n        \n        # Randomly choose dimensions and location for a patch\n        oh = randint(2, h//2+1)\n        ow = randint(2, w//2+1)\n        loci = randint(0, fullh - oh)\n        locj = randint(0, fullw - ow)\n        \n        # Create backdrop for the patch\n        bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        isleft = set()\n        \n        # Fill the patch with the patch color\n        gi2 = fill(gi, patchcol, bd)\n        \n        # Check if patch overlaps with forbidden area\n        if patchcol in palette(toobject(forbidden, gi2)):\n            continue\n        \n        # Check diagonal mirror areas\n        oo1 = toindices(sfilter(toobject(dmirrareaL, gi2), lambda cij: cij[0] != patchcol))\n        oo2 = toindices(sfilter(toobject(dmirrareaT, gi2), lambda cij: cij[0] != patchcol))\n        oo2 = frozenset({(ij[1], ij[0]) for ij in oo2})\n        if oo1 | oo2 != dmirrareaL:\n            continue\n        \n        # Apply transformations and check results\n        for ii, ff in zip(indsarr, farr):\n            oo = toobject(ii, gi2)\n            rem = toindices(sfilter(oo, lambda cij: cij[0] != patchcol))\n            if len(rem) > 0:\n                isleft = isleft | ff(rem)\n        \n        # Check if transformation preserves symmetry\n        if isleft != inds1:\n            continue\n        \n        # If all checks pass, increment success counter and update input grid\n        succ += 1\n        gi = gi2\n    \n    # Return dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "363442ee": {
    "original": "def generate_363442ee(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 3))\n    w = unifint(diff_lb, diff_ub, (1, 3))\n    h = h * 2 + 1\n    w = w * 2 + 1\n    nremh = unifint(diff_lb, diff_ub, (2, 30 // h))\n    nremw = unifint(diff_lb, diff_ub, (2, (30 - w - 1) // w))\n    rsh = nremh * h\n    rsw = nremw * w\n    rss = (rsh, rsw)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    rsi = canvas(bgc, rss)\n    rso = canvas(bgc, rss)\n    ls = canvas(bgc, ((nremh - 1) * h, w))\n    ulc = canvas(bgc, (h, w))\n    bar = canvas(barcol, (nremh * h, 1))\n    dotcands = totuple(product(interval(0, rsh, h), interval(0, rsw, w)))\n    dotcol = choice(remcols)\n    dev = unifint(diff_lb, diff_ub, (1, len(dotcands) // 2))\n    ndots = choice((dev, len(dotcands) - dev))\n    ndots = min(max(1, ndots), len(dotcands))\n    dots = sample(dotcands, ndots)\n    nfullremcols = unifint(diff_lb, diff_ub, (1, 8))\n    fullremcols = sample(remcols, nfullremcols)\n    for ij in asindices(ulc):\n        ulc = fill(ulc, choice(fullremcols), {ij})\n    ulco = asobject(ulc)\n    osf = (h//2, w//2)\n    for d in dots:\n        rsi = fill(rsi, dotcol, {add(osf, d)})\n        rso = paint(rso, shift(ulco, d))\n    gi = hconcat(hconcat(vconcat(ulc, ls), bar), rsi)\n    go = hconcat(hconcat(vconcat(ulc, ls), bar), rso)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_363442ee(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Determine the height and width of the unit cell\n    # The difficulty affects the size: higher difficulty, potentially larger size\n    h = unifint(diff_lb, diff_ub, (1, 3))\n    w = unifint(diff_lb, diff_ub, (1, 3))\n    \n    # Ensure odd dimensions for the unit cell\n    h = h * 2 + 1\n    w = w * 2 + 1\n    \n    # Determine the number of repeats for height and width\n    # This affects the overall size of the grid\n    nremh = unifint(diff_lb, diff_ub, (2, 30 // h))\n    nremw = unifint(diff_lb, diff_ub, (2, (30 - w - 1) // w))\n    \n    # Calculate the total size of the right side of the grid\n    rsh = nremh * h\n    rsw = nremw * w\n    rss = (rsh, rsw)\n    \n    # Choose background color\n    bgc = choice(cols)\n    \n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose color for the vertical bar\n    barcol = choice(remcols)\n    \n    # Remove bar color from remaining colors\n    remcols = remove(barcol, remcols)\n    \n    # Create the right side input and output grids with background color\n    rsi = canvas(bgc, rss)\n    rso = canvas(bgc, rss)\n    \n    # Create the left side of the grid\n    ls = canvas(bgc, ((nremh - 1) * h, w))\n    \n    # Create the upper-left corner unit cell\n    ulc = canvas(bgc, (h, w))\n    \n    # Create the vertical bar\n    bar = canvas(barcol, (nremh * h, 1))\n    \n    # Generate candidate positions for dots\n    dotcands = totuple(product(interval(0, rsh, h), interval(0, rsw, w)))\n    \n    # Choose color for dots\n    dotcol = choice(remcols)\n    \n    # Determine the number of dots based on difficulty\n    dev = unifint(diff_lb, diff_ub, (1, len(dotcands) // 2))\n    ndots = choice((dev, len(dotcands) - dev))\n    ndots = min(max(1, ndots), len(dotcands))\n    \n    # Randomly select dot positions\n    dots = sample(dotcands, ndots)\n    \n    # Choose number of colors for the unit cell\n    nfullremcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Select colors for the unit cell\n    fullremcols = sample(remcols, nfullremcols)\n    \n    # Fill the unit cell with random colors\n    for ij in asindices(ulc):\n        ulc = fill(ulc, choice(fullremcols), {ij})\n    \n    # Convert unit cell to object representation\n    ulco = asobject(ulc)\n    \n    # Calculate offset for dot placement\n    osf = (h//2, w//2)\n    \n    # Place dots on input grid and corresponding unit cells on output grid\n    for d in dots:\n        rsi = fill(rsi, dotcol, {add(osf, d)})\n        rso = paint(rso, shift(ulco, d))\n    \n    # Construct the full input and output grids\n    gi = hconcat(hconcat(vconcat(ulc, ls), bar), rsi)\n    go = hconcat(hconcat(vconcat(ulc, ls), bar), rso)\n    \n    # Define possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose number of transformations to apply\n    nmfs = choice((1, 2))\n    \n    # Apply random transformations to both input and output\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "36d67576": {
    "original": "def generate_36d67576(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        bgc, mainc, markerc = sample(cols, 3)\n        remcols = difference(cols, (bgc, mainc, markerc))\n        ncols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n        ccols = sample(remcols, ncols)\n        gi = canvas(bgc, (h, w))\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        ow = unifint(diff_lb, diff_ub, (3 if oh == 2 else 2, 5))\n        if choice((True, False)):\n            oh, ow = ow, oh\n        bounds = asindices(canvas(-1, (oh, ow)))\n        ncells = unifint(diff_lb, diff_ub, (4, len(bounds)))\n        obj = {choice(totuple(bounds))}\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        obj = normalize(obj)\n        oh, ow = shape(obj)\n        ntocompc = unifint(diff_lb, diff_ub, (1, ncells - 3))\n        markercell = choice(totuple(obj))\n        remobj = remove(markercell, obj)\n        markercellobj = {(markerc, markercell)}\n        tocompc = set(sample(totuple(remobj), ntocompc))\n        mainpart = (obj - {markercell}) - tocompc\n        mainpartobj = recolor(mainc, mainpart)\n        tocompcobj = {(choice(remcols), ij) for ij in tocompc}\n        obj = tocompcobj | mainpartobj | markercellobj\n        smobj = mainpartobj | markercellobj\n        smobjn = normalize(smobj)\n        isfakesymm = False\n        for symmf in [dmirror, cmirror, hmirror, vmirror]:\n            if symmf(smobjn) == smobjn and symmf(obj) != obj:\n                isfakesymm = True\n                break\n        if isfakesymm:\n            continue\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        plcd = shift(obj, (loci, locj))\n        gi = paint(gi, plcd)\n        plcdi = toindices(plcd)\n        inds = (asindices(gi) - plcdi) - mapply(neighbors, plcdi)\n        noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (2 * len(obj)))))\n        succ = 0\n        tr = 0\n        maxtr = noccs * 5\n        go = tuple(e for e in gi)\n        while tr < maxtr and succ < noccs:\n            tr += 1\n            mf1 = choice((identity, dmirror, cmirror, hmirror, vmirror))\n            mf2 = choice((identity, dmirror, cmirror, hmirror, vmirror))\n            mf = compose(mf1, mf2)\n            outobj = normalize(mf(obj))\n            inobj = sfilter(outobj, lambda cij: cij[0] in [mainc, markerc])\n            oh, ow = shape(outobj)\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            outobjp = shift(outobj, loc)\n            inobjp = shift(inobj, loc)\n            outobjpi = toindices(outobjp)\n            if outobjpi.issubset(inds):\n                succ += 1\n                inds = (inds - outobjpi) - mapply(neighbors, outobjpi)\n                gi = paint(gi, inobjp)\n                go = paint(go, outobjp)\n        break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_36d67576(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    while True:\n        # Randomly generate grid height between 10 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        # Randomly generate grid width between 10 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        # Randomly select 3 colors: background, main, and marker\n        bgc, mainc, markerc = sample(cols, 3)\n        # Get the remaining colors not used for bg, main, or marker\n        remcols = difference(cols, (bgc, mainc, markerc))\n        # Choose a random number of additional colors to use\n        ncols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n        # Randomly select the additional colors\n        ccols = sample(remcols, ncols)\n        # Create an initial grid filled with the background color\n        gi = canvas(bgc, (h, w))\n        # Randomly generate object height between 2 and 5\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        # Randomly generate object width between 2 and 5, ensuring it's at least 3 if height is 2\n        ow = unifint(diff_lb, diff_ub, (3 if oh == 2 else 2, 5))\n        # 50% chance to swap height and width (rotate object)\n        if choice((True, False)):\n            oh, ow = ow, oh\n        # Create a set of all possible coordinates within the object's dimensions\n        bounds = asindices(canvas(-1, (oh, ow)))\n        # Choose a random number of cells for the object between 4 and the total possible cells\n        ncells = unifint(diff_lb, diff_ub, (4, len(bounds)))\n        # Start creating the object with a random cell\n        obj = {choice(totuple(bounds))}\n        # Add more cells to the object, ensuring they're connected\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        # Normalize the object's position (move to top-left corner)\n        obj = normalize(obj)\n        # Get the final height and width of the created object\n        oh, ow = shape(obj)\n        # Choose a random number of cells to assign different colors\n        ntocompc = unifint(diff_lb, diff_ub, (1, ncells - 3))\n        # Select a random cell for the marker color\n        markercell = choice(totuple(obj))\n        # Remove the marker cell from the object\n        remobj = remove(markercell, obj)\n        # Create a single-cell object with the marker color\n        markercellobj = {(markerc, markercell)}\n        # Randomly select cells to be assigned different colors\n        tocompc = set(sample(totuple(remobj), ntocompc))\n        # The main part of the object (excluding marker and differently colored cells)\n        mainpart = (obj - {markercell}) - tocompc\n        # Color the main part with the main color\n        mainpartobj = recolor(mainc, mainpart)\n        # Assign random colors to the selected cells\n        tocompcobj = {(choice(remcols), ij) for ij in tocompc}\n        # Combine all parts of the object\n        obj = tocompcobj | mainpartobj | markercellobj\n        # Create a simplified object (main part + marker)\n        smobj = mainpartobj | markercellobj\n        # Normalize the simplified object\n        smobjn = normalize(smobj)\n        # Flag to check if the object has fake symmetry\n        isfakesymm = False\n        # Check for fake symmetry (simplified object is symmetric but full object isn't)\n        for symmf in [dmirror, cmirror, hmirror, vmirror]:\n            if symmf(smobjn) == smobjn and symmf(obj) != obj:\n                isfakesymm = True\n                break\n        # If fake symmetry is found, restart the object generation\n        if isfakesymm:\n            continue\n        # Choose a random location to place the object on the grid\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        # Shift the object to the chosen location\n        plcd = shift(obj, (loci, locj))\n        # Paint the object onto the input grid\n        gi = paint(gi, plcd)\n        # Get the indices of the placed object\n        plcdi = toindices(plcd)\n        # Find all available spaces on the grid (not occupied or adjacent to the object)\n        inds = (asindices(gi) - plcdi) - mapply(neighbors, plcdi)\n        # Choose a random number of additional occurrences to place\n        noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (2 * len(obj)))))\n        # Counter for successful placements\n        succ = 0\n        # Counter for placement attempts\n        tr = 0\n        # Maximum number of attempts\n        maxtr = noccs * 5\n        # Create the output grid (initially same as input)\n        go = tuple(e for e in gi)\n        # Loop to place additional occurrences\n        while tr < maxtr and succ < noccs:\n            tr += 1\n            # Choose random mirror functions for transformation\n            mf1 = choice((identity, dmirror, cmirror, hmirror, vmirror))\n            mf2 = choice((identity, dmirror, cmirror, hmirror, vmirror))\n            # Compose the two mirror functions\n            mf = compose(mf1, mf2)\n            # Apply the transformation to the object\n            outobj = normalize(mf(obj))\n            # Get the inner part of the transformed object (main color and marker)\n            inobj = sfilter(outobj, lambda cij: cij[0] in [mainc, markerc])\n            # Get the dimensions of the transformed object\n            oh, ow = shape(outobj)\n            # Find possible locations to place the transformed object\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            # If no valid locations, try again\n            if len(cands) == 0:\n                continue\n            # Choose a random location from the candidates\n            loc = choice(totuple(cands))\n            # Shift the transformed object to the chosen location\n            outobjp = shift(outobj, loc)\n            inobjp = shift(inobj, loc)\n            # Get the indices of the placed transformed object\n            outobjpi = toindices(outobjp)\n            # If the placement is valid (doesn't overlap with existing objects)\n            if outobjpi.issubset(inds):\n                succ += 1\n                # Update available spaces\n                inds = (inds - outobjpi) - mapply(neighbors, outobjpi)\n                # Paint the inner part on the input grid\n                gi = paint(gi, inobjp)\n                # Paint the full object on the output grid\n                go = paint(go, outobjp)\n        # If placement loop completes successfully, exit the main loop\n        break\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "36fdfd69": {
    "original": "def generate_36fdfd69(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (4,))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    bgc, fgc, objc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    namt = randint(int(0.35 * h * w), int(0.65 * h * w))\n    noise = sample(totuple(inds), namt)\n    gi = fill(gi, fgc, noise)\n    go = tuple(e for e in gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        if bd.issubset(inds):\n            ncells = randint(2, oh * ow - 1)\n            obj = {choice(totuple(bd))}\n            for k in range(ncells - 1):\n                obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))\n            while len(obj) == height(obj) * width(obj):\n                obj = {choice(totuple(bd))}\n                for k in range(ncells - 1):\n                    obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))\n            obj = normalize(obj)\n            oh, ow = shape(obj)\n            obj = shift(obj, loc)\n            bd = backdrop(obj)\n            gi2 = fill(gi, fgc, bd)\n            gi2 = fill(gi2, objc, obj)\n            if colorcount(gi2, objc) < min(colorcount(gi2, fgc), colorcount(gi2, bgc)):\n                succ += 1\n                inds = (inds - bd) - (outbox(bd) | outbox(outbox(bd)))\n                gi = gi2\n                go = fill(go, 4, bd)\n                go = fill(go, objc, obj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_36fdfd69(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 4\n    cols = difference(interval(0, 10, 1), (4,))\n    \n    # Determine grid height based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Determine grid width based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Determine number of objects to place based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))\n    \n    # Randomly select three colors for background, foreground, and objects\n    bgc, fgc, objc = sample(cols, 3)\n    \n    # Create initial input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Initialize counters for successful object placements and attempts\n    succ = 0\n    tr = 0\n    \n    # Set maximum number of placement attempts\n    maxtr = 5 * nobjs\n    \n    # Determine number of noise cells to add (35-65% of grid size)\n    namt = randint(int(0.35 * h * w), int(0.65 * h * w))\n    \n    # Randomly select cells for noise\n    noise = sample(totuple(inds), namt)\n    \n    # Add noise to the input grid by filling selected cells with foreground color\n    gi = fill(gi, fgc, noise)\n    \n    # Create initial output grid as a copy of input grid\n    go = tuple(e for e in gi)\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1  # Increment attempt counter\n        \n        # Randomly determine object height and width\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        \n        # Find valid locations for object placement\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create a backdrop for the object\n        bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Check if backdrop is within grid boundaries\n        if bd.issubset(inds):\n            # Determine number of cells for the object\n            ncells = randint(2, oh * ow - 1)\n            \n            # Initialize object with a random cell\n            obj = {choice(totuple(bd))}\n            \n            # Add cells to the object\n            for k in range(ncells - 1):\n                obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))\n            \n            # Ensure object is not rectangular\n            while len(obj) == height(obj) * width(obj):\n                obj = {choice(totuple(bd))}\n                for k in range(ncells - 1):\n                    obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))\n            \n            # Normalize and shift object to its placement location\n            obj = normalize(obj)\n            oh, ow = shape(obj)\n            obj = shift(obj, loc)\n            \n            # Update backdrop based on final object shape\n            bd = backdrop(obj)\n            \n            # Create a temporary grid with object placement\n            gi2 = fill(gi, fgc, bd)\n            gi2 = fill(gi2, objc, obj)\n            \n            # Check if object color is least common in the grid\n            if colorcount(gi2, objc) < min(colorcount(gi2, fgc), colorcount(gi2, bgc)):\n                succ += 1  # Increment successful placement counter\n                \n                # Update available indices for future placements\n                inds = (inds - bd) - (outbox(bd) | outbox(outbox(bd)))\n                \n                # Update input grid with new object\n                gi = gi2\n                \n                # Update output grid: mark object backdrop with color 4, fill object with its color\n                go = fill(go, 4, bd)\n                go = fill(go, objc, obj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3906de3d": {
    "original": "def generate_3906de3d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    oh = unifint(diff_lb, diff_ub, (2, h // 2))\n    ow = unifint(diff_lb, diff_ub, (3, w - 2))\n    bgc, boxc, linc = sample(cols, 3)\n    locj = randint(1, w - ow - 1)\n    bx = backdrop(frozenset({(0, locj), (oh - 1, locj + ow - 1)}))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, boxc, bx)\n    rng = range(locj, locj + ow)\n    cutoffs = [randint(1, oh - 1) for j in rng]\n    for jj, co in zip(rng, cutoffs):\n        gi = fill(gi, bgc, connect((co, jj), (oh - 1, jj)))\n    numlns = unifint(diff_lb, diff_ub, (1, ow - 1))\n    lnlocs = sample(list(rng), numlns)\n    go = tuple(e for e in gi)\n    for jj, co in zip(rng, cutoffs):\n        if jj in lnlocs:\n            lineh = randint(1, h - co - 1)\n            linei = connect((h - lineh, jj), (h - 1, jj))\n            lineo = connect((co, jj), (co + lineh - 1, jj))\n            gi = fill(gi, linc, linei)\n            go = fill(go, linc, lineo)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3906de3d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the height of the object (box) based on difficulty\n    oh = unifint(diff_lb, diff_ub, (2, h // 2))\n    \n    # Randomly determine the width of the object (box) based on difficulty\n    ow = unifint(diff_lb, diff_ub, (3, w - 2))\n    \n    # Randomly select three distinct colors for background, box, and lines\n    bgc, boxc, linc = sample(cols, 3)\n    \n    # Randomly determine the left edge position of the box\n    locj = randint(1, w - ow - 1)\n    \n    # Create a set of coordinates for the box\n    bx = backdrop(frozenset({(0, locj), (oh - 1, locj + ow - 1)}))\n    \n    # Create the initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill the box area with the box color\n    gi = fill(gi, boxc, bx)\n    \n    # Define the range of columns for the box\n    rng = range(locj, locj + ow)\n    \n    # Randomly determine cutoff heights for each column in the box\n    cutoffs = [randint(1, oh - 1) for j in rng]\n    \n    # Create gaps in the box by filling with background color up to cutoff heights\n    for jj, co in zip(rng, cutoffs):\n        gi = fill(gi, bgc, connect((co, jj), (oh - 1, jj)))\n    \n    # Randomly determine the number of lines to add based on difficulty\n    numlns = unifint(diff_lb, diff_ub, (1, ow - 1))\n    \n    # Randomly select columns where lines will be added\n    lnlocs = sample(list(rng), numlns)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Add lines to both input and output grids\n    for jj, co in zip(rng, cutoffs):\n        if jj in lnlocs:\n            # Randomly determine the height of the line\n            lineh = randint(1, h - co - 1)\n            \n            # Create coordinates for the line in the input grid\n            linei = connect((h - lineh, jj), (h - 1, jj))\n            \n            # Create coordinates for the line in the output grid\n            lineo = connect((co, jj), (co + lineh - 1, jj))\n            \n            # Add the line to the input grid\n            gi = fill(gi, linc, linei)\n            \n            # Add the line to the output grid\n            go = fill(go, linc, lineo)\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "39a8645d": {
    "original": "def generate_39a8645d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (15, 30))\n    w = unifint(diff_lb, diff_ub, (15, 30))\n    oh = randint(2, 4)\n    ow = randint(2, 4)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nobjs = unifint(diff_lb, diff_ub, (1, oh + ow))\n    ccols = sample(remcols, nobjs+1)\n    mxcol = ccols[0]\n    rcols = ccols[1:]\n    maxnocc = unifint(diff_lb, diff_ub, (nobjs + 2, max(nobjs + 2, (h * w) // 16)))\n    tr = 0\n    maxtr = 10 * maxnocc\n    succ = 0\n    allobjs = []\n    bounds = asindices(canvas(-1, (oh, ow)))\n    for k in range(nobjs + 1):\n        while True:\n            ncells = randint(oh + ow - 1, oh * ow)\n            cobj = {choice(totuple(bounds))}\n            while shape(cobj) != (oh, ow) and len(cobj) < ncells:\n                cobj.add(choice(totuple((bounds - cobj) & mapply(neighbors, cobj))))\n            if cobj not in allobjs:\n                break\n        allobjs.append(frozenset(cobj))\n    mcobj = normalize(allobjs[0])\n    remobjs = apply(normalize, allobjs[1:])\n    mxobjcounter = 0\n    remobjcounter = {robj: 0 for robj in remobjs}\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while tr < maxtr and succ < maxnocc:\n        tr += 1\n        candobjs = [robj for robj, cnt in remobjcounter.items() if cnt + 1 < mxobjcounter]\n        if len(candobjs) == 0 or randint(0, 100) / 100 > diff_lb:\n            obj = mcobj\n            col = mxcol\n        else:\n            obj = choice(candobjs)\n            col = rcols[remobjs.index(obj)]\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds - mapply(neighbors, ofcolor(gi, col))):\n            succ += 1\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            gi = fill(gi, col, plcd)\n            if obj in remobjcounter:\n                remobjcounter[obj] += 1\n            else:\n                mxobjcounter += 1\n    go = fill(canvas(bgc, shape(mcobj)), mxcol, mcobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_39a8645d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (15, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (15, 30))\n    \n    # Randomly choose the height of objects (2 to 4)\n    oh = randint(2, 4)\n    \n    # Randomly choose the width of objects (2 to 4)\n    ow = randint(2, 4)\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of objects based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, oh + ow))\n    \n    # Randomly select colors for objects (including the main object color)\n    ccols = sample(remcols, nobjs+1)\n    \n    # Set the color for the main object\n    mxcol = ccols[0]\n    \n    # Set colors for the remaining objects\n    rcols = ccols[1:]\n    \n    # Determine the maximum number of occurrences based on difficulty\n    maxnocc = unifint(diff_lb, diff_ub, (nobjs + 2, max(nobjs + 2, (h * w) // 16)))\n    \n    # Initialize counters and lists\n    tr = 0  # Trial counter\n    maxtr = 10 * maxnocc  # Maximum number of trials\n    succ = 0  # Success counter\n    allobjs = []  # List to store all objects\n    \n    # Define the bounds for object placement\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Generate objects\n    for k in range(nobjs + 1):\n        while True:\n            # Determine the number of cells for the object\n            ncells = randint(oh + ow - 1, oh * ow)\n            \n            # Start with a random cell within the bounds\n            cobj = {choice(totuple(bounds))}\n            \n            # Grow the object by adding neighboring cells\n            while shape(cobj) != (oh, ow) and len(cobj) < ncells:\n                cobj.add(choice(totuple((bounds - cobj) & mapply(neighbors, cobj))))\n            \n            # If the object is unique, add it to the list\n            if cobj not in allobjs:\n                break\n        allobjs.append(frozenset(cobj))\n    \n    # Normalize the main object\n    mcobj = normalize(allobjs[0])\n    \n    # Normalize the remaining objects\n    remobjs = apply(normalize, allobjs[1:])\n    \n    # Initialize counters for object occurrences\n    mxobjcounter = 0\n    remobjcounter = {robj: 0 for robj in remobjs}\n    \n    # Create the initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing objects on the grid\n    while tr < maxtr and succ < maxnocc:\n        tr += 1\n        \n        # Determine candidate objects for placement\n        candobjs = [robj for robj, cnt in remobjcounter.items() if cnt + 1 < mxobjcounter]\n        \n        # Choose between main object and other objects based on difficulty\n        if len(candobjs) == 0 or randint(0, 100) / 100 > diff_lb:\n            obj = mcobj\n            col = mxcol\n        else:\n            obj = choice(candobjs)\n            col = rcols[remobjs.index(obj)]\n        \n        # Find valid placement locations\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # Break if no valid locations are available\n        if len(cands) == 0:\n            break\n        \n        # Choose a random location for placement\n        loc = choice(totuple(cands))\n        \n        # Shift the object to the chosen location\n        plcd = shift(obj, loc)\n        \n        # Check if the placement is valid (not adjacent to same color)\n        if plcd.issubset(inds - mapply(neighbors, ofcolor(gi, col))):\n            succ += 1\n            \n            # Update available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            \n            # Place the object on the grid\n            gi = fill(gi, col, plcd)\n            \n            # Update object counters\n            if obj in remobjcounter:\n                remobjcounter[obj] += 1\n            else:\n                mxobjcounter += 1\n    \n    # Create the output grid with the main object\n    go = fill(canvas(bgc, shape(mcobj)), mxcol, mcobj)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "39e1d7f9": {
    "original": "def generate_39e1d7f9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 10))\n    w = unifint(diff_lb, diff_ub, (5, 10))\n    bgc, linc, dotc = sample(cols, 3)\n    remcols = difference(cols, (bgc, linc, dotc))\n    gi = canvas(bgc, (h, w))\n    loci = randint(1, h - 2)\n    locj = randint(1, w - 2)\n    if h == 5:\n        loci = choice((1, h - 2))\n    if w == 5:\n        locj = choice((1, w - 2))\n    npix = unifint(diff_lb, diff_ub, (1, 8))\n    ncols = unifint(diff_lb, diff_ub, (1, 7))\n    ccols = sample(remcols, ncols)\n    candsss = neighbors((loci, locj))\n    pixs = {(loci, locj)}\n    for k in range(npix):\n        pixs.add(choice(totuple((mapply(dneighbors, pixs) & candsss) - pixs)))\n    pixs = totuple(remove((loci, locj), pixs))\n    obj = {(choice(ccols), ij) for ij in pixs}\n    gi = fill(gi, dotc, {(loci, locj)})\n    gi = paint(gi, obj)\n    go = tuple(e for e in gi)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * len(pixs) + 1)))\n    succ = 0\n    tr = 0\n    maxtr = 6 * noccs\n    inds = ofcolor(gi, bgc) - mapply(dneighbors, neighbors((loci, locj)))\n    objn = shift(obj, (-loci, -locj))\n    triedandfailed = set()\n    while (tr < maxtr and succ < noccs) or succ == 0:\n        lopcands = totuple(inds - triedandfailed)\n        if len(lopcands) == 0:\n            break\n        tr += 1\n        loci, locj = choice(lopcands)\n        plcd = shift(objn, (loci, locj))\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            inds = inds - (plcdi | {(loci, locj)})\n            succ += 1\n            gi = fill(gi, dotc, {(loci, locj)})\n            go = fill(go, dotc, {(loci, locj)})\n            go = paint(go, plcd)\n        else:\n            triedandfailed.add((loci, locj))\n    hfac = unifint(diff_lb, diff_ub, (1, (30 - h + 1) // h))\n    wfac = unifint(diff_lb, diff_ub, (1, (30 - w + 1) // w))\n    fullh = hfac * h + h - 1\n    fullw = wfac * w + w - 1\n    gi2 = canvas(linc, (fullh, fullw))\n    go2 = canvas(linc, (fullh, fullw))\n    bd = asindices(canvas(-1, (hfac, wfac)))\n    for a in range(h):\n        for b in range(w):\n            c = gi[a][b]\n            gi2 = fill(gi2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))\n    for a in range(h):\n        for b in range(w):\n            c = go[a][b]\n            go2 = fill(go2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))\n    gi, go = gi2, go2\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_39e1d7f9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose height between 5 and 10 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 10))\n    \n    # Randomly choose width between 5 and 10 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 10))\n    \n    # Randomly select 3 colors for background, lines, and dots\n    bgc, linc, dotc = sample(cols, 3)\n    \n    # Get remaining colors not used for background, lines, and dots\n    remcols = difference(cols, (bgc, linc, dotc))\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Choose random row index for initial dot, avoiding edges\n    loci = randint(1, h - 2)\n    \n    # Choose random column index for initial dot, avoiding edges\n    locj = randint(1, w - 2)\n    \n    # If height is 5, force dot to be on second or second-to-last row\n    if h == 5:\n        loci = choice((1, h - 2))\n    \n    # If width is 5, force dot to be on second or second-to-last column\n    if w == 5:\n        locj = choice((1, w - 2))\n    \n    # Choose number of pixels in the object (1 to 8)\n    npix = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Choose number of colors for the object (1 to 7)\n    ncols = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Select colors for the object\n    ccols = sample(remcols, ncols)\n    \n    # Get neighbors of the initial dot location\n    candsss = neighbors((loci, locj))\n    \n    # Initialize set of pixels with the initial dot location\n    pixs = {(loci, locj)}\n    \n    # Add random neighboring pixels to form the object\n    for k in range(npix):\n        # Choose a new pixel from neighbors of existing pixels, within constraints\n        pixs.add(choice(totuple((mapply(dneighbors, pixs) & candsss) - pixs)))\n    \n    # Remove the initial dot location from the object pixels\n    pixs = totuple(remove((loci, locj), pixs))\n    \n    # Create the object by assigning random colors to pixels\n    obj = {(choice(ccols), ij) for ij in pixs}\n    \n    # Place the initial dot on the input grid\n    gi = fill(gi, dotc, {(loci, locj)})\n    \n    # Paint the object on the input grid\n    gi = paint(gi, obj)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Determine number of occurrences to place (1 to half the grid area divided by object size)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * len(pixs) + 1)))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 6 * noccs\n    \n    # Get available positions for placing objects (background color, not near initial dot)\n    inds = ofcolor(gi, bgc) - mapply(dneighbors, neighbors((loci, locj)))\n    \n    # Normalize object coordinates relative to (0,0)\n    objn = shift(obj, (-loci, -locj))\n    \n    # Keep track of failed placement attempts\n    triedandfailed = set()\n    \n    # Main loop for placing objects\n    while (tr < maxtr and succ < noccs) or succ == 0:\n        # Get candidate locations for placement\n        lopcands = totuple(inds - triedandfailed)\n        \n        # Break if no more candidates available\n        if len(lopcands) == 0:\n            break\n        \n        # Increment attempt counter\n        tr += 1\n        \n        # Choose a random location for placement\n        loci, locj = choice(lopcands)\n        \n        # Shift object to new location\n        plcd = shift(objn, (loci, locj))\n        \n        # Get indices of shifted object\n        plcdi = toindices(plcd)\n        \n        # Check if object can be placed at new location\n        if plcdi.issubset(inds):\n            # Update available positions\n            inds = inds - (plcdi | {(loci, locj)})\n            \n            # Increment successful placement counter\n            succ += 1\n            \n            # Place dot on input grid\n            gi = fill(gi, dotc, {(loci, locj)})\n            \n            # Place dot on output grid\n            go = fill(go, dotc, {(loci, locj)})\n            \n            # Paint object on output grid\n            go = paint(go, plcd)\n        else:\n            # Mark location as failed if object couldn't be placed\n            triedandfailed.add((loci, locj))\n    \n    # Choose vertical scaling factor\n    hfac = unifint(diff_lb, diff_ub, (1, (30 - h + 1) // h))\n    \n    # Choose horizontal scaling factor\n    wfac = unifint(diff_lb, diff_ub, (1, (30 - w + 1) // w))\n    \n    # Calculate full height after scaling\n    fullh = hfac * h + h - 1\n    \n    # Calculate full width after scaling\n    fullw = wfac * w + w - 1\n    \n    # Create scaled input grid with line color\n    gi2 = canvas(linc, (fullh, fullw))\n    \n    # Create scaled output grid with line color\n    go2 = canvas(linc, (fullh, fullw))\n    \n    # Create indices for filling scaled cells\n    bd = asindices(canvas(-1, (hfac, wfac)))\n    \n    # Fill scaled input grid\n    for a in range(h):\n        for b in range(w):\n            c = gi[a][b]\n            gi2 = fill(gi2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))\n    \n    # Fill scaled output grid\n    for a in range(h):\n        for b in range(w):\n            c = go[a][b]\n            go2 = fill(go2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))\n    \n    # Update input and output grids with scaled versions\n    gi, go = gi2, go2\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "3aa6fb7a": {
    "original": "def generate_3aa6fb7a(diff_lb: float, diff_ub: float) -> dict:\n    base = (ORIGIN, RIGHT, DOWN, UNITY)\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    inds = totuple(asindices(gi))\n    maxnum = ((h * w) // 2) // 3\n    num = unifint(diff_lb, diff_ub, (1, maxnum))\n    kk, tr = 0, 0\n    maxtrials = num * 2\n    binds = set()\n    while kk < num and tr < maxtrials:\n        loc = choice(inds)\n        ooo = choice(base)\n        oo = remove(ooo, base)\n        oop = shift(oo, loc)\n        if set(oop).issubset(inds):\n            inds = difference(inds, totuple(combine(oop, totuple(mapply(dneighbors, oop)))))\n            gi = fill(gi, fgc, oop)\n            binds.add(add(ooo, loc))\n            kk += 1\n        tr += 1\n    go = fill(gi, 1, binds)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3aa6fb7a(diff_lb: float, diff_ub: float) -> dict:\n    # Define base shapes: origin, right, down, and unity (1,1)\n    base = (ORIGIN, RIGHT, DOWN, UNITY)\n    \n    # Create a list of colors 0-9, excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Randomly determine height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose a random foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Calculate the maximum number of shapes to add (1/6 of the grid area)\n    maxnum = ((h * w) // 2) // 3\n    \n    # Randomly determine the number of shapes to add, between 1 and maxnum\n    num = unifint(diff_lb, diff_ub, (1, maxnum))\n    \n    # Initialize counters for successful placements (kk) and trials (tr)\n    kk, tr = 0, 0\n    \n    # Set maximum number of trials to twice the number of shapes\n    maxtrials = num * 2\n    \n    # Initialize a set to store the positions of shape origins\n    binds = set()\n    \n    # Loop to place shapes on the grid\n    while kk < num and tr < maxtrials:\n        # Choose a random location on the grid\n        loc = choice(inds)\n        \n        # Choose a random shape from the base shapes\n        ooo = choice(base)\n        \n        # Create a set of the other base shapes\n        oo = remove(ooo, base)\n        \n        # Shift the chosen shape to the random location\n        oop = shift(oo, loc)\n        \n        # Check if the shifted shape fits within the grid\n        if set(oop).issubset(inds):\n            # Remove the shape and its neighbors from available indices\n            inds = difference(inds, totuple(combine(oop, totuple(mapply(dneighbors, oop)))))\n            \n            # Fill the shape on the grid with the foreground color\n            gi = fill(gi, fgc, oop)\n            \n            # Add the origin of the shape to binds\n            binds.add(add(ooo, loc))\n            \n            # Increment the counter for successful placements\n            kk += 1\n        \n        # Increment the trial counter\n        tr += 1\n    \n    # Create the output grid by filling the shape origins with color 1\n    go = fill(gi, 1, binds)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3ac3eb23": {
    "original": "def generate_3ac3eb23(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nlocs = unifint(diff_lb, diff_ub, (1, max(1, (w - 2) // 3)))\n    locopts = interval(1, w - 1, 1)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for k in range(nlocs):\n        if len(locopts) == 0:\n            break\n        locj = choice(locopts)\n        locopts = difference(locopts, interval(locj - 2, locj + 3, 1))\n        col = choice(remcols)\n        gi = fill(gi, col, {(0, locj)})\n        go = fill(go, col, {(p, locj) for p in interval(0, h, 2)})\n        go = fill(go, col, {(p, locj - 1) for p in interval(1, h, 2)})\n        go = fill(go, col, {(p, locj + 1) for p in interval(1, h, 2)})\n    mf = choice((identity, rot90, rot180, rot270))\n    gi = mf(gi)\n    go = mf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3ac3eb23(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of vertical lines to be drawn, based on difficulty\n    nlocs = unifint(diff_lb, diff_ub, (1, max(1, (w - 2) // 3)))\n    \n    # Create a list of possible column indices for vertical lines\n    locopts = interval(1, w - 1, 1)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Loop to create vertical lines\n    for k in range(nlocs):\n        # Break if there are no more available column options\n        if len(locopts) == 0:\n            break\n        \n        # Choose a random column for the vertical line\n        locj = choice(locopts)\n        \n        # Remove nearby columns from future options to prevent overlapping\n        locopts = difference(locopts, interval(locj - 2, locj + 3, 1))\n        \n        # Choose a random color for the line (different from background)\n        col = choice(remcols)\n        \n        # Place a single pixel of the chosen color at the top of the input grid\n        gi = fill(gi, col, {(0, locj)})\n        \n        # In the output grid, draw a zigzag pattern:\n        # Fill even rows in the chosen column\n        go = fill(go, col, {(p, locj) for p in interval(0, h, 2)})\n        # Fill odd rows in the column to the left\n        go = fill(go, col, {(p, locj - 1) for p in interval(1, h, 2)})\n        # Fill odd rows in the column to the right\n        go = fill(go, col, {(p, locj + 1) for p in interval(1, h, 2)})\n    \n    # Choose a random rotation function (including no rotation)\n    mf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = mf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = mf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "3af2c5a8": {
    "original": "def generate_3af2c5a8(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = hconcat(gi, vmirror(gi))\n    go = vconcat(go, hmirror(go))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3af2c5a8(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (1, 30)\n    \n    # Create a tuple of colors (0 to 9)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use, based on difficulty\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select cells to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid:\n    # First, horizontally concatenate the input with its vertical mirror\n    go = hconcat(gi, vmirror(gi))\n    \n    # Then, vertically concatenate the result with its horizontal mirror\n    go = vconcat(go, hmirror(go))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3bd67248": {
    "original": "def generate_3bd67248(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 4))\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    bgc, linc = sample(cols, 2)\n    fac = unifint(diff_lb, diff_ub, (1, 30 // max(h, w)))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, linc, connect((0, 0), (h - 1, 0)))\n    go = fill(gi, 4, connect((h - 1, 1), (h - 1, w - 1)))\n    go = fill(go, 2, shoot((h - 2, 1), (-1, 1)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    gi = upscale(gi, fac)\n    go = upscale(go, fac)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3bd67248(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 2 and 4\n    cols = difference(interval(0, 10, 1), (2, 4))\n    \n    # Randomly determine the height of the grid between 3 and 15\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Randomly determine the width of the grid between 3 and 15\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Randomly select two colors from the set: one for background, one for line\n    bgc, linc = sample(cols, 2)\n    \n    # Determine a scaling factor between 1 and 30 divided by the larger dimension\n    fac = unifint(diff_lb, diff_ub, (1, 30 // max(h, w)))\n    \n    # Create a canvas filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Draw a vertical line on the left edge of the input grid\n    gi = fill(gi, linc, connect((0, 0), (h - 1, 0)))\n    \n    # Create the output grid by copying the input\n    # Then draw a horizontal line at the bottom with color 4\n    go = fill(gi, 4, connect((h - 1, 1), (h - 1, w - 1)))\n    \n    # Draw a diagonal line from bottom-left to top-right with color 2\n    go = fill(go, 2, shoot((h - 2, 1), (-1, 1)))\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Scale up both grids by the determined factor\n    gi = upscale(gi, fac)\n    go = upscale(go, fac)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3bdb4ada": {
    "original": "def generate_3bdb4ada(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        if choice((True, False)):\n            oh = 3\n            ow = unifint(diff_lb, diff_ub, (1, max(1, w // 2 - 1))) * 2 + 1\n        else:\n            ow = 3\n            oh = unifint(diff_lb, diff_ub, (1, max(1, h // 2 - 1))) * 2 + 1\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            go = fill(go, col, bd)\n            if oh == 3:\n                ln = {(loci + 1, j) for j in range(locj+1, locj+ow, 2)}\n            else:\n                ln = {(j, locj + 1) for j in range(loci+1, loci+oh, 2)}\n            go = fill(go, bgc, ln)\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3bdb4ada(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose a height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly choose a width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly select a background color\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Randomly choose the number of objects to place (between 1 and 8)\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    # Initialize trial counter\n    tr = 0\n    # Initialize successful placements counter\n    succ = 0\n    \n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we run out of colors or available spaces\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        \n        # Randomly choose between horizontal or vertical object\n        if choice((True, False)):\n            # Set height to 3 for horizontal object\n            oh = 3\n            # Randomly choose an odd width for horizontal object\n            ow = unifint(diff_lb, diff_ub, (1, max(1, w // 2 - 1))) * 2 + 1\n        else:\n            # Set width to 3 for vertical object\n            ow = 3\n            # Randomly choose an odd height for vertical object\n            oh = unifint(diff_lb, diff_ub, (1, max(1, h // 2 - 1))) * 2 + 1\n        \n        # Find all possible starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position\n        loci, locj = choice(subs)\n        # Define the object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get all cells that the object occupies\n        bd = backdrop(obj)\n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # Check if the object fits within the available space\n        if bd.issubset(indss):\n            # Remove the chosen color from available colors\n            remcols = remove(col, remcols)\n            # Fill the input grid with the object\n            gi = fill(gi, col, bd)\n            # Fill the output grid with the object\n            go = fill(go, col, bd)\n            \n            # Create a line of background color in the middle of the object for output grid\n            if oh == 3:\n                # For horizontal objects, create vertical gaps\n                ln = {(loci + 1, j) for j in range(locj+1, locj+ow, 2)}\n            else:\n                # For vertical objects, create horizontal gaps\n                ln = {(j, locj + 1) for j in range(loci+1, loci+oh, 2)}\n            \n            # Apply the line to the output grid\n            go = fill(go, bgc, ln)\n            # Increment successful placements counter\n            succ += 1\n            # Remove the used space from available indices\n            indss = indss - bd\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3befdf3e": {
    "original": "def generate_3befdf3e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, numcols)\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 40)))\n    succ = 0\n    maxtr = 5 * nobjs\n    tr = 0\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        if len(inds) == 0:\n            break\n        rh = choice((1, 2))\n        rw = choice((1, 2))\n        fullh = (2 + 3 * rh)\n        fullw = (2 + 3 * rw)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - fullh and ij[1] <= w - fullw)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        fullobj = backdrop(frozenset({loc, (loci + fullh - 1, locj + fullw - 1)}))\n        if fullobj.issubset(inds):\n            succ += 1\n            inds = inds - fullobj\n            incol, outcol = sample(ccols, 2)\n            ofincol = backdrop(frozenset({(loci + rh + 1, locj + rw + 1), (loci + 2 * rh, locj + 2 * rw)}))\n            ofoutcol = outbox(ofincol)\n            gi = fill(gi, incol, ofincol)\n            gi = fill(gi, outcol, ofoutcol)\n            go = fill(go, outcol, ofincol)\n            go = fill(go, incol, ofoutcol)\n            ilocs = apply(first, ofoutcol)\n            jlocs = apply(last, ofoutcol)\n            ff = lambda ij: ij[0] in ilocs or ij[1] in jlocs\n            addon = sfilter(fullobj - (ofincol | ofoutcol), ff)\n            go = fill(go, outcol, addon)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3befdf3e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose a height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly choose a width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly choose a background color\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Choose a number of colors to use (between 2 and 9) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (2, 9))\n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    # Determine the number of objects to generate based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 40)))\n    # Initialize counter for successful object placements\n    succ = 0\n    # Set maximum number of attempts to place objects\n    maxtr = 5 * nobjs\n    # Initialize attempt counter\n    tr = 0\n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        tr += 1  # Increment attempt counter\n        if len(inds) == 0:\n            break  # Exit if no more available indices\n        # Randomly choose height multiplier (1 or 2)\n        rh = choice((1, 2))\n        # Randomly choose width multiplier (1 or 2)\n        rw = choice((1, 2))\n        # Calculate full height of the object (including border)\n        fullh = (2 + 3 * rh)\n        # Calculate full width of the object (including border)\n        fullw = (2 + 3 * rw)\n        # Filter indices where the full object can fit\n        cands = sfilter(inds, lambda ij: ij[0] <= h - fullh and ij[1] <= w - fullw)\n        if len(cands) == 0:\n            continue  # Skip if no valid positions found\n        # Choose a random position for the object\n        loc = choice(totuple(cands))\n        # Unpack the chosen location\n        loci, locj = loc\n        # Calculate the full area the object will occupy\n        fullobj = backdrop(frozenset({loc, (loci + fullh - 1, locj + fullw - 1)}))\n        \n        # Check if the full object fits within available indices\n        if fullobj.issubset(inds):\n            succ += 1  # Increment success counter\n            # Remove occupied indices from available indices\n            inds = inds - fullobj\n            # Choose two random colors for the object\n            incol, outcol = sample(ccols, 2)\n            # Define the inner area of the object\n            ofincol = backdrop(frozenset({(loci + rh + 1, locj + rw + 1), (loci + 2 * rh, locj + 2 * rw)}))\n            # Define the outer border of the object\n            ofoutcol = outbox(ofincol)\n            # Fill the inner area on the input grid\n            gi = fill(gi, incol, ofincol)\n            # Fill the outer border on the input grid\n            gi = fill(gi, outcol, ofoutcol)\n            # Fill the inner area on the output grid (with swapped colors)\n            go = fill(go, outcol, ofincol)\n            # Fill the outer border on the output grid (with swapped colors)\n            go = fill(go, incol, ofoutcol)\n            # Get row indices of the outer border\n            ilocs = apply(first, ofoutcol)\n            # Get column indices of the outer border\n            jlocs = apply(last, ofoutcol)\n            # Define a function to check if a cell is in the same row or column as the border\n            ff = lambda ij: ij[0] in ilocs or ij[1] in jlocs\n            # Find cells in the full object area that are in line with the border\n            addon = sfilter(fullobj - (ofincol | ofoutcol), ff)\n            # Fill these additional cells on the output grid\n            go = fill(go, outcol, addon)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3c9b0459": {
    "original": "def generate_3c9b0459(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = rot180(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3c9b0459(diff_lb: float, diff_ub: float) -> dict:\n    # Define the bounds for grid dimensions\n    dim_bounds = (1, 30)\n    # Create a tuple of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly select a height within the difficulty bounds\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    # Randomly select a width within the difficulty bounds\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    # Create a grid (canvas) filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Determine the number of unique colors to use (up to 9 or h*w, whichever is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    # Create a tuple of all indices in the grid\n    inds = totuple(asindices(gi))\n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        # Randomly select indices to fill with this color\n        chos = sample(inds, num)\n        # Fill the selected indices with the current color\n        gi = fill(gi, col, chos)\n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    # Create the output grid by rotating the input grid 180 degrees\n    go = rot180(gi)\n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3de23699": {
    "original": "def generate_3de23699(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    c = canvas(bgc, (h, w))\n    hi = unifint(diff_lb, diff_ub, (4, h))\n    wi = unifint(diff_lb, diff_ub, (4, w))\n    loci = randint(0, h - hi)\n    locj = randint(0, w - wi)\n    remcols = remove(bgc, cols)\n    ccol = choice(remcols)\n    remcols = remove(ccol, remcols)\n    ncol = choice(remcols)\n    tmpo = frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)})\n    cnds = totuple(backdrop(inbox(tmpo)))\n    mp = len(cnds) // 2\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    ncnds = choice((dev, len(cnds) - dev))\n    ncnds = min(max(0, ncnds), len(cnds))\n    ss = sample(cnds, ncnds)\n    gi = fill(c, ccol, corners(tmpo))\n    gi = fill(gi, ncol, ss)\n    go = trim(crop(switch(gi, ccol, ncol), (loci, locj), (hi, wi)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3de23699(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Generate a random inner height between 4 and h based on difficulty\n    hi = unifint(diff_lb, diff_ub, (4, h))\n    \n    # Generate a random inner width between 4 and w based on difficulty\n    wi = unifint(diff_lb, diff_ub, (4, w))\n    \n    # Choose a random starting row for the inner rectangle\n    loci = randint(0, h - hi)\n    \n    # Choose a random starting column for the inner rectangle\n    locj = randint(0, w - wi)\n    \n    # Remove the background color from the list of colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the corners\n    ccol = choice(remcols)\n    \n    # Remove the corner color from the remaining colors\n    remcols = remove(ccol, remcols)\n    \n    # Choose a random color for the noise\n    ncol = choice(remcols)\n    \n    # Create a set with the upper-left and lower-right corners of the inner rectangle\n    tmpo = frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)})\n    \n    # Get all the cells inside the inner rectangle as a tuple\n    cnds = totuple(backdrop(inbox(tmpo)))\n    \n    # Calculate the midpoint of the number of cells\n    mp = len(cnds) // 2\n    \n    # Generate a random deviation based on difficulty\n    dev = unifint(diff_lb, diff_ub, (0, mp))\n    \n    # Choose either the deviation or its complement for the number of noise cells\n    ncnds = choice((dev, len(cnds) - dev))\n    \n    # Ensure the number of noise cells is within valid range\n    ncnds = min(max(0, ncnds), len(cnds))\n    \n    # Randomly sample the specified number of cells for noise\n    ss = sample(cnds, ncnds)\n    \n    # Fill the corners of the inner rectangle with the corner color\n    gi = fill(c, ccol, corners(tmpo))\n    \n    # Add noise to the input grid by filling sampled cells with the noise color\n    gi = fill(gi, ncol, ss)\n    \n    # Create the output grid:\n    # 1. Switch the corner color with the noise color\n    # 2. Crop the inner rectangle\n    # 3. Remove the outer border\n    go = trim(crop(switch(gi, ccol, ncol), (loci, locj), (hi, wi)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3e980e27": {
    "original": "def generate_3e980e27(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 3))\n    h = unifint(diff_lb, diff_ub, (11, 30))\n    w = unifint(diff_lb, diff_ub, (11, 30))\n    bgc, rcol, gcol = sample(cols, 3)\n    objs = []\n    for (fixc, remc) in ((2, rcol), (3, gcol)):\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        ow = unifint(diff_lb, diff_ub, (2, 5))\n        bounds = asindices(canvas(-1, (oh, ow)))\n        obj = {choice(totuple(bounds))}\n        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        ncells = min(max(2, ncells), oh * ow)\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        obj = normalize(obj)\n        fixp = choice(totuple(obj))\n        rem = remove(fixp, obj)\n        obj = {(fixc, fixp)} | recolor(remc, rem)\n        objs.append(obj)\n    robj, gobj = objs\n    obj1, obj2 = sample(objs, 2)\n    loci1 = randint(0, h - height(obj1) - height(obj2) - 1)\n    locj1 = randint(0, w - width(obj1))\n    loci2 = randint(loci1+height(obj1)+1, h - height(obj2))\n    locj2 = randint(0, w - width(obj2))\n    gi = canvas(bgc, (h, w))\n    obj1p = shift(obj1, (loci1, locj1))\n    obj2p = shift(obj2, (loci2, locj2))\n    gi = paint(gi, obj1p)\n    gi = paint(gi, obj2p)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // int(1.5 * (len(robj) + len(gobj)))))\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    robj = vmirror(robj)\n    inds = ofcolor(gi, bgc) - (mapply(neighbors, toindices(obj1p)) | mapply(neighbors, toindices(obj2p)))\n    go = tuple(e for e in gi)\n    objopts = [robj, gobj]\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        obj = choice(objopts)\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            succ += 1\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n            gi = paint(gi, sfilter(plcd, lambda cij: cij[0] in (2, 3)))\n            go = paint(go, plcd)\n    if unifint(diff_lb, diff_ub, (1, 100)) < 30:\n        c = choice((2, 3))\n        giobjs = objects(gi, F, T, T)\n        goobjs = objects(go, F, T, T)\n        gi = fill(gi, bgc, mfilter(giobjs, lambda o: c in palette(o)))\n        go = fill(go, bgc, mfilter(goobjs, lambda o: c in palette(o)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3e980e27(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of color values from 0 to 9, excluding 2 and 3\n    cols = difference(interval(0, 10, 1), (2, 3))\n    \n    # Generate random height between 11 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (11, 30))\n    \n    # Generate random width between 11 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (11, 30))\n    \n    # Randomly select three colors: background, red, and green\n    bgc, rcol, gcol = sample(cols, 3)\n    \n    objs = []\n    # Create two objects: one with color 2 (red) and one with color 3 (green)\n    for (fixc, remc) in ((2, rcol), (3, gcol)):\n        # Generate random height for the object between 2 and 5\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        \n        # Generate random width for the object between 2 and 5\n        ow = unifint(diff_lb, diff_ub, (2, 5))\n        \n        # Create a set of all possible coordinates within the object's dimensions\n        bounds = asindices(canvas(-1, (oh, ow)))\n        \n        # Start the object with a random cell\n        obj = {choice(totuple(bounds))}\n        \n        # Determine the number of cells to add to the object\n        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        ncells = min(max(2, ncells), oh * ow)\n        \n        # Grow the object by adding adjacent cells\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        \n        # Normalize the object's position\n        obj = normalize(obj)\n        \n        # Choose a fixed point in the object\n        fixp = choice(totuple(obj))\n        \n        # Remove the fixed point from the object\n        rem = remove(fixp, obj)\n        \n        # Create the final object with fixed color point and remaining cells\n        obj = {(fixc, fixp)} | recolor(remc, rem)\n        objs.append(obj)\n    \n    # Assign the created objects to red and green\n    robj, gobj = objs\n    \n    # Randomly choose two objects for placement\n    obj1, obj2 = sample(objs, 2)\n    \n    # Generate random positions for the two objects, ensuring they don't overlap\n    loci1 = randint(0, h - height(obj1) - height(obj2) - 1)\n    locj1 = randint(0, w - width(obj1))\n    loci2 = randint(loci1+height(obj1)+1, h - height(obj2))\n    locj2 = randint(0, w - width(obj2))\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Shift the objects to their positions\n    obj1p = shift(obj1, (loci1, locj1))\n    obj2p = shift(obj2, (loci2, locj2))\n    \n    # Paint the objects onto the input grid\n    gi = paint(gi, obj1p)\n    gi = paint(gi, obj2p)\n    \n    # Determine the number of additional objects to place\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // int(1.5 * (len(robj) + len(gobj)))))\n    \n    succ = 0  # Counter for successfully placed objects\n    tr = 0    # Counter for placement attempts\n    maxtr = 5 * noccs  # Maximum number of placement attempts\n    \n    # Vertically mirror the red object\n    robj = vmirror(robj)\n    \n    # Find available positions for new objects\n    inds = ofcolor(gi, bgc) - (mapply(neighbors, toindices(obj1p)) | mapply(neighbors, toindices(obj2p)))\n    \n    # Create the output grid, initially identical to the input grid\n    go = tuple(e for e in gi)\n    \n    # List of objects to choose from for placement\n    objopts = [robj, gobj]\n    \n    # Place additional objects\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        # Choose an object to place\n        obj = choice(objopts)\n        oh, ow = shape(obj)\n        \n        # Find valid positions for the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        \n        # Shift the object to the chosen position\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        \n        # If the object can be placed without overlap\n        if plcdi.issubset(inds):\n            succ += 1\n            # Update available positions\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n            # Update input grid with only the fixed color points\n            gi = paint(gi, sfilter(plcd, lambda cij: cij[0] in (2, 3)))\n            # Update output grid with the full object\n            go = paint(go, plcd)\n    \n    # 30% chance to remove all objects of a certain color\n    if unifint(diff_lb, diff_ub, (1, 100)) < 30:\n        c = choice((2, 3))\n        giobjs = objects(gi, F, T, T)\n        goobjs = objects(go, F, T, T)\n        # Remove objects of the chosen color from input grid\n        gi = fill(gi, bgc, mfilter(giobjs, lambda o: c in palette(o)))\n        # Remove objects of the chosen color from output grid\n        go = fill(go, bgc, mfilter(goobjs, lambda o: c in palette(o)))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "3eda0437": {
    "original": "def generate_3eda0437(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(1, 10, 1), (6,))\n    h = unifint(diff_lb, diff_ub, (3, 8))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    if choice((True, False)):\n        h, w = w, h\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    fgcs = sample(cols, ncols)\n    gi = canvas(-1, (h, w))\n    gi = paint(gi, {(choice(fgcs), ij) for ij in asindices(gi)})\n    spac = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))\n    inds = asindices(gi)\n    obj = sample(totuple(inds), spac)\n    gi = fill(gi, 0, obj)\n    locx = (randint(0, h-1), randint(0, w-1))\n    gi = fill(gi, 0, {locx, add(locx, RIGHT), add(locx, DOWN), add(locx, UNITY)})\n    maxsiz = -1\n    mapper = dict()\n    maxpossw = max([r.count(0) for r in gi])\n    maxpossh = max([c.count(0) for c in dmirror(gi)])\n    for a in range(2, maxpossh+1):\n        for b in range(2, maxpossw+1):\n            siz = a * b\n            if siz < maxsiz:\n                continue\n            objx = recolor(0, asindices(canvas(-1, (a, b))))\n            occs = occurrences(gi, objx)\n            if len(occs) > 0:\n                if siz == maxsiz:\n                    mapper[objx] = occs\n                elif siz > maxsiz:\n                    mapper = {objx: occs}\n                    maxsiz = siz\n    go = tuple(e for e in gi)\n    for obj, locs in mapper.items():\n        go = fill(go, 6, mapply(lbind(shift, obj), locs))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3eda0437(diff_lb: float, diff_ub: float) -> dict:\n    # Define possible column values, excluding 6\n    cols = difference(interval(1, 10, 1), (6,))\n    \n    # Randomly generate height between 3 and 8\n    h = unifint(diff_lb, diff_ub, (3, 8))\n    \n    # Randomly generate width between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # 50% chance to swap height and width\n    if choice((True, False)):\n        h, w = w, h\n    \n    # Randomly choose number of foreground colors between 1 and 8\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample foreground colors from cols\n    fgcs = sample(cols, ncols)\n    \n    # Create initial grid filled with -1\n    gi = canvas(-1, (h, w))\n    \n    # Paint grid with random foreground colors\n    gi = paint(gi, {(choice(fgcs), ij) for ij in asindices(gi)})\n    \n    # Calculate number of spaces to fill with 0 (between 1 and 2/3 of grid size)\n    spac = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly sample indices to fill with 0\n    obj = sample(totuple(inds), spac)\n    \n    # Fill selected indices with 0\n    gi = fill(gi, 0, obj)\n    \n    # Choose a random location for a 2x2 square of 0s\n    locx = (randint(0, h-1), randint(0, w-1))\n    \n    # Fill the 2x2 square with 0s\n    gi = fill(gi, 0, {locx, add(locx, RIGHT), add(locx, DOWN), add(locx, UNITY)})\n    \n    # Initialize variables for finding largest rectangles of 0s\n    maxsiz = -1\n    mapper = dict()\n    \n    # Calculate maximum possible width and height of rectangles\n    maxpossw = max([r.count(0) for r in gi])\n    maxpossh = max([c.count(0) for c in dmirror(gi)])\n    \n    # Iterate through possible rectangle sizes\n    for a in range(2, maxpossh+1):\n        for b in range(2, maxpossw+1):\n            siz = a * b\n            # Skip if smaller than current max size\n            if siz < maxsiz:\n                continue\n            # Create a rectangle object of 0s\n            objx = recolor(0, asindices(canvas(-1, (a, b))))\n            # Find occurrences of this rectangle in the grid\n            occs = occurrences(gi, objx)\n            if len(occs) > 0:\n                # Update mapper if same size or larger than current max\n                if siz == maxsiz:\n                    mapper[objx] = occs\n                elif siz > maxsiz:\n                    mapper = {objx: occs}\n                    maxsiz = siz\n    \n    # Create output grid, initially same as input\n    go = tuple(e for e in gi)\n    \n    # Fill found rectangles with 6 in the output grid\n    for obj, locs in mapper.items():\n        go = fill(go, 6, mapply(lbind(shift, obj), locs))\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "3f7978a0": {
    "original": "def generate_3f7978a0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, noisec, linec = sample(cols, 3)\n    c = canvas(bgc, (h, w))\n    oh = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * h))))\n    oh = min(oh, h)\n    ow = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * w))))\n    ow = min(ow, w)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    nnoise = unifint(diff_lb, diff_ub, (0, (h * w) // 4))\n    inds = totuple(asindices(c))\n    noise = sample(inds, nnoise)\n    gi = fill(c, noisec, noise)\n    ulc = (loci, locj)\n    lrc = (loci + oh - 1, locj + ow - 1)\n    llc = (loci + oh - 1, locj)\n    urc = (loci, locj + ow - 1)\n    gi = fill(gi, linec, connect(ulc, llc))\n    gi = fill(gi, linec, connect(urc, lrc))\n    crns = {ulc, lrc, llc, urc}\n    gi = fill(gi, noisec, crns)\n    go = subgrid(crns, gi)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_3f7978a0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly select three distinct colors for background, noise, and lines\n    bgc, noisec, linec = sample(cols, 3)\n    \n    # Create a canvas (grid) with the background color and dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Determine the height of the object (rectangle) to be drawn\n    oh = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * h))))\n    # Ensure the object height doesn't exceed the grid height\n    oh = min(oh, h)\n    \n    # Determine the width of the object (rectangle) to be drawn\n    ow = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * w))))\n    # Ensure the object width doesn't exceed the grid width\n    ow = min(ow, w)\n    \n    # Randomly choose the row index for the top-left corner of the object\n    loci = randint(0, h - oh)\n    \n    # Randomly choose the column index for the top-left corner of the object\n    locj = randint(0, w - ow)\n    \n    # Determine the number of noise pixels to add\n    nnoise = unifint(diff_lb, diff_ub, (0, (h * w) // 4))\n    \n    # Get all grid indices as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select indices for noise pixels\n    noise = sample(inds, nnoise)\n    \n    # Add noise pixels to the grid\n    gi = fill(c, noisec, noise)\n    \n    # Define the corners of the rectangle\n    ulc = (loci, locj)  # Upper-left corner\n    lrc = (loci + oh - 1, locj + ow - 1)  # Lower-right corner\n    llc = (loci + oh - 1, locj)  # Lower-left corner\n    urc = (loci, locj + ow - 1)  # Upper-right corner\n    \n    # Draw the left vertical line of the rectangle\n    gi = fill(gi, linec, connect(ulc, llc))\n    \n    # Draw the right vertical line of the rectangle\n    gi = fill(gi, linec, connect(urc, lrc))\n    \n    # Create a set of corner coordinates\n    crns = {ulc, lrc, llc, urc}\n    \n    # Fill the corners with the noise color\n    gi = fill(gi, noisec, crns)\n    \n    # Extract the subgrid containing only the rectangle\n    go = subgrid(crns, gi)\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)  # Mirror the input grid\n        go = dmirror(go)  # Mirror the output grid\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "40853293": {
    "original": "def generate_40853293(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    nlines = unifint(diff_lb, diff_ub, (2, min(8, (h*w)//2)))\n    nhorilines = randint(1, nlines - 1)\n    nvertilines = nlines - nhorilines\n    ilocs = interval(0, h, 1)\n    ilocs = sample(ilocs, min(nhorilines, len(ilocs)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for ii in ilocs:\n        llen = unifint(diff_lb, diff_ub, (2, w - 1))\n        js = randint(0, w - llen)\n        je = js + llen - 1\n        a = (ii, js)\n        b = (ii, je)\n        hln = connect(a, b)\n        col = choice(remcols)\n        remcols = remove(col, remcols)\n        gi = fill(gi, col, {a, b})\n        go = fill(go, col, hln)\n    jlocs = interval(0, w, 1)\n    gim = dmirror(gi)\n    jlocs = sfilter(jlocs, lambda j: sum(1 for e in gim[j] if e == bgc) > 1)\n    nvertilines = min(nvertilines, len(jlocs))\n    jlocs = sample(jlocs, nvertilines)\n    for jj in jlocs:\n        jcands = [idx for idx, e in enumerate(gim[jj]) if e == bgc]\n        kk = len(jcands)\n        locopts = interval(0, kk, 1)\n        llen = unifint(diff_lb, diff_ub, (2, kk))\n        sp = randint(0, kk - llen)\n        ep = sp + llen - 1\n        sp = jcands[sp]\n        ep = jcands[ep]\n        a = (sp, jj)\n        b = (ep, jj)\n        vln = connect(a, b)\n        col = choice(remcols)\n        remcols = remove(col, remcols)\n        gi = fill(gi, col, {a, b})\n        go = fill(go, col, vln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_40853293(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Determine the total number of lines to draw, based on difficulty and grid size\n    nlines = unifint(diff_lb, diff_ub, (2, min(8, (h*w)//2)))\n    \n    # Randomly split the total lines between horizontal and vertical\n    nhorilines = randint(1, nlines - 1)\n    nvertilines = nlines - nhorilines\n    \n    # Create a range of possible row indices for horizontal lines\n    ilocs = interval(0, h, 1)\n    \n    # Randomly select row indices for horizontal lines\n    ilocs = sample(ilocs, min(nhorilines, len(ilocs)))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # For each horizontal line:\n    for ii in ilocs:\n        # Determine the length of the line based on difficulty\n        llen = unifint(diff_lb, diff_ub, (2, w - 1))\n        \n        # Choose a random starting point for the line\n        js = randint(0, w - llen)\n        \n        # Calculate the ending point of the line\n        je = js + llen - 1\n        \n        # Define start and end points of the line\n        a = (ii, js)\n        b = (ii, je)\n        \n        # Create the full horizontal line\n        hln = connect(a, b)\n        \n        # Choose a random color for the line\n        col = choice(remcols)\n        \n        # Remove the chosen color from available colors\n        remcols = remove(col, remcols)\n        \n        # Add start and end points of the line to the input grid\n        gi = fill(gi, col, {a, b})\n        \n        # Add the full line to the output grid\n        go = fill(go, col, hln)\n    \n    # Create a range of possible column indices for vertical lines\n    jlocs = interval(0, w, 1)\n    \n    # Mirror the input grid diagonally\n    gim = dmirror(gi)\n    \n    # Filter column indices to avoid overlapping with horizontal lines\n    jlocs = sfilter(jlocs, lambda j: sum(1 for e in gim[j] if e == bgc) > 1)\n    \n    # Adjust the number of vertical lines if necessary\n    nvertilines = min(nvertilines, len(jlocs))\n    \n    # Randomly select column indices for vertical lines\n    jlocs = sample(jlocs, nvertilines)\n    \n    # For each vertical line:\n    for jj in jlocs:\n        # Find available positions in the column\n        jcands = [idx for idx, e in enumerate(gim[jj]) if e == bgc]\n        \n        # Count available positions\n        kk = len(jcands)\n        \n        # Create a range of possible lengths\n        locopts = interval(0, kk, 1)\n        \n        # Determine the length of the line based on difficulty\n        llen = unifint(diff_lb, diff_ub, (2, kk))\n        \n        # Choose a random starting point for the line\n        sp = randint(0, kk - llen)\n        \n        # Calculate the ending point of the line\n        ep = sp + llen - 1\n        \n        # Map the chosen points to actual grid coordinates\n        sp = jcands[sp]\n        ep = jcands[ep]\n        \n        # Define start and end points of the line\n        a = (sp, jj)\n        b = (ep, jj)\n        \n        # Create the full vertical line\n        vln = connect(a, b)\n        \n        # Choose a random color for the line\n        col = choice(remcols)\n        \n        # Remove the chosen color from available colors\n        remcols = remove(col, remcols)\n        \n        # Add start and end points of the line to the input grid\n        gi = fill(gi, col, {a, b})\n        \n        # Add the full line to the output grid\n        go = fill(go, col, vln)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "4093f84a": {
    "original": "def generate_4093f84a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    loci1, loci2 = sorted(sample(interval(2, h - 2, 1), 2))\n    bgc, barc, dotc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    for ii in range(loci1, loci2+1, 1):\n        gi = fill(gi, barc, connect((ii, 0), (ii, w - 1)))\n    go = tuple(e for e in gi)\n    opts = interval(0, w, 1)\n    num1 = unifint(diff_lb, diff_ub, (1, w // 2))\n    num2 = unifint(diff_lb, diff_ub, (1, w // 2))\n    locs1 = sample(opts, num1)\n    locs2 = sample(opts, num2)\n    for l1 in locs1:\n        k = unifint(diff_lb, diff_ub, (1, loci1 - 1))\n        locsx = sample(interval(0, loci1, 1), k)\n        gi = fill(gi, dotc, apply(rbind(astuple, l1), locsx))\n        go = fill(go, barc, connect((loci1 - 1, l1), (loci1 - k, l1)))\n    for l2 in locs2:\n        k = unifint(diff_lb, diff_ub, (1, h - loci2 - 2))\n        locsx = sample(interval(loci2+1, h, 1), k)\n        gi = fill(gi, dotc, apply(rbind(astuple, l2), locsx))\n        go = fill(go, barc, connect((loci2 + 1, l2), (loci2 + k, l2)))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4093f84a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 7 and 30\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the width of the grid between 7 and 30\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Choose two random distinct row indices between 2 and h-3\n    loci1, loci2 = sorted(sample(interval(2, h - 2, 1), 2))\n    \n    # Randomly select three distinct colors for background, bars, and dots\n    bgc, barc, dotc = sample(cols, 3)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Draw horizontal bars of 'barc' color between loci1 and loci2\n    for ii in range(loci1, loci2+1, 1):\n        gi = fill(gi, barc, connect((ii, 0), (ii, w - 1)))\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Define possible column indices for dots\n    opts = interval(0, w, 1)\n    \n    # Randomly determine the number of columns for dots above loci1 (1 to w/2)\n    num1 = unifint(diff_lb, diff_ub, (1, w // 2))\n    \n    # Randomly determine the number of columns for dots below loci2 (1 to w/2)\n    num2 = unifint(diff_lb, diff_ub, (1, w // 2))\n    \n    # Randomly select column indices for dots above loci1\n    locs1 = sample(opts, num1)\n    \n    # Randomly select column indices for dots below loci2\n    locs2 = sample(opts, num2)\n    \n    # Process dots above loci1\n    for l1 in locs1:\n        # Randomly determine the number of dots in this column (1 to loci1-1)\n        k = unifint(diff_lb, diff_ub, (1, loci1 - 1))\n        \n        # Randomly select row indices for dots in this column\n        locsx = sample(interval(0, loci1, 1), k)\n        \n        # Place dots in the input grid\n        gi = fill(gi, dotc, apply(rbind(astuple, l1), locsx))\n        \n        # Draw a vertical bar in the output grid connecting the dots\n        go = fill(go, barc, connect((loci1 - 1, l1), (loci1 - k, l1)))\n    \n    # Process dots below loci2\n    for l2 in locs2:\n        # Randomly determine the number of dots in this column (1 to h-loci2-2)\n        k = unifint(diff_lb, diff_ub, (1, h - loci2 - 2))\n        \n        # Randomly select row indices for dots in this column\n        locsx = sample(interval(loci2+1, h, 1), k)\n        \n        # Place dots in the input grid\n        gi = fill(gi, dotc, apply(rbind(astuple, l2), locsx))\n        \n        # Draw a vertical bar in the output grid connecting the dots\n        go = fill(go, barc, connect((loci2 + 1, l2), (loci2 + k, l2)))\n    \n    # 50% chance to mirror the entire grid diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "41e4d17e": {
    "original": "def generate_41e4d17e(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(6, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    bx = box(frozenset({(0, 0), (4, 4)}))\n    bd = backdrop(bx)\n    maxtrials = 4 * num\n    succ = 0\n    tr = 0\n    while succ < num and tr < maxtrials:\n        loc = choice(totuple(inds))\n        bxs = shift(bx, loc)\n        if bxs.issubset(set(inds)):\n            gi = fill(gi, fgc, bxs)\n            go = fill(go, fgc, bxs)\n            cen = center(bxs)\n            frns = hfrontier(cen) | vfrontier(cen)\n            kep = frns & ofcolor(go, bgc)\n            go = fill(go, 6, kep)\n            inds = difference(inds, shift(bd, loc))\n            succ += 1\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_41e4d17e(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 6\n    cols = remove(6, interval(0, 10, 1))\n    \n    # Generate a random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Calculate number of boxes to place, between 1 and 1/16th of grid area\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    \n    # Randomly select background and foreground colors\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Define a 5x5 box outline\n    bx = box(frozenset({(0, 0), (4, 4)}))\n    \n    # Get all indices within the 5x5 box\n    bd = backdrop(bx)\n    \n    # Set maximum number of attempts to place boxes\n    maxtrials = 4 * num\n    \n    # Initialize counter for successfully placed boxes\n    succ = 0\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Loop to place boxes on the grid\n    while succ < num and tr < maxtrials:\n        # Randomly select a location on the grid\n        loc = choice(totuple(inds))\n        \n        # Shift the box to the selected location\n        bxs = shift(bx, loc)\n        \n        # Check if the shifted box fits within the grid\n        if bxs.issubset(set(inds)):\n            # Fill the box outline with foreground color in input grid\n            gi = fill(gi, fgc, bxs)\n            \n            # Fill the box outline with foreground color in output grid\n            go = fill(go, fgc, bxs)\n            \n            # Find the center of the box\n            cen = center(bxs)\n            \n            # Get horizontal and vertical lines passing through the center\n            frns = hfrontier(cen) | vfrontier(cen)\n            \n            # Keep only the parts of lines that are background color\n            kep = frns & ofcolor(go, bgc)\n            \n            # Fill the kept parts with color 6 in the output grid\n            go = fill(go, 6, kep)\n            \n            # Remove the area of the placed box from available indices\n            inds = difference(inds, shift(bd, loc))\n            \n            # Increment the counter for successfully placed boxes\n            succ += 1\n        \n        # Increment the trial counter\n        tr += 1\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "4258a5f9": {
    "original": "def generate_4258a5f9(diff_lb: float, diff_ub: float) -> dict:\n    colopts = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    fgc = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    mp = ((h * w) // 2) if (h * w) % 2 == 1 else ((h * w) // 2 - 1)\n    ndots = unifint(diff_lb, diff_ub, (1, mp))\n    inds = totuple(asindices(gi))\n    dots = sample(inds, ndots)\n    go = fill(gi, 1, mapply(neighbors, frozenset(dots)))\n    go = fill(go, fgc, dots)\n    gi = fill(gi, fgc, dots)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4258a5f9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color options (0-9) excluding 1\n    colopts = remove(1, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Choose a random background color from the color options\n    bgc = choice(colopts)\n    \n    # Create a new list of remaining colors, excluding the background color\n    remcols = remove(bgc, colopts)\n    \n    # Choose a random foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Calculate the maximum number of dots (half the grid size, adjusted for odd total)\n    mp = ((h * w) // 2) if (h * w) % 2 == 1 else ((h * w) // 2 - 1)\n    \n    # Generate a random number of dots between 1 and mp based on difficulty\n    ndots = unifint(diff_lb, diff_ub, (1, mp))\n    \n    # Convert all grid indices to a tuple\n    inds = totuple(asindices(gi))\n    \n    # Randomly select ndots number of positions for the dots\n    dots = sample(inds, ndots)\n    \n    # Create the output grid: fill neighbors of dots with color 1\n    go = fill(gi, 1, mapply(neighbors, frozenset(dots)))\n    \n    # In the output grid: fill the dot positions with the foreground color\n    go = fill(go, fgc, dots)\n    \n    # In the input grid: fill the dot positions with the foreground color\n    gi = fill(gi, fgc, dots)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "4290ef0e": {
    "original": "def generate_4290ef0e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        d = unifint(diff_lb, diff_ub, (2, 7))\n        h, w = d, d\n        fullh = unifint(diff_lb, diff_ub, (4*d, 30))\n        fullw = unifint(diff_lb, diff_ub, (4*d, 30))\n        bgc = choice(cols)\n        remcols = remove(bgc, cols)\n        ccols = sample(remcols, d)\n        quad = canvas(bgc, (d+1, d+1))\n        for idx, c in enumerate(ccols):\n            linlen = randint(2, w-idx+1)\n            quad = fill(quad, c, (connect((idx, idx), (idx+linlen-1, idx))))\n            quad = fill(quad, c, (connect((idx, idx), (idx, idx+linlen-1))))\n        go = canvas(bgc, (d+1, 2*d+1))\n        qobj1 = asobject(quad)\n        qobj2 = shift(asobject(vmirror(quad)), (0, d))\n        go = paint(go, qobj1)\n        go = paint(go, qobj2)\n        go = vconcat(go, hmirror(go)[1:])\n        if choice((True, False)):\n            go = fill(go, choice(difference(remcols, ccols)), {center(asindices(go))})\n        objs = partition(go)\n        objs = sfilter(objs, lambda o: color(o) != bgc)\n        gi = canvas(bgc, (fullh, fullw))\n        objs = order(objs, width)\n        fullinds = asindices(gi)\n        inds = asindices(gi)\n        fullsuc = True\n        for obj in objs:\n            objn = normalize(obj)\n            obji = toindices(objn)\n            d = width(obj)\n            dh = max(0, d//2-1)\n            cands = sfilter(fullinds, lambda ij: ij[0] <= fullh - d and ij[1] <= fullw - d)\n            cands = cands | shift(cands, (-dh, 0)) | shift(cands, (0, -dh)) | shift(cands, (dh, 0)) | shift(cands, (0, dh))\n            maxtr = 10\n            tr = 0\n            succ = False\n            if len(cands) == 0:\n                break\n            while tr < maxtr and not succ:\n                tr += 1    \n                loc = choice(totuple(cands))\n                if (shift(obji, loc) & fullinds).issubset(inds):\n                    succ = True\n                    break\n            if not succ:\n                fullsuc = False\n                break\n            gi = paint(gi, shift(objn, loc))\n            inds = inds - shift(obji, loc)\n        if not fullsuc:\n            continue\n        break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4290ef0e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    while True:\n        # Generate a random dimension 'd' between 2 and 7 based on difficulty\n        d = unifint(diff_lb, diff_ub, (2, 7))\n        # Set height and width to 'd'\n        h, w = d, d\n        # Generate full height between 4d and 30\n        fullh = unifint(diff_lb, diff_ub, (4*d, 30))\n        # Generate full width between 4d and 30\n        fullw = unifint(diff_lb, diff_ub, (4*d, 30))\n        # Choose a random background color\n        bgc = choice(cols)\n        # Remove background color from available colors\n        remcols = remove(bgc, cols)\n        # Sample 'd' colors from remaining colors\n        ccols = sample(remcols, d)\n        # Create a canvas of size (d+1) x (d+1) with background color\n        quad = canvas(bgc, (d+1, d+1))\n        # For each color, draw lines in the quadrant\n        for idx, c in enumerate(ccols):\n            # Choose a random line length\n            linlen = randint(2, w-idx+1)\n            # Draw horizontal line\n            quad = fill(quad, c, (connect((idx, idx), (idx+linlen-1, idx))))\n            # Draw vertical line\n            quad = fill(quad, c, (connect((idx, idx), (idx, idx+linlen-1))))\n        # Create a canvas for the output grid\n        go = canvas(bgc, (d+1, 2*d+1))\n        # Convert quadrant to object\n        qobj1 = asobject(quad)\n        # Create mirrored quadrant and shift it\n        qobj2 = shift(asobject(vmirror(quad)), (0, d))\n        # Paint both quadrants onto the output grid\n        go = paint(go, qobj1)\n        go = paint(go, qobj2)\n        # Vertically concatenate with horizontal mirror (excluding first row)\n        go = vconcat(go, hmirror(go)[1:])\n        # Randomly decide to add a center point\n        if choice((True, False)):\n            # Add a random color (not used in quadrants) to the center\n            go = fill(go, choice(difference(remcols, ccols)), {center(asindices(go))})\n        # Partition the output grid into objects\n        objs = partition(go)\n        # Filter out background-colored objects\n        objs = sfilter(objs, lambda o: color(o) != bgc)\n        # Create input grid canvas\n        gi = canvas(bgc, (fullh, fullw))\n        # Order objects by width\n        objs = order(objs, width)\n        # Get all indices of the input grid\n        fullinds = asindices(gi)\n        inds = asindices(gi)\n        fullsuc = True\n        # Try to place each object on the input grid\n        for obj in objs:\n            objn = normalize(obj)\n            obji = toindices(objn)\n            d = width(obj)\n            dh = max(0, d//2-1)\n            # Find candidate positions for placing the object\n            cands = sfilter(fullinds, lambda ij: ij[0] <= fullh - d and ij[1] <= fullw - d)\n            cands = cands | shift(cands, (-dh, 0)) | shift(cands, (0, -dh)) | shift(cands, (dh, 0)) | shift(cands, (0, dh))\n            maxtr = 10\n            tr = 0\n            succ = False\n            # If no candidates, break and try again\n            if len(cands) == 0:\n                break\n            # Try to place the object up to 10 times\n            while tr < maxtr and not succ:\n                tr += 1    \n                loc = choice(totuple(cands))\n                # Check if object can be placed at chosen location\n                if (shift(obji, loc) & fullinds).issubset(inds):\n                    succ = True\n                    break\n            # If placement unsuccessful, mark as failed and break\n            if not succ:\n                fullsuc = False\n                break\n            # Paint the object onto the input grid\n            gi = paint(gi, shift(objn, loc))\n            # Remove placed object indices from available indices\n            inds = inds - shift(obji, loc)\n        # If not all objects placed successfully, try again\n        if not fullsuc:\n            continue\n        # If successful, break the loop\n        break\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "42a50994": {
    "original": "def generate_42a50994(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    c = canvas(bgc, (h, w))\n    card_bounds = (0, max(0, (h * w) // 2 - 1))\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    numcols = unifint(diff_lb, diff_ub, (0, min(9, num)))\n    inds = totuple(asindices(c))\n    chosinds = sample(inds, num)\n    choscols = sample(remcols, numcols)\n    locs = interval(0, len(chosinds), 1)\n    choslocs = sample(locs, numcols)\n    gi = canvas(bgc, (h, w))\n    for col, endidx in zip(choscols, sorted(choslocs)[::-1]):\n        gi = fill(gi, col, chosinds[:endidx])\n    objs = objects(gi, F, T, T)\n    res = merge(sizefilter(objs, 1))\n    go = fill(gi, bgc, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_42a50994(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the color options\n    bgc = choice(colopts)\n    \n    # Create a new list of colors, excluding the background color\n    remcols = remove(bgc, colopts)\n    \n    # Create an initial canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Calculate the upper bound for the number of cells to be colored\n    # It's either 0 or half the total number of cells, whichever is larger\n    card_bounds = (0, max(0, (h * w) // 2 - 1))\n    \n    # Randomly determine the number of cells to be colored based on difficulty\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    \n    # Randomly determine the number of different colors to use (excluding background)\n    numcols = unifint(diff_lb, diff_ub, (0, min(9, num)))\n    \n    # Get all possible cell indices in the grid\n    inds = totuple(asindices(c))\n    \n    # Randomly select 'num' cells to be colored\n    chosinds = sample(inds, num)\n    \n    # Randomly select 'numcols' colors to use\n    choscols = sample(remcols, numcols)\n    \n    # Create a range of indices for the chosen cells\n    locs = interval(0, len(chosinds), 1)\n    \n    # Randomly select 'numcols' positions to change colors\n    choslocs = sample(locs, numcols)\n    \n    # Create the input grid, initially filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill the chosen cells with different colors\n    # This creates a layered effect, with each color filling a subset of the chosen cells\n    for col, endidx in zip(choscols, sorted(choslocs)[::-1]):\n        gi = fill(gi, col, chosinds[:endidx])\n    \n    # Identify all objects in the grid (connected components of non-background color)\n    objs = objects(gi, F, T, T)\n    \n    # Merge all single-cell objects into one set\n    res = merge(sizefilter(objs, 1))\n    \n    # Create the output grid by filling all single-cell objects with the background color\n    # This effectively removes all single-cell objects from the input grid\n    go = fill(gi, bgc, res)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "4347f46a": {
    "original": "def generate_4347f46a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            go = fill(go, col, box(obj))\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4347f46a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random height between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random width between 10 and 30 based on difficulty\n    bgc = choice(cols)  # Randomly select a background color from the available colors\n    remcols = remove(bgc, cols)  # Remove the background color from the available colors\n    gi = canvas(bgc, (h, w))  # Create an input grid filled with the background color\n    go = canvas(bgc, (h, w))  # Create an output grid filled with the background color\n    num = unifint(diff_lb, diff_ub, (1, 9))  # Determine the number of objects to generate (1-9) based on difficulty\n    indss = asindices(gi)  # Get all possible indices in the input grid\n    maxtrials = 4 * num  # Set maximum number of attempts to place objects\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize successful placements counter\n    while succ < num and tr <= maxtrials:\n        # Continue loop until all objects are placed or max trials reached\n        if len(remcols) == 0 or len(indss) == 0:\n            break  # Exit loop if no colors or indices left\n        oh = randint(3, 7)  # Generate random object height between 3 and 7\n        ow = randint(3, 7)  # Generate random object width between 3 and 7\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        # Filter valid starting positions for the object\n        if len(subs) == 0:\n            tr += 1\n            continue  # If no valid positions, increment trial and continue loop\n        loci, locj = choice(subs)  # Randomly choose a starting position for the object\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Create object as a frozenset of its corner coordinates\n        bd = backdrop(obj)  # Get all indices within the object's bounding box\n        col = choice(remcols)  # Randomly choose a color for the object\n        if bd.issubset(indss):\n            # If the object's bounding box fits within available indices\n            remcols = remove(col, remcols)  # Remove used color from available colors\n            gi = fill(gi, col, bd)  # Fill the object area in the input grid\n            go = fill(go, col, box(obj))  # Draw the object's outline in the output grid\n            succ += 1  # Increment successful placements counter\n            indss = indss - bd  # Remove used indices from available indices\n        tr += 1  # Increment trial counter\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "444801d8": {
    "original": "def generate_444801d8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, numcols)\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(4, 6)\n        ow = 5\n        bx = box({(1, 0), (oh - 1, 4)}) - {(1, 2)}\n        fullobj = backdrop({(0, 0), (oh - 1, 4)})\n        cands = backdrop(bx) - bx\n        dot = choice(totuple(cands))\n        dcol, bxcol = sample(ccols, 2)\n        inobj = recolor(bxcol, bx) | recolor(dcol, {dot})\n        outobj = recolor(bxcol, bx) | recolor(dcol, fullobj - bx)\n        if choice((True, False)):\n            inobj = shift(hmirror(inobj), UP)\n            outobj = hmirror(outobj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        outplcd = shift(outobj, loc)\n        outplcdi = toindices(outplcd)\n        if outplcdi.issubset(inds):\n            succ += 1\n            inplcd = shift(inobj, loc)\n            inds = (inds - outplcdi) - outbox(inplcd)\n            gi = paint(gi, inplcd)\n            go = paint(go, outplcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_444801d8(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Calculate the number of objects to place based on grid size (1 to 1/25th of grid area)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (between 2 and 9)\n    numcols = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly select colors to use for objects\n    ccols = sample(remcols, numcols)\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    \n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        \n        # Randomly determine object height (4 to 6) and set width to 5\n        oh = randint(4, 6)\n        ow = 5\n        \n        # Define the box shape of the object\n        bx = box({(1, 0), (oh - 1, 4)}) - {(1, 2)}\n        \n        # Define the full object area\n        fullobj = backdrop({(0, 0), (oh - 1, 4)})\n        \n        # Determine candidates for dot placement\n        cands = backdrop(bx) - bx\n        \n        # Randomly choose dot location\n        dot = choice(totuple(cands))\n        \n        # Randomly choose colors for dot and box\n        dcol, bxcol = sample(ccols, 2)\n        \n        # Create input object (box with dot)\n        inobj = recolor(bxcol, bx) | recolor(dcol, {dot})\n        \n        # Create output object (box filled with dot color)\n        outobj = recolor(bxcol, bx) | recolor(dcol, fullobj - bx)\n        \n        # Randomly decide to mirror the object horizontally\n        if choice((True, False)):\n            inobj = shift(hmirror(inobj), UP)\n            outobj = hmirror(outobj)\n        \n        # Find valid placement locations on the grid\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location to place the object\n        loc = choice(totuple(cands))\n        \n        # Shift the output object to the chosen location\n        outplcd = shift(outobj, loc)\n        outplcdi = toindices(outplcd)\n        \n        # Check if the output object fits within the grid\n        if outplcdi.issubset(inds):\n            succ += 1\n            \n            # Shift the input object to the chosen location\n            inplcd = shift(inobj, loc)\n            \n            # Update available indices by removing the object area and its surrounding box\n            inds = (inds - outplcdi) - outbox(inplcd)\n            \n            # Paint the input and output objects on their respective grids\n            gi = paint(gi, inplcd)\n            go = paint(go, outplcd)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "445eab21": {
    "original": "def generate_445eab21(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    succ = 0\n    tr = 0\n    bigcol, area = 0, 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        if oh * ow == area:\n            continue\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, box(bd))\n            succ += 1\n            indss = indss - bd\n            if oh * ow > area:\n                bigcol, area = col, oh * ow\n        tr += 1\n    go = canvas(bigcol, (2, 2))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_445eab21(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random color for the background\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Create a canvas (grid) filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Generate a random number of objects to place, between 1 and 9\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    # Initialize counters for successful placements and trials\n    succ = 0\n    tr = 0\n    # Initialize variables to track the largest object\n    bigcol, area = 0, 0\n    # Start loop to place objects\n    while succ < num and tr <= maxtrials:\n        # Break if we've used all colors or filled the grid\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        # Generate random height and width for the new object\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        # Skip if this object has the same area as the largest one\n        if oh * ow == area:\n            continue\n        # Find all possible placements for the new object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        # If no valid placements, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        # Choose a random location for the object\n        loci, locj = choice(subs)\n        # Create the object (defined by its corners)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get the full area covered by the object\n        bd = backdrop(obj)\n        # Choose a random color for the object\n        col = choice(remcols)\n        # If the object fits within the available space\n        if bd.issubset(indss):\n            # Remove the chosen color from available colors\n            remcols = remove(col, remcols)\n            # Fill the object area with the chosen color\n            gi = fill(gi, col, box(bd))\n            # Increment successful placement counter\n            succ += 1\n            # Remove the object area from available indices\n            indss = indss - bd\n            # Update largest object info if this one is larger\n            if oh * ow > area:\n                bigcol, area = col, oh * ow\n        # Increment trial counter\n        tr += 1\n    # Create a 2x2 grid with the color of the largest object\n    go = canvas(bigcol, (2, 2))\n    # Return the input grid and output grid as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "447fd412": {
    "original": "def generate_447fd412(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    bgc, indic, mainc = sample(cols, 3)\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    if oh * ow < 3:\n        if choice((True, False)):\n            oh = unifint(diff_lb, diff_ub, (3, 4))\n        else:\n            ow = unifint(diff_lb, diff_ub, (3, 4))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    ncells = unifint(diff_lb, diff_ub, (3, oh * ow))\n    obj = {choice(totuple(bounds))}\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    objt = totuple(obj)\n    kk = len(obj)\n    nindic = randint(1, kk // 2 if kk % 2 == 1 else kk // 2 - 1)\n    indicobj = set(sample(objt, nindic))\n    mainobj = obj - indicobj\n    obj = recolor(indic, indicobj) | recolor(mainc, mainobj)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    plcd = shift(obj, (loci, locj))\n    gi = paint(gi, plcd)\n    go = paint(go, plcd)\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))\n    fullinds = asindices(gi)\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (4 * len(plcd)))))\n    tr = 0\n    maxtr = 5 * noccs\n    succ = 0\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        fac = randint(1, min(5, min(h, w) // max(oh, ow) - 1))\n        outobj = upscale(obj, fac)\n        inobj = sfilter(outobj, lambda cij: cij[0] == indic)\n        hh, ww = shape(outobj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        inobjp = shift(inobj, loc)\n        outobjp = shift(outobj, loc)\n        outobjp = sfilter(outobjp, lambda cij: cij[1] in fullinds)\n        outobjpi = toindices(outobjp)\n        if outobjpi.issubset(inds):\n            succ += 1\n            inds = (inds - outobjpi) - mapply(neighbors, toindices(inobjp))\n            gi = paint(gi, inobjp)\n            go = paint(go, outobjp)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_447fd412(diff_lb: float, diff_ub: float) -> dict:\n    # Generate a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the grid between 12 and 30\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Randomly choose the width of the grid between 12 and 30\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Randomly select 3 unique colors from the range 0-9\n    bgc, indic, mainc = sample(cols, 3)\n    \n    # Randomly choose the height of the object between 1 and 4\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # Randomly choose the width of the object between 1 and 4\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # Ensure the object has at least 3 cells\n    if oh * ow < 3:\n        # Randomly choose to increase either height or width\n        if choice((True, False)):\n            # Increase height to be between 3 and 4\n            oh = unifint(diff_lb, diff_ub, (3, 4))\n        else:\n            # Increase width to be between 3 and 4\n            ow = unifint(diff_lb, diff_ub, (3, 4))\n    \n    # Create a set of all possible coordinates within the object's dimensions\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Choose a random number of cells for the object, between 3 and the total area\n    ncells = unifint(diff_lb, diff_ub, (3, oh * ow))\n    \n    # Initialize the object with a random cell\n    obj = {choice(totuple(bounds))}\n    \n    # Add cells to the object until it reaches the desired size\n    for k in range(ncells - 1):\n        # Add a new cell that's adjacent to an existing cell but not already in the object\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    \n    # Shift the object so its top-left corner is at (0,0)\n    obj = normalize(obj)\n    \n    # Get the final dimensions of the object\n    oh, ow = shape(obj)\n    \n    # Convert the object to a tuple for easier manipulation\n    objt = totuple(obj)\n    \n    # Get the total number of cells in the object\n    kk = len(obj)\n    \n    # Choose a random number of indicator cells (less than half the total)\n    nindic = randint(1, kk // 2 if kk % 2 == 1 else kk // 2 - 1)\n    \n    # Randomly select cells to be indicators\n    indicobj = set(sample(objt, nindic))\n    \n    # The remaining cells form the main part of the object\n    mainobj = obj - indicobj\n    \n    # Color the indicator and main parts of the object\n    obj = recolor(indic, indicobj) | recolor(mainc, mainobj)\n    \n    # Choose a random location for the object on the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Shift the object to its position on the grid\n    plcd = shift(obj, (loci, locj))\n    \n    # Place the object on both input and output grids\n    gi = paint(gi, plcd)\n    go = paint(go, plcd)\n    \n    # Find all background cells not adjacent to the placed object\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))\n    \n    # Get all indices of the grid\n    fullinds = asindices(gi)\n    \n    # Choose a random number of occurrences for the upscaled object\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (4 * len(plcd)))))\n    \n    # Initialize counters for attempts and successes\n    tr = 0\n    maxtr = 5 * noccs\n    succ = 0\n    \n    # Try to place upscaled versions of the object\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        # Choose a random scaling factor\n        fac = randint(1, min(5, min(h, w) // max(oh, ow) - 1))\n        \n        # Create an upscaled version of the object\n        outobj = upscale(obj, fac)\n        \n        # Get the indicator part of the upscaled object\n        inobj = sfilter(outobj, lambda cij: cij[0] == indic)\n        \n        # Get the dimensions of the upscaled object\n        hh, ww = shape(outobj)\n        \n        # Find valid positions to place the upscaled object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)\n        \n        # If no valid positions, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random position for the upscaled object\n        loc = choice(totuple(cands))\n        \n        # Shift the indicator part to the chosen position\n        inobjp = shift(inobj, loc)\n        \n        # Shift the entire upscaled object to the chosen position\n        outobjp = shift(outobj, loc)\n        \n        # Remove any parts of the upscaled object that fall outside the grid\n        outobjp = sfilter(outobjp, lambda cij: cij[1] in fullinds)\n        \n        # Get the indices of the placed upscaled object\n        outobjpi = toindices(outobjp)\n        \n        # If the upscaled object can be placed without overlap\n        if outobjpi.issubset(inds):\n            succ += 1\n            # Update available positions\n            inds = (inds - outobjpi) - mapply(neighbors, toindices(inobjp))\n            # Place the indicator part on the input grid\n            gi = paint(gi, inobjp)\n            # Place the full upscaled object on the output grid\n            go = paint(go, outobjp)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "44d8ac46": {
    "original": "def generate_44d8ac46(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 10))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        tr += 1\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(5, 7)\n        ow = randint(5, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            ensuresq = choice((True, False))\n            if ensuresq:\n                dim = randint(1, min(oh, ow) - 2)\n                iloci = randint(1, oh - dim - 1)\n                ilocj = randint(1, ow - dim - 1)\n                inpart = backdrop({(loci + iloci, locj + ilocj), (loci + iloci + dim - 1, locj + ilocj + dim - 1)})\n            else:\n                cnds = backdrop(inbox(bd))\n                ch = choice(totuple(cnds))\n                inpart = {ch}\n                kk = unifint(diff_lb, diff_ub, (1, len(cnds)))\n                for k in range(kk - 1):\n                    inpart.add(choice(totuple((cnds - inpart) & mapply(dneighbors, inpart))))\n            inpart = frozenset(inpart)\n            hi, wi = shape(inpart)\n            if hi == wi and len(inpart) == hi * wi:\n                incol = 2\n            else:\n                incol = bgc\n            gi = fill(gi, col, bd)\n            go = fill(go, col, bd)\n            gi = fill(gi, bgc, inpart)\n            go = fill(go, incol, inpart)\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_44d8ac46(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Generate random number of objects to place (1-10) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placements counter\n    succ = 0\n    \n    # Start placing objects\n    while succ < num and tr <= maxtrials:\n        # Increment trial counter\n        tr += 1\n        \n        # Break if we've run out of colors or space\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        \n        # Generate random object height (5-7)\n        oh = randint(5, 7)\n        \n        # Generate random object width (5-7)\n        ow = randint(5, 7)\n        \n        # Find valid placement locations for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # Skip this iteration if no valid placements found\n        if len(subs) == 0:\n            continue\n        \n        # Choose a random valid location\n        loci, locj = choice(subs)\n        \n        # Create object (defined by its corners)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get the backdrop (all cells) of the object\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # If the object fits within the available space\n        if bd.issubset(indss):\n            # Randomly decide whether to ensure a square inside\n            ensuresq = choice((True, False))\n            \n            if ensuresq:\n                # Create a square inside the object\n                dim = randint(1, min(oh, ow) - 2)\n                iloci = randint(1, oh - dim - 1)\n                ilocj = randint(1, ow - dim - 1)\n                inpart = backdrop({(loci + iloci, locj + ilocj), (loci + iloci + dim - 1, locj + ilocj + dim - 1)})\n            else:\n                # Create a random shape inside the object\n                cnds = backdrop(inbox(bd))\n                ch = choice(totuple(cnds))\n                inpart = {ch}\n                kk = unifint(diff_lb, diff_ub, (1, len(cnds)))\n                for k in range(kk - 1):\n                    inpart.add(choice(totuple((cnds - inpart) & mapply(dneighbors, inpart))))\n            \n            # Finalize the inner part\n            inpart = frozenset(inpart)\n            \n            # Determine dimensions of inner part\n            hi, wi = shape(inpart)\n            \n            # Set inner color based on shape (2 if square, background color otherwise)\n            if hi == wi and len(inpart) == hi * wi:\n                incol = 2\n            else:\n                incol = bgc\n            \n            # Fill object color in input grid\n            gi = fill(gi, col, bd)\n            \n            # Fill object color in output grid\n            go = fill(go, col, bd)\n            \n            # Fill inner part with background color in input grid\n            gi = fill(gi, bgc, inpart)\n            \n            # Fill inner part with inner color in output grid\n            go = fill(go, incol, inpart)\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Remove used space from available indices\n            indss = (indss - bd) - outbox(bd)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "44f52bb0": {
    "original": "def generate_44f52bb0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    numcells = unifint(diff_lb, diff_ub, (1, h * w - 1))\n    inds = asindices(gi)\n    while gi == hmirror(gi):\n        cells = sample(totuple(inds), numcells)\n        gi = canvas(bgc, (h, w))\n        for ij in cells:\n            a, b = ij\n            col = choice(ccols)\n            gi = fill(gi, col, {ij})\n            gi = fill(gi, col, {(a, w - 1 - b)})\n    issymm = choice((True, False))\n    if not issymm:\n        numpert = unifint(diff_lb, diff_ub, (1, h * (w // 2)))\n        cands = asindices(canvas(-1, (h, w // 2)))\n        locs = sample(totuple(cands), numpert)\n        for a, b in locs:\n            col = gi[a][b]\n            newcol = choice(totuple(remove(col, insert(bgc, set(ccols)))))\n            gi = fill(gi, newcol, {(a, b)})\n        go = canvas(7, (1, 1))\n    else:\n        go = canvas(1, (1, 1))\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_44f52bb0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (3, 30))  # Generate a random height between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))  # Generate a random width between 3 and 30 based on difficulty\n    bgc = choice(cols)  # Randomly select a background color from the available colors\n    remcols = remove(bgc, cols)  # Remove the background color from the list of available colors\n    ncols = unifint(diff_lb, diff_ub, (2, 9))  # Determine the number of colors to use (between 2 and 9)\n    ccols = sample(remcols, ncols)  # Randomly select 'ncols' colors from the remaining colors\n    gi = canvas(bgc, (h, w))  # Create an initial grid filled with the background color\n    numcells = unifint(diff_lb, diff_ub, (1, h * w - 1))  # Determine the number of cells to color\n    inds = asindices(gi)  # Get all possible indices of the grid\n\n    # Loop to ensure the grid is not horizontally symmetric initially\n    while gi == hmirror(gi):\n        cells = sample(totuple(inds), numcells)  # Randomly select cells to color\n        gi = canvas(bgc, (h, w))  # Reset the grid\n        for ij in cells:\n            a, b = ij\n            col = choice(ccols)  # Choose a random color\n            gi = fill(gi, col, {ij})  # Color the selected cell\n            gi = fill(gi, col, {(a, w - 1 - b)})  # Color the horizontally mirrored cell\n\n    issymm = choice((True, False))  # Randomly decide if the final grid should be symmetric\n\n    if not issymm:\n        numpert = unifint(diff_lb, diff_ub, (1, h * (w // 2)))  # Number of perturbations to make\n        cands = asindices(canvas(-1, (h, w // 2)))  # Get indices for the left half of the grid\n        locs = sample(totuple(cands), numpert)  # Select random locations to perturb\n        for a, b in locs:\n            col = gi[a][b]  # Get the current color at the location\n            newcol = choice(totuple(remove(col, insert(bgc, set(ccols)))))  # Choose a new color\n            gi = fill(gi, newcol, {(a, b)})  # Apply the new color to break symmetry\n        go = canvas(7, (1, 1))  # Output is a 1x1 grid with color 7 (indicating asymmetry)\n    else:\n        go = canvas(1, (1, 1))  # Output is a 1x1 grid with color 1 (indicating symmetry)\n\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)  # List of possible transformations\n    nmfs = choice((1, 2))  # Decide whether to apply 1 or 2 transformations\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)  # Apply the transformation to the input grid\n        go = fn(go)  # Apply the same transformation to the output grid\n\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "4522001f": {
    "original": "def generate_4522001f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    w = unifint(diff_lb, diff_ub, (3, 10))\n    bgc, sqc, dotc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (3*h, 3*w))\n    sqi = {(dotc, (1, 1))} | recolor(sqc, {(0, 0), (0, 1), (1, 0)})\n    sqo = backdrop(frozenset({(0, 0), (3, 3)}))\n    sqo |= shift(sqo, (4, 4))\n    loci = randint(0, min(h-2, 3*h-8))\n    locj = randint(0, min(w-2, 3*w-8))\n    loc = (loci, locj)\n    plcdi = shift(sqi, loc)\n    plcdo = shift(sqo, loc)\n    gi = paint(gi, plcdi)\n    go = fill(go, sqc, plcdo)\n    noccs = unifint(diff_lb, diff_ub, (0, (h*w) // 9))\n    succ = 0\n    tr = 0\n    maxtr = 10 * noccs\n    iinds = ofcolor(gi, bgc) - mapply(dneighbors, toindices(plcdi))\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        cands = sfilter(iinds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        plcdi = shift(sqi, loc)\n        plcdo = shift(sqo, loc)\n        plcdii = toindices(plcdi)\n        if plcdii.issubset(iinds):\n            succ += 1\n            iinds = (iinds - plcdii) - mapply(dneighbors, plcdii)\n            gi = paint(gi, plcdi)\n            go = fill(go, sqc, plcdo)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4522001f(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 10))\n    # Randomly determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 10))\n    \n    # Randomly select 3 unique colors for background, square, and dot\n    bgc, sqc, dotc = sample(cols, 3)\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create the output grid with background color (3 times larger in both dimensions)\n    go = canvas(bgc, (3*h, 3*w))\n    \n    # Define a small square pattern with a dot in the center\n    sqi = {(dotc, (1, 1))} | recolor(sqc, {(0, 0), (0, 1), (1, 0)})\n    \n    # Define a larger square pattern for the output\n    sqo = backdrop(frozenset({(0, 0), (3, 3)}))\n    # Expand the larger square pattern\n    sqo |= shift(sqo, (4, 4))\n    \n    # Randomly choose a location for the first square in the input grid\n    loci = randint(0, min(h-2, 3*h-8))\n    locj = randint(0, min(w-2, 3*w-8))\n    loc = (loci, locj)\n    \n    # Place the small square pattern in the input grid\n    plcdi = shift(sqi, loc)\n    # Place the large square pattern in the output grid\n    plcdo = shift(sqo, loc)\n    \n    # Paint the small square onto the input grid\n    gi = paint(gi, plcdi)\n    # Fill the large square onto the output grid\n    go = fill(go, sqc, plcdo)\n    \n    # Determine the number of additional squares to add based on difficulty\n    noccs = unifint(diff_lb, diff_ub, (0, (h*w) // 9))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 10 * noccs\n    \n    # Find valid locations for new squares in the input grid\n    iinds = ofcolor(gi, bgc) - mapply(dneighbors, toindices(plcdi))\n    \n    # Loop to add more squares\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        # Find candidate locations that fit within the grid\n        cands = sfilter(iinds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)\n        # Break if no valid locations remain\n        if len(cands) == 0:\n            break\n        # Choose a random location from candidates\n        loc = choice(totuple(cands))\n        # Calculate positions for new squares in input and output\n        plcdi = shift(sqi, loc)\n        plcdo = shift(sqo, loc)\n        plcdii = toindices(plcdi)\n        # If the new square fits, add it to both grids\n        if plcdii.issubset(iinds):\n            succ += 1\n            # Update valid locations for future squares\n            iinds = (iinds - plcdii) - mapply(dneighbors, plcdii)\n            # Paint new square onto input grid\n            gi = paint(gi, plcdi)\n            # Fill new large square onto output grid\n            go = fill(go, sqc, plcdo)\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply rotation to input grid\n    gi = rotf(gi)\n    # Apply same rotation to output grid\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "4612dd53": {
    "original": "def generate_4612dd53(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    ih = unifint(diff_lb, diff_ub, (5, h-1))\n    iw = unifint(diff_lb, diff_ub, (5, w-1))\n    bgc, col = sample(cols, 2)\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    bx = box(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    if choice((True, False)):\n        locc = randint(loci + 2, loci + ih - 3)\n        br = connect((locc, locj+1), (locc, locj + iw - 2))\n    else:\n        locc = randint(locj + 2, locj + iw - 3)\n        br = connect((loci+1, locc), (loci + ih - 2, locc))\n    c = canvas(bgc, (h, w))\n    crns = sample(totuple(corners(bx)), 3)\n    onbx = totuple(crns)\n    rembx = difference(bx, crns)\n    onbr = sample(totuple(br), 2)\n    rembr = difference(br, onbr)\n    noccbx = unifint(diff_lb, diff_ub, (0, len(rembx)))\n    noccbr = unifint(diff_lb, diff_ub, (0, len(rembr)))\n    occbx = sample(totuple(rembx), noccbx)\n    occbr = sample(totuple(rembr), noccbr)\n    c = fill(c, col, bx)\n    c = fill(c, col, br)\n    gi = fill(c, bgc, occbx)\n    gi = fill(gi, bgc, occbr)\n    go = fill(c, 2, occbx)\n    go = fill(go, 2, occbr)\n    if choice((True, False)):\n        gi = fill(gi, bgc, br)\n        go = fill(go, bgc, br)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4612dd53(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-9, excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate random height between 8 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    # Generate random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Generate random inner height between 5 and h-1 based on difficulty\n    ih = unifint(diff_lb, diff_ub, (5, h-1))\n    # Generate random inner width between 5 and w-1 based on difficulty\n    iw = unifint(diff_lb, diff_ub, (5, w-1))\n    \n    # Randomly select two colors: one for background and one for the box\n    bgc, col = sample(cols, 2)\n    \n    # Generate random top-left corner coordinates for the inner box\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    \n    # Create the outline of the box\n    bx = box(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    \n    # Randomly decide whether to create a horizontal or vertical bar inside the box\n    if choice((True, False)):\n        # Create a horizontal bar\n        locc = randint(loci + 2, loci + ih - 3)\n        br = connect((locc, locj+1), (locc, locj + iw - 2))\n    else:\n        # Create a vertical bar\n        locc = randint(locj + 2, locj + iw - 3)\n        br = connect((loci+1, locc), (loci + ih - 2, locc))\n    \n    # Create a canvas with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Randomly select 3 corners of the box\n    crns = sample(totuple(corners(bx)), 3)\n    onbx = totuple(crns)\n    # Get the remaining points on the box outline\n    rembx = difference(bx, crns)\n    \n    # Randomly select 2 points on the bar\n    onbr = sample(totuple(br), 2)\n    # Get the remaining points on the bar\n    rembr = difference(br, onbr)\n    \n    # Randomly decide how many points on the box outline to occlude\n    noccbx = unifint(diff_lb, diff_ub, (0, len(rembx)))\n    # Randomly decide how many points on the bar to occlude\n    noccbr = unifint(diff_lb, diff_ub, (0, len(rembr)))\n    \n    # Randomly select points to occlude on the box outline\n    occbx = sample(totuple(rembx), noccbx)\n    # Randomly select points to occlude on the bar\n    occbr = sample(totuple(rembr), noccbr)\n    \n    # Fill the box and bar with the selected color\n    c = fill(c, col, bx)\n    c = fill(c, col, br)\n    \n    # Create input grid: occlude selected points with background color\n    gi = fill(c, bgc, occbx)\n    gi = fill(gi, bgc, occbr)\n    \n    # Create output grid: fill occluded points with color 2\n    go = fill(c, 2, occbx)\n    go = fill(go, 2, occbr)\n    \n    # Randomly decide whether to remove the bar in both input and output\n    if choice((True, False)):\n        gi = fill(gi, bgc, br)\n        go = fill(go, bgc, br)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "46442a0e": {
    "original": "def generate_46442a0e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = h\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go1 = hconcat(gi, rot90(gi))\n    go2 = hconcat(rot270(gi), rot180(gi))\n    go = vconcat(go1, go2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_46442a0e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    # Set width equal to height, creating a square grid\n    w = h\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (excluding background) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the input grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose indices to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the top-left and top-right quadrants of the output grid\n    go1 = hconcat(gi, rot90(gi))\n    \n    # Create the bottom-left and bottom-right quadrants of the output grid\n    go2 = hconcat(rot270(gi), rot180(gi))\n    \n    # Combine all quadrants to create the final output grid\n    go = vconcat(go1, go2)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "469497ad": {
    "original": "def generate_469497ad(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 6))\n    w = unifint(diff_lb, diff_ub, (3, 6))\n    bgc, sqc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    sqh = randint(1, h - 2)\n    sqw = randint(1, w - 2)\n    sqloci = randint(0, h - sqh - 2)\n    sqlocj = randint(0, w - sqw - 2)\n    sq = backdrop(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))\n    gi = fill(gi, sqc, sq)\n    numcub = min(min(min(h, w)+1, 30//(max(h, w))), 7)\n    numc = unifint(diff_lb, diff_ub, (2, numcub))\n    numaccc = numc - 1\n    remcols = remove(bgc, remove(sqc, cols))\n    ccols = sample(remcols, numaccc)\n    gi = rot180(gi)\n    locs = sample(interval(1, min(h, w), 1), numaccc - 1)\n    locs = [0] + sorted(locs)\n    for c, l in zip(ccols, locs):\n        gi = fill(gi, c, shoot((0, l), (0, 1)))\n        gi = fill(gi, c, shoot((l, 0), (1, 0)))\n    gi = rot180(gi)\n    go = upscale(gi, numc)\n    rect = ofcolor(go, sqc)\n    l1 = shoot(lrcorner(rect), (1, 1))\n    l2 = shoot(ulcorner(rect), (-1, -1))\n    l3 = shoot(urcorner(rect), (-1, 1))\n    l4 = shoot(llcorner(rect), (1, -1))\n    ll = l1 | l2 | l3 | l4\n    go = fill(go, 2, ll & ofcolor(go, bgc))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_469497ad(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly determine the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 6))\n    # Randomly determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 6))\n    \n    # Randomly select two different colors for background and square\n    bgc, sqc = sample(cols, 2)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly determine the height of the square (1 to h-2)\n    sqh = randint(1, h - 2)\n    # Randomly determine the width of the square (1 to w-2)\n    sqw = randint(1, w - 2)\n    \n    # Randomly determine the top-left position of the square\n    sqloci = randint(0, h - sqh - 2)\n    sqlocj = randint(0, w - sqw - 2)\n    \n    # Create the square as a set of coordinates\n    sq = backdrop(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))\n    \n    # Fill the square area with the square color\n    gi = fill(gi, sqc, sq)\n    \n    # Calculate the maximum number of cubes (colors) allowed\n    numcub = min(min(min(h, w)+1, 30//(max(h, w))), 7)\n    # Randomly determine the actual number of cubes (colors) to use based on difficulty\n    numc = unifint(diff_lb, diff_ub, (2, numcub))\n    # Calculate the number of additional colors (excluding background and square)\n    numaccc = numc - 1\n    \n    # Create a list of remaining colors (excluding background and square colors)\n    remcols = remove(bgc, remove(sqc, cols))\n    # Randomly select colors for the additional cubes\n    ccols = sample(remcols, numaccc)\n    \n    # Rotate the grid 180 degrees (preparing for adding color lines)\n    gi = rot180(gi)\n    \n    # Randomly select positions for the color lines\n    locs = sample(interval(1, min(h, w), 1), numaccc - 1)\n    locs = [0] + sorted(locs)\n    \n    # Add color lines to the grid\n    for c, l in zip(ccols, locs):\n        # Add horizontal color line\n        gi = fill(gi, c, shoot((0, l), (0, 1)))\n        # Add vertical color line\n        gi = fill(gi, c, shoot((l, 0), (1, 0)))\n    \n    # Rotate the grid back to its original orientation\n    gi = rot180(gi)\n    \n    # Create the output grid by upscaling the input grid\n    go = upscale(gi, numc)\n    \n    # Find the square in the output grid\n    rect = ofcolor(go, sqc)\n    \n    # Create diagonal lines from the corners of the square\n    l1 = shoot(lrcorner(rect), (1, 1))   # Lower-right to upper-right\n    l2 = shoot(ulcorner(rect), (-1, -1)) # Upper-left to lower-left\n    l3 = shoot(urcorner(rect), (-1, 1))  # Upper-right to lower-right\n    l4 = shoot(llcorner(rect), (1, -1))  # Lower-left to upper-left\n    \n    # Combine all diagonal lines\n    ll = l1 | l2 | l3 | l4\n    \n    # Fill the diagonal lines with color 2, but only where they intersect with the background color\n    go = fill(go, 2, ll & ofcolor(go, bgc))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "46f33fce": {
    "original": "def generate_46f33fce(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 7))\n    w = unifint(diff_lb, diff_ub, (2, 7))\n    nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    go = canvas(bgc, (h, w))\n    gi = canvas(bgc, (h*2, w*2))\n    inds = totuple(asindices(go))\n    locs = sample(inds, nc)\n    objo = frozenset({(choice(remcols), ij) for ij in locs})\n    f = lambda cij: (cij[0], double(cij[1]))\n    obji = shift(apply(f, objo), (1, 1))\n    gi = paint(gi, obji)\n    go = paint(go, objo)\n    go = upscale(go, 4)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_46f33fce(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the output grid between 2 and 7\n    h = unifint(diff_lb, diff_ub, (2, 7))\n    \n    # Randomly choose the width of the output grid between 2 and 7\n    w = unifint(diff_lb, diff_ub, (2, 7))\n    \n    # Randomly choose the number of colored cells, up to half the grid size\n    nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Create a list of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Create the input grid, twice the size of the output grid\n    gi = canvas(bgc, (h*2, w*2))\n    \n    # Get all indices of the output grid as a tuple\n    inds = totuple(asindices(go))\n    \n    # Randomly select locations for colored cells\n    locs = sample(inds, nc)\n    \n    # Create an object representing colored cells in the output grid\n    objo = frozenset({(choice(remcols), ij) for ij in locs})\n    \n    # Define a function to double the coordinates of each cell\n    f = lambda cij: (cij[0], double(cij[1]))\n    \n    # Apply the doubling function and shift the object for the input grid\n    obji = shift(apply(f, objo), (1, 1))\n    \n    # Paint the colored cells onto the input grid\n    gi = paint(gi, obji)\n    \n    # Paint the colored cells onto the output grid\n    go = paint(go, objo)\n    \n    # Upscale the output grid by a factor of 4\n    go = upscale(go, 4)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "47c1f68c": {
    "original": "def generate_47c1f68c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc, linc = sample(cols, 2)\n    remcols = difference(cols, (bgc, linc))\n    objc = choice(remcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w - 1))\n    bx = asindices(canv)\n    obj = {choice(totuple(bx))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, obj)\n        ch = choice(totuple(bx & dns))\n        obj.add(ch)\n        bx = bx - {ch}\n    obj = recolor(objc, obj)\n    gi = paint(canv, obj)\n    gi1 = hconcat(hconcat(gi, canvas(linc, (h, 1))), canv)\n    gi2 = hconcat(hconcat(canv, canvas(linc, (h, 1))), canv)\n    gi = vconcat(vconcat(gi1, canvas(linc, (1, 2*w+1))), gi2)\n    go = paint(canv, obj)\n    go = hconcat(go, vmirror(go))\n    go = vconcat(go, hmirror(go))\n    go = replace(go, objc, linc)\n    scf = choice((identity, hmirror, vmirror, compose(hmirror, vmirror)))\n    gi = scf(gi)\n    go = scf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_47c1f68c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly choose a height between 2 and 14 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly choose a width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly select two colors: one for background and one for lines\n    bgc, linc = sample(cols, 2)\n    \n    # Get the remaining colors not used for background or lines\n    remcols = difference(cols, (bgc, linc))\n    \n    # Choose a color for the object from the remaining colors\n    objc = choice(remcols)\n    \n    # Create a canvas filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Choose a random number of cells for the object, between 1 and h*w-1\n    nc = unifint(diff_lb, diff_ub, (1, h * w - 1))\n    \n    # Get all indices of the canvas as a set\n    bx = asindices(canv)\n    \n    # Start the object with a random cell\n    obj = {choice(totuple(bx))}\n    \n    # Grow the object by adding adjacent cells\n    for kk in range(nc - 1):\n        # Get all neighbors of the current object\n        dns = mapply(neighbors, obj)\n        \n        # Choose a random cell that's both in the canvas and adjacent to the object\n        ch = choice(totuple(bx & dns))\n        \n        # Add the chosen cell to the object\n        obj.add(ch)\n        \n        # Remove the chosen cell from the available cells\n        bx = bx - {ch}\n    \n    # Color the object with the chosen object color\n    obj = recolor(objc, obj)\n    \n    # Paint the object onto the canvas\n    gi = paint(canv, obj)\n    \n    # Create the input grid: object | line | background\n    gi1 = hconcat(hconcat(gi, canvas(linc, (h, 1))), canv)\n    \n    # Create another row: background | line | background\n    gi2 = hconcat(hconcat(canv, canvas(linc, (h, 1))), canv)\n    \n    # Combine the two rows with a horizontal line in between\n    gi = vconcat(vconcat(gi1, canvas(linc, (1, 2*w+1))), gi2)\n    \n    # Start creating the output grid: paint the object on the canvas\n    go = paint(canv, obj)\n    \n    # Mirror the object horizontally\n    go = hconcat(go, vmirror(go))\n    \n    # Mirror the result vertically\n    go = vconcat(go, hmirror(go))\n    \n    # Replace the object color with the line color\n    go = replace(go, objc, linc)\n    \n    # Randomly choose a transformation function\n    scf = choice((identity, hmirror, vmirror, compose(hmirror, vmirror)))\n    \n    # Apply the chosen transformation to both input and output grids\n    gi = scf(gi)\n    go = scf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "484b58aa": {
    "original": "def generate_484b58aa(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    pinds = asindices(canvas(-1, (hp, wp)))\n    noisec = choice(cols)\n    remcols = remove(noisec, cols)\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, numc)\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    go = canvas(-1, (h, w))\n    locs = set()\n    ofs = randint(1, hp - 1)\n    for a in range(2*(h//hp+1)):\n        for b in range(w//wp+1):\n            loci = hp * a - ofs * b\n            locj = wp * b\n            locs.add((loci, locj))\n            go = paint(go, shift(pobj, (loci, locj)))\n    numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    gi = tuple(e for e in go)\n    places = apply(lbind(shift, pinds), locs)\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        gi2 = fill(gi, noisec, ptch)\n        if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):\n            if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:\n                succ += 1\n                gi = gi2\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_484b58aa(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random height for pattern, between 2 and half of total height\n    hp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    \n    # Generate random width for pattern, between 2 and half of total width\n    wp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    \n    # Create indices for the pattern grid\n    pinds = asindices(canvas(-1, (hp, wp)))\n    \n    # Choose a random color for noise\n    noisec = choice(cols)\n    \n    # Remove the noise color from the available colors\n    remcols = remove(noisec, cols)\n    \n    # Choose a random number of colors to use (between 2 and 9)\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Create a pattern object with random colors\n    pobj = frozenset({(choice(ccols), ij) for ij in pinds})\n    \n    # Initialize the grid with -1 (empty)\n    go = canvas(-1, (h, w))\n    \n    # Initialize a set to store locations\n    locs = set()\n    \n    # Generate a random offset\n    ofs = randint(1, hp - 1)\n    \n    # Nested loops to place the pattern across the grid\n    for a in range(2*(h//hp+1)):\n        for b in range(w//wp+1):\n            # Calculate location for each pattern instance\n            loci = hp * a - ofs * b\n            locj = wp * b\n            # Add location to the set\n            locs.add((loci, locj))\n            # Paint the pattern onto the grid at the calculated location\n            go = paint(go, shift(pobj, (loci, locj)))\n    \n    # Determine number of noise patches to add\n    numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Convert grid to tuple for easier manipulation\n    gi = tuple(e for e in go)\n    \n    # Generate all possible locations for the pattern\n    places = apply(lbind(shift, pinds), locs)\n    \n    # Initialize counters for successful noise additions and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * numpatches\n    \n    # Loop to add noise patches\n    while succ < numpatches and tr < maxtr:\n        tr += 1\n        # Generate random height and width for noise patch\n        ph = randint(2, 6)\n        pw = randint(2, 6)\n        # Generate random location for noise patch\n        loci = randint(0, h - ph)\n        locj = randint(0, w - pw)\n        # Create the noise patch\n        ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))\n        # Add noise to a copy of the grid\n        gi2 = fill(gi, noisec, ptch)\n        # Check if the pattern is still recognizable after adding noise\n        if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):\n            # Ensure the noise doesn't cover entire rows or columns\n            if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:\n                succ += 1\n                gi = gi2  # Update the grid with successful noise addition\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input (with noise) and output (without noise) grids\n    return {'input': gi, 'output': go}\n"
  },
  "48d8fb45": {
    "original": "def generate_48d8fb45(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))\n    tr = 0\n    maxtr = 4 * nobjs\n    done = False\n    succ = 0\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while tr < maxtr and succ < nobjs:\n        oh = randint(2, 6)\n        ow = randint(2, 6)\n        bx = asindices(canvas(-1, (oh, ow)))\n        nc = randint(3, oh * ow)\n        sp = choice(totuple(bx))\n        bx = remove(sp, bx)\n        obj = {sp}\n        for k in range(nc - 1):\n            obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))\n        if not done:\n            done = True\n            idx = choice(totuple(obj))\n            coll = choice(remcols)\n            obj2 = {(coll, idx)}\n            obj3 = recolor(choice(remove(coll, remcols)), remove(idx, obj))\n            obj = obj2 | obj3\n            go = paint(canvas(bgc, shape(obj3)), normalize(obj3))\n        else:\n            obj = recolor(choice(remcols), obj)\n        locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        tr += 1\n        if len(locopts) == 0:\n            continue\n        loc = choice(totuple(locopts))\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            gi = paint(gi, plcd)\n            succ += 1\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_48d8fb45(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random height between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random width between 10 and 30 based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))  # Calculate number of objects based on grid size and difficulty\n    tr = 0  # Initialize trial counter\n    maxtr = 4 * nobjs  # Set maximum number of trials\n    done = False  # Flag to track if special object has been created\n    succ = 0  # Counter for successfully placed objects\n    bgc = choice(cols)  # Randomly choose background color\n    remcols = remove(bgc, cols)  # Remove background color from available colors\n    gi = canvas(bgc, (h, w))  # Create input grid with background color\n    inds = asindices(gi)  # Get all indices of the grid\n\n    while tr < maxtr and succ < nobjs:  # Loop until max trials reached or all objects placed\n        oh = randint(2, 6)  # Random object height between 2 and 6\n        ow = randint(2, 6)  # Random object width between 2 and 6\n        bx = asindices(canvas(-1, (oh, ow)))  # Create a set of indices for the object\n        nc = randint(3, oh * ow)  # Random number of cells for the object\n        sp = choice(totuple(bx))  # Choose a starting point for the object\n        bx = remove(sp, bx)  # Remove starting point from available indices\n        obj = {sp}  # Initialize object with starting point\n\n        for k in range(nc - 1):  # Add cells to the object until desired size is reached\n            obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))  # Add a neighboring cell\n\n        if not done:  # Create the special object (only once)\n            done = True\n            idx = choice(totuple(obj))  # Choose a cell to be differently colored\n            coll = choice(remcols)  # Choose a color for the special cell\n            obj2 = {(coll, idx)}  # Create the special cell\n            obj3 = recolor(choice(remove(coll, remcols)), remove(idx, obj))  # Color the rest of the object\n            obj = obj2 | obj3  # Combine special cell and rest of object\n            go = paint(canvas(bgc, shape(obj3)), normalize(obj3))  # Create output grid with only this object\n        else:  # For regular objects\n            obj = recolor(choice(remcols), obj)  # Color the object randomly\n\n        locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)  # Find possible placement locations\n        tr += 1  # Increment trial counter\n        if len(locopts) == 0:  # If no valid locations, skip to next iteration\n            continue\n        loc = choice(totuple(locopts))  # Choose a random location\n        plcd = shift(obj, loc)  # Place the object at the chosen location\n        plcdi = toindices(plcd)  # Get indices of placed object\n        if plcdi.issubset(inds):  # If object fits within grid\n            gi = paint(gi, plcd)  # Add object to input grid\n            succ += 1  # Increment success counter\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)  # Remove object and neighboring cells from available indices\n\n    return {'input': gi, 'output': go}  # Return input and output grids\n"
  },
  "4938f0c2": {
    "original": "def generate_4938f0c2(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 31))\n    w = unifint(diff_lb, diff_ub, (10, 31))\n    oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))\n    ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    cc = choice(remcols)\n    remcols = remove(cc, remcols)\n    objc = choice(remcols)\n    sg = canvas(bgc, (oh, ow))\n    locc = (oh - 1, ow - 1)\n    sg = fill(sg, cc, {locc})\n    reminds = totuple(remove(locc, asindices(sg)))\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n    cells = sample(reminds, ncells)\n    while ncells == 4 and shape(cells) == (2, 2):\n        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n        cells = sample(reminds, ncells)\n    sg = fill(sg, objc, cells)\n    G1 = sg\n    G2 = vmirror(sg)\n    G3 = hmirror(sg)\n    G4 = vmirror(hmirror(sg))\n    vbar = canvas(bgc, (oh, 1))\n    hbar = canvas(bgc, (1, ow))\n    cp = canvas(cc, (1, 1))\n    topg = hconcat(hconcat(G1, vbar), G2)\n    botg = hconcat(hconcat(G3, vbar), G4)\n    ggm = hconcat(hconcat(hbar, cp), hbar)\n    GG = vconcat(vconcat(topg, ggm), botg)\n    gg = asobject(GG)\n    canv = canvas(bgc, (h, w))\n    loci = randint(0, h - 2 * oh - 1)\n    locj = randint(0, w - 2 * ow - 1)\n    loc = (loci, locj)\n    go = paint(canv, shift(gg, loc))\n    gi = paint(canv, shift(asobject(sg), loc))\n    gi = fill(gi, cc, ofcolor(go, cc))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    ccpi, ccpj = center(ofcolor(gi, cc))\n    gi = gi[:ccpi] + gi[ccpi+1:]\n    gi = tuple(r[:ccpj] + r[ccpj + 1:] for r in gi)\n    go = go[:ccpi] + go[ccpi+1:]\n    go = tuple(r[:ccpj] + r[ccpj + 1:] for r in go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4938f0c2(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors (0 to 9)\n    cols = interval(0, 10, 1)\n    \n    # Determine the height of the output grid (between 10 and 30)\n    h = unifint(diff_lb, diff_ub, (10, 31))\n    \n    # Determine the width of the output grid (between 10 and 30)\n    w = unifint(diff_lb, diff_ub, (10, 31))\n    \n    # Determine the height of the sub-grid (between 2 and half of the output height minus 3)\n    oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))\n    \n    # Determine the width of the sub-grid (between 2 and half of the output width minus 3)\n    ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))\n    \n    # Choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the center point\n    cc = choice(remcols)\n    \n    # Remove the center point color from the remaining colors\n    remcols = remove(cc, remcols)\n    \n    # Choose a color for the object\n    objc = choice(remcols)\n    \n    # Create a sub-grid canvas with the background color\n    sg = canvas(bgc, (oh, ow))\n    \n    # Define the location of the center point in the sub-grid\n    locc = (oh - 1, ow - 1)\n    \n    # Place the center point color in the sub-grid\n    sg = fill(sg, cc, {locc})\n    \n    # Get all indices of the sub-grid except the center point\n    reminds = totuple(remove(locc, asindices(sg)))\n    \n    # Determine the number of cells for the object (between 1 and 2/3 of the sub-grid area)\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n    \n    # Randomly select cells for the object\n    cells = sample(reminds, ncells)\n    \n    # Ensure the object is not a 2x2 square when it has 4 cells\n    while ncells == 4 and shape(cells) == (2, 2):\n        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n        cells = sample(reminds, ncells)\n    \n    # Place the object in the sub-grid\n    sg = fill(sg, objc, cells)\n    \n    # Create four variations of the sub-grid (original, vertical mirror, horizontal mirror, both mirrors)\n    G1 = sg\n    G2 = vmirror(sg)\n    G3 = hmirror(sg)\n    G4 = vmirror(hmirror(sg))\n    \n    # Create vertical and horizontal bars for separating the sub-grids\n    vbar = canvas(bgc, (oh, 1))\n    hbar = canvas(bgc, (1, ow))\n    \n    # Create a center point for the full grid\n    cp = canvas(cc, (1, 1))\n    \n    # Combine the top two sub-grids with a vertical bar\n    topg = hconcat(hconcat(G1, vbar), G2)\n    \n    # Combine the bottom two sub-grids with a vertical bar\n    botg = hconcat(hconcat(G3, vbar), G4)\n    \n    # Create the middle separator with the center point\n    ggm = hconcat(hconcat(hbar, cp), hbar)\n    \n    # Combine all parts to create the full grid\n    GG = vconcat(vconcat(topg, ggm), botg)\n    \n    # Convert the full grid to an object representation\n    gg = asobject(GG)\n    \n    # Create a canvas for the final output with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly determine the location to place the full grid\n    loci = randint(0, h - 2 * oh - 1)\n    locj = randint(0, w - 2 * ow - 1)\n    loc = (loci, locj)\n    \n    # Place the full grid on the canvas (output)\n    go = paint(canv, shift(gg, loc))\n    \n    # Place only the original sub-grid on the canvas (input)\n    gi = paint(canv, shift(asobject(sg), loc))\n    \n    # Add the center point to the input grid\n    gi = fill(gi, cc, ofcolor(go, cc))\n    \n    # Randomly rotate both input and output grids\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Find the center of the center point\n    ccpi, ccpj = center(ofcolor(gi, cc))\n    \n    # Remove the center point from the input grid\n    gi = gi[:ccpi] + gi[ccpi+1:]\n    gi = tuple(r[:ccpj] + r[ccpj + 1:] for r in gi)\n    \n    # Remove the center point from the output grid\n    go = go[:ccpi] + go[ccpi+1:]\n    go = tuple(r[:ccpj] + r[ccpj + 1:] for r in go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "496994bd": {
    "original": "def generate_496994bd(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 1))\n    bx = asindices(canv)\n    obj = {\n        (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] < h//2)))),\n        (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] > h//2))))\n    }\n    for kk in range(nc - 2):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gix = paint(canv, obj)\n    gix = apply(rbind(order, matcher(identity, bgc)), gix)\n    flag = choice((True, False))\n    gi = hconcat(gix, canv if flag else hconcat(canvas(bgc, (h, 1)), canv))\n    go = hconcat(gix, vmirror(gix) if flag else hconcat(canvas(bgc, (h, 1)), vmirror(gix)))\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    if choice((True, False)):\n        gi = hmirror(gi)\n        go = hmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_496994bd(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly select a height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select a width between 3 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select the number of colors to use (1 to 8) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample colors from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly select the number of cells to color (2 to h*w-1) based on difficulty\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 1))\n    \n    # Get all indices of the canvas as a set\n    bx = asindices(canv)\n    \n    # Create an initial object with two colored cells:\n    # One in the upper half and one in the lower half of the grid\n    obj = {\n        # Choose a random color and position in the upper half\n        (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] < h//2)))),\n        # Choose a random color and position in the lower half\n        (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] > h//2))))\n    }\n    \n    # Add more colored cells to the object\n    for kk in range(nc - 2):\n        # Get all neighbors of the existing colored cells\n        dns = mapply(neighbors, toindices(obj))\n        # Choose a random cell from the intersection of available cells and neighbors\n        ch = choice(totuple(bx & dns))\n        # Add the chosen cell with a random color to the object\n        obj.add((choice(remcols), ch))\n        # Remove the chosen cell from the available cells\n        bx = bx - {ch}\n    \n    # Paint the object onto the canvas\n    gix = paint(canv, obj)\n    \n    # Sort each row of the grid, keeping background color cells at the end\n    gix = apply(rbind(order, matcher(identity, bgc)), gix)\n    \n    # Randomly decide whether to add an extra column or not\n    flag = choice((True, False))\n    \n    # Create the input grid: original + (extra column + original) or (original)\n    gi = hconcat(gix, canv if flag else hconcat(canvas(bgc, (h, 1)), canv))\n    \n    # Create the output grid: original + (vertically mirrored original) or (extra column + vertically mirrored original)\n    go = hconcat(gix, vmirror(gix) if flag else hconcat(canvas(bgc, (h, 1)), vmirror(gix)))\n    \n    # Randomly decide whether to vertically mirror both input and output\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    \n    # Randomly decide whether to horizontally mirror both input and output\n    if choice((True, False)):\n        gi = hmirror(gi)\n        go = hmirror(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "49d1d64f": {
    "original": "def generate_49d1d64f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 28))\n    w = unifint(diff_lb, diff_ub, (2, 28))\n    ncols = unifint(diff_lb, diff_ub, (1, 10))\n    ccols = sample(cols, ncols)\n    gi = canvas(-1, (h, w))\n    obj = {(choice(ccols), ij) for ij in asindices(gi)}\n    gi = paint(gi, obj)\n    go = canvas(0, (h+2, w+2))\n    go = paint(go, shift(asobject(gi), (1, 1)))\n    ts = sfilter(obj, lambda cij: cij[1][0] == 0)\n    bs = sfilter(obj, lambda cij: cij[1][0] == h - 1)\n    ls = sfilter(obj, lambda cij: cij[1][1] == 0)\n    rs = sfilter(obj, lambda cij: cij[1][1] == w - 1)\n    ts = shift(ts, (1, 1))\n    bs = shift(bs, (1, 1))\n    ls = shift(ls, (1, 1))\n    rs = shift(rs, (1, 1))\n    go = paint(go, shift(ts, (-1, 0)))\n    go = paint(go, shift(bs, (1, 0)))\n    go = paint(go, shift(ls, (0, -1)))\n    go = paint(go, shift(rs, (0, 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_49d1d64f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 2 and 28 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 28))\n    \n    # Generate a random width between 2 and 28 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 28))\n    \n    # Choose a random number of colors to use (between 1 and 10)\n    ncols = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly sample 'ncols' colors from the 'cols' range\n    ccols = sample(cols, ncols)\n    \n    # Create an empty input grid filled with -1 of size h x w\n    gi = canvas(-1, (h, w))\n    \n    # Create an object by assigning random colors to all grid positions\n    obj = {(choice(ccols), ij) for ij in asindices(gi)}\n    \n    # Paint the input grid with the created object\n    gi = paint(gi, obj)\n    \n    # Create an output grid filled with 0, with dimensions (h+2) x (w+2)\n    go = canvas(0, (h+2, w+2))\n    \n    # Paint the output grid with the input grid, shifted by (1,1)\n    go = paint(go, shift(asobject(gi), (1, 1)))\n    \n    # Filter object cells that are on the top edge of the input grid\n    ts = sfilter(obj, lambda cij: cij[1][0] == 0)\n    \n    # Filter object cells that are on the bottom edge of the input grid\n    bs = sfilter(obj, lambda cij: cij[1][0] == h - 1)\n    \n    # Filter object cells that are on the left edge of the input grid\n    ls = sfilter(obj, lambda cij: cij[1][1] == 0)\n    \n    # Filter object cells that are on the right edge of the input grid\n    rs = sfilter(obj, lambda cij: cij[1][1] == w - 1)\n    \n    # Shift all edge cells by (1,1) to align with the output grid\n    ts = shift(ts, (1, 1))\n    bs = shift(bs, (1, 1))\n    ls = shift(ls, (1, 1))\n    rs = shift(rs, (1, 1))\n    \n    # Paint the top edge cells onto the output grid, shifted up by 1\n    go = paint(go, shift(ts, (-1, 0)))\n    \n    # Paint the bottom edge cells onto the output grid, shifted down by 1\n    go = paint(go, shift(bs, (1, 0)))\n    \n    # Paint the left edge cells onto the output grid, shifted left by 1\n    go = paint(go, shift(ls, (0, -1)))\n    \n    # Paint the right edge cells onto the output grid, shifted right by 1\n    go = paint(go, shift(rs, (0, 1)))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "4be741c5": {
    "original": "def generate_4be741c5(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    numcolors = unifint(diff_lb, diff_ub, (2, w // 3))\n    ccols = sample(cols, numcolors)\n    go = (tuple(ccols),)\n    gi = merge(tuple(repeat(repeat(c, h), 3) for c in ccols))\n    while len(gi) < w:\n        idx = randint(0, len(gi) - 1)\n        gi = gi[:idx] + gi[idx:idx+1] + gi[idx:]\n    gi = dmirror(gi)\n    ndisturbances = unifint(diff_lb, diff_ub, (0, 3 * h * numcolors))\n    for k in range(ndisturbances):\n        options = []\n        for a in range(h):\n            for b in range(w - 3):\n                if gi[a][b] == gi[a][b+1] and gi[a][b+2] == gi[a][b+3]:\n                    options.append((a, b, gi[a][b], gi[a][b+2]))\n        if len(options) == 0:\n            break\n        a, b, c1, c2 = choice(options)\n        if choice((True, False)):\n            gi = fill(gi, c2, {(a, b+1)})\n        else:\n            gi = fill(gi, c1, {(a, b+2)})\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4be741c5(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Determine the number of colors to use (between 2 and 1/3 of the width)\n    numcolors = unifint(diff_lb, diff_ub, (2, w // 3))\n    \n    # Randomly select 'numcolors' colors from the available colors\n    ccols = sample(cols, numcolors)\n    \n    # Create the output grid: a single row containing the selected colors\n    go = (tuple(ccols),)\n    \n    # Create the initial input grid: vertical stripes of each color, each 3 columns wide\n    gi = merge(tuple(repeat(repeat(c, h), 3) for c in ccols))\n    \n    # Expand the input grid width to match the desired width by duplicating random columns\n    while len(gi) < w:\n        idx = randint(0, len(gi) - 1)\n        gi = gi[:idx] + gi[idx:idx+1] + gi[idx:]\n    \n    # Mirror the input grid diagonally (transpose)\n    gi = dmirror(gi)\n    \n    # Determine the number of disturbances to apply (0 to 3 * height * number of colors)\n    ndisturbances = unifint(diff_lb, diff_ub, (0, 3 * h * numcolors))\n    \n    # Apply random disturbances to the input grid\n    for k in range(ndisturbances):\n        options = []\n        # Find all possible locations for disturbances\n        for a in range(h):\n            for b in range(w - 3):\n                # Check for adjacent pairs of same-colored cells\n                if gi[a][b] == gi[a][b+1] and gi[a][b+2] == gi[a][b+3]:\n                    options.append((a, b, gi[a][b], gi[a][b+2]))\n        \n        # If no valid locations for disturbances, break the loop\n        if len(options) == 0:\n            break\n        \n        # Choose a random location and colors for the disturbance\n        a, b, c1, c2 = choice(options)\n        \n        # Randomly choose to apply the disturbance to the left or right cell\n        if choice((True, False)):\n            gi = fill(gi, c2, {(a, b+1)})  # Change left cell to right color\n        else:\n            gi = fill(gi, c1, {(a, b+2)})  # Change right cell to left color\n    \n    # 50% chance to mirror the input and output grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "4c4377d9": {
    "original": "def generate_4c4377d9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(cols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = vconcat(hmirror(gi), gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4c4377d9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 1 and 15\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly determine the width of the grid between 1 and 30\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (between 0 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use in the grid\n    colsch = sample(cols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose cells to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by vertically concatenating:\n    # 1. The horizontal mirror of the input grid\n    # 2. The original input grid\n    go = vconcat(hmirror(gi), gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "4c5c2cf0": {
    "original": "def generate_4c5c2cf0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))\n    ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    cc = choice(remcols)\n    remcols = remove(cc, remcols)\n    objc = choice(remcols)\n    sg = canvas(bgc, (oh, ow))\n    locc = (oh - 1, ow - 1)\n    sg = fill(sg, cc, {locc})\n    reminds = totuple(remove(locc, asindices(sg)))\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n    cells = sample(reminds, ncells)\n    while ncells == 5 and shape(cells) == (3, 3):\n        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n        cells = sample(reminds, ncells)\n    sg = fill(sg, objc, cells)\n    G1 = sg\n    G2 = vmirror(sg)\n    G3 = hmirror(sg)\n    G4 = vmirror(hmirror(sg))\n    vbar = canvas(bgc, (oh, 1))\n    hbar = canvas(bgc, (1, ow))\n    cp = canvas(cc, (1, 1))\n    topg = hconcat(hconcat(G1, vbar), G2)\n    botg = hconcat(hconcat(G3, vbar), G4)\n    ggm = hconcat(hconcat(hbar, cp), hbar)\n    GG = vconcat(vconcat(topg, ggm), botg)\n    gg = asobject(GG)\n    canv = canvas(bgc, (h, w))\n    loci = randint(0, h - 2 * oh - 1)\n    locj = randint(0, w - 2 * ow - 1)\n    loc = (loci, locj)\n    go = paint(canv, shift(gg, loc))\n    gi = paint(canv, shift(asobject(sg), loc))\n    gi = fill(gi, cc, ofcolor(go, cc))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_4c5c2cf0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random object height between 2 and half of (h-3)\n    oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))\n    \n    # Generate a random object width between 2 and half of (w-3)\n    ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the corner pixel\n    cc = choice(remcols)\n    \n    # Remove the corner color from the remaining colors\n    remcols = remove(cc, remcols)\n    \n    # Choose a random color for the object\n    objc = choice(remcols)\n    \n    # Create a canvas of size (oh, ow) filled with the background color\n    sg = canvas(bgc, (oh, ow))\n    \n    # Define the location of the corner pixel\n    locc = (oh - 1, ow - 1)\n    \n    # Fill the corner pixel with the corner color\n    sg = fill(sg, cc, {locc})\n    \n    # Get all indices except the corner pixel\n    reminds = totuple(remove(locc, asindices(sg)))\n    \n    # Generate a random number of cells to fill, between 1 and 2/3 of the area\n    ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n    \n    # Randomly select cells to fill\n    cells = sample(reminds, ncells)\n    \n    # Ensure that if 5 cells are selected, they don't form a 3x3 square\n    while ncells == 5 and shape(cells) == (3, 3):\n        # If they do, regenerate the number of cells and reselect\n        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))\n        cells = sample(reminds, ncells)\n    \n    # Fill the selected cells with the object color\n    sg = fill(sg, objc, cells)\n    \n    # Create four versions of the small grid: original and three mirrors\n    G1 = sg\n    G2 = vmirror(sg)  # Vertical mirror\n    G3 = hmirror(sg)  # Horizontal mirror\n    G4 = vmirror(hmirror(sg))  # Both vertical and horizontal mirror\n    \n    # Create vertical and horizontal bars for separating the grids\n    vbar = canvas(bgc, (oh, 1))\n    hbar = canvas(bgc, (1, ow))\n    \n    # Create a single pixel of the corner color\n    cp = canvas(cc, (1, 1))\n    \n    # Concatenate the top grids with a vertical bar between them\n    topg = hconcat(hconcat(G1, vbar), G2)\n    \n    # Concatenate the bottom grids with a vertical bar between them\n    botg = hconcat(hconcat(G3, vbar), G4)\n    \n    # Create the middle separator with the corner pixel in the center\n    ggm = hconcat(hconcat(hbar, cp), hbar)\n    \n    # Combine all parts to create the final large grid\n    GG = vconcat(vconcat(topg, ggm), botg)\n    \n    # Convert the grid to an object representation\n    gg = asobject(GG)\n    \n    # Create a canvas of the final size with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Generate random coordinates to place the large grid\n    loci = randint(0, h - 2 * oh - 1)\n    locj = randint(0, w - 2 * ow - 1)\n    loc = (loci, locj)\n    \n    # Paint the large grid onto the canvas (output)\n    go = paint(canv, shift(gg, loc))\n    \n    # Paint only the small grid onto the canvas (input)\n    gi = paint(canv, shift(asobject(sg), loc))\n    \n    # Add corner pixels to the input grid\n    gi = fill(gi, cc, ofcolor(go, cc))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "50846271": {
    "original": "def generate_50846271(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    cf1 = lambda d: {(d//2, 0), (d//2, d-1)} | set(sample(totuple(connect((d//2, 0), (d//2, d-1))), randint(1, d)))\n    cf2 = lambda d: {(0, d//2), (d - 1, d//2)} | set(sample(totuple(connect((0, d//2), (d-1, d//2))), randint(1, d)))\n    cf3 = lambda d: set(sample(totuple(remove((d//2, d//2), connect((d//2, 0), (d//2, d-1)))), randint(1, d-1))) | set(sample(totuple(remove((d//2, d//2), connect((0, d//2), (d - 1, d//2)))), randint(1, d-1)))\n    cf = lambda d: choice((cf1, cf2, cf3))(d)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    dim = unifint(diff_lb, diff_ub, (1, 3))\n    dim = 2 * dim + 1\n    cross = connect((dim//2, 0), (dim//2, dim - 1)) | connect((0, dim//2), (dim - 1, dim//2))\n    bgc, crossc, noisec = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    namt = unifint(diff_lb, diff_ub, (int(0.35 * h * w), int(0.65 * h * w)))\n    inds = asindices(gi)\n    noise = sample(totuple(inds), namt)\n    gi = fill(gi, noisec, noise)\n    initcross = choice((cf1, cf2))(dim)\n    loci = randint(0, h - dim)\n    locj = randint(0, w - dim)\n    delt = shift(cross - initcross, (loci, locj))\n    gi = fill(gi, crossc, shift(initcross, (loci, locj)))\n    gi = fill(gi, noisec, delt)\n    go = fill(gi, 8, delt)\n    plcd = shift(cross, (loci, locj))\n    bd = backdrop(plcd)\n    nbhs = mapply(neighbors, plcd)\n    inds = (inds - plcd) - nbhs\n    nbhs2 = mapply(neighbors, nbhs)\n    inds = inds - nbhs2\n    inds = inds - mapply(neighbors, nbhs2)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) / (10 * dim)))\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        cands = sfilter(inds, lambda ij: ij[0] <= h - dim and ij[1] <= w - dim)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        marked = shift(cf(dim), loc)\n        full = shift(cross, loc)\n        unmarked = full - marked\n        inobj = recolor(noisec, unmarked) | recolor(crossc, marked)\n        outobj = recolor(8, unmarked) | recolor(crossc, marked)\n        outobji = toindices(outobj)\n        if outobji.issubset(inds):\n            dnbhs = mapply(neighbors, outobji)\n            dnbhs2 = mapply(neighbors, dnbhs)\n            inds = (inds - outobji) - (dnbhs | dnbhs2 | mapply(neighbors, dnbhs2))\n            succ += 1\n            gi = paint(gi, inobj)\n            go = paint(go, outobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_50846271(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-7, 9 (excluding 8)\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Define lambda function for creating a vertical cross pattern\n    cf1 = lambda d: {(d//2, 0), (d//2, d-1)} | set(sample(totuple(connect((d//2, 0), (d//2, d-1))), randint(1, d)))\n    \n    # Define lambda function for creating a horizontal cross pattern\n    cf2 = lambda d: {(0, d//2), (d - 1, d//2)} | set(sample(totuple(connect((0, d//2), (d-1, d//2))), randint(1, d)))\n    \n    # Define lambda function for creating a random cross pattern\n    cf3 = lambda d: set(sample(totuple(remove((d//2, d//2), connect((d//2, 0), (d//2, d-1)))), randint(1, d-1))) | set(sample(totuple(remove((d//2, d//2), connect((0, d//2), (d - 1, d//2)))), randint(1, d-1)))\n    \n    # Choose one of the cross pattern functions randomly\n    cf = lambda d: choice((cf1, cf2, cf3))(d)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random dimension (1, 2, or 3) based on difficulty\n    dim = unifint(diff_lb, diff_ub, (1, 3))\n    \n    # Ensure dimension is odd by multiplying by 2 and adding 1\n    dim = 2 * dim + 1\n    \n    # Create a full cross pattern\n    cross = connect((dim//2, 0), (dim//2, dim - 1)) | connect((0, dim//2), (dim - 1, dim//2))\n    \n    # Choose background, cross, and noise colors randomly\n    bgc, crossc, noisec = sample(cols, 3)\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Calculate number of noise points (35-65% of total grid size)\n    namt = unifint(diff_lb, diff_ub, (int(0.35 * h * w), int(0.65 * h * w)))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Choose random positions for noise\n    noise = sample(totuple(inds), namt)\n    \n    # Add noise to the grid\n    gi = fill(gi, noisec, noise)\n    \n    # Choose initial cross pattern (vertical or horizontal)\n    initcross = choice((cf1, cf2))(dim)\n    \n    # Choose random location for the initial cross\n    loci = randint(0, h - dim)\n    locj = randint(0, w - dim)\n    \n    # Calculate the difference between full cross and initial cross\n    delt = shift(cross - initcross, (loci, locj))\n    \n    # Add initial cross to the grid\n    gi = fill(gi, crossc, shift(initcross, (loci, locj)))\n    \n    # Add noise to the delta (difference between full and initial cross)\n    gi = fill(gi, noisec, delt)\n    \n    # Create output grid by filling delta with color 8\n    go = fill(gi, 8, delt)\n    \n    # Calculate the position of the placed cross\n    plcd = shift(cross, (loci, locj))\n    \n    # Get the backdrop (bounding box) of the placed cross\n    bd = backdrop(plcd)\n    \n    # Get neighbors of the placed cross\n    nbhs = mapply(neighbors, plcd)\n    \n    # Remove placed cross and its neighbors from available indices\n    inds = (inds - plcd) - nbhs\n    \n    # Get second-order neighbors\n    nbhs2 = mapply(neighbors, nbhs)\n    \n    # Remove second-order neighbors from available indices\n    inds = inds - nbhs2\n    \n    # Remove third-order neighbors from available indices\n    inds = inds - mapply(neighbors, nbhs2)\n    \n    # Calculate number of occurrences based on difficulty\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) / (10 * dim)))\n    \n    # Initialize success and trial counters\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    \n    # Loop to place additional crosses\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        # Filter candidate positions that fit within the grid\n        cands = sfilter(inds, lambda ij: ij[0] <= h - dim and ij[1] <= w - dim)\n        if len(cands) == 0:\n            break\n        # Choose a random location for the new cross\n        loc = choice(totuple(cands))\n        # Generate a random cross pattern\n        marked = shift(cf(dim), loc)\n        # Generate the full cross at the chosen location\n        full = shift(cross, loc)\n        # Calculate the unmarked part of the cross\n        unmarked = full - marked\n        # Create input object (marked parts in cross color, unmarked in noise color)\n        inobj = recolor(noisec, unmarked) | recolor(crossc, marked)\n        # Create output object (marked parts in cross color, unmarked in color 8)\n        outobj = recolor(8, unmarked) | recolor(crossc, marked)\n        # Get indices of the output object\n        outobji = toindices(outobj)\n        # Check if the output object fits within available indices\n        if outobji.issubset(inds):\n            # Calculate neighbors of the output object\n            dnbhs = mapply(neighbors, outobji)\n            dnbhs2 = mapply(neighbors, dnbhs)\n            # Remove output object and its neighbors from available indices\n            inds = (inds - outobji) - (dnbhs | dnbhs2 | mapply(neighbors, dnbhs2))\n            succ += 1\n            # Add the new cross to the input and output grids\n            gi = paint(gi, inobj)\n            go = paint(go, outobj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "508bd3b6": {
    "original": "def generate_508bd3b6(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (h, 30))\n    barh = unifint(diff_lb, diff_ub, (1, h // 2))\n    barloci = unifint(diff_lb, diff_ub, (2, h - barh))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    barc = choice(remcols)\n    remcols = remove(barc, remcols)\n    linc = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    for j in range(barloci, barloci + barh):\n        gi = fill(gi, barc, connect((j, 0), (j, w - 1)))\n    dotlociinv = unifint(diff_lb, diff_ub, (0, barloci - 1))\n    dotloci = min(max(0, barloci - 2 - dotlociinv), barloci - 1)\n    ln1 = shoot((dotloci, 0), (1, 1))\n    ofbgc = ofcolor(gi, bgc)\n    ln1 = sfilter(ln1 & ofbgc, lambda ij: ij[0] < barloci)\n    ln1 = order(ln1, first)\n    ln2 = shoot(ln1[-1], (-1, 1))\n    ln2 = sfilter(ln2 & ofbgc, lambda ij: ij[0] < barloci)\n    ln2 = order(ln2, last)[1:]\n    ln = ln1 + ln2\n    k = len(ln1)\n    lineleninv = unifint(diff_lb, diff_ub, (0, k - 2))\n    linelen = k - lineleninv\n    givenl = ln[:linelen]\n    reml = ln[linelen:]\n    gi = fill(gi, linc, givenl)\n    go = fill(gi, 3, reml)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_508bd3b6(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (5-30)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid (h-30)\n    w = unifint(diff_lb, diff_ub, (h, 30))\n    \n    # Randomly determine the height of the bar (1 to half of grid height)\n    barh = unifint(diff_lb, diff_ub, (1, h // 2))\n    \n    # Randomly determine the starting row of the bar (2 to h-barh)\n    barloci = unifint(diff_lb, diff_ub, (2, h - barh))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a color for the bar\n    barc = choice(remcols)\n    \n    # Remove the bar color from the remaining colors\n    remcols = remove(barc, remcols)\n    \n    # Randomly choose a color for the line\n    linc = choice(remcols)\n    \n    # Create a grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill in the bar with the bar color\n    for j in range(barloci, barloci + barh):\n        gi = fill(gi, barc, connect((j, 0), (j, w - 1)))\n    \n    # Randomly determine the inverse of the dot's starting row\n    dotlociinv = unifint(diff_lb, diff_ub, (0, barloci - 1))\n    \n    # Calculate the actual starting row of the dot\n    dotloci = min(max(0, barloci - 2 - dotlociinv), barloci - 1)\n    \n    # Create a diagonal line starting from the dot's position\n    ln1 = shoot((dotloci, 0), (1, 1))\n    \n    # Get all background-colored cells\n    ofbgc = ofcolor(gi, bgc)\n    \n    # Filter ln1 to only include background-colored cells before the bar\n    ln1 = sfilter(ln1 & ofbgc, lambda ij: ij[0] < barloci)\n    \n    # Order ln1 by first coordinate\n    ln1 = order(ln1, first)\n    \n    # Create a second diagonal line starting from the end of ln1\n    ln2 = shoot(ln1[-1], (-1, 1))\n    \n    # Filter ln2 to only include background-colored cells before the bar\n    ln2 = sfilter(ln2 & ofbgc, lambda ij: ij[0] < barloci)\n    \n    # Order ln2 by last coordinate and remove the first element\n    ln2 = order(ln2, last)[1:]\n    \n    # Combine ln1 and ln2 to form the complete line\n    ln = ln1 + ln2\n    \n    # Get the length of ln1\n    k = len(ln1)\n    \n    # Randomly determine how much of the line to remove\n    lineleninv = unifint(diff_lb, diff_ub, (0, k - 2))\n    \n    # Calculate the length of the visible part of the line\n    linelen = k - lineleninv\n    \n    # Split the line into visible and hidden parts\n    givenl = ln[:linelen]\n    reml = ln[linelen:]\n    \n    # Draw the visible part of the line on the input grid\n    gi = fill(gi, linc, givenl)\n    \n    # Draw the hidden part of the line on the output grid\n    go = fill(gi, 3, reml)\n    \n    # Define a list of possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Randomly choose to apply 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen number of random transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "50cb2852": {
    "original": "def generate_50cb2852(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            go = fill(go, 8, bd)\n            go = fill(go, col, box(obj))\n            box(obj)\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_50cb2852(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Generate random number of objects to place (1-8) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placements counter\n    succ = 0\n    \n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we run out of colors or available indices\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        \n        # Generate random object height (3-7)\n        oh = randint(3, 7)\n        \n        # Generate random object width (3-7)\n        ow = randint(3, 7)\n        \n        # Find valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position for the object\n        loci, locj = choice(subs)\n        \n        # Create the object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get the backdrop (all cells) of the object\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # Check if the object fits within the available indices\n        if bd.issubset(indss):\n            # Remove the chosen color from available colors\n            remcols = remove(col, remcols)\n            \n            # Fill the input grid with the object color\n            gi = fill(gi, col, bd)\n            \n            # Fill the output grid with color 8 (outline color) for the entire object area\n            go = fill(go, 8, bd)\n            \n            # Fill the output grid with the object color for the outline\n            go = fill(go, col, box(obj))\n            \n            # Calculate the box (outline) of the object (unused result)\n            box(obj)\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Remove used indices from available indices\n            indss = indss - bd\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "5117e062": {
    "original": "def generate_5117e062(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))\n    tr = 0\n    maxtr = 4 * nobjs\n    done = False\n    succ = 0\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while tr < maxtr and succ < nobjs:\n        oh = randint(2, 6)\n        ow = randint(2, 6)\n        bx = asindices(canvas(-1, (oh, ow)))\n        nc = randint(3, oh * ow)\n        sp = choice(totuple(bx))\n        bx = remove(sp, bx)\n        obj = {sp}\n        for k in range(nc - 1):\n            obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))\n        if not done:\n            done = True\n            idx = choice(totuple(obj))\n            coll = choice(remcols)\n            obj2 = {(coll, idx)}\n            coll2 = choice(remove(coll, remcols))\n            obj3 = recolor(coll2, remove(idx, obj))\n            obj = obj2 | obj3\n            go = fill(canvas(bgc, shape(obj)), coll2, normalize(obj))\n        else:\n            obj = recolor(choice(remcols), obj)\n        locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        tr += 1\n        if len(locopts) == 0:\n            continue\n        loc = choice(totuple(locopts))\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            gi = paint(gi, plcd)\n            succ += 1\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5117e062(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Determine the number of objects to place on the grid\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))\n    # Initialize try counter\n    tr = 0\n    # Set maximum number of tries\n    maxtr = 4 * nobjs\n    # Flag to ensure one special object is created\n    done = False\n    # Counter for successfully placed objects\n    succ = 0\n    # Randomly choose background color\n    bgc = choice(cols)\n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    # Create initial grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing objects\n    while tr < maxtr and succ < nobjs:\n        # Randomly determine object height\n        oh = randint(2, 6)\n        # Randomly determine object width\n        ow = randint(2, 6)\n        # Create a box of indices for the object\n        bx = asindices(canvas(-1, (oh, ow)))\n        # Determine number of cells in the object\n        nc = randint(3, oh * ow)\n        # Choose a starting point for the object\n        sp = choice(totuple(bx))\n        # Remove starting point from available box indices\n        bx = remove(sp, bx)\n        # Initialize object with starting point\n        obj = {sp}\n        \n        # Build the object by adding connected cells\n        for k in range(nc - 1):\n            obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))\n        \n        # Create a special object once\n        if not done:\n            done = True\n            # Choose a random index from the object\n            idx = choice(totuple(obj))\n            # Choose a color for the special cell\n            coll = choice(remcols)\n            # Create the special cell\n            obj2 = {(coll, idx)}\n            # Choose a different color for the rest of the object\n            coll2 = choice(remove(coll, remcols))\n            # Color the rest of the object\n            obj3 = recolor(coll2, remove(idx, obj))\n            # Combine the special cell and the rest of the object\n            obj = obj2 | obj3\n            # Create the output grid with the special object\n            go = fill(canvas(bgc, shape(obj)), coll2, normalize(obj))\n        else:\n            # For non-special objects, just assign a random color\n            obj = recolor(choice(remcols), obj)\n        \n        # Find possible locations to place the object\n        locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # Increment try counter\n        tr += 1\n        # If no valid locations, continue to next iteration\n        if len(locopts) == 0:\n            continue\n        # Choose a random location for the object\n        loc = choice(totuple(locopts))\n        # Shift the object to the chosen location\n        plcd = shift(obj, loc)\n        # Get indices of the placed object\n        plcdi = toindices(plcd)\n        \n        # If the object fits on the grid\n        if plcdi.issubset(inds):\n            # Paint the object onto the input grid\n            gi = paint(gi, plcd)\n            # Increment success counter\n            succ += 1\n            # Remove used indices and their neighbors from available indices\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n    \n    # Return the generated input grid and the output grid with the special object\n    return {'input': gi, 'output': go}\n"
  },
  "5168d44c": {
    "original": "def generate_5168d44c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    doth = unifint(diff_lb, diff_ub, (1, h//3))\n    dotw = unifint(diff_lb, diff_ub, (1, w//3))\n    borderh = unifint(diff_lb, diff_ub, (1, h//4))\n    borderw = unifint(diff_lb, diff_ub, (1, w//4))\n    direc = choice((DOWN, RIGHT, UNITY))\n    dotloci = randint(0, h - doth - 1 if direc == RIGHT else h - doth - borderh - 1)\n    dotlocj = randint(0, w - dotw - 1 if direc == DOWN else w - dotw - borderw - 1)\n    dotloc = (dotloci, dotlocj)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    dotcol = choice(remcols)\n    remcols = remove(dotcol, remcols)\n    boxcol = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    dotshap = (doth, dotw)\n    starterdot = backdrop(frozenset({dotloc, add(dotloc, decrement(dotshap))}))\n    bordershap = (borderh, borderw)\n    offset = add(multiply(direc, dotshap), multiply(direc, bordershap))\n    itv = interval(-15, 16, 1)\n    itv = apply(lbind(multiply, offset), itv)\n    dots = mapply(lbind(shift, starterdot), itv)\n    gi = fill(gi, dotcol, dots)\n    protobx = backdrop(frozenset({\n        (dotloci - borderh, dotlocj - borderw),\n        (dotloci + doth + borderh - 1, dotlocj + dotw + borderw - 1),\n    }))\n    bx = protobx - starterdot\n    bxshifted = shift(bx, offset)\n    go = fill(gi, boxcol, bxshifted)\n    gi = fill(gi, boxcol, bx)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5168d44c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 7 and 30\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the width of the grid between 7 and 30\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the height of the dot, up to 1/3 of the grid height\n    doth = unifint(diff_lb, diff_ub, (1, h//3))\n    \n    # Randomly determine the width of the dot, up to 1/3 of the grid width\n    dotw = unifint(diff_lb, diff_ub, (1, w//3))\n    \n    # Randomly determine the height of the border, up to 1/4 of the grid height\n    borderh = unifint(diff_lb, diff_ub, (1, h//4))\n    \n    # Randomly determine the width of the border, up to 1/4 of the grid width\n    borderw = unifint(diff_lb, diff_ub, (1, w//4))\n    \n    # Randomly choose a direction for the dot to move: down, right, or diagonally\n    direc = choice((DOWN, RIGHT, UNITY))\n    \n    # Determine the starting row for the dot, ensuring it fits within the grid\n    dotloci = randint(0, h - doth - 1 if direc == RIGHT else h - doth - borderh - 1)\n    \n    # Determine the starting column for the dot, ensuring it fits within the grid\n    dotlocj = randint(0, w - dotw - 1 if direc == DOWN else w - dotw - borderw - 1)\n    \n    # Combine the row and column to get the starting location of the dot\n    dotloc = (dotloci, dotlocj)\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a color for the dot\n    dotcol = choice(remcols)\n    \n    # Remove the dot color from the remaining colors\n    remcols = remove(dotcol, remcols)\n    \n    # Randomly choose a color for the box\n    boxcol = choice(remcols)\n    \n    # Create the initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Define the shape of the dot\n    dotshap = (doth, dotw)\n    \n    # Create the initial dot shape\n    starterdot = backdrop(frozenset({dotloc, add(dotloc, decrement(dotshap))}))\n    \n    # Define the shape of the border\n    bordershap = (borderh, borderw)\n    \n    # Calculate the offset for the dot's movement\n    offset = add(multiply(direc, dotshap), multiply(direc, bordershap))\n    \n    # Create a range of integers from -15 to 15\n    itv = interval(-15, 16, 1)\n    \n    # Multiply each value in the range by the offset\n    itv = apply(lbind(multiply, offset), itv)\n    \n    # Generate all positions of the dot as it moves\n    dots = mapply(lbind(shift, starterdot), itv)\n    \n    # Fill the grid with the dot color at all dot positions\n    gi = fill(gi, dotcol, dots)\n    \n    # Create the initial box shape\n    protobx = backdrop(frozenset({\n        (dotloci - borderh, dotlocj - borderw),\n        (dotloci + doth + borderh - 1, dotlocj + dotw + borderw - 1),\n    }))\n    \n    # Remove the dot from the box shape\n    bx = protobx - starterdot\n    \n    # Shift the box shape by the offset\n    bxshifted = shift(bx, offset)\n    \n    # Create the output grid by filling the shifted box shape\n    go = fill(gi, boxcol, bxshifted)\n    \n    # Fill the input grid with the initial box shape\n    gi = fill(gi, boxcol, bx)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "539a4f51": {
    "original": "def generate_539a4f51(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    d = unifint(diff_lb, diff_ub, (2, 15))\n    h, w = d, d\n    gi = canvas(0, (h, w))\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(cols, numc)\n    numocc = unifint(diff_lb, diff_ub, (1, d))\n    arr = [choice(ccols) for k in range(numocc)]\n    while len(set(arr)) == 1:\n        arr = [choice(ccols) for k in range(d)]\n    for j, col in enumerate(arr):\n        gi = fill(gi, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))\n    go = canvas(0, (2*d, 2*d))\n    for j in range(2*d):\n        col = arr[j % len(arr)]\n        go = fill(go, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_539a4f51(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color values from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Determine the size of the input grid based on difficulty\n    d = unifint(diff_lb, diff_ub, (2, 15))\n    # Set height and width of the input grid to be equal\n    h, w = d, d\n    \n    # Create an empty input grid filled with zeros\n    gi = canvas(0, (h, w))\n    \n    # Determine the number of colors to use based on difficulty\n    numc = unifint(diff_lb, diff_ub, (2, 9))\n    # Randomly select colors from the color range\n    ccols = sample(cols, numc)\n    \n    # Determine the number of occurrences of colors in the pattern\n    numocc = unifint(diff_lb, diff_ub, (1, d))\n    # Create a random array of colors for the pattern\n    arr = [choice(ccols) for k in range(numocc)]\n    \n    # Ensure the array has at least two different colors\n    while len(set(arr)) == 1:\n        arr = [choice(ccols) for k in range(d)]\n    \n    # Fill the input grid with the color pattern\n    for j, col in enumerate(arr):\n        # Draw an L-shaped pattern for each color\n        gi = fill(gi, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))\n    \n    # Create an empty output grid twice the size of the input\n    go = canvas(0, (2*d, 2*d))\n    \n    # Fill the output grid with an extended version of the color pattern\n    for j in range(2*d):\n        col = arr[j % len(arr)]\n        # Draw an L-shaped pattern for each color, continuing the input pattern\n        go = fill(go, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "53b68214": {
    "original": "def generate_53b68214(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        h = unifint(diff_lb, diff_ub, (2, 6))\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        bgc = choice(cols)\n        remcols = remove(bgc, cols)\n        ncols = unifint(diff_lb, diff_ub, (1, 9))\n        ccols = sample(remcols, ncols)\n        oh = unifint(diff_lb, diff_ub, (1, h//2))\n        ow = unifint(diff_lb, diff_ub, (1, w//2-1))\n        bounds = asindices(canvas(-1, (oh, ow)))\n        ncells = unifint(diff_lb, diff_ub, (1, oh * ow))\n        obj = sample(totuple(bounds), ncells)\n        obj = {(choice(ccols), ij) for ij in obj}\n        obj = normalize(obj)\n        oh, ow = shape(obj)\n        locj = randint(0, w//2)\n        plcd = shift(obj, (0, locj))\n        go = canvas(bgc, (10, w))\n        hoffs = randint(0, ow//2 + 1)\n        for k in range(10//oh+1):\n            go = paint(go, shift(plcd, (k*oh, k*hoffs)))\n        if len(palette(go[h:])) > 1:\n            break\n    gi = go[:h]\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_53b68214(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    while True:\n        # Randomly choose the height of the input grid between 2 and 6\n        h = unifint(diff_lb, diff_ub, (2, 6))\n        # Randomly choose the width of the input grid between 8 and 30\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        # Randomly select a background color from the available colors\n        bgc = choice(cols)\n        # Remove the background color from the list of available colors\n        remcols = remove(bgc, cols)\n        # Randomly choose the number of colors to use (excluding background) between 1 and 9\n        ncols = unifint(diff_lb, diff_ub, (1, 9))\n        # Randomly select the colors to be used in the pattern\n        ccols = sample(remcols, ncols)\n        # Randomly choose the height of the object between 1 and half the input height\n        oh = unifint(diff_lb, diff_ub, (1, h//2))\n        # Randomly choose the width of the object between 1 and half the input width minus 1\n        ow = unifint(diff_lb, diff_ub, (1, w//2-1))\n        # Create a set of all possible coordinates for the object\n        bounds = asindices(canvas(-1, (oh, ow)))\n        # Randomly choose the number of cells in the object\n        ncells = unifint(diff_lb, diff_ub, (1, oh * ow))\n        # Randomly select the cells that will form the object\n        obj = sample(totuple(bounds), ncells)\n        # Assign random colors from ccols to each cell in the object\n        obj = {(choice(ccols), ij) for ij in obj}\n        # Move the object to the top-left corner\n        obj = normalize(obj)\n        # Get the final dimensions of the object\n        oh, ow = shape(obj)\n        # Randomly choose the starting column for placing the object\n        locj = randint(0, w//2)\n        # Place the object at the chosen starting position\n        plcd = shift(obj, (0, locj))\n        # Create the output grid with the background color\n        go = canvas(bgc, (10, w))\n        # Randomly choose a horizontal offset for each repetition of the object\n        hoffs = randint(0, ow//2 + 1)\n        # Place repeated and shifted copies of the object on the output grid\n        for k in range(10//oh+1):\n            go = paint(go, shift(plcd, (k*oh, k*hoffs)))\n        # Ensure that the pattern continues beyond the input grid height\n        if len(palette(go[h:])) > 1:\n            break\n    # Create the input grid by taking the top h rows of the output grid\n    gi = go[:h]\n    # 50% chance to mirror the input and output grids horizontally\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "543a7ed5": {
    "original": "def generate_543a7ed5(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3, 4))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    ccols = sample(remcols, numc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        oh = randint(4, 8)\n        ow = randint(4, 8)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(ccols)\n        if bd.issubset(indss):\n            bdibd = backdrop(frozenset({(loci+1, locj+1), (loci + oh - 2, locj + ow - 2)}))\n            go = fill(go, col, bdibd)\n            go = fill(go, 3, box(bd))\n            gi = fill(gi, col, bdibd)\n            if oh > 5 and ow > 5 and randint(1, 10) != 1:\n                ulci, ulcj = ulcorner(bdibd)\n                lrci, lrcj = lrcorner(bdibd)\n                aa = randint(ulci + 1, lrci - 1)\n                aa = randint(ulci + 1, aa)\n                bb = randint(ulcj + 1, lrcj - 1)\n                bb = randint(ulcj + 1, bb)\n                cc = randint(aa, lrci - 1)\n                dd = randint(bb, lrcj - 1)\n                cc = randint(cc, lrci - 1)\n                dd = randint(dd, lrcj - 1)\n                ins = backdrop({(aa, bb), (cc, dd)})\n                go = fill(go, 4, ins)\n                gi = fill(gi, bgc, ins)\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_543a7ed5(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 3 and 4\n    cols = difference(interval(0, 10, 1), (3, 4))    \n    \n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose background color from available colors\n    bgc = choice(cols)\n    \n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine number of colors to use (1-7) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Randomly select colors to use\n    ccols = sample(remcols, numc)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine number of objects to place based on difficulty and grid size\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placements counter\n    succ = 0\n    \n    # Loop to place objects\n    while succ < num and tr <= maxtrials:\n        # Break if no more available indices\n        if len(indss) == 0:\n            break\n        \n        # Randomly determine object height (4-8)\n        oh = randint(4, 8)\n        \n        # Randomly determine object width (4-8)\n        ow = randint(4, 8)\n        \n        # Find valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose random starting position\n        loci, locj = choice(subs)\n        \n        # Define object as its top-left and bottom-right corners\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get all cells in the object's bounding box\n        bd = backdrop(obj)\n        \n        # Choose random color for the object\n        col = choice(ccols)\n        \n        # Check if object fits in available space\n        if bd.issubset(indss):\n            # Get inner bounding box (excluding border)\n            bdibd = backdrop(frozenset({(loci+1, locj+1), (loci + oh - 2, locj + ow - 2)}))\n            \n            # Fill output grid with chosen color in inner area\n            go = fill(go, col, bdibd)\n            \n            # Draw border (color 3) in output grid\n            go = fill(go, 3, box(bd))\n            \n            # Fill input grid with chosen color in inner area\n            gi = fill(gi, col, bdibd)\n            \n            # Randomly decide to add an inner rectangle (90% chance if object is large enough)\n            if oh > 5 and ow > 5 and randint(1, 10) != 1:\n                # Get corners of inner area\n                ulci, ulcj = ulcorner(bdibd)\n                lrci, lrcj = lrcorner(bdibd)\n                \n                # Randomly determine top-left corner of inner rectangle\n                aa = randint(ulci + 1, lrci - 1)\n                aa = randint(ulci + 1, aa)\n                bb = randint(ulcj + 1, lrcj - 1)\n                bb = randint(ulcj + 1, bb)\n                \n                # Randomly determine bottom-right corner of inner rectangle\n                cc = randint(aa, lrci - 1)\n                dd = randint(bb, lrcj - 1)\n                cc = randint(cc, lrci - 1)\n                dd = randint(dd, lrcj - 1)\n                \n                # Get all cells in the inner rectangle\n                ins = backdrop({(aa, bb), (cc, dd)})\n                \n                # Fill output grid with color 4 in inner rectangle\n                go = fill(go, 4, ins)\n                \n                # Fill input grid with background color in inner rectangle (effectively \"cutting out\" the inner part)\n                gi = fill(gi, bgc, ins)\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Remove used cells from available indices\n            indss = indss - bd\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "54d82841": {
    "original": "def generate_54d82841(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nshps = unifint(diff_lb, diff_ub, (1, w // 3))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    locs = interval(1, w - 1, 1)\n    for k in range(nshps):\n        if len(locs) == 0:\n            break\n        loc = choice(locs)\n        locs = remove(loc, locs)\n        locs = remove(loc + 1, locs)\n        locs = remove(loc - 1, locs)\n        locs = remove(loc + 2, locs)\n        locs = remove(loc - 2, locs)\n        loci = randint(1, h - 1)\n        col = choice(remcols)\n        ij = (loci, loc)\n        shp = neighbors(ij) - connect((loci + 1, loc - 1), (loci + 1, loc + 1))\n        gi = fill(gi, col, shp)\n        go = fill(go, col, shp)\n        go = fill(go, 4, {(h - 1, loc)})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_54d82841(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color indices 0-9, excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Randomly choose a height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly choose a width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of shapes to generate, between 1 and 1/3 of the width\n    nshps = unifint(diff_lb, diff_ub, (1, w // 3))\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Create a list of possible horizontal locations for shapes\n    locs = interval(1, w - 1, 1)\n    \n    # Loop to create the specified number of shapes\n    for k in range(nshps):\n        # Break if no more locations are available\n        if len(locs) == 0:\n            break\n        \n        # Choose a random horizontal location for the shape\n        loc = choice(locs)\n        \n        # Remove the chosen location and nearby locations from available spots\n        locs = remove(loc, locs)\n        locs = remove(loc + 1, locs)\n        locs = remove(loc - 1, locs)\n        locs = remove(loc + 2, locs)\n        locs = remove(loc - 2, locs)\n        \n        # Choose a random vertical location for the shape\n        loci = randint(1, h - 1)\n        \n        # Choose a random color for the shape from the remaining colors\n        col = choice(remcols)\n        \n        # Create a tuple of the shape's location\n        ij = (loci, loc)\n        \n        # Generate the shape: neighbors of the location minus a horizontal line below\n        shp = neighbors(ij) - connect((loci + 1, loc - 1), (loci + 1, loc + 1))\n        \n        # Fill the shape with the chosen color in the input grid\n        gi = fill(gi, col, shp)\n        \n        # Fill the shape with the chosen color in the output grid\n        go = fill(go, col, shp)\n        \n        # Add a dot of color 4 below the shape in the output grid\n        go = fill(go, 4, {(h - 1, loc)})\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "54d9e175": {
    "original": "def generate_54d9e175(diff_lb: float, diff_ub: float) -> dict:\n    cols = (0, 5)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nh = unifint(diff_lb, diff_ub, (1, 31 // (h + 1)))\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 31 // (w + 1)))\n    fullh = (h + 1) * nh - 1\n    fullw = (w + 1) * nw - 1\n    linc, bgc = sample(cols, 2)\n    gi = canvas(linc, (fullh, fullw))\n    go = canvas(linc, (fullh, fullw))\n    obj = asindices(canvas(bgc, (h, w)))\n    for a in range(nh):\n        for b in range(nw):\n            plcd = shift(obj, (a * (h + 1), b * (w + 1)))\n            icol = randint(1, 4)\n            ocol = icol + 5\n            gi = fill(gi, bgc, plcd)\n            go = fill(go, ocol, plcd)\n            dot = choice(totuple(plcd))\n            gi = fill(gi, icol, {dot})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_54d9e175(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of color values for lines and background\n    cols = (0, 5)\n    \n    # Randomly determine the height of each object based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly determine the width of each object based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Determine the number of objects vertically, ensuring they fit in a 30x30 grid\n    nh = unifint(diff_lb, diff_ub, (1, 31 // (h + 1)))\n    \n    # Determine the number of objects horizontally, ensuring at least 2 if only 1 row\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 31 // (w + 1)))\n    \n    # Calculate the full height of the grid, including spacing between objects\n    fullh = (h + 1) * nh - 1\n    \n    # Calculate the full width of the grid, including spacing between objects\n    fullw = (w + 1) * nw - 1\n    \n    # Randomly choose colors for lines and background from the cols tuple\n    linc, bgc = sample(cols, 2)\n    \n    # Create an input grid filled with the line color\n    gi = canvas(linc, (fullh, fullw))\n    \n    # Create an output grid filled with the line color\n    go = canvas(linc, (fullh, fullw))\n    \n    # Create a set of indices representing an object of size h x w\n    obj = asindices(canvas(bgc, (h, w)))\n    \n    # Iterate over each position where an object should be placed\n    for a in range(nh):\n        for b in range(nw):\n            # Shift the object to its correct position in the grid\n            plcd = shift(obj, (a * (h + 1), b * (w + 1)))\n            \n            # Choose a random input color between 1 and 4\n            icol = randint(1, 4)\n            \n            # Set the output color to be 5 more than the input color\n            ocol = icol + 5\n            \n            # Fill the input grid with the background color for this object\n            gi = fill(gi, bgc, plcd)\n            \n            # Fill the output grid with the output color for this object\n            go = fill(go, ocol, plcd)\n            \n            # Choose a random cell within the object\n            dot = choice(totuple(plcd))\n            \n            # Place a dot of the input color in the chosen cell of the input grid\n            gi = fill(gi, icol, {dot})\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "5521c0d9": {
    "original": "def generate_5521c0d9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    inds = interval(0, w, 1)\n    nobjs = unifint(diff_lb, diff_ub, (1, w//3))\n    speps = sample(inds, nobjs*2)\n    while 0 in speps or w - 1 in speps:\n        nobjs = unifint(diff_lb, diff_ub, (1, w//3))\n        speps = sample(inds, nobjs*2)\n    speps = sorted(speps)\n    starts = speps[::2]\n    ends = speps[1::2]\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, ncols)\n    forb = -1\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    forb = -1\n    for sp, ep in zip(starts, ends):\n        col = choice(remove(forb, ccols))\n        forb = col\n        hdev = unifint(diff_lb, diff_ub, (0, h//2))\n        hei = choice((hdev, h - hdev))\n        hei = min(max(1, hei), h - 1)\n        ulc = (h - hei, sp)\n        lrc = (h - 1, ep)\n        obj = backdrop(frozenset({ulc, lrc}))\n        gi = fill(gi, col, obj)\n        go = fill(go, col, shift(obj, (-hei, 0)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5521c0d9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (4, 30))  # Randomly choose a height between 4 and 30\n    w = unifint(diff_lb, diff_ub, (6, 30))  # Randomly choose a width between 6 and 30\n    inds = interval(0, w, 1)  # Create a range of indices from 0 to width-1\n    nobjs = unifint(diff_lb, diff_ub, (1, w//3))  # Randomly choose number of objects between 1 and 1/3 of width\n    speps = sample(inds, nobjs*2)  # Randomly sample start and end points for objects\n    while 0 in speps or w - 1 in speps:  # Ensure objects don't start or end at grid edges\n        nobjs = unifint(diff_lb, diff_ub, (1, w//3))  # Rechoose number of objects if condition not met\n        speps = sample(inds, nobjs*2)  # Resample start and end points\n    speps = sorted(speps)  # Sort the start and end points\n    starts = speps[::2]  # Extract start points (even indices)\n    ends = speps[1::2]  # Extract end points (odd indices)\n    bgc = choice(cols)  # Randomly choose a background color\n    remcols = remove(bgc, cols)  # Remove background color from available colors\n    ncols = unifint(diff_lb, diff_ub, (2, 9))  # Randomly choose number of colors to use (2-9)\n    ccols = sample(remcols, ncols)  # Randomly sample colors to use for objects\n    forb = -1  # Initialize forbidden color (ensures adjacent objects have different colors)\n    gi = canvas(bgc, (h, w))  # Create input grid with background color\n    go = canvas(bgc, (h, w))  # Create output grid with background color\n    forb = -1  # Reset forbidden color\n    for sp, ep in zip(starts, ends):  # For each object (defined by start and end points)\n        col = choice(remove(forb, ccols))  # Choose a color different from the previous object\n        forb = col  # Set this color as forbidden for the next object\n        hdev = unifint(diff_lb, diff_ub, (0, h//2))  # Randomly choose a height deviation\n        hei = choice((hdev, h - hdev))  # Randomly choose between upper or lower placement\n        hei = min(max(1, hei), h - 1)  # Ensure height is within grid bounds\n        ulc = (h - hei, sp)  # Calculate upper-left corner of object\n        lrc = (h - 1, ep)  # Calculate lower-right corner of object\n        obj = backdrop(frozenset({ulc, lrc}))  # Create object as rectangle defined by corners\n        gi = fill(gi, col, obj)  # Fill object area in input grid with chosen color\n        go = fill(go, col, shift(obj, (-hei, 0)))  # Fill shifted object area in output grid\n    rotf = choice((identity, rot90, rot180, rot270))  # Randomly choose a rotation function\n    gi = rotf(gi)  # Apply chosen rotation to input grid\n    go = rotf(go)  # Apply same rotation to output grid\n    return {'input': gi, 'output': go}  # Return input and output grids as dictionary\n"
  },
  "5582e5ca": {
    "original": "def generate_5582e5ca(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    numc = unifint(diff_lb, diff_ub, (2, min(10, h * w - 1)))\n    ccols = sample(colopts, numc)\n    mostc = ccols[0]\n    remcols = ccols[1:]\n    leastnummostcol = (h * w) // numc + 1\n    maxnummostcol = h * w - numc + 1\n    nummostcold = unifint(diff_lb, diff_ub, (0, maxnummostcol - leastnummostcol))\n    nummostcol = min(max(leastnummostcol, maxnummostcol - nummostcold), maxnummostcol)\n    kk = len(remcols)\n    remcount = h * w - nummostcol - kk\n    remcounts = [1 for k in range(kk)]\n    for j in range(remcount):\n        cands = [idx for idx, c in enumerate(remcounts) if c < nummostcol - 1]\n        if len(cands) == 0:\n            break\n        idx = choice(cands)\n        remcounts[idx] += 1\n    nummostcol = h * w - sum(remcounts)\n    gi = canvas(-1, (h, w))\n    inds = asindices(gi)\n    mclocs = sample(totuple(inds), nummostcol)\n    gi = fill(gi, mostc, mclocs)\n    go = canvas(mostc, (h, w))\n    inds = inds - set(mclocs)\n    for col, count in zip(remcols, remcounts):\n        locs = sample(totuple(inds), count)\n        inds = inds - set(locs)\n        gi = fill(gi, col, locs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5582e5ca(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the number of colors to use, between 2 and min(10, h*w-1)\n    numc = unifint(diff_lb, diff_ub, (2, min(10, h * w - 1)))\n    \n    # Randomly select 'numc' colors from the color options\n    ccols = sample(colopts, numc)\n    \n    # Set the most common color as the first color in the list\n    mostc = ccols[0]\n    \n    # Set the remaining colors\n    remcols = ccols[1:]\n    \n    # Calculate the minimum number of cells for the most common color\n    leastnummostcol = (h * w) // numc + 1\n    \n    # Calculate the maximum number of cells for the most common color\n    maxnummostcol = h * w - numc + 1\n    \n    # Randomly determine a difficulty factor for the number of most common color cells\n    nummostcold = unifint(diff_lb, diff_ub, (0, maxnummostcol - leastnummostcol))\n    \n    # Calculate the actual number of cells for the most common color\n    nummostcol = min(max(leastnummostcol, maxnummostcol - nummostcold), maxnummostcol)\n    \n    # Get the number of remaining colors\n    kk = len(remcols)\n    \n    # Calculate the number of cells for the remaining colors\n    remcount = h * w - nummostcol - kk\n    \n    # Initialize counts for remaining colors to 1\n    remcounts = [1 for k in range(kk)]\n    \n    # Distribute remaining cells among the remaining colors\n    for j in range(remcount):\n        # Find colors that can still receive more cells\n        cands = [idx for idx, c in enumerate(remcounts) if c < nummostcol - 1]\n        # If no candidates, break the loop\n        if len(cands) == 0:\n            break\n        # Randomly choose a color and increment its count\n        idx = choice(cands)\n        remcounts[idx] += 1\n    \n    # Recalculate the number of cells for the most common color\n    nummostcol = h * w - sum(remcounts)\n    \n    # Create an initial input grid filled with -1\n    gi = canvas(-1, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly select locations for the most common color\n    mclocs = sample(totuple(inds), nummostcol)\n    \n    # Fill the input grid with the most common color at selected locations\n    gi = fill(gi, mostc, mclocs)\n    \n    # Create the output grid filled entirely with the most common color\n    go = canvas(mostc, (h, w))\n    \n    # Remove the locations of the most common color from available indices\n    inds = inds - set(mclocs)\n    \n    # Fill the remaining locations with the other colors\n    for col, count in zip(remcols, remcounts):\n        # Randomly select locations for this color\n        locs = sample(totuple(inds), count)\n        # Remove these locations from available indices\n        inds = inds - set(locs)\n        # Fill the input grid with this color at selected locations\n        gi = fill(gi, col, locs)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "5614dbcf": {
    "original": "def generate_5614dbcf(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (2, 10)\n    col_card_bounds = (1, 8)\n    noise_card_bounds = (0, 8)\n    colopts = remove(5, interval(1, 10, 1))\n    noisedindscands = totuple(asindices(canvas(0, (3, 3))))\n    d = unifint(diff_lb, diff_ub, dim_bounds)\n    cells_card_bounds = (1, d * d)\n    go = canvas(0, (d, d))\n    inds = totuple(asindices(go))\n    numocc = unifint(diff_lb, diff_ub, cells_card_bounds)\n    numcol = unifint(diff_lb, diff_ub, col_card_bounds)\n    occs = sample(inds, numocc)\n    colset = sample(colopts, numcol)\n    gi = upscale(go, THREE)\n    for occ in inds:\n        offset = multiply(3, occ)\n        numnoise = unifint(diff_lb, diff_ub, noise_card_bounds)\n        noise = sample(noisedindscands, numnoise)\n        if occ in occs:\n            col = choice(colset)\n            go = fill(go, col, initset(occ))\n            gi = fill(gi, col, shift(noisedindscands, offset))\n        gi = fill(gi, 5, shift(noise, offset))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5614dbcf(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions (2x2 to 10x10)\n    dim_bounds = (2, 10)\n    # Define bounds for number of colors (1 to 8)\n    col_card_bounds = (1, 8)\n    # Define bounds for number of noise cells (0 to 8)\n    noise_card_bounds = (0, 8)\n    # Create a tuple of color options (1-4, 6-9), excluding 5\n    colopts = remove(5, interval(1, 10, 1))\n    # Create a tuple of all possible indices in a 3x3 grid\n    noisedindscands = totuple(asindices(canvas(0, (3, 3))))\n    # Randomly determine the grid dimension based on difficulty\n    d = unifint(diff_lb, diff_ub, dim_bounds)\n    # Define bounds for number of colored cells (1 to d^2)\n    cells_card_bounds = (1, d * d)\n    # Create an empty output grid of size dxd\n    go = canvas(0, (d, d))\n    # Create a tuple of all indices in the output grid\n    inds = totuple(asindices(go))\n    # Randomly determine the number of colored cells based on difficulty\n    numocc = unifint(diff_lb, diff_ub, cells_card_bounds)\n    # Randomly determine the number of colors to use based on difficulty\n    numcol = unifint(diff_lb, diff_ub, col_card_bounds)\n    # Randomly select indices for colored cells\n    occs = sample(inds, numocc)\n    # Randomly select colors to use\n    colset = sample(colopts, numcol)\n    # Create an empty input grid, 3 times larger than the output grid\n    gi = upscale(go, THREE)\n\n    # Iterate through each cell in the output grid\n    for occ in inds:\n        # Calculate the corresponding top-left corner in the input grid\n        offset = multiply(3, occ)\n        # Randomly determine the number of noise cells for this 3x3 block\n        numnoise = unifint(diff_lb, diff_ub, noise_card_bounds)\n        # Randomly select indices for noise within the 3x3 block\n        noise = sample(noisedindscands, numnoise)\n        \n        # If this cell should be colored in the output\n        if occ in occs:\n            # Randomly choose a color\n            col = choice(colset)\n            # Color the cell in the output grid\n            go = fill(go, col, initset(occ))\n            # Color the entire 3x3 block in the input grid\n            gi = fill(gi, col, shift(noisedindscands, offset))\n        \n        # Add noise (color 5) to the selected noise cells in the input grid\n        gi = fill(gi, 5, shift(noise, offset))\n\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "56dc2b01": {
    "original": "def generate_56dc2b01(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 8))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    oh = unifint(diff_lb, diff_ub, (1, h))\n    ow = unifint(diff_lb, diff_ub, (1, (w - 1) // 2 - 1))\n    bb = asindices(canvas(-1, (oh, ow)))\n    sp = choice(totuple(bb))\n    obj = {sp}\n    bb = remove(sp, bb)\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(0, ncells), oh * ow - 1)\n    for k in range(ncells):\n        obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    loci = randint(0, h - oh)\n    locj = unifint(diff_lb, diff_ub, (1, w - ow))\n    bgc, objc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    barlocji = unifint(diff_lb, diff_ub, (0, locj))\n    barlocj = locj - barlocji\n    barlocj = min(max(0, barlocj), locj - 1)\n    gi = fill(gi, 2, connect((0, barlocj), (h - 1, barlocj)))\n    go = fill(gi, objc, shift(obj, (loci, barlocj + 1)))\n    go = fill(go, 8, connect((0, barlocj + ow + 1), (h - 1, barlocj + ow + 1)))\n    gi = fill(gi, objc, shift(obj, (loci, locj)))\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_56dc2b01(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 2 and 8\n    cols = difference(interval(0, 10, 1), (2, 8))\n    \n    # Generate random height between 4 and 30\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate random width between 6 and 30\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random object height between 1 and h\n    oh = unifint(diff_lb, diff_ub, (1, h))\n    # Generate random object width between 1 and half of the grid width minus 1\n    ow = unifint(diff_lb, diff_ub, (1, (w - 1) // 2 - 1))\n    \n    # Create a set of indices for a canvas of size oh x ow\n    bb = asindices(canvas(-1, (oh, ow)))\n    # Choose a random starting point for the object\n    sp = choice(totuple(bb))\n    # Initialize the object with the starting point\n    obj = {sp}\n    # Remove the starting point from the available indices\n    bb = remove(sp, bb)\n    \n    # Determine a random number of cells to add to the object\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(0, ncells), oh * ow - 1)\n    \n    # Grow the object by adding neighboring cells\n    for k in range(ncells):\n        obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))\n    \n    # Normalize the object (move it to the origin)\n    obj = normalize(obj)\n    # Get the final shape of the object\n    oh, ow = shape(obj)\n    \n    # Choose a random vertical position for the object\n    loci = randint(0, h - oh)\n    # Choose a random horizontal position for the object\n    locj = unifint(diff_lb, diff_ub, (1, w - ow))\n    \n    # Choose background and object colors\n    bgc, objc = sample(cols, 2)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the position of the vertical bar\n    barlocji = unifint(diff_lb, diff_ub, (0, locj))\n    barlocj = locj - barlocji\n    barlocj = min(max(0, barlocj), locj - 1)\n    \n    # Add the first vertical bar (color 2) to the input grid\n    gi = fill(gi, 2, connect((0, barlocj), (h - 1, barlocj)))\n    \n    # Create the output grid: add the object to the right of the first bar\n    go = fill(gi, objc, shift(obj, (loci, barlocj + 1)))\n    # Add the second vertical bar (color 8) to the output grid\n    go = fill(go, 8, connect((0, barlocj + ow + 1), (h - 1, barlocj + ow + 1)))\n    \n    # Add the object to the input grid at its original position\n    gi = fill(gi, objc, shift(obj, (loci, locj)))\n    \n    # Define possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "56ff96f3": {
    "original": "def generate_56ff96f3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            if choice((True, False)):\n                cnrs = ((loci, locj), (loci + oh - 1, locj + ow - 1))\n            else:\n                cnrs = ((loci + oh - 1, locj), (loci, locj + ow - 1))\n            gi = fill(gi, col, cnrs)\n            go = fill(go, col, bd)\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_56ff96f3(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Determine a random number of objects to place (1-9) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    # Initialize trial counter\n    tr = 0\n    # Initialize successful placements counter\n    succ = 0\n    # Loop until all objects are placed or max trials reached\n    while succ < num and tr <= maxtrials:\n        # Break if no colors or indices left\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        # Generate random object height (2-7)\n        oh = randint(2, 7)\n        # Generate random object width (2-7)\n        ow = randint(2, 7)\n        # Filter valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        # If no valid positions, increment trial and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        # Choose a random starting position for the object\n        loci, locj = choice(subs)\n        # Define the object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get all cells within the object's bounding box\n        bd = backdrop(obj)\n        # Choose a random color for the object\n        col = choice(remcols)\n        # Check if the object fits within the available space\n        if bd.issubset(indss):\n            # Remove the chosen color from available colors\n            remcols = remove(col, remcols)\n            # Randomly decide whether to draw diagonal or anti-diagonal\n            if choice((True, False)):\n                # Set corners for diagonal\n                cnrs = ((loci, locj), (loci + oh - 1, locj + ow - 1))\n            else:\n                # Set corners for anti-diagonal\n                cnrs = ((loci + oh - 1, locj), (loci, locj + ow - 1))\n            # Draw the diagonal/anti-diagonal on the input grid\n            gi = fill(gi, col, cnrs)\n            # Fill the entire bounding box on the output grid\n            go = fill(go, col, bd)\n            # Increment successful placements counter\n            succ += 1\n            # Remove used cells from available indices\n            indss = indss - bd\n        # Increment trial counter\n        tr += 1\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "57aa92db": {
    "original": "def generate_57aa92db(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = randint(2, 5)\n    ow = randint(2, 5)\n    bounds = asindices(canvas(-1, (oh, ow)))\n    obj = {choice(totuple(bounds))}\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(3, ncells), oh * ow)\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    fixp = choice(totuple(obj))\n    bgc, fixc, mainc = sample(cols, 3)\n    remcols = difference(cols, (bgc, fixc, mainc))\n    gi = canvas(bgc, (h, w))\n    obj = {(fixc, fixp)} | recolor(mainc, remove(fixp, obj))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    plcd = shift(obj, (loci, locj))\n    gi = paint(gi, plcd)\n    go = tuple(e for e in gi)\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))\n    nocc = unifint(diff_lb, diff_ub, (1, (h * w) // (4 * len(obj))))\n    tr = 0\n    succ = 0\n    maxtr = 5 * nocc\n    while succ < nocc and tr < maxtr:\n        tr += 1\n        fac = randint(1, 4)\n        objups = upscale(obj, fac)\n        hh, ww = shape(objups)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        objupsplcd = shift(objups, loc)\n        objupsplcdi = toindices(objupsplcd)\n        if objupsplcdi.issubset(inds):\n            succ += 1\n            newc = choice(remcols)\n            fixp2 = sfilter(objupsplcd, lambda cij: cij[0] == fixc)\n            inds = inds - mapply(neighbors, objupsplcdi)\n            gi = paint(gi, fixp2)\n            go = paint(go, fixp2)\n            remobjfull = toindices(objupsplcd - fixp2)\n            ntorem = unifint(diff_lb, diff_ub, (0, max(0, len(remobjfull) - 1)))\n            ntokeep = len(remobjfull) - ntorem\n            tokeep = {choice(totuple(remobjfull & outbox(fixp2)))}\n            fixp2i = toindices(fixp2)\n            for k in range(ntokeep - 1):\n                fullopts = remobjfull & mapply(neighbors, tokeep | fixp2i)\n                remopts = fullopts - tokeep\n                tokeep.add(choice(totuple(remopts)))\n            gi = fill(gi, newc, tokeep)\n            go = fill(go, newc, remobjfull)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_57aa92db(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors (0 to 9)\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid (between 10 and 30)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid (between 10 and 30)\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Set a random height for the object (between 2 and 5)\n    oh = randint(2, 5)\n    \n    # Set a random width for the object (between 2 and 5)\n    ow = randint(2, 5)\n    \n    # Create a set of all possible coordinates for the object\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Choose a random starting point for the object\n    obj = {choice(totuple(bounds))}\n    \n    # Determine a random number of cells to add to the object\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(3, ncells), oh * ow)\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    \n    # Normalize the object's position (move it to the top-left corner)\n    obj = normalize(obj)\n    \n    # Get the final shape of the object\n    oh, ow = shape(obj)\n    \n    # Choose a fixed point in the object\n    fixp = choice(totuple(obj))\n    \n    # Select three different colors for background, fixed point, and main object\n    bgc, fixc, mainc = sample(cols, 3)\n    \n    # Get the remaining colors\n    remcols = difference(cols, (bgc, fixc, mainc))\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Color the object: fixed point with fixc, rest with mainc\n    obj = {(fixc, fixp)} | recolor(mainc, remove(fixp, obj))\n    \n    # Choose a random location to place the object\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Shift the object to its new location\n    plcd = shift(obj, (loci, locj))\n    \n    # Paint the object onto the input grid\n    gi = paint(gi, plcd)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Find all background cells not adjacent to the object\n    inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))\n    \n    # Determine how many additional objects to add\n    nocc = unifint(diff_lb, diff_ub, (1, (h * w) // (4 * len(obj))))\n    \n    # Initialize counters for attempts and successes\n    tr = 0\n    succ = 0\n    maxtr = 5 * nocc\n    \n    # Add additional objects\n    while succ < nocc and tr < maxtr:\n        tr += 1\n        # Choose a random upscale factor\n        fac = randint(1, 4)\n        # Upscale the original object\n        objups = upscale(obj, fac)\n        hh, ww = shape(objups)\n        # Find valid positions to place the upscaled object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)\n        if len(cands) == 0:\n            continue\n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        # Shift the upscaled object to the chosen position\n        objupsplcd = shift(objups, loc)\n        objupsplcdi = toindices(objupsplcd)\n        # If the object fits, add it to the grids\n        if objupsplcdi.issubset(inds):\n            succ += 1\n            # Choose a new color for this object\n            newc = choice(remcols)\n            # Find the fixed point in the upscaled object\n            fixp2 = sfilter(objupsplcd, lambda cij: cij[0] == fixc)\n            # Update available positions\n            inds = inds - mapply(neighbors, objupsplcdi)\n            # Paint the fixed point on both input and output grids\n            gi = paint(gi, fixp2)\n            go = paint(go, fixp2)\n            # Get all non-fixed cells of the upscaled object\n            remobjfull = toindices(objupsplcd - fixp2)\n            # Determine how many cells to remove\n            ntorem = unifint(diff_lb, diff_ub, (0, max(0, len(remobjfull) - 1)))\n            ntokeep = len(remobjfull) - ntorem\n            # Choose cells to keep, starting with one on the border\n            tokeep = {choice(totuple(remobjfull & outbox(fixp2)))}\n            fixp2i = toindices(fixp2)\n            for k in range(ntokeep - 1):\n                fullopts = remobjfull & mapply(neighbors, tokeep | fixp2i)\n                remopts = fullopts - tokeep\n                tokeep.add(choice(totuple(remopts)))\n            # Paint the kept cells on the input grid\n            gi = fill(gi, newc, tokeep)\n            # Paint all non-fixed cells on the output grid\n            go = fill(go, newc, remobjfull)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "5ad4f10b": {
    "original": "def generate_5ad4f10b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    nbh = {(0, 0), (1, 0), (0, 1), (1, 1)}\n    nbhs = apply(lbind(shift, nbh), {(0, 0), (-1, 0), (0, -1), (-1, -1)})\n    oh = unifint(diff_lb, diff_ub, (2, 6))\n    ow = unifint(diff_lb, diff_ub, (2, 6))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(1, ncells), oh * ow - 1)\n    obj = set(sample(totuple(bounds), ncells))\n    while len(sfilter(obj, lambda ij: sum([len(obj & shift(nbh, ij)) < 4 for nbh in nbhs]) > 0)) == 0:\n        ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        ncells = min(max(1, ncells), oh * ow)\n        obj = set(sample(totuple(bounds), ncells))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    bgc, noisec, objc = sample(cols, 3)\n    go = canvas(bgc, (oh, ow))\n    go = fill(go, noisec, obj)\n    fac = unifint(diff_lb, diff_ub, (2, min(28//oh, 28//ow)))\n    gobj = asobject(upscale(replace(go, noisec, objc), fac))\n    oh, ow = shape(gobj)\n    h = unifint(diff_lb, diff_ub, (oh+2, 30))\n    w = unifint(diff_lb, diff_ub, (ow+2, 30))\n    loci = randint(1, h - oh-1)\n    locj = randint(1, w - ow-1)\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, shift(gobj, (loci, locj)))\n    cands = ofcolor(gi, bgc)\n    namt = unifint(diff_lb, diff_ub, (2, max(1, len(cands) // 4)))\n    noise = sample(totuple(cands), namt)\n    gi = fill(gi, noisec, noise)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5ad4f10b(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a 2x2 neighborhood\n    nbh = {(0, 0), (1, 0), (0, 1), (1, 1)}\n    \n    # Create four shifted versions of the neighborhood\n    nbhs = apply(lbind(shift, nbh), {(0, 0), (-1, 0), (0, -1), (-1, -1)})\n    \n    # Randomly determine the height of the original object (2 to 6)\n    oh = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Randomly determine the width of the original object (2 to 6)\n    ow = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Create a set of all possible coordinates in the original object\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Randomly determine the number of cells in the object (1 to half the area)\n    ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n    \n    # Randomly choose between ncellsd and its complement\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    \n    # Ensure ncells is between 1 and one less than the total area\n    ncells = min(max(1, ncells), oh * ow - 1)\n    \n    # Randomly select cells to form the object\n    obj = set(sample(totuple(bounds), ncells))\n    \n    # Ensure the object has at least one cell with an incomplete neighborhood\n    while len(sfilter(obj, lambda ij: sum([len(obj & shift(nbh, ij)) < 4 for nbh in nbhs]) > 0)) == 0:\n        # If not, regenerate the object\n        ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        ncells = min(max(1, ncells), oh * ow)\n        obj = set(sample(totuple(bounds), ncells))\n    \n    # Normalize the object's position (move to top-left corner)\n    obj = normalize(obj)\n    \n    # Get the actual shape of the normalized object\n    oh, ow = shape(obj)\n    \n    # Randomly select three distinct colors for background, noise, and object\n    bgc, noisec, objc = sample(cols, 3)\n    \n    # Create a grid with the background color\n    go = canvas(bgc, (oh, ow))\n    \n    # Fill the object cells with the noise color\n    go = fill(go, noisec, obj)\n    \n    # Randomly determine the upscaling factor (2 to 28/max(oh,ow))\n    fac = unifint(diff_lb, diff_ub, (2, min(28//oh, 28//ow)))\n    \n    # Upscale the grid and convert noise color to object color\n    gobj = asobject(upscale(replace(go, noisec, objc), fac))\n    \n    # Get the shape of the upscaled object\n    oh, ow = shape(gobj)\n    \n    # Randomly determine the height of the input grid (object height + 2 to 30)\n    h = unifint(diff_lb, diff_ub, (oh+2, 30))\n    \n    # Randomly determine the width of the input grid (object width + 2 to 30)\n    w = unifint(diff_lb, diff_ub, (ow+2, 30))\n    \n    # Randomly determine the vertical position of the object in the input grid\n    loci = randint(1, h - oh-1)\n    \n    # Randomly determine the horizontal position of the object in the input grid\n    locj = randint(1, w - ow-1)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Paint the upscaled object onto the input grid at the chosen location\n    gi = paint(gi, shift(gobj, (loci, locj)))\n    \n    # Find all background color cells in the input grid\n    cands = ofcolor(gi, bgc)\n    \n    # Randomly determine the number of noise cells (2 to 1/4 of background cells)\n    namt = unifint(diff_lb, diff_ub, (2, max(1, len(cands) // 4)))\n    \n    # Randomly select cells for noise\n    noise = sample(totuple(cands), namt)\n    \n    # Add noise to the input grid\n    gi = fill(gi, noisec, noise)\n    \n    # Return a dictionary with the input grid and the original small grid as output\n    return {'input': gi, 'output': go}\n"
  },
  "5bd6f4ac": {
    "original": "def generate_5bd6f4ac(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = rot90(crop(rot270(gi), (0, 0), (3, 3)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5bd6f4ac(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 4 and 30\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid between 4 and 30\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose a background color from the color range\n    bgc = choice(cols)\n    \n    # Create a grid (canvas) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the color range to get remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (between 0 and 9, or less if grid is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly choose colors from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose indices to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid:\n    # 1. Rotate the input grid 270 degrees (counterclockwise)\n    # 2. Crop a 3x3 section from the top-left corner\n    # 3. Rotate the cropped section 90 degrees (clockwise)\n    go = rot90(crop(rot270(gi), (0, 0), (3, 3)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "5c0a986e": {
    "original": "def generate_5c0a986e(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))    \n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    tr = 0\n    maxtr = 5 * nobjs\n    succ = 0\n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        cands = sfilter(inds, lambda ij: 0 < ij[0] <= h - 3 and 0 < ij[1] <= w - 3)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        col = choice((1, 2))\n        sq = {(loc), add(loc, (0, 1)), add(loc, (1, 0)), add(loc, (1, 1))}\n        if col == 1:\n            obj = sq | (shoot(loc, (-1, -1)) & fullinds)\n        else:\n            obj = sq | (shoot(loc, (1, 1)) & fullinds)\n        if obj.issubset(inds):\n            succ += 1\n            inds = (inds - obj) - mapply(dneighbors, sq)\n            gi = fill(gi, col, sq)\n            go = fill(go, col, obj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5c0a986e(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))    \n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly choose background color from available colors\n    bgc = choice(cols)\n    # Determine number of objects to place based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))\n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    # Initialize trial counter\n    tr = 0\n    # Set maximum number of trials based on number of objects\n    maxtr = 5 * nobjs\n    # Initialize success counter for placed objects\n    succ = 0\n    # Get all indices of the input grid\n    inds = asindices(gi)\n    # Store all indices of the grid for later use\n    fullinds = asindices(gi)\n    \n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        # Increment trial counter\n        tr += 1\n        # Filter valid locations for placing objects (not too close to edges)\n        cands = sfilter(inds, lambda ij: 0 < ij[0] <= h - 3 and 0 < ij[1] <= w - 3)\n        # Break if no valid locations are left\n        if len(cands) == 0:\n            break\n        # Choose a random location from valid candidates\n        loc = choice(totuple(cands))\n        # Randomly choose color (1 or 2) for the object\n        col = choice((1, 2))\n        # Define a 2x2 square at the chosen location\n        sq = {(loc), add(loc, (0, 1)), add(loc, (1, 0)), add(loc, (1, 1))}\n        \n        # For color 1, extend object diagonally up-left\n        if col == 1:\n            obj = sq | (shoot(loc, (-1, -1)) & fullinds)\n        # For color 2, extend object diagonally down-right\n        else:\n            obj = sq | (shoot(loc, (1, 1)) & fullinds)\n        \n        # Check if the object can be placed without overlapping\n        if obj.issubset(inds):\n            # Increment success counter\n            succ += 1\n            # Remove object and its neighbors from available indices\n            inds = (inds - obj) - mapply(dneighbors, sq)\n            # Place the 2x2 square on the input grid\n            gi = fill(gi, col, sq)\n            # Place the full object (square + diagonal) on the output grid\n            go = fill(go, col, obj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "5c2c9af4": {
    "original": "def generate_5c2c9af4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    boxhd = unifint(diff_lb, diff_ub, (0, h // 2))\n    boxwd = unifint(diff_lb, diff_ub, (0, w // 2))\n    boxh = choice((boxhd, h - boxhd))\n    boxw = choice((boxwd, w - boxwd))\n    if boxh % 2 == 0:\n        boxh = choice((boxh - 1, boxh + 1))\n    if boxw % 2 == 0:\n        boxw = choice((boxw - 1, boxw + 1))\n    boxh = min(max(1, boxh), h if h % 2 == 1 else h - 1)\n    boxw = min(max(1, boxw), w if w % 2 == 1 else w - 1)\n    boxshap = (boxh, boxw)\n    loci = randint(0, h - boxh)\n    locj = randint(0, w - boxw)\n    loc = (loci, locj)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    cpi = loci + boxh // 2\n    cpj = locj + boxw // 2\n    cp = (cpi, cpj)\n    A = (loci, locj)\n    B = (loci + boxh - 1, locj + boxw - 1)\n    gi = fill(c, fgc, {A, B, cp})\n    go = fill(c, fgc, {A, B, cp})\n    cond = True\n    ooo = {A, B, cp}\n    if hline(ooo) and len(ooo) == 3:\n        go = fill(go, fgc, hfrontier(cp))\n        cond = False\n    if vline(ooo) and len(ooo) == 3:\n        go = fill(go, fgc, vfrontier(cp))\n        cond = False\n    k = 1\n    while cond:\n        f1 = k * (boxh // 2)\n        f2 = k * (boxw // 2)\n        ulci = cpi - f1\n        ulcj = cpj - f2\n        lrci = cpi + f1\n        lrcj = cpj + f2\n        ulc = (ulci, ulcj)\n        lrc = (lrci, lrcj)\n        bx = box(frozenset({ulc, lrc}))\n        go2 = fill(go, fgc, bx)\n        cond = go != go2\n        go = go2\n        k += 1\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5c2c9af4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (5, 30))  # Generate a random height between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))  # Generate a random width between 5 and 30 based on difficulty\n    boxhd = unifint(diff_lb, diff_ub, (0, h // 2))  # Generate a random box height displacement\n    boxwd = unifint(diff_lb, diff_ub, (0, w // 2))  # Generate a random box width displacement\n    boxh = choice((boxhd, h - boxhd))  # Choose between top or bottom half for box height\n    boxw = choice((boxwd, w - boxwd))  # Choose between left or right half for box width\n    if boxh % 2 == 0:\n        boxh = choice((boxh - 1, boxh + 1))  # Ensure box height is odd by adjusting if even\n    if boxw % 2 == 0:\n        boxw = choice((boxw - 1, boxw + 1))  # Ensure box width is odd by adjusting if even\n    boxh = min(max(1, boxh), h if h % 2 == 1 else h - 1)  # Constrain box height within grid bounds\n    boxw = min(max(1, boxw), w if w % 2 == 1 else w - 1)  # Constrain box width within grid bounds\n    boxshap = (boxh, boxw)  # Create a tuple representing the box shape\n    loci = randint(0, h - boxh)  # Generate random vertical position for the box\n    locj = randint(0, w - boxw)  # Generate random horizontal position for the box\n    loc = (loci, locj)  # Create a tuple for the box's top-left corner position\n    bgc = choice(cols)  # Choose a random background color\n    remcols = remove(bgc, cols)  # Create a list of remaining colors (excluding background color)\n    fgc = choice(remcols)  # Choose a random foreground color from remaining colors\n    c = canvas(bgc, (h, w))  # Create a grid filled with the background color\n    cpi = loci + boxh // 2  # Calculate the vertical center point of the box\n    cpj = locj + boxw // 2  # Calculate the horizontal center point of the box\n    cp = (cpi, cpj)  # Create a tuple for the center point of the box\n    A = (loci, locj)  # Top-left corner of the box\n    B = (loci + boxh - 1, locj + boxw - 1)  # Bottom-right corner of the box\n    gi = fill(c, fgc, {A, B, cp})  # Create input grid with 3 points colored\n    go = fill(c, fgc, {A, B, cp})  # Initialize output grid same as input\n    cond = True  # Initialize condition for the following while loop\n    ooo = {A, B, cp}  # Create a set of the three colored points\n    if hline(ooo) and len(ooo) == 3:\n        go = fill(go, fgc, hfrontier(cp))  # If points form a horizontal line, fill entire row\n        cond = False  # Set condition to false to skip the while loop\n    if vline(ooo) and len(ooo) == 3:\n        go = fill(go, fgc, vfrontier(cp))  # If points form a vertical line, fill entire column\n        cond = False  # Set condition to false to skip the while loop\n    k = 1  # Initialize counter for the while loop\n    while cond:\n        f1 = k * (boxh // 2)  # Calculate vertical expansion factor\n        f2 = k * (boxw // 2)  # Calculate horizontal expansion factor\n        ulci = cpi - f1  # Calculate new top edge of the expanding box\n        ulcj = cpj - f2  # Calculate new left edge of the expanding box\n        lrci = cpi + f1  # Calculate new bottom edge of the expanding box\n        lrcj = cpj + f2  # Calculate new right edge of the expanding box\n        ulc = (ulci, ulcj)  # Create tuple for new top-left corner\n        lrc = (lrci, lrcj)  # Create tuple for new bottom-right corner\n        bx = box(frozenset({ulc, lrc}))  # Generate the outline of the new box\n        go2 = fill(go, fgc, bx)  # Fill the outline of the new box with foreground color\n        cond = go != go2  # Check if the grid has changed\n        go = go2  # Update the output grid\n        k += 1  # Increment the counter\n    if choice((True, False)):\n        gi = dmirror(gi)  # Randomly mirror the input grid diagonally\n        go = dmirror(go)  # Mirror the output grid diagonally to match\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "5daaa586": {
    "original": "def generate_5daaa586(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    loci1 = randint(1, h - 4)\n    locj1 = randint(1, w - 4)\n    loci1dev = unifint(diff_lb, diff_ub, (0, loci1 - 1))\n    locj1dev = unifint(diff_lb, diff_ub, (0, locj1 - 1))\n    loci1 -= loci1dev\n    locj1 -= locj1dev\n    loci2 = unifint(diff_lb, diff_ub, (loci1 + 2, h - 2))\n    locj2 = unifint(diff_lb, diff_ub, (locj1 + 2, w - 2))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c1, c2, c3, c4 = sample(remcols, 4)\n    f1 = recolor(c1, hfrontier(toivec(loci1)))\n    f2 = recolor(c2, hfrontier(toivec(loci2)))\n    f3 = recolor(c3, vfrontier(tojvec(locj1)))\n    f4 = recolor(c4, vfrontier(tojvec(locj2)))\n    gi = canvas(bgc, (h, w))\n    fronts = [f1, f2, f3, f4]\n    shuffle(fronts)\n    for fr in fronts:\n        gi = paint(gi, fr)\n    cands = totuple(ofcolor(gi, bgc))\n    nn = len(cands)\n    nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))\n    noise = sample(cands, nnoise)\n    gi = fill(gi, c1, noise)\n    while len(frontiers(gi)) > 4:\n        gi = fill(gi, bgc, noise)\n        nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))\n        noise = sample(cands, nnoise)\n        if len(set(noise) & ofcolor(gi, c1)) >= len(ofcolor(gi, bgc)):\n            break\n        gi = fill(gi, c1, noise)\n    go = crop(gi, (loci1, locj1), (loci2 - loci1 + 1, locj2 - locj1 + 1))\n    ns = ofcolor(go, c1)\n    go = fill(go, c1, mapply(rbind(shoot, (-1, 0)), ns))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_5daaa586(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 7 and 30\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the width of the grid between 7 and 30\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Choose a random row index for the first horizontal line, leaving space for another line below\n    loci1 = randint(1, h - 4)\n    \n    # Choose a random column index for the first vertical line, leaving space for another line to the right\n    locj1 = randint(1, w - 4)\n    \n    # Randomly adjust the first row index upwards\n    loci1dev = unifint(diff_lb, diff_ub, (0, loci1 - 1))\n    \n    # Randomly adjust the first column index leftwards\n    locj1dev = unifint(diff_lb, diff_ub, (0, locj1 - 1))\n    \n    # Apply the adjustments to the first row and column indices\n    loci1 -= loci1dev\n    locj1 -= locj1dev\n    \n    # Choose a random row index for the second horizontal line, ensuring it's below the first\n    loci2 = unifint(diff_lb, diff_ub, (loci1 + 2, h - 2))\n    \n    # Choose a random column index for the second vertical line, ensuring it's to the right of the first\n    locj2 = unifint(diff_lb, diff_ub, (locj1 + 2, w - 2))\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select 4 different colors for the lines\n    c1, c2, c3, c4 = sample(remcols, 4)\n    \n    # Create a horizontal line of color c1 at row loci1\n    f1 = recolor(c1, hfrontier(toivec(loci1)))\n    \n    # Create a horizontal line of color c2 at row loci2\n    f2 = recolor(c2, hfrontier(toivec(loci2)))\n    \n    # Create a vertical line of color c3 at column locj1\n    f3 = recolor(c3, vfrontier(tojvec(locj1)))\n    \n    # Create a vertical line of color c4 at column locj2\n    f4 = recolor(c4, vfrontier(tojvec(locj2)))\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Combine all four lines into a list\n    fronts = [f1, f2, f3, f4]\n    \n    # Randomly shuffle the order of the lines\n    shuffle(fronts)\n    \n    # Paint each line onto the grid\n    for fr in fronts:\n        gi = paint(gi, fr)\n    \n    # Find all background-colored cells in the grid\n    cands = totuple(ofcolor(gi, bgc))\n    \n    # Count the number of background-colored cells\n    nn = len(cands)\n    \n    # Determine the number of noise cells to add (between 1 and 1/3 of background cells)\n    nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))\n    \n    # Randomly select cells for noise\n    noise = sample(cands, nnoise)\n    \n    # Fill the selected noise cells with color c1\n    gi = fill(gi, c1, noise)\n    \n    # Continue adding noise until there are only 4 frontiers (lines) left\n    while len(frontiers(gi)) > 4:\n        # Reset noise cells to background color\n        gi = fill(gi, bgc, noise)\n        \n        # Determine a new number of noise cells\n        nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))\n        \n        # Select new cells for noise\n        noise = sample(cands, nnoise)\n        \n        # If more than half of the background cells would become noise, stop\n        if len(set(noise) & ofcolor(gi, c1)) >= len(ofcolor(gi, bgc)):\n            break\n        \n        # Fill the new noise cells with color c1\n        gi = fill(gi, c1, noise)\n    \n    # Crop the grid to create the output, focusing on the area between the lines\n    go = crop(gi, (loci1, locj1), (loci2 - loci1 + 1, locj2 - locj1 + 1))\n    \n    # Find all cells of color c1 in the output grid\n    ns = ofcolor(go, c1)\n    \n    # Extend color c1 upwards from each of its occurrences\n    go = fill(go, c1, mapply(rbind(shoot, (-1, 0)), ns))\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "60b61512": {
    "original": "def generate_60b61512(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(7, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        indsss = asindices(canvas(-1, (oh, ow)))\n        chch = choice(totuple(indsss))\n        obj = {chch}\n        indsss = remove(chch, indsss)\n        numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        numc = choice((numcd, oh * ow - numcd))\n        numc = min(max(2, numc), oh * ow - 1)\n        for k in range(numc):\n            obj.add(choice(totuple(indsss & mapply(neighbors, obj))))\n            indsss = indsss - obj\n        oh, ow = shape(obj)\n        obj = shift(obj, (loci, locj))\n        bd = backdrop(obj)\n        col = choice(ccols)\n        if bd.issubset(indss):\n            gi = fill(gi, col, obj)\n            go = fill(go, 7, bd)\n            go = fill(go, col, obj)\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_60b61512(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 7\n    cols = remove(7, interval(0, 10, 1))    \n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    # Create a list of remaining colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (1-8) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Calculate number of objects to place (1 to 5% of grid size) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    tr = 0  # Trial counter\n    succ = 0  # Successful placements counter\n    \n    # Main loop for placing objects\n    while succ < num and tr <= maxtrials:\n        # Break if no more available indices\n        if len(indss) == 0:\n            break\n        \n        # Generate random object height (2-7)\n        oh = randint(2, 7)\n        # Generate random object width (2-7)\n        ow = randint(2, 7)\n        \n        # Filter valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose random starting position for the object\n        loci, locj = choice(subs)\n        \n        # Generate indices for the object's bounding box\n        indsss = asindices(canvas(-1, (oh, ow)))\n        \n        # Choose a random starting cell for the object\n        chch = choice(totuple(indsss))\n        obj = {chch}\n        indsss = remove(chch, indsss)\n        \n        # Determine object size based on difficulty\n        numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        numc = choice((numcd, oh * ow - numcd))\n        numc = min(max(2, numc), oh * ow - 1)\n        \n        # Grow the object by adding neighboring cells\n        for k in range(numc):\n            obj.add(choice(totuple(indsss & mapply(neighbors, obj))))\n            indsss = indsss - obj\n        \n        # Get final object shape\n        oh, ow = shape(obj)\n        # Shift object to its position on the grid\n        obj = shift(obj, (loci, locj))\n        \n        # Get the backdrop (bounding box) of the object\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(ccols)\n        \n        # If the object fits in the available space\n        if bd.issubset(indss):\n            # Place the object on the input grid\n            gi = fill(gi, col, obj)\n            # Fill the object's bounding box with color 7 on the output grid\n            go = fill(go, 7, bd)\n            # Place the object on the output grid\n            go = fill(go, col, obj)\n            succ += 1  # Increment successful placements\n            # Remove used indices and their surroundings from available indices\n            indss = (indss - bd) - outbox(bd)\n        \n        tr += 1  # Increment trial counter\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6150a2bd": {
    "original": "def generate_6150a2bd(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = rot180(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6150a2bd(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Generate a random width between 1 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (between 0 and min(9, h*w)) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Create a tuple of all indices in the grid\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color (based on difficulty)\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose indices to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by rotating the input grid 180 degrees\n    go = rot180(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "623ea044": {
    "original": "def generate_623ea044(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    bgc = choice(colopts)\n    g = canvas(bgc, (h, w))\n    fullinds = asindices(g)\n    inds = totuple(asindices(g))\n    card_bounds = (0, max(int(h * w * 0.1), 1))\n    numdots = unifint(diff_lb, diff_ub, card_bounds)\n    dots = sample(inds, numdots)\n    gi = canvas(bgc, (h, w))\n    fgc = choice(remove(bgc, colopts))\n    gi = fill(gi, fgc, dots)\n    go = fill(gi, fgc, mapply(rbind(shoot, UP_RIGHT), dots))\n    go = fill(go, fgc, mapply(rbind(shoot, DOWN_LEFT), dots))\n    go = fill(go, fgc, mapply(rbind(shoot, UNITY), dots))\n    go = fill(go, fgc, mapply(rbind(shoot, NEG_UNITY), dots))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_623ea044(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Create a range of color options from 0 to 9\n    colopts = interval(0, 10, 1)\n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose a background color\n    bgc = choice(colopts)\n    # Create a grid filled with the background color\n    g = canvas(bgc, (h, w))\n    # Get all possible indices in the grid\n    fullinds = asindices(g)\n    # Convert indices to a tuple for sampling\n    inds = totuple(asindices(g))\n    # Define bounds for the number of dots based on grid size\n    card_bounds = (0, max(int(h * w * 0.1), 1))\n    # Randomly determine the number of dots based on difficulty\n    numdots = unifint(diff_lb, diff_ub, card_bounds)\n    # Randomly select positions for the dots\n    dots = sample(inds, numdots)\n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Choose a foreground color different from the background\n    fgc = choice(remove(bgc, colopts))\n    # Place the dots on the input grid\n    gi = fill(gi, fgc, dots)\n    # Create lines in the up-right direction from each dot\n    go = fill(gi, fgc, mapply(rbind(shoot, UP_RIGHT), dots))\n    # Add lines in the down-left direction from each dot\n    go = fill(go, fgc, mapply(rbind(shoot, DOWN_LEFT), dots))\n    # Add lines in the down-right direction from each dot\n    go = fill(go, fgc, mapply(rbind(shoot, UNITY), dots))\n    # Add lines in the up-left direction from each dot\n    go = fill(go, fgc, mapply(rbind(shoot, NEG_UNITY), dots))\n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "62c24649": {
    "original": "def generate_62c24649(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = vconcat(\n        hconcat(gi, vmirror(gi)),\n        hconcat(hmirror(gi), hmirror(vmirror(gi)))\n    )\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_62c24649(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 15 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a width between 1 and 15 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a grid (input) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Create a tuple of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (0 to 9, or less if grid is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select the colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Create a tuple of all indices in the input grid\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select the cells to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by:\n    go = vconcat(\n        hconcat(gi, vmirror(gi)),  # Concatenate input and its vertical mirror horizontally\n        hconcat(hmirror(gi), hmirror(vmirror(gi)))  # Concatenate horizontal mirror of input and its vertical mirror horizontally\n    )\n    # This creates a 2x2 grid where each quadrant is a variation of the input\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "63613498": {
    "original": "def generate_63613498(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, sepc = sample(cols, 2)\n    remcols = remove(bgc, remove(sepc, cols))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    objh = unifint(diff_lb, diff_ub, (1, h//3))\n    objw = unifint(diff_lb, diff_ub, (1, w//3))\n    bounds = asindices(canvas(-1, (objh, objw)))\n    sp = choice(totuple(bounds))\n    obj = {sp}\n    ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    gi = canvas(bgc, (h, w))\n    objc = choice(ccols)\n    gi = fill(gi, objc, obj)\n    sep = connect((objh+1, 0), (objh+1, objw+1)) | connect((0, objw+1), (objh+1, objw+1))\n    gi = fill(gi, sepc, sep)\n    inds = asindices(gi)\n    inds -= backdrop(sep)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    baseobj = normalize(obj)\n    obj = normalize(obj)\n    go = tuple(e for e in gi)\n    while (succ < nobjs and tr < maxtr) or succ == 0:\n        tr += 1\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds):\n            col = choice(ccols)\n            gi = fill(gi, col, plcd)\n            go = fill(go, sepc if succ == 0 else col, plcd)\n            succ += 1\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n        objh = randint(1, h // 3)\n        objw = randint(2 if objh == 1 else 1, w // 3)\n        if choice((True, False)):\n            objh, objw = objw, objh\n        bounds = asindices(canvas(-1, (objh, objw)))\n        sp = choice(totuple(bounds))\n        obj = {sp}\n        ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        obj = normalize(obj)\n        obj = set(obj)\n        if obj == baseobj:\n            if len(obj) < objh * objw:\n                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n            else:\n                obj = remove(choice(totuple(corners(obj))), obj)\n        obj = normalize(obj)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_63613498(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select two colors: one for background and one for separator\n    bgc, sepc = sample(cols, 2)\n    \n    # Remove background and separator colors from available colors\n    remcols = remove(bgc, remove(sepc, cols))\n    \n    # Randomly determine the number of colors to use (1 to 8)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors for objects\n    ccols = sample(remcols, ncols)\n    \n    # Randomly determine the height of objects (1 to 1/3 of grid height)\n    objh = unifint(diff_lb, diff_ub, (1, h//3))\n    \n    # Randomly determine the width of objects (1 to 1/3 of grid width)\n    objw = unifint(diff_lb, diff_ub, (1, w//3))\n    \n    # Create a set of all possible coordinates within the object dimensions\n    bounds = asindices(canvas(-1, (objh, objw)))\n    \n    # Randomly select a starting point for the object\n    sp = choice(totuple(bounds))\n    \n    # Initialize the object with the starting point\n    obj = {sp}\n    \n    # Randomly determine the number of cells in the object\n    ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))\n    \n    # Add cells to the object, ensuring they're connected\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    \n    # Create the initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly select a color for the first object\n    objc = choice(ccols)\n    \n    # Place the first object on the grid\n    gi = fill(gi, objc, obj)\n    \n    # Create a separator line\n    sep = connect((objh+1, 0), (objh+1, objw+1)) | connect((0, objw+1), (objh+1, objw+1))\n    \n    # Add the separator to the grid\n    gi = fill(gi, sepc, sep)\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Remove the separator area from available indices\n    inds -= backdrop(sep)\n    \n    # Randomly determine the number of objects to place (1 to 1/20 of grid area)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    \n    # Store the original object shape\n    baseobj = normalize(obj)\n    \n    # Normalize the current object\n    obj = normalize(obj)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Main loop for placing objects\n    while (succ < nobjs and tr < maxtr) or succ == 0:\n        tr += 1\n        oh, ow = shape(obj)\n        \n        # Find valid positions to place the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # Break if no valid positions are left\n        if len(cands) == 0:\n            break\n        \n        # Choose a random position for the object\n        loc = choice(totuple(cands))\n        \n        # Shift the object to the chosen position\n        plcd = shift(obj, loc)\n        \n        # If the object fits in the available space\n        if plcd.issubset(inds):\n            # Choose a random color for the object\n            col = choice(ccols)\n            \n            # Place the object on the input grid\n            gi = fill(gi, col, plcd)\n            \n            # Place the object on the output grid (with separator color for first object)\n            go = fill(go, sepc if succ == 0 else col, plcd)\n            \n            succ += 1\n            \n            # Update available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n        \n        # Randomly generate new object dimensions\n        objh = randint(1, h // 3)\n        objw = randint(2 if objh == 1 else 1, w // 3)\n        \n        # Randomly swap height and width\n        if choice((True, False)):\n            objh, objw = objw, objh\n        \n        # Create new bounds for the object\n        bounds = asindices(canvas(-1, (objh, objw)))\n        \n        # Choose a new starting point\n        sp = choice(totuple(bounds))\n        \n        # Initialize new object\n        obj = {sp}\n        \n        # Determine number of cells for the new object\n        ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))\n        \n        # Add cells to the new object\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        \n        # Normalize the new object\n        obj = normalize(obj)\n        obj = set(obj)\n        \n        # If the new object is identical to the base object, modify it slightly\n        if obj == baseobj:\n            if len(obj) < objh * objw:\n                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n            else:\n                obj = remove(choice(totuple(corners(obj))), obj)\n        \n        # Normalize the object again\n        obj = normalize(obj)\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6430c8c4": {
    "original": "def generate_6430c8c4(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    bar = canvas(linc, (h, 1))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(hconcat(A, bar), B)\n    res = (set(inds) - set(aset)) - set(bset)\n    go = fill(c, 3, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6430c8c4(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (2-30)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid (2-14)\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the separating line\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a color for set A\n    acol = choice(remcols)\n    \n    # Remove color A from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a color for set B\n    bcol = choice(remcols)\n    \n    # Create a canvas (grid) with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Create a vertical bar with the line color\n    bar = canvas(linc, (h, 1))\n    \n    # Randomly determine the number of deviations for set A (0 to half of total cells)\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly determine the number of deviations for set B (0 to half of total cells)\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose either the deviation count or its complement for set A\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose either the deviation count or its complement for set B\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure numa is between 1 and total cells - 1\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure numb is between 1 and total cells - 1\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly sample indices for set A\n    aset = sample(inds, numa)\n    \n    # Randomly sample indices for set B\n    bset = sample(inds, numb)\n    \n    # Fill the canvas with color A at the sampled indices for set A\n    A = fill(c, acol, aset)\n    \n    # Fill the canvas with color B at the sampled indices for set B\n    B = fill(c, bcol, bset)\n    \n    # Concatenate A, the separating bar, and B horizontally to create the input grid\n    gi = hconcat(hconcat(A, bar), B)\n    \n    # Calculate the remaining indices (not in A or B)\n    res = (set(inds) - set(aset)) - set(bset)\n    \n    # Fill the output canvas with color 3 at the remaining indices\n    go = fill(c, 3, res)\n    \n    # 50% chance to diagonally mirror both input and output grids\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6455b5f5": {
    "original": "def generate_6455b5f5(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 8))\n    while True:\n        h = unifint(diff_lb, diff_ub, (6, 30))\n        w = unifint(diff_lb, diff_ub, (6, 30))\n        bgc = choice(cols)\n        fgc = choice(remove(bgc, cols))\n        gi = canvas(bgc, (h, w))\n        ub = int((h * w) ** 0.5 * 1.5)\n        num = unifint(diff_lb, diff_ub, (1, ub))\n        for k in range(num):\n            objs = colorfilter(objects(gi, T, T, F), bgc)\n            eligobjs = sfilter(objs, lambda o: height(o) > 2 or width(o) > 2)\n            if len(eligobjs) == 0:\n                break\n            if choice((True, False)):\n                ro = argmax(eligobjs, size)\n            else:\n                ro = choice(totuple(eligobjs))\n            if choice((True, False)):\n                vfr = height(ro) < width(ro)\n            else:\n                vfr = choice((True, False))\n            if vfr and width(ro) < 3:\n                vfr = False\n            if (not vfr) and height(ro) < 3:\n                vfr = True\n            if vfr:\n                j = randint(leftmost(ro)+1, rightmost(ro)-1)\n                ln = connect((uppermost(ro), j), (lowermost(ro), j))\n            else:\n                j = randint(uppermost(ro)+1, lowermost(ro)-1)\n                ln = connect((j, leftmost(ro)), (j, rightmost(ro)))\n            gi = fill(gi, fgc, ln)\n        objs = colorfilter(objects(gi, T, T, F), bgc)\n        if valmin(objs, size) != valmax(objs, size):\n            break\n    lblues = mfilter(objs, matcher(size, valmin(objs, size)))\n    dblues = mfilter(objs, matcher(size, valmax(objs, size)))\n    go = fill(gi, 8, lblues)\n    go = fill(go, 1, dblues)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6455b5f5(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1 and 8\n    cols = difference(interval(0, 10, 1), (1, 8))\n    \n    while True:\n        # Generate random height between 6 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (6, 30))\n        # Generate random width between 6 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (6, 30))\n        # Choose a random background color\n        bgc = choice(cols)\n        # Choose a random foreground color different from the background\n        fgc = choice(remove(bgc, cols))\n        # Create an initial grid filled with the background color\n        gi = canvas(bgc, (h, w))\n        # Calculate upper bound for number of lines to draw\n        ub = int((h * w) ** 0.5 * 1.5)\n        # Choose a random number of lines to draw based on difficulty\n        num = unifint(diff_lb, diff_ub, (1, ub))\n        \n        for k in range(num):\n            # Find all background-colored objects in the grid\n            objs = colorfilter(objects(gi, T, T, F), bgc)\n            # Filter objects to only those larger than 2x2\n            eligobjs = sfilter(objs, lambda o: height(o) > 2 or width(o) > 2)\n            # If no eligible objects, break the loop (grid is full)\n            if len(eligobjs) == 0:\n                break\n            # Randomly choose between selecting the largest object or a random object\n            if choice((True, False)):\n                ro = argmax(eligobjs, size)\n            else:\n                ro = choice(totuple(eligobjs))\n            # Randomly decide whether to draw a vertical or horizontal line\n            if choice((True, False)):\n                vfr = height(ro) < width(ro)\n            else:\n                vfr = choice((True, False))\n            # Ensure the chosen direction is valid (object is wide/tall enough)\n            if vfr and width(ro) < 3:\n                vfr = False\n            if (not vfr) and height(ro) < 3:\n                vfr = True\n            # Draw a vertical line\n            if vfr:\n                j = randint(leftmost(ro)+1, rightmost(ro)-1)\n                ln = connect((uppermost(ro), j), (lowermost(ro), j))\n            # Draw a horizontal line\n            else:\n                j = randint(uppermost(ro)+1, lowermost(ro)-1)\n                ln = connect((j, leftmost(ro)), (j, rightmost(ro)))\n            # Add the line to the grid\n            gi = fill(gi, fgc, ln)\n        \n        # Find all background-colored objects after drawing lines\n        objs = colorfilter(objects(gi, T, T, F), bgc)\n        # If all objects are the same size, repeat the process\n        if valmin(objs, size) != valmax(objs, size):\n            break\n    \n    # Group objects by size (smallest and largest)\n    lblues = mfilter(objs, matcher(size, valmin(objs, size)))\n    dblues = mfilter(objs, matcher(size, valmax(objs, size)))\n    # Color the smallest objects with color 8 (light blue)\n    go = fill(gi, 8, lblues)\n    # Color the largest objects with color 1 (dark blue)\n    go = fill(go, 1, dblues)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "662c240a": {
    "original": "def generate_662c240a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    d = unifint(diff_lb, diff_ub, (2, 7))\n    ng = unifint(diff_lb, diff_ub, (2, 30 // d))\n    nc = unifint(diff_lb, diff_ub, (2, min(9, d ** 2)))\n    c = canvas(-1, (d, d))\n    inds = totuple(asindices(c))\n    tria = sfilter(inds, lambda ij: ij[1] >= ij[0])\n    tcolset = sample(cols, nc)\n    triaf = frozenset((choice(tcolset), ij) for ij in tria)\n    triaf = triaf | dmirror(triaf)\n    gik = paint(c, triaf)\n    ndistinv = unifint(diff_lb, diff_ub, (0, (d * (d - 1) // 2 - 1)))\n    ndist = d * (d - 1) // 2 - ndistinv\n    distinds = sample(difference(inds, sfilter(inds, lambda ij: ij[0] == ij[1])), ndist)\n    \n    for ij in distinds:\n        if gik[ij[0]][ij[1]] == gik[ij[1]][ij[0]]:\n            gik = fill(gik, choice(remove(gik[ij[0]][ij[1]], tcolset)), {ij})\n        else:\n            gik = fill(gik, gik[ij[1]][ij[0]], {ij})\n    gi = gik\n    go = tuple(e for e in gik)\n    concatf = choice((hconcat, vconcat))\n    for k in range(ng - 1):\n        tria = sfilter(inds, lambda ij: ij[1] >= ij[0])\n        tcolset = sample(cols, nc)\n        triaf = frozenset((choice(tcolset), ij) for ij in tria)\n        triaf = triaf | dmirror(triaf)\n        gik = paint(c, triaf)\n        if choice((True, False)):\n            gi = concatf(gi, gik)\n        else:\n            gi = concatf(gik, gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_662c240a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    d = unifint(diff_lb, diff_ub, (2, 7))  # Randomly choose the dimension of the square grid (2 to 7)\n    ng = unifint(diff_lb, diff_ub, (2, 30 // d))  # Randomly choose the number of grids to generate (2 to 30/d)\n    nc = unifint(diff_lb, diff_ub, (2, min(9, d ** 2)))  # Randomly choose the number of colors to use (2 to min(9, d^2))\n    c = canvas(-1, (d, d))  # Create a dxd canvas filled with -1\n    inds = totuple(asindices(c))  # Get all indices of the canvas as a tuple\n    tria = sfilter(inds, lambda ij: ij[1] >= ij[0])  # Filter indices to get the upper triangle (including diagonal)\n    tcolset = sample(cols, nc)  # Randomly sample nc colors from the color range\n    triaf = frozenset((choice(tcolset), ij) for ij in tria)  # Assign random colors to the upper triangle\n    triaf = triaf | dmirror(triaf)  # Mirror the upper triangle to create a symmetric pattern\n    gik = paint(c, triaf)  # Paint the symmetric pattern onto the canvas\n    ndistinv = unifint(diff_lb, diff_ub, (0, (d * (d - 1) // 2 - 1)))  # Choose number of cells to keep invariant\n    ndist = d * (d - 1) // 2 - ndistinv  # Calculate number of cells to make distinct\n    distinds = sample(difference(inds, sfilter(inds, lambda ij: ij[0] == ij[1])), ndist)  # Sample indices to make distinct, excluding diagonal\n    \n    for ij in distinds:\n        if gik[ij[0]][ij[1]] == gik[ij[1]][ij[0]]:  # If the cell and its mirror are the same color\n            gik = fill(gik, choice(remove(gik[ij[0]][ij[1]], tcolset)), {ij})  # Fill with a different color\n        else:\n            gik = fill(gik, gik[ij[1]][ij[0]], {ij})  # Swap colors with its mirror cell\n    gi = gik  # Set the input grid to the modified grid\n    go = tuple(e for e in gik)  # Create the output grid as a copy of the input grid\n    concatf = choice((hconcat, vconcat))  # Randomly choose between horizontal or vertical concatenation\n    for k in range(ng - 1):  # Generate ng-1 additional grids\n        tria = sfilter(inds, lambda ij: ij[1] >= ij[0])  # Get upper triangle indices\n        tcolset = sample(cols, nc)  # Sample new set of colors\n        triaf = frozenset((choice(tcolset), ij) for ij in tria)  # Assign random colors to upper triangle\n        triaf = triaf | dmirror(triaf)  # Mirror to create symmetric pattern\n        gik = paint(c, triaf)  # Paint new symmetric pattern onto canvas\n        if choice((True, False)):  # Randomly decide concatenation order\n            gi = concatf(gi, gik)  # Concatenate new grid to the right/bottom of existing grid\n        else:\n            gi = concatf(gik, gi)  # Concatenate new grid to the left/top of existing grid\n    return {'input': gi, 'output': go}  # Return input (concatenated grids) and output (single modified grid)\n"
  },
  "67385a82": {
    "original": "def generate_67385a82(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(0, remove(8, interval(0, 10, 1)))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    col = choice(cols)\n    gi = canvas(0, (h, w))\n    inds = totuple(asindices(gi))\n    ncd = unifint(diff_lb, diff_ub, (0, len(inds) // 2))\n    nc = choice((ncd, len(inds) - ncd))\n    nc = min(max(1, nc), len(inds) - 1)\n    locs = sample(inds, nc)\n    gi = fill(gi, col, locs)\n    objs = objects(gi, T, F, F)\n    rems = toindices(merge(sizefilter(colorfilter(objs, col), 1)))\n    blues = difference(ofcolor(gi, col), rems)\n    go = fill(gi, 8, blues)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_67385a82(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of color values from 1 to 7 and 9\n    cols = remove(0, remove(8, interval(0, 10, 1)))\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a color from the available colors\n    col = choice(cols)\n    \n    # Create an empty grid filled with 0s of size h x w\n    gi = canvas(0, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Calculate a random number of cells to color, based on difficulty\n    # This number is between 0 and half the total number of cells\n    ncd = unifint(diff_lb, diff_ub, (0, len(inds) // 2))\n    \n    # Randomly choose whether to use ncd or (total cells - ncd)\n    nc = choice((ncd, len(inds) - ncd))\n    \n    # Ensure nc is between 1 and (total cells - 1)\n    nc = min(max(1, nc), len(inds) - 1)\n    \n    # Randomly select nc locations from the grid\n    locs = sample(inds, nc)\n    \n    # Fill the selected locations with the chosen color\n    gi = fill(gi, col, locs)\n    \n    # Identify all objects in the grid (considering 4-connected cells of the same color)\n    objs = objects(gi, T, F, F)\n    \n    # Find all single-cell objects of the chosen color\n    rems = toindices(merge(sizefilter(colorfilter(objs, col), 1)))\n    \n    # Find all cells of the chosen color that are not single-cell objects\n    blues = difference(ofcolor(gi, col), rems)\n    \n    # Create the output grid by filling these non-single cells with color 8\n    go = fill(gi, 8, blues)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "673ef223": {
    "original": "def generate_673ef223(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    barh = unifint(diff_lb, diff_ub, (2, (h-1)//2))\n    ncells = unifint(diff_lb, diff_ub, (1, barh))\n    bgc, barc, dotc = sample(cols, 3)\n    sg = canvas(bgc, (barh, w))\n    topsgi = fill(sg, barc, connect((0, 0), (barh-1, 0)))\n    botsgi = vmirror(topsgi)\n    topsgo = tuple(e for e in topsgi)\n    botsgo = tuple(e for e in botsgi)\n    iloccands = interval(0, barh, 1)\n    ilocs = sample(iloccands, ncells)\n    for k in ilocs:\n        jloc = randint(2, w - 2)\n        topsgi = fill(topsgi, dotc, {(k, jloc)})\n        topsgo = fill(topsgo, 4, {(k, jloc)})\n        topsgo = fill(topsgo, dotc, connect((k, 1), (k, jloc-1)))\n        botsgo = fill(botsgo, dotc, connect((k, 0), (k, w - 2)))\n    outpi = (topsgi, botsgi)\n    outpo = (topsgo, botsgo)\n    rr = canvas(bgc, (1, w))\n    while len(merge(outpi)) < h:\n        idx = randint(0, len(outpi) - 1)\n        outpi = outpi[:idx] + (rr,) + outpi[idx:]\n        outpo = outpo[:idx] + (rr,) + outpo[idx:]\n    gi = merge(outpi)\n    go = merge(outpo)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_673ef223(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 4 from the range of colors 0-9\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random bar height between 2 and half of the total height\n    barh = unifint(diff_lb, diff_ub, (2, (h-1)//2))\n    \n    # Generate random number of cells to be filled, between 1 and bar height\n    ncells = unifint(diff_lb, diff_ub, (1, barh))\n    \n    # Randomly select 3 colors: background, bar, and dot colors\n    bgc, barc, dotc = sample(cols, 3)\n    \n    # Create a canvas with background color and dimensions (bar height, width)\n    sg = canvas(bgc, (barh, w))\n    \n    # Fill the leftmost column of the top segment with bar color\n    topsgi = fill(sg, barc, connect((0, 0), (barh-1, 0)))\n    \n    # Mirror the top segment vertically to create the bottom segment\n    botsgi = vmirror(topsgi)\n    \n    # Create copies of the top and bottom segments for output\n    topsgo = tuple(e for e in topsgi)\n    botsgo = tuple(e for e in botsgi)\n    \n    # Create a range of possible row indices for placing dots\n    iloccands = interval(0, barh, 1)\n    \n    # Randomly select row indices for placing dots\n    ilocs = sample(iloccands, ncells)\n    \n    # For each selected row index\n    for k in ilocs:\n        # Choose a random column index between 2 and width-2\n        jloc = randint(2, w - 2)\n        \n        # Place a dot in the input top segment\n        topsgi = fill(topsgi, dotc, {(k, jloc)})\n        \n        # Place a color 4 dot in the output top segment\n        topsgo = fill(topsgo, 4, {(k, jloc)})\n        \n        # Fill the output top segment with dots from column 1 to jloc-1\n        topsgo = fill(topsgo, dotc, connect((k, 1), (k, jloc-1)))\n        \n        # Fill the output bottom segment with dots from column 0 to width-2\n        botsgo = fill(botsgo, dotc, connect((k, 0), (k, w - 2)))\n    \n    # Combine top and bottom segments for input and output\n    outpi = (topsgi, botsgi)\n    outpo = (topsgo, botsgo)\n    \n    # Create a row of background color\n    rr = canvas(bgc, (1, w))\n    \n    # Add background rows until the desired height is reached\n    while len(merge(outpi)) < h:\n        # Choose a random index to insert the background row\n        idx = randint(0, len(outpi) - 1)\n        \n        # Insert the background row at the chosen index for input\n        outpi = outpi[:idx] + (rr,) + outpi[idx:]\n        \n        # Insert the background row at the chosen index for output\n        outpo = outpo[:idx] + (rr,) + outpo[idx:]\n    \n    # Merge the input and output segments into single grids\n    gi = merge(outpi)\n    go = merge(outpo)\n    \n    # Define a list of possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen number of random transformations to both input and output\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6773b310": {
    "original": "def generate_6773b310(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nh = unifint(diff_lb, diff_ub, (2, 5))\n    nw = unifint(diff_lb, diff_ub, (2, 5))\n    bgc, linc, fgc = sample(cols, 3)\n    fullh = h * nh + (nh - 1)\n    fullw = w * nw + (nw - 1)\n    c = canvas(linc, (fullh, fullw))\n    smallc = canvas(bgc, (h, w))\n    llocs = set()\n    for a in range(0, fullh, h + 1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    nbldev = unifint(diff_lb, diff_ub, (0, (nh * nw) // 2))\n    nbl = choice((nbldev, nh * nw - nbldev))\n    nbl = min(max(1, nbl), nh * nw - 1)\n    bluelocs = sample(llocs, nbl)\n    bglocs = difference(llocs, bluelocs)\n    inds = totuple(asindices(smallc))\n    gi = tuple(e for e in c)\n    go = canvas(bgc, (nh, nw))\n    for ij in bluelocs:\n        subg = asobject(fill(smallc, fgc, sample(inds, 2)))\n        gi = paint(gi, shift(subg, ij))\n        a, b = ij\n        loci = a // (h+1)\n        locj = b // (w+1)\n        go = fill(go, 1, {(loci, locj)})\n    for ij in bglocs:\n        subg = asobject(fill(smallc, fgc, sample(inds, 1)))\n        gi = paint(gi, shift(subg, ij))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6773b310(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Randomly determine height of small grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    # Randomly determine width of small grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    # Randomly determine number of rows in the final output grid\n    nh = unifint(diff_lb, diff_ub, (2, 5))\n    # Randomly determine number of columns in the final output grid\n    nw = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly select three colors for background, lines, and foreground\n    bgc, linc, fgc = sample(cols, 3)\n    \n    # Calculate full height of the input grid (small grids + separator lines)\n    fullh = h * nh + (nh - 1)\n    # Calculate full width of the input grid (small grids + separator lines)\n    fullw = w * nw + (nw - 1)\n    \n    # Create a canvas filled with the line color\n    c = canvas(linc, (fullh, fullw))\n    # Create a small canvas filled with the background color\n    smallc = canvas(bgc, (h, w))\n    \n    # Generate locations for the top-left corners of each small grid\n    llocs = set()\n    for a in range(0, fullh, h + 1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    \n    # Determine number of blue locations (small grids with 2 foreground cells)\n    nbldev = unifint(diff_lb, diff_ub, (0, (nh * nw) // 2))\n    nbl = choice((nbldev, nh * nw - nbldev))\n    nbl = min(max(1, nbl), nh * nw - 1)\n    \n    # Randomly select locations for blue grids\n    bluelocs = sample(llocs, nbl)\n    # Determine locations for background grids (1 foreground cell)\n    bglocs = difference(llocs, bluelocs)\n    \n    # Get all indices of the small canvas\n    inds = totuple(asindices(smallc))\n    \n    # Initialize input grid with line color\n    gi = tuple(e for e in c)\n    # Initialize output grid with background color\n    go = canvas(bgc, (nh, nw))\n    \n    # Process blue locations (2 foreground cells)\n    for ij in bluelocs:\n        # Create a small grid with 2 random foreground cells\n        subg = asobject(fill(smallc, fgc, sample(inds, 2)))\n        # Paint the small grid onto the input grid\n        gi = paint(gi, shift(subg, ij))\n        \n        # Calculate the corresponding position in the output grid\n        a, b = ij\n        loci = a // (h+1)\n        locj = b // (w+1)\n        # Mark the corresponding cell in the output grid as 1 (blue)\n        go = fill(go, 1, {(loci, locj)})\n    \n    # Process background locations (1 foreground cell)\n    for ij in bglocs:\n        # Create a small grid with 1 random foreground cell\n        subg = asobject(fill(smallc, fgc, sample(inds, 1)))\n        # Paint the small grid onto the input grid\n        gi = paint(gi, shift(subg, ij))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "67a3c6ac": {
    "original": "def generate_67a3c6ac(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = vmirror(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_67a3c6ac(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the color range\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the color options\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (other than background)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose cells to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by mirroring the input grid vertically\n    go = vmirror(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "67a423a3": {
    "original": "def generate_67a423a3(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    lineh = unifint(diff_lb, diff_ub, (1, h // 3))\n    linew = unifint(diff_lb, diff_ub, (1, w // 3))\n    loci = randint(1, h - lineh - 1)\n    locj = randint(1, w - linew - 1)\n    acol = choice(remcols)\n    bcol = choice(remove(acol, remcols))\n    for a in range(lineh):\n        gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))\n    for b in range(linew):\n        gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))\n    bx = outbox(frozenset({(loci, locj), (loci + lineh - 1, locj + linew - 1)}))\n    go = fill(gi, 4, bx)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_67a423a3(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 4 from the range 0-9, creating a list of available colors\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from available colors\n    bgc = choice(cols)\n    \n    # Create a new list of colors without the chosen background color\n    remcols = remove(bgc, cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Generate a random height for the horizontal lines (1 to 1/3 of grid height)\n    lineh = unifint(diff_lb, diff_ub, (1, h // 3))\n    \n    # Generate a random width for the vertical lines (1 to 1/3 of grid width)\n    linew = unifint(diff_lb, diff_ub, (1, w // 3))\n    \n    # Choose a random starting row for the horizontal lines\n    loci = randint(1, h - lineh - 1)\n    \n    # Choose a random starting column for the vertical lines\n    locj = randint(1, w - linew - 1)\n    \n    # Choose a color for the horizontal lines\n    acol = choice(remcols)\n    \n    # Choose a different color for the vertical lines\n    bcol = choice(remove(acol, remcols))\n    \n    # Draw horizontal lines on the grid\n    for a in range(lineh):\n        # Fill a horizontal line with color 'acol'\n        gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))\n    \n    # Draw vertical lines on the grid\n    for b in range(linew):\n        # Fill a vertical line with color 'bcol'\n        gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))\n    \n    # Create a bounding box around the intersection of horizontal and vertical lines\n    bx = outbox(frozenset({(loci, locj), (loci + lineh - 1, locj + linew - 1)}))\n    \n    # Create the output grid by filling the bounding box with color 4\n    go = fill(gi, 4, bx)\n    \n    # Randomly decide whether to mirror the input and output grids diagonally\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "67e8384a": {
    "original": "def generate_67e8384a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    go = paint(canv, obj)\n    go = hconcat(go, vmirror(go))\n    go = vconcat(go, hmirror(go))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_67e8384a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 14 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Randomly choose a width between 1 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (1 to 9) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample colors from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly choose the number of cells to color (1 to h*w) based on difficulty\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Create a set of all possible cell indices in the canvas\n    bx = asindices(canv)\n    \n    # Initialize the object with a single randomly colored cell at a random position\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Loop to add more colored cells to the object\n    for kk in range(nc - 1):\n        # Find all neighbors of the current object cells\n        dns = mapply(neighbors, toindices(obj))\n        \n        # Choose a random cell from the intersection of available cells and neighbors\n        ch = choice(totuple(bx & dns))\n        \n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        \n        # Remove the chosen cell from the available cells\n        bx = bx - {ch}\n    \n    # Paint the input canvas with the created object\n    gi = paint(canv, obj)\n    \n    # Create the output by first copying the input\n    go = paint(canv, obj)\n    \n    # Horizontally concatenate the output with its vertical mirror\n    # This doubles the width of the output\n    go = hconcat(go, vmirror(go))\n    \n    # Vertically concatenate the result with its horizontal mirror\n    # This doubles the height of the output, creating a 4x larger symmetrical pattern\n    go = vconcat(go, hmirror(go))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "681b3aeb": {
    "original": "def generate_681b3aeb(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    fullsuc = False\n    while not fullsuc:\n        hi = unifint(diff_lb, diff_ub, (2, 8))\n        wi = unifint(diff_lb, diff_ub, (2, 8))\n        h = unifint(diff_lb, diff_ub, ((3*hi, 30)))\n        w = unifint(diff_lb, diff_ub, ((3*wi, 30)))\n        c = canvas(-1, (hi, hi))\n        bgc, ca, cb = sample(cols, 3)\n        gi = canvas(bgc, (h, w))\n        conda, condb = True, True\n        while conda and condb:\n            inds = totuple(asindices(c))\n            pa = choice(inds)\n            reminds = remove(pa, inds)\n            pb = choice(reminds)\n            reminds = remove(pb, reminds)\n            A = {pa}\n            B = {pb}\n            for k in range(len(reminds)):\n                acands = set(reminds) & mapply(dneighbors, A)\n                bcands = set(reminds) & mapply(dneighbors, B)\n                opts = []\n                if len(acands) > 0:\n                    opts.append(0)\n                if len(bcands) > 0:\n                    opts.append(1)\n                idx = choice(opts)\n                if idx == 0:\n                    loc = choice(totuple(acands))\n                    A.add(loc)\n                else:\n                    loc = choice(totuple(bcands))\n                    B.add(loc)\n                reminds = remove(loc, reminds)\n            conda = len(A) == height(A) * width(A)\n            condb = len(B) == height(B) * width(B)\n        go = fill(c, ca, A)\n        go = fill(go, cb, B)\n        fullocs = totuple(asindices(gi))\n        A = normalize(A)\n        B = normalize(B)\n        ha, wa = shape(A)\n        hb, wb = shape(B)\n        minisuc = False\n        if not (ha > h or wa > w):\n            for kkk in range(10):\n                locai = randint(0, h - ha)\n                locaj = randint(0, w - wa)\n                plcda = shift(A, (locaj, locaj))\n                remlocs = difference(fullocs, plcda)\n                remlocs2 = sfilter(remlocs, lambda ij: ij[0] <= h - hb and ij[1] <= w - wb)\n                if len(remlocs2) == 0:\n                    continue\n                ch = choice(remlocs2)\n                plcdb = shift(B, (ch))\n                if set(plcdb).issubset(set(remlocs2)):\n                    minisuc = True\n                    break\n        if minisuc:\n            fullsuc = True\n    gi = fill(gi, ca, plcda)\n    gi = fill(gi, cb, plcdb)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_681b3aeb(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a tuple of integers from 0 to 9\n    fullsuc = False  # Initialize full success flag\n    while not fullsuc:  # Loop until a fully successful generation\n        hi = unifint(diff_lb, diff_ub, (2, 8))  # Generate random height for inner grid\n        wi = unifint(diff_lb, diff_ub, (2, 8))  # Generate random width for inner grid\n        h = unifint(diff_lb, diff_ub, ((3*hi, 30)))  # Generate random height for outer grid\n        w = unifint(diff_lb, diff_ub, ((3*wi, 30)))  # Generate random width for outer grid\n        c = canvas(-1, (hi, hi))  # Create a square canvas filled with -1\n        bgc, ca, cb = sample(cols, 3)  # Randomly select 3 colors\n        gi = canvas(bgc, (h, w))  # Create output grid filled with background color\n        conda, condb = True, True  # Initialize condition flags for shapes A and B\n        while conda and condb:  # Loop to generate valid shapes A and B\n            inds = totuple(asindices(c))  # Get all indices of the inner canvas\n            pa = choice(inds)  # Choose a random starting point for shape A\n            reminds = remove(pa, inds)  # Remove pa from available indices\n            pb = choice(reminds)  # Choose a random starting point for shape B\n            reminds = remove(pb, reminds)  # Remove pb from available indices\n            A = {pa}  # Initialize shape A with its starting point\n            B = {pb}  # Initialize shape B with its starting point\n            for k in range(len(reminds)):  # Distribute remaining points between A and B\n                acands = set(reminds) & mapply(dneighbors, A)  # Find valid neighbors for A\n                bcands = set(reminds) & mapply(dneighbors, B)  # Find valid neighbors for B\n                opts = []  # Initialize options list\n                if len(acands) > 0:\n                    opts.append(0)  # Add option to expand A if possible\n                if len(bcands) > 0:\n                    opts.append(1)  # Add option to expand B if possible\n                idx = choice(opts)  # Randomly choose to expand A or B\n                if idx == 0:\n                    loc = choice(totuple(acands))  # Choose a location to add to A\n                    A.add(loc)  # Add the chosen location to A\n                else:\n                    loc = choice(totuple(bcands))  # Choose a location to add to B\n                    B.add(loc)  # Add the chosen location to B\n                reminds = remove(loc, reminds)  # Remove the chosen location from available indices\n            conda = len(A) == height(A) * width(A)  # Check if A is a rectangle\n            condb = len(B) == height(B) * width(B)  # Check if B is a rectangle\n        go = fill(c, ca, A)  # Fill shape A with color ca in the output grid\n        go = fill(go, cb, B)  # Fill shape B with color cb in the output grid\n        fullocs = totuple(asindices(gi))  # Get all indices of the outer grid\n        A = normalize(A)  # Move shape A to the origin\n        B = normalize(B)  # Move shape B to the origin\n        ha, wa = shape(A)  # Get height and width of shape A\n        hb, wb = shape(B)  # Get height and width of shape B\n        minisuc = False  # Initialize mini success flag\n        if not (ha > h or wa > w):  # Check if A fits in the outer grid\n            for kkk in range(10):  # Try 10 times to place A and B\n                locai = randint(0, h - ha)  # Choose random row for A\n                locaj = randint(0, w - wa)  # Choose random column for A\n                plcda = shift(A, (locaj, locaj))  # Place A in the chosen location\n                remlocs = difference(fullocs, plcda)  # Find remaining locations\n                remlocs2 = sfilter(remlocs, lambda ij: ij[0] <= h - hb and ij[1] <= w - wb)  # Filter valid locations for B\n                if len(remlocs2) == 0:\n                    continue  # If no valid locations for B, try again\n                ch = choice(remlocs2)  # Choose a random location for B\n                plcdb = shift(B, (ch))  # Place B in the chosen location\n                if set(plcdb).issubset(set(remlocs2)):  # Check if B fits without overlapping A\n                    minisuc = True  # Set mini success flag\n                    break  # Exit the loop if successful\n        if minisuc:\n            fullsuc = True  # Set full success flag if mini success achieved\n    gi = fill(gi, ca, plcda)  # Fill shape A in the input grid\n    gi = fill(gi, cb, plcdb)  # Fill shape B in the input grid\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "6855a6e4": {
    "original": "def generate_6855a6e4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    fullh = unifint(diff_lb, diff_ub, (10, h))\n    fullw = unifint(diff_lb, diff_ub, (3, w))\n    bgc, objc, boxc = sample(cols, 3)\n    bcanv = canvas(bgc, (h, w))\n    loci = randint(0, h - fullh)\n    locj = randint(0, w - fullw)\n    loc = (loci, locj)\n    canvi = canvas(bgc, (fullh, fullw))\n    canvo = canvas(bgc, (fullh, fullw))\n    objh = (fullh // 2 - 3) // 2\n    br = connect((objh + 1, 0), (objh + 1, fullw - 1))\n    br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}\n    cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))\n    for k in range(2):\n        canvi = fill(canvi, boxc, br)\n        canvo = fill(canvo, boxc, br)\n        ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))\n        ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))\n        ncells = min(max(1, ncells), objh * (fullw - 2))\n        cells = frozenset(sample(totuple(cands), ncells))\n        canvi = fill(canvi, objc, cells)\n        canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))\n        canvi = hmirror(canvi)\n        canvo = hmirror(canvo)\n    gi = paint(bcanv, shift(asobject(canvi), loc))\n    go = paint(bcanv, shift(asobject(canvo), loc))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6855a6e4(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random full height between 10 and h based on difficulty\n    fullh = unifint(diff_lb, diff_ub, (10, h))\n    \n    # Generate a random full width between 3 and w based on difficulty\n    fullw = unifint(diff_lb, diff_ub, (3, w))\n    \n    # Randomly select 3 distinct colors for background, object, and box\n    bgc, objc, boxc = sample(cols, 3)\n    \n    # Create a background canvas of size h x w with background color\n    bcanv = canvas(bgc, (h, w))\n    \n    # Generate random starting row for the pattern\n    loci = randint(0, h - fullh)\n    \n    # Generate random starting column for the pattern\n    locj = randint(0, w - fullw)\n    \n    # Combine row and column into a tuple\n    loc = (loci, locj)\n    \n    # Create an input canvas of size fullh x fullw with background color\n    canvi = canvas(bgc, (fullh, fullw))\n    \n    # Create an output canvas of size fullh x fullw with background color\n    canvo = canvas(bgc, (fullh, fullw))\n    \n    # Calculate the height of each object (quarter of fullh minus some padding)\n    objh = (fullh // 2 - 3) // 2\n    \n    # Create a horizontal line (box boundary) in the middle of the canvas\n    br = connect((objh + 1, 0), (objh + 1, fullw - 1))\n    \n    # Add two points to make the box boundary thicker\n    br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}\n    \n    # Create a set of candidate positions for object cells\n    cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))\n    \n    # Loop twice to create upper and lower parts of the pattern\n    for k in range(2):\n        # Fill the box boundary on the input canvas\n        canvi = fill(canvi, boxc, br)\n        \n        # Fill the box boundary on the output canvas\n        canvo = fill(canvo, boxc, br)\n        \n        # Generate a random number of cells to fill based on difficulty\n        ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))\n        \n        # Choose between ncellsd and its complement randomly\n        ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))\n        \n        # Ensure at least one cell is filled and not more than available space\n        ncells = min(max(1, ncells), objh * (fullw - 2))\n        \n        # Randomly select positions for object cells\n        cells = frozenset(sample(totuple(cands), ncells))\n        \n        # Fill selected cells with object color on input canvas\n        canvi = fill(canvi, objc, cells)\n        \n        # Fill mirrored cells on output canvas (flipped vertically and shifted down)\n        canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))\n        \n        # Flip input canvas horizontally (to work on the other half)\n        canvi = hmirror(canvi)\n        \n        # Flip output canvas horizontally (to work on the other half)\n        canvo = hmirror(canvo)\n    \n    # Paint the input pattern onto the background canvas\n    gi = paint(bcanv, shift(asobject(canvi), loc))\n    \n    # Paint the output pattern onto the background canvas\n    go = paint(bcanv, shift(asobject(canvo), loc))\n    \n    # Randomly decide whether to mirror the entire pattern diagonally\n    if choice((True, False)):\n        # Mirror input grid diagonally\n        gi = dmirror(gi)\n        # Mirror output grid diagonally\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "68b16354": {
    "original": "def generate_68b16354(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = hmirror(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_68b16354(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a width between 1 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a grid (canvas) filled with the background color of size h x w\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (between 0 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select 'numc' colors from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select 'num' indices from the available indices\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by horizontally mirroring the input grid\n    go = hmirror(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "694f12f3": {
    "original": "def generate_694f12f3(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    h = unifint(diff_lb, diff_ub, (9, 30))\n    w = unifint(diff_lb, diff_ub, (9, 30))\n    seploc = randint(4, h - 5)\n    bigh = unifint(diff_lb, diff_ub, (4, seploc))\n    bigw = unifint(diff_lb, diff_ub, (3, w - 1))\n    bigloci = randint(0, seploc - bigh)\n    biglocj = randint(0, w - bigw)\n    smallmaxh = h - seploc - 1\n    smallmaxw = w - 1\n    cands = []\n    bigsize = bigh * bigw\n    for a in range(3, smallmaxh+1):\n        for b in range(3, smallmaxw+1):\n            if a * b < bigsize:\n                cands.append((a, b))\n    cands = sorted(cands, key=lambda ab: ab[0]*ab[1])\n    num = len(cands)\n    idx = unifint(diff_lb, diff_ub, (0, num - 1))\n    smallh, smallw = cands[idx]\n    smallloci = randint(seploc+1, h - smallh)\n    smalllocj = randint(0, w - smallw)\n    bgc, sqc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    bigsq = backdrop(frozenset({(bigloci, biglocj), (bigloci + bigh - 1, biglocj + bigw - 1)}))\n    smallsq = backdrop(frozenset({(smallloci, smalllocj), (smallloci + smallh - 1, smalllocj + smallw - 1)}))\n    gi = fill(gi, sqc, bigsq | smallsq)\n    go = fill(gi, 2, backdrop(inbox(bigsq)))\n    go = fill(go, 1, backdrop(inbox(smallsq)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_694f12f3(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    \n    # Generate random height between 9 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (9, 30))\n    # Generate random width between 9 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (9, 30))\n    \n    # Choose a random separation line between 4 and h-5\n    seploc = randint(4, h - 5)\n    \n    # Generate height for the big square, between 4 and seploc\n    bigh = unifint(diff_lb, diff_ub, (4, seploc))\n    # Generate width for the big square, between 3 and w-1\n    bigw = unifint(diff_lb, diff_ub, (3, w - 1))\n    \n    # Choose random top-left corner for big square\n    bigloci = randint(0, seploc - bigh)\n    biglocj = randint(0, w - bigw)\n    \n    # Calculate maximum dimensions for small square\n    smallmaxh = h - seploc - 1\n    smallmaxw = w - 1\n    \n    # Initialize list for possible small square dimensions\n    cands = []\n    # Calculate area of big square\n    bigsize = bigh * bigw\n    \n    # Generate all possible dimensions for small square\n    for a in range(3, smallmaxh+1):\n        for b in range(3, smallmaxw+1):\n            # Ensure small square area is less than big square\n            if a * b < bigsize:\n                cands.append((a, b))\n    \n    # Sort candidates by area\n    cands = sorted(cands, key=lambda ab: ab[0]*ab[1])\n    # Count number of candidates\n    num = len(cands)\n    \n    # Choose a random index based on difficulty\n    idx = unifint(diff_lb, diff_ub, (0, num - 1))\n    # Select dimensions for small square\n    smallh, smallw = cands[idx]\n    \n    # Choose random top-left corner for small square\n    smallloci = randint(seploc+1, h - smallh)\n    smalllocj = randint(0, w - smallw)\n    \n    # Select two different colors for background and squares\n    bgc, sqc = sample(cols, 2)\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create big square area\n    bigsq = backdrop(frozenset({(bigloci, biglocj), (bigloci + bigh - 1, biglocj + bigw - 1)}))\n    # Create small square area\n    smallsq = backdrop(frozenset({(smallloci, smalllocj), (smallloci + smallh - 1, smalllocj + smallw - 1)}))\n    \n    # Fill both squares with the square color\n    gi = fill(gi, sqc, bigsq | smallsq)\n    \n    # Create output grid, filling big square's inner box with color 2\n    go = fill(gi, 2, backdrop(inbox(bigsq)))\n    # Fill small square's inner box with color 1\n    go = fill(go, 1, backdrop(inbox(smallsq)))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply rotation to input grid\n    gi = rotf(gi)\n    # Apply same rotation to output grid\n    go = rotf(go)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6a1e5592": {
    "original": "def generate_6a1e5592(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (9, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    barh = randint(3, h//3)\n    maxobjh = h - barh - 1\n    nobjs = unifint(diff_lb, diff_ub, (1, w//3))\n    barc, bgc, objc = sample(cols, 3)\n    c1 = canvas(barc, (barh, w))\n    c2 = canvas(bgc, (h - barh, w))\n    gi = vconcat(c1, c2)\n    go = tuple(e for e in gi)\n    tr = 0\n    succ = 0\n    maxtr = 10 * nobjs\n    placopts = interval(1, w - 1, 1)\n    iinds = ofcolor(gi, bgc)\n    oinds = asindices(go)\n    barinds = ofcolor(gi, barc)\n    forbmarkers = set()\n    while tr < maxtr and succ < nobjs:\n        tr += 1\n        oh = randint(1, maxobjh)\n        ow = randint(1, min(4, w//2))\n        bounds = asindices(canvas(-1, (oh, ow)))\n        ncells = randint(1, oh * ow)\n        sp = choice(totuple(connect((0, 0), (0, ow - 1))))\n        obj = {sp}\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        obj = normalize(obj)\n        oh, ow = shape(obj)\n        markerh = randint(1, min(oh, barh-1))\n        markpart = sfilter(obj, lambda ij: ij[0] < markerh)\n        markpartn = normalize(markpart)\n        isinvalid = False\n        for k in range(1, markerh+1):\n            if normalize(sfilter(markpartn, lambda ij: ij[0] < k)) in forbmarkers:\n                isinvalid = True\n        if isinvalid:\n            continue\n        for k in range(1, markerh+1):\n            forbmarkers.add(normalize(sfilter(markpartn, lambda ij: ij[0] < k)))\n        placoptcands = sfilter(placopts, lambda jj: set(interval(jj, jj+ow+1, 1)).issubset(set(placopts)))\n        if len(placoptcands) == 0:\n            continue\n        jloc = choice(placoptcands)\n        iloc = barh - markerh\n        oplcd = shift(obj, (iloc, jloc))\n        if oplcd.issubset(oinds):\n            icands = sfilter(iinds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(icands) == 0:\n                continue\n            loc = choice(totuple(icands))\n            iplcd = shift(obj, loc)\n            if iplcd.issubset(iinds):\n                succ += 1\n                iinds = (iinds - iplcd) - mapply(neighbors, iplcd)\n                oinds = (oinds - oplcd)\n                gi = fill(gi, objc, iplcd)\n                gi = fill(gi, bgc, oplcd & barinds)\n                go = fill(go, 1, oplcd)\n                jm = apply(last, ofcolor(go, 1))\n                placopts = sorted(difference(placopts, jm | apply(decrement, jm) | apply(increment, jm)))\n        if len(placopts) == 0:\n            break\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6a1e5592(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors (0-9) excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Generate random height between 9 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (9, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Set bar height to a random value between 3 and 1/3 of total height\n    barh = randint(3, h//3)\n    \n    # Calculate maximum object height\n    maxobjh = h - barh - 1\n    \n    # Generate random number of objects based on difficulty (up to 1/3 of width)\n    nobjs = unifint(diff_lb, diff_ub, (1, w//3))\n    \n    # Randomly select colors for bar, background, and objects\n    barc, bgc, objc = sample(cols, 3)\n    \n    # Create a canvas for the bar area\n    c1 = canvas(barc, (barh, w))\n    \n    # Create a canvas for the background area\n    c2 = canvas(bgc, (h - barh, w))\n    \n    # Concatenate bar and background vertically to form input grid\n    gi = vconcat(c1, c2)\n    \n    # Create output grid as a copy of input grid\n    go = tuple(e for e in gi)\n    \n    # Initialize counters and options\n    tr = 0  # Attempt counter\n    succ = 0  # Successful placements counter\n    maxtr = 10 * nobjs  # Maximum attempts allowed\n    placopts = interval(1, w - 1, 1)  # Possible placement columns\n    \n    # Get indices of background color in input grid\n    iinds = ofcolor(gi, bgc)\n    \n    # Get all indices of output grid\n    oinds = asindices(go)\n    \n    # Get indices of bar color in input grid\n    barinds = ofcolor(gi, barc)\n    \n    # Set to store forbidden marker shapes\n    forbmarkers = set()\n\n    # Main loop for object placement\n    while tr < maxtr and succ < nobjs:\n        tr += 1  # Increment attempt counter\n        \n        # Generate random object dimensions\n        oh = randint(1, maxobjh)\n        ow = randint(1, min(4, w//2))\n        \n        # Create bounds for object shape\n        bounds = asindices(canvas(-1, (oh, ow)))\n        \n        # Determine number of cells in object\n        ncells = randint(1, oh * ow)\n        \n        # Choose a starting point for object\n        sp = choice(totuple(connect((0, 0), (0, ow - 1))))\n        obj = {sp}\n        \n        # Generate object shape\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        \n        # Normalize object position\n        obj = normalize(obj)\n        \n        # Get final object dimensions\n        oh, ow = shape(obj)\n        \n        # Generate marker height\n        markerh = randint(1, min(oh, barh-1))\n        \n        # Create marker part of object\n        markpart = sfilter(obj, lambda ij: ij[0] < markerh)\n        markpartn = normalize(markpart)\n        \n        # Check if marker shape is valid\n        isinvalid = False\n        for k in range(1, markerh+1):\n            if normalize(sfilter(markpartn, lambda ij: ij[0] < k)) in forbmarkers:\n                isinvalid = True\n        if isinvalid:\n            continue\n        \n        # Add valid marker shapes to forbidden set\n        for k in range(1, markerh+1):\n            forbmarkers.add(normalize(sfilter(markpartn, lambda ij: ij[0] < k)))\n        \n        # Find valid placement options\n        placoptcands = sfilter(placopts, lambda jj: set(interval(jj, jj+ow+1, 1)).issubset(set(placopts)))\n        if len(placoptcands) == 0:\n            continue\n        \n        # Choose placement location\n        jloc = choice(placoptcands)\n        iloc = barh - markerh\n        \n        # Shift object to output placement location\n        oplcd = shift(obj, (iloc, jloc))\n        \n        # Check if object can be placed in output grid\n        if oplcd.issubset(oinds):\n            # Find candidates for input grid placement\n            icands = sfilter(iinds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(icands) == 0:\n                continue\n            \n            # Choose input placement location\n            loc = choice(totuple(icands))\n            iplcd = shift(obj, loc)\n            \n            # Check if object can be placed in input grid\n            if iplcd.issubset(iinds):\n                succ += 1  # Increment successful placements\n                \n                # Update available indices\n                iinds = (iinds - iplcd) - mapply(neighbors, iplcd)\n                oinds = (oinds - oplcd)\n                \n                # Place object in input grid\n                gi = fill(gi, objc, iplcd)\n                \n                # Clear bar area in input grid where object is placed in output\n                gi = fill(gi, bgc, oplcd & barinds)\n                \n                # Place object in output grid\n                go = fill(go, 1, oplcd)\n                \n                # Update placement options\n                jm = apply(last, ofcolor(go, 1))\n                placopts = sorted(difference(placopts, jm | apply(decrement, jm) | apply(increment, jm)))\n        \n        # Break if no more placement options\n        if len(placopts) == 0:\n            break\n\n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply rotation to input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input-output pair\n    return {'input': gi, 'output': go}\n"
  },
  "6aa20dc0": {
    "original": "def generate_6aa20dc0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    od = unifint(diff_lb, diff_ub, (2, 4))\n    ncellsextra = randint(1, max(1, (od ** 2 - 2) // 2))\n    sinds = asindices(canvas(-1, (od, od)))\n    extracells = set(sample(totuple(sinds - {(0, 0), (od - 1, od - 1)}), ncellsextra))\n    extracells.add(choice(totuple(dneighbors((0, 0)) & sinds)))\n    extracells.add(choice(totuple(dneighbors((od - 1, od - 1)) & sinds)))\n    extracells = frozenset(extracells)\n    bgc, fgc, c1, c2 = sample(cols, 4)\n    obj = frozenset({(c1, (0, 0)), (c2, (od - 1, od - 1))}) | recolor(fgc, extracells)\n    obj = obj | dmirror(obj)\n    if choice((True, False)):\n        obj = hmirror(obj)\n    gi = canvas(bgc, (h, w))\n    loci = randint(0, h - od)\n    locj = randint(0, w - od)\n    plcd = shift(obj, (loci, locj))\n    gi = paint(gi, plcd)\n    go = tuple(e for e in gi)\n    inds = asindices(gi)\n    inds = inds - backdrop(outbox(plcd))\n    nocc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (od ** 2 * 2))))\n    succ = 0\n    tr = 0\n    maxtr = 4 * nocc\n    while succ < nocc and tr < maxtr:\n        tr += 1\n        fac = randint(1, 4)\n        mf1 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        mf2 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        mf = compose(mf2, mf1)\n        cobj = normalize(upscale(mf(obj), fac))\n        ohx, owx = shape(cobj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - ohx and ij[1] <= w - owx)\n        if len(cands) == 0:\n            continue\n        locc = choice(totuple(cands))\n        cobjo = shift(cobj, locc)\n        cobji = sfilter(cobjo, lambda cij: cij[0] != fgc)\n        cobjoi = toindices(cobjo)\n        if cobjoi.issubset(inds):\n            succ += 1\n            inds = inds - backdrop(outbox(cobjoi))\n            gi = paint(gi, cobji)\n            go = paint(go, cobjo)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6aa20dc0(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random object dimension (2, 3, or 4) based on difficulty\n    od = unifint(diff_lb, diff_ub, (2, 4))\n    \n    # Calculate number of extra cells to add to the object\n    ncellsextra = randint(1, max(1, (od ** 2 - 2) // 2))\n    \n    # Generate indices for a square canvas of size od x od\n    sinds = asindices(canvas(-1, (od, od)))\n    \n    # Randomly select extra cells, excluding corners\n    extracells = set(sample(totuple(sinds - {(0, 0), (od - 1, od - 1)}), ncellsextra))\n    \n    # Add a cell adjacent to top-left corner\n    extracells.add(choice(totuple(dneighbors((0, 0)) & sinds)))\n    \n    # Add a cell adjacent to bottom-right corner\n    extracells.add(choice(totuple(dneighbors((od - 1, od - 1)) & sinds)))\n    \n    # Convert extra cells to a frozenset\n    extracells = frozenset(extracells)\n    \n    # Randomly select 4 distinct colors\n    bgc, fgc, c1, c2 = sample(cols, 4)\n    \n    # Create the initial object with corners and extra cells\n    obj = frozenset({(c1, (0, 0)), (c2, (od - 1, od - 1))}) | recolor(fgc, extracells)\n    \n    # Make the object symmetric along the diagonal\n    obj = obj | dmirror(obj)\n    \n    # Randomly mirror the object horizontally\n    if choice((True, False)):\n        obj = hmirror(obj)\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Choose random location to place the object\n    loci = randint(0, h - od)\n    locj = randint(0, w - od)\n    \n    # Shift the object to the chosen location\n    plcd = shift(obj, (loci, locj))\n    \n    # Paint the object onto the input grid\n    gi = paint(gi, plcd)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Remove the area around the placed object from available indices\n    inds = inds - backdrop(outbox(plcd))\n    \n    # Determine number of additional objects to place based on difficulty\n    nocc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (od ** 2 * 2))))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 4 * nocc\n    \n    # Loop to place additional objects\n    while succ < nocc and tr < maxtr:\n        tr += 1\n        # Choose a random scaling factor\n        fac = randint(1, 4)\n        \n        # Choose random transformation functions\n        mf1 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        mf2 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        \n        # Compose the transformation functions\n        mf = compose(mf2, mf1)\n        \n        # Apply transformations and scaling to the object\n        cobj = normalize(upscale(mf(obj), fac))\n        \n        # Get dimensions of the transformed object\n        ohx, owx = shape(cobj)\n        \n        # Find valid locations to place the transformed object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - ohx and ij[1] <= w - owx)\n        \n        # If no valid locations, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location from valid candidates\n        locc = choice(totuple(cands))\n        \n        # Shift the object to the chosen location\n        cobjo = shift(cobj, locc)\n        \n        # Filter out foreground color from the object for input grid\n        cobji = sfilter(cobjo, lambda cij: cij[0] != fgc)\n        \n        # Get indices of the placed object\n        cobjoi = toindices(cobjo)\n        \n        # If the object fits within available space\n        if cobjoi.issubset(inds):\n            succ += 1\n            # Remove the area around the placed object from available indices\n            inds = inds - backdrop(outbox(cobjoi))\n            \n            # Paint the filtered object onto the input grid\n            gi = paint(gi, cobji)\n            \n            # Paint the full object onto the output grid\n            go = paint(go, cobjo)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6b9890af": {
    "original": "def generate_6b9890af(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    oh = unifint(diff_lb, diff_ub, (2, 5))\n    ow = unifint(diff_lb, diff_ub, (2, 5))\n    h = unifint(diff_lb, diff_ub, (2*oh+2, 30))\n    w = unifint(diff_lb, diff_ub, (2*ow+2, 30))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    obj = {choice(totuple(bounds))}\n    while shape(obj) != (oh, ow):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    maxfac = 1\n    while oh * maxfac + 2 <= h - oh and ow * maxfac + 2 <= w - ow:\n        maxfac += 1\n    maxfac -= 1\n    fac = unifint(diff_lb, diff_ub, (1, maxfac))\n    bgc, sqc = sample(cols, 2)\n    remcols = remove(bgc, remove(sqc, cols))\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    obj = {(choice(ccols), ij) for ij in obj}\n    gi = canvas(bgc, (h, w))\n    sq = box(frozenset({(0, 0), (oh * fac + 1, ow * fac + 1)}))\n    loci = randint(0, h - (oh * fac + 2) - oh)\n    locj = randint(0, w - (ow * fac + 2))\n    gi = fill(gi, sqc, shift(sq, (loci, locj)))\n    loci = randint(loci+oh*fac+2, h - oh)\n    locj = randint(0, w - ow)\n    objp = shift(obj, (loci, locj))\n    gi = paint(gi, objp)\n    go = canvas(bgc, (oh * fac + 2, ow * fac + 2))\n    go = fill(go, sqc, sq)\n    go2 = paint(canvas(bgc, (oh, ow)), obj)\n    upscobj = asobject(upscale(go2, fac))\n    go = paint(go, shift(upscobj, (1, 1)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6b9890af(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the object (2 to 5)\n    oh = unifint(diff_lb, diff_ub, (2, 5))\n    # Randomly determine the width of the object (2 to 5)\n    ow = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly determine the height of the input grid (at least 2*oh+2, up to 30)\n    h = unifint(diff_lb, diff_ub, (2*oh+2, 30))\n    # Randomly determine the width of the input grid (at least 2*ow+2, up to 30)\n    w = unifint(diff_lb, diff_ub, (2*ow+2, 30))\n    \n    # Create a set of all possible coordinates for the object\n    bounds = asindices(canvas(-1, (oh, ow)))\n    # Start the object with a random coordinate\n    obj = {choice(totuple(bounds))}\n    \n    # Grow the object until it reaches the desired size\n    while shape(obj) != (oh, ow):\n        # Add a random neighboring cell to the object\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    \n    # Calculate the maximum scaling factor that fits in the input grid\n    maxfac = 1\n    while oh * maxfac + 2 <= h - oh and ow * maxfac + 2 <= w - ow:\n        maxfac += 1\n    maxfac -= 1\n    \n    # Randomly choose a scaling factor\n    fac = unifint(diff_lb, diff_ub, (1, maxfac))\n    \n    # Choose background and square outline colors\n    bgc, sqc = sample(cols, 2)\n    # Get the remaining colors\n    remcols = remove(bgc, remove(sqc, cols))\n    \n    # Randomly choose the number of colors for the object (1 to 8)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    # Choose the colors for the object\n    ccols = sample(remcols, numc)\n    \n    # Assign random colors to each cell of the object\n    obj = {(choice(ccols), ij) for ij in obj}\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the square outline\n    sq = box(frozenset({(0, 0), (oh * fac + 1, ow * fac + 1)}))\n    \n    # Randomly position the square outline in the input grid\n    loci = randint(0, h - (oh * fac + 2) - oh)\n    locj = randint(0, w - (ow * fac + 2))\n    gi = fill(gi, sqc, shift(sq, (loci, locj)))\n    \n    # Randomly position the object in the input grid (below the square)\n    loci = randint(loci+oh*fac+2, h - oh)\n    locj = randint(0, w - ow)\n    objp = shift(obj, (loci, locj))\n    gi = paint(gi, objp)\n    \n    # Create the output grid with the square and scaled object\n    go = canvas(bgc, (oh * fac + 2, ow * fac + 2))\n    go = fill(go, sqc, sq)\n    go2 = paint(canvas(bgc, (oh, ow)), obj)\n    upscobj = asobject(upscale(go2, fac))\n    go = paint(go, shift(upscobj, (1, 1)))\n    \n    # Randomly rotate both input and output grids\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6c434453": {
    "original": "def generate_6c434453(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 16))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        if choice((True, False)):\n            oh = choice((3, 5))\n            ow = choice((3, 5))\n            obji = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        else:\n            oh = randint(1, 5)\n            ow = randint(1, 5)\n            bounds = asindices(canvas(-1, (oh, ow)))\n            ncells = randint(1, oh * ow)\n            obji = {choice(totuple(bounds))}\n            for k in range(ncells - 1):\n                obji.add(choice(totuple((bounds - obji) & mapply(dneighbors, obji))))\n            obji = normalize(obji)\n        oh, ow = shape(obji)\n        flag = obji == box(obji) and set(shape(obji)).issubset({3, 5})\n        if flag:\n            objo = connect((0, ow//2), (oh - 1, ow//2)) | connect((oh//2, 0), (oh//2, ow - 1))\n            tocover = backdrop(obji)\n        else:\n            objo = obji\n            tocover = obji\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        loc = choice(totuple(cands))\n        plcdi = shift(obji, loc)\n        if plcdi.issubset(inds):\n            plcdo = shift(objo, loc)\n            succ += 1\n            tocoveri = shift(tocover, loc)\n            inds = (inds - tocoveri) - mapply(dneighbors, tocoveri)\n            col = choice(ccols)\n            gi = fill(gi, col, plcdi)\n            go = fill(go, 2 if flag else col, plcdo)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6c434453(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (10-30)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid (10-30)\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1-8)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors to use from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Randomly determine the number of objects to place (2 to 1/16th of grid area)\n    nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 16))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    \n    # Create input and output grids filled with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        \n        # Randomly choose between creating a box or a random shape\n        if choice((True, False)):\n            # Create a box shape (3x3 or 5x5)\n            oh = choice((3, 5))\n            ow = choice((3, 5))\n            obji = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        else:\n            # Create a random shape (1x1 to 5x5)\n            oh = randint(1, 5)\n            ow = randint(1, 5)\n            bounds = asindices(canvas(-1, (oh, ow)))\n            ncells = randint(1, oh * ow)\n            obji = {choice(totuple(bounds))}\n            # Grow the shape by adding adjacent cells\n            for k in range(ncells - 1):\n                obji.add(choice(totuple((bounds - obji) & mapply(dneighbors, obji))))\n            obji = normalize(obji)\n        \n        # Get the shape dimensions\n        oh, ow = shape(obji)\n        \n        # Check if the shape is a 3x3 or 5x5 box\n        flag = obji == box(obji) and set(shape(obji)).issubset({3, 5})\n        \n        if flag:\n            # For boxes, create a cross shape for the output\n            objo = connect((0, ow//2), (oh - 1, ow//2)) | connect((oh//2, 0), (oh//2, ow - 1))\n            tocover = backdrop(obji)\n        else:\n            # For non-boxes, use the same shape in the output\n            objo = obji\n            tocover = obji\n        \n        # Find valid placement locations\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # Choose a random valid location\n        loc = choice(totuple(cands))\n        \n        # Shift the input shape to the chosen location\n        plcdi = shift(obji, loc)\n        \n        # If the placement is valid (within grid bounds)\n        if plcdi.issubset(inds):\n            # Shift the output shape to the chosen location\n            plcdo = shift(objo, loc)\n            succ += 1\n            \n            # Update available indices, removing the placed shape and its neighbors\n            tocoveri = shift(tocover, loc)\n            inds = (inds - tocoveri) - mapply(dneighbors, tocoveri)\n            \n            # Choose a random color for the shape\n            col = choice(ccols)\n            \n            # Place the shape on the input grid\n            gi = fill(gi, col, plcdi)\n            \n            # Place the shape on the output grid (using color 2 for boxes, original color otherwise)\n            go = fill(go, 2 if flag else col, plcdo)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6cdd2623": {
    "original": "def generate_6cdd2623(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    nnoisecols = unifint(diff_lb, diff_ub, (1, 7))\n    noisecols = sample(remcols, nnoisecols)\n    c = canvas(bgc, (h, w))\n    ininds = totuple(shift(asindices(canvas(-1, (h-2, w-1))), (1, 1)))\n    fixinds = sample(ininds, nnoisecols)\n    fixobj = {(col, ij) for col, ij in zip(list(noisecols), fixinds)}\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    gi = paint(gi, fixobj)\n    nnoise = unifint(diff_lb, diff_ub, (1, (h * w - nnoisecols) // 3))\n    noise = sample(totuple(asindices(c) - set(fixinds)), nnoise)\n    noise = {(choice(remcols), ij) for ij in noise}\n    gi = paint(gi, noise)\n    ilocs = interval(1, h - 1, 1)\n    jlocs = interval(1, w - 1, 1)\n    aa, bb = sample((0, 1), 2)\n    nilocs = unifint(diff_lb, diff_ub, (aa, (h - 2) // 2))\n    njlocs = unifint(diff_lb, diff_ub, (bb, (w - 2) // 2))\n    ilocs = sample(ilocs, nilocs)\n    jlocs = sample(jlocs, njlocs)\n    for ii in ilocs:\n        gi = fill(gi, linc, {(ii, 0)})\n        gi = fill(gi, linc, {(ii, w - 1)})\n        go = fill(go, linc, connect((ii, 0), (ii, w - 1)))\n    for jj in jlocs:\n        gi = fill(gi, linc, {(0, jj)})\n        gi = fill(gi, linc, {(h - 1, jj)})\n        go = fill(go, linc, connect((0, jj), (h - 1, jj)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6cdd2623(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 8 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Generate a random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the lines\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random number of noise colors between 1 and 7 based on difficulty\n    nnoisecols = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Select random colors for noise from the remaining colors\n    noisecols = sample(remcols, nnoisecols)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Generate indices for the inner area of the grid (excluding borders)\n    ininds = totuple(shift(asindices(canvas(-1, (h-2, w-1))), (1, 1)))\n    \n    # Select random fixed positions for noise colors\n    fixinds = sample(ininds, nnoisecols)\n    \n    # Create an object with fixed noise colors at their positions\n    fixobj = {(col, ij) for col, ij in zip(list(noisecols), fixinds)}\n    \n    # Create input and output grids with background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Paint the fixed noise colors onto the input grid\n    gi = paint(gi, fixobj)\n    \n    # Generate a random number of additional noise points\n    nnoise = unifint(diff_lb, diff_ub, (1, (h * w - nnoisecols) // 3))\n    \n    # Select random positions for additional noise, excluding fixed positions\n    noise = sample(totuple(asindices(c) - set(fixinds)), nnoise)\n    \n    # Assign random colors to the additional noise points\n    noise = {(choice(remcols), ij) for ij in noise}\n    \n    # Paint the additional noise onto the input grid\n    gi = paint(gi, noise)\n    \n    # Generate possible row indices for lines (excluding borders)\n    ilocs = interval(1, h - 1, 1)\n    \n    # Generate possible column indices for lines (excluding borders)\n    jlocs = interval(1, w - 1, 1)\n    \n    # Randomly choose whether to have horizontal or vertical lines (or both)\n    aa, bb = sample((0, 1), 2)\n    \n    # Choose a random number of horizontal lines based on difficulty\n    nilocs = unifint(diff_lb, diff_ub, (aa, (h - 2) // 2))\n    \n    # Choose a random number of vertical lines based on difficulty\n    njlocs = unifint(diff_lb, diff_ub, (bb, (w - 2) // 2))\n    \n    # Select random row indices for horizontal lines\n    ilocs = sample(ilocs, nilocs)\n    \n    # Select random column indices for vertical lines\n    jlocs = sample(jlocs, njlocs)\n    \n    # For each selected row index:\n    for ii in ilocs:\n        # Add line color to the left border of the input grid\n        gi = fill(gi, linc, {(ii, 0)})\n        # Add line color to the right border of the input grid\n        gi = fill(gi, linc, {(ii, w - 1)})\n        # Draw a complete horizontal line on the output grid\n        go = fill(go, linc, connect((ii, 0), (ii, w - 1)))\n    \n    # For each selected column index:\n    for jj in jlocs:\n        # Add line color to the top border of the input grid\n        gi = fill(gi, linc, {(0, jj)})\n        # Add line color to the bottom border of the input grid\n        gi = fill(gi, linc, {(h - 1, jj)})\n        # Draw a complete vertical line on the output grid\n        go = fill(go, linc, connect((0, jj), (h - 1, jj)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6cf79266": {
    "original": "def generate_6cf79266(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (0, 1))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    nfgcs = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(cols, nfgcs)\n    gi = canvas(-1, (h, w))\n    fgcobj = {(choice(ccols), ij) for ij in asindices(gi)}\n    gi = paint(gi, fgcobj)\n    num = unifint(diff_lb, diff_ub, (int(0.25 * h * w), int(0.6 * h * w)))\n    inds = asindices(gi)\n    locs = sample(totuple(inds), num)\n    gi = fill(gi, 0, locs)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    cands = asindices(canvas(-1, (h - 2, w - 2)))\n    locs = sample(totuple(cands), noccs)\n    mini = asindices(canvas(-1, (3, 3)))\n    for ij in locs:\n        gi = fill(gi, 0, shift(mini, ij))\n    trg = recolor(0, mini)\n    occs = occurrences(gi, trg)\n    go = tuple(e for e in gi)\n    for occ in occs:\n        go = fill(go, 1, shift(mini, occ))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6cf79266(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors (0-9) excluding 0 and 1\n    cols = difference(interval(0, 10, 1), (0, 1))\n    \n    # Randomly determine the height of the grid (between 6 and 30)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly determine the width of the grid (between 6 and 30)\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly choose the number of foreground colors (between 1 and 8)\n    nfgcs = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample the chosen number of colors from the color set\n    ccols = sample(cols, nfgcs)\n    \n    # Create an initial grid filled with -1 (placeholder color)\n    gi = canvas(-1, (h, w))\n    \n    # Create a set of cells with random colors from ccols at all grid positions\n    fgcobj = {(choice(ccols), ij) for ij in asindices(gi)}\n    \n    # Paint the initial grid with the randomly colored cells\n    gi = paint(gi, fgcobj)\n    \n    # Determine the number of cells to be filled with 0 (between 25% and 60% of total cells)\n    num = unifint(diff_lb, diff_ub, (int(0.25 * h * w), int(0.6 * h * w)))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly sample 'num' locations from all grid indices\n    locs = sample(totuple(inds), num)\n    \n    # Fill the sampled locations with 0 (creating \"holes\" in the colored grid)\n    gi = fill(gi, 0, locs)\n    \n    # Determine the number of 3x3 black squares to add (up to 1/16 of total grid size)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    \n    # Create a set of possible locations for 3x3 squares (excluding edges)\n    cands = asindices(canvas(-1, (h - 2, w - 2)))\n    \n    # Randomly sample locations for the 3x3 squares\n    locs = sample(totuple(cands), noccs)\n    \n    # Create a 3x3 grid of indices\n    mini = asindices(canvas(-1, (3, 3)))\n    \n    # For each sampled location, add a 3x3 black square to the grid\n    for ij in locs:\n        gi = fill(gi, 0, shift(mini, ij))\n    \n    # Create a 3x3 black square object\n    trg = recolor(0, mini)\n    \n    # Find all occurrences of the 3x3 black square in the input grid\n    occs = occurrences(gi, trg)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # For each occurrence of a 3x3 black square, fill it with 1 in the output grid\n    # This effectively outlines all 3x3 black squares with color 1\n    for occ in occs:\n        go = fill(go, 1, shift(mini, occ))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6d0160f0": {
    "original": "def generate_6d0160f0(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (4,))\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nh, nw = h, w\n    bgc, linc = sample(cols, 2)\n    fullh = h * nh + nh - 1\n    fullw = w * nw + nw - 1\n    gi = canvas(bgc, (fullh, fullw))\n    for iloc in range(h, fullh, h+1):\n        gi = fill(gi, linc, hfrontier((iloc, 0)))\n    for jloc in range(w, fullw, w+1):\n        gi = fill(gi, linc, vfrontier((0, jloc)))\n    noccs = unifint(diff_lb, diff_ub, (1, h * w))\n    denseinds = asindices(canvas(-1, (h, w)))\n    sparseinds = {(a*(h+1), b*(w+1)) for a, b in denseinds}\n    locs = sample(totuple(sparseinds), noccs)\n    trgtl = choice(locs)\n    remlocs = remove(trgtl, locs)\n    ntrgt = unifint(diff_lb, diff_ub, (1, (h * w - 1)))\n    place = choice(totuple(denseinds))\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(cols, ncols)\n    candss = totuple(remove(place, denseinds))\n    trgrem = sample(candss, ntrgt)\n    trgrem = {(choice(ccols), ij) for ij in trgrem}\n    trgtobj = {(4, place)} | trgrem\n    go = paint(gi, shift(sfilter(trgtobj, lambda cij: cij[0] != linc), multiply(place, increment((h, w)))))\n    gi = paint(gi, shift(trgtobj, trgtl))\n    toleaveout = ccols\n    for rl in remlocs:\n        tlo = choice(totuple(ccols))\n        ncells = unifint(diff_lb, diff_ub, (1, h * w - 1))\n        inds = sample(totuple(denseinds), ncells)\n        obj = {(choice(remove(tlo, ccols) if len(ccols) > 1 else ccols), ij) for ij in inds}\n        toleaveout = remove(tlo, toleaveout)\n        gi = paint(gi, shift(obj, rl))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6d0160f0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 4\n    cols = difference(interval(0, 10, 1), (4,))\n    \n    # Randomly choose height and width of sub-grids between 2 and 5\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Set number of sub-grids in height and width directions\n    nh, nw = h, w\n    \n    # Randomly choose background color and line color\n    bgc, linc = sample(cols, 2)\n    \n    # Calculate full height and width of the grid\n    fullh = h * nh + nh - 1  # Includes space for separator lines\n    fullw = w * nw + nw - 1  # Includes space for separator lines\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (fullh, fullw))\n    \n    # Draw horizontal separator lines\n    for iloc in range(h, fullh, h+1):\n        gi = fill(gi, linc, hfrontier((iloc, 0)))\n    \n    # Draw vertical separator lines\n    for jloc in range(w, fullw, w+1):\n        gi = fill(gi, linc, vfrontier((0, jloc)))\n    \n    # Choose number of objects to place\n    noccs = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Create dense indices for sub-grid placement\n    denseinds = asindices(canvas(-1, (h, w)))\n    \n    # Create sparse indices for actual grid placement\n    sparseinds = {(a*(h+1), b*(w+1)) for a, b in denseinds}\n    \n    # Choose locations for objects\n    locs = sample(totuple(sparseinds), noccs)\n    \n    # Choose target location (where the object will be moved to)\n    trgtl = choice(locs)\n    \n    # Remove target location from remaining locations\n    remlocs = remove(trgtl, locs)\n    \n    # Choose number of cells for target object (excluding central cell)\n    ntrgt = unifint(diff_lb, diff_ub, (1, (h * w - 1)))\n    \n    # Choose placement of target object in output grid\n    place = choice(totuple(denseinds))\n    \n    # Choose number of colors to use\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Choose colors for objects\n    ccols = sample(cols, ncols)\n    \n    # Create candidate positions for target object cells\n    candss = totuple(remove(place, denseinds))\n    \n    # Choose positions for target object cells\n    trgrem = sample(candss, ntrgt)\n    \n    # Assign random colors to target object cells\n    trgrem = {(choice(ccols), ij) for ij in trgrem}\n    \n    # Create complete target object with central cell (color 4)\n    trgtobj = {(4, place)} | trgrem\n    \n    # Paint target object in output grid\n    go = paint(gi, shift(sfilter(trgtobj, lambda cij: cij[0] != linc), multiply(place, increment((h, w)))))\n    \n    # Paint target object in input grid\n    gi = paint(gi, shift(trgtobj, trgtl))\n    \n    # Initialize set of colors to leave out\n    toleaveout = ccols\n    \n    # Place remaining objects in input grid\n    for rl in remlocs:\n        # Choose color to leave out for this object\n        tlo = choice(totuple(ccols))\n        \n        # Choose number of cells for this object\n        ncells = unifint(diff_lb, diff_ub, (1, h * w - 1))\n        \n        # Choose positions for object cells\n        inds = sample(totuple(denseinds), ncells)\n        \n        # Create object with random colors (excluding the leave-out color)\n        obj = {(choice(remove(tlo, ccols) if len(ccols) > 1 else ccols), ij) for ij in inds}\n        \n        # Update colors to leave out\n        toleaveout = remove(tlo, toleaveout)\n        \n        # Paint object in input grid\n        gi = paint(gi, shift(obj, rl))\n    \n    # Return input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6d0aefbc": {
    "original": "def generate_6d0aefbc(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = hconcat(gi, vmirror(gi))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6d0aefbc(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (1, 30)\n    \n    # Create a tuple of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly select height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly select width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select number of colors to use (excluding background)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly sample colors to use from remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Randomly select number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose cells to fill\n        chos = sample(inds, num)\n        \n        # Fill chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove filled indices from available indices\n        inds = difference(inds, chos)\n    \n    # Create output by horizontally concatenating input with its vertical mirror\n    go = hconcat(gi, vmirror(gi))\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6d58a25d": {
    "original": "def generate_6d58a25d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    shp = normalize(frozenset({\n    (0, 0), (1, 0), (1, 1), (1, -1), (2, -1), (2, -2), (2, 1), (2, 2), (3, 3), (3, -3)\n    }))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    c1 = choice(remcols)\n    c2 = choice(remove(c1, remcols))\n    loci = randint(0, h - 4)\n    locj = randint(0, w - 7)\n    plcd = shift(shp, (loci, locj))\n    rem = difference(inds, plcd)\n    nnoise = unifint(diff_lb, diff_ub, (1, max(1, len(rem) // 2 - 1)))\n    nois = sample(rem, nnoise)\n    gi = fill(c, c2, nois)\n    gi = fill(gi, c1, plcd)\n    ff = lambda ij: len(intersection(shoot(ij, (-1, 0)), plcd)) > 0\n    trg = sfilter(nois, ff)\n    gg = lambda ij: valmax(sfilter(plcd, lambda kl: kl[1] == ij[1]), first) + 1\n    kk = lambda ij: connect((gg(ij), ij[1]), (h - 1, ij[1]))\n    fullres = mapply(kk, trg)\n    go = fill(gi, c2, fullres)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6d58a25d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (representing possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Define a shape as a set of coordinates, then normalize it (shift to origin)\n    shp = normalize(frozenset({\n    (0, 0), (1, 0), (1, 1), (1, -1), (2, -1), (2, -2), (2, 1), (2, 2), (3, 3), (3, -3)\n    }))\n    \n    # Randomly determine the height of the grid between 5 and 30\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (all colors except the background color)\n    remcols = remove(bgc, cols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Choose a color for the shape\n    c1 = choice(remcols)\n    \n    # Choose a color for the 'noise' and 'lines', different from background and shape color\n    c2 = choice(remove(c1, remcols))\n    \n    # Randomly choose a location to place the shape (ensuring it fits within the grid)\n    loci = randint(0, h - 4)\n    locj = randint(0, w - 7)\n    \n    # Shift the shape to the chosen location\n    plcd = shift(shp, (loci, locj))\n    \n    # Get all indices not occupied by the shape\n    rem = difference(inds, plcd)\n    \n    # Randomly determine the number of 'noise' points (between 1 and half of remaining space)\n    nnoise = unifint(diff_lb, diff_ub, (1, max(1, len(rem) // 2 - 1)))\n    \n    # Randomly choose locations for the 'noise' points\n    nois = sample(rem, nnoise)\n    \n    # Create the input grid: fill noise points with color c2\n    gi = fill(c, c2, nois)\n    \n    # Fill the shape with color c1 on the input grid\n    gi = fill(gi, c1, plcd)\n    \n    # Define a function to check if a point has any part of the shape above it\n    ff = lambda ij: len(intersection(shoot(ij, (-1, 0)), plcd)) > 0\n    \n    # Filter noise points to only those that have part of the shape above them\n    trg = sfilter(nois, ff)\n    \n    # Define a function to find the bottom of the shape in a given column\n    gg = lambda ij: valmax(sfilter(plcd, lambda kl: kl[1] == ij[1]), first) + 1\n    \n    # Define a function to create a vertical line from the bottom of the shape to the grid bottom\n    kk = lambda ij: connect((gg(ij), ij[1]), (h - 1, ij[1]))\n    \n    # Create all the vertical lines\n    fullres = mapply(kk, trg)\n    \n    # Create the output grid: fill the vertical lines with color c2\n    go = fill(gi, c2, fullres)\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6d75e8bb": {
    "original": "def generate_6d75e8bb(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(c)\n    ch = choice(totuple(bounds))\n    shp = {ch}\n    bounds = remove(ch, bounds)\n    for j in range(nc - 1):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    plcd = shift(shp, loc)\n    gi = fill(c, fgc, plcd)\n    go = fill(c, 2, backdrop(plcd))\n    go = fill(go, fgc, plcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6d75e8bb(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly generate height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate number of cells for the shape, between 1 and half the grid area minus 1\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    bounds = asindices(c)\n    \n    # Choose a random starting cell for the shape\n    ch = choice(totuple(bounds))\n    \n    # Initialize the shape with the chosen cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available indices\n    bounds = remove(ch, bounds)\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc - 1):\n        # Find neighbors of the current shape that are within bounds and not part of the shape\n        # Then choose a random cell from these to add to the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the normalized shape\n    oh, ow = shape(shp)\n    \n    # Choose a random location to place the shape in the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    \n    # Shift the shape to the chosen location\n    plcd = shift(shp, loc)\n    \n    # Create the input grid by filling the shape with the foreground color\n    gi = fill(c, fgc, plcd)\n    \n    # Create the output grid by first filling the shape's bounding box with color 2\n    go = fill(c, 2, backdrop(plcd))\n    \n    # Then fill the actual shape with the foreground color in the output grid\n    go = fill(go, fgc, plcd)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6e02f1e3": {
    "original": "def generate_6e02f1e3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    d = unifint(diff_lb, diff_ub, (3, 30))\n    c = canvas(0, (d, d))\n    inds = list(asindices(c))\n    shuffle(inds)\n    num = d ** 2\n    numcols = choice((1, 2, 3))\n    chcols = sample(cols, numcols)\n    if len(chcols) == 1:\n        gi = canvas(chcols[0], (d, d))\n        go = canvas(0, (d, d))\n        go = fill(go, 5, connect((0, 0), (0, d - 1)))\n    elif len(chcols) == 2:\n        c1, c2 = chcols\n        mp = (d ** 2) // 2\n        nc1 = unifint(diff_lb, diff_ub, (1, mp))\n        a = inds[:nc1]\n        b = inds[nc1:]\n        gi = fill(c, c1, a)\n        gi = fill(gi, c2, b)\n        go = fill(canvas(0, (d, d)), 5, connect((0, 0), (d - 1, d - 1)))\n    elif len(chcols) == 3:\n        c1, c2, c3 = chcols\n        kk = d ** 2\n        a = int(1/3 * kk)\n        b = int(2/3 * kk)\n        adev = unifint(diff_lb, diff_ub, (0, a - 1))\n        bdev = unifint(diff_lb, diff_ub, (0, kk - b - 1))\n        a -= adev\n        b -= bdev\n        x1, x2, x3 = inds[:a], inds[a:b], inds[b:]\n        gi = fill(c, c1, x1)\n        gi = fill(gi, c2, x2)\n        gi = fill(gi, c3, x3)\n        go = fill(canvas(0, (d, d)), 5, connect((d - 1, 0), (0, d - 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6e02f1e3(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random grid size between 3 and 30 based on difficulty\n    d = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Create an empty canvas of size d x d filled with 0s\n    c = canvas(0, (d, d))\n    \n    # Get all indices of the canvas as a list\n    inds = list(asindices(c))\n    \n    # Randomly shuffle the indices\n    shuffle(inds)\n    \n    # Calculate total number of cells in the grid\n    num = d ** 2\n    \n    # Randomly choose the number of colors to use (1, 2, or 3)\n    numcols = choice((1, 2, 3))\n    \n    # Randomly select 'numcols' colors from the color range\n    chcols = sample(cols, numcols)\n    \n    # Case: Using only one color\n    if len(chcols) == 1:\n        # Create input grid filled with the chosen color\n        gi = canvas(chcols[0], (d, d))\n        \n        # Create output grid filled with 0s\n        go = canvas(0, (d, d))\n        \n        # Fill the left edge of the output grid with color 5\n        go = fill(go, 5, connect((0, 0), (0, d - 1)))\n    \n    # Case: Using two colors\n    elif len(chcols) == 2:\n        c1, c2 = chcols  # Unpack the two chosen colors\n        \n        # Calculate the midpoint of total cells\n        mp = (d ** 2) // 2\n        \n        # Randomly determine the number of cells for the first color\n        nc1 = unifint(diff_lb, diff_ub, (1, mp))\n        \n        # Split the shuffled indices into two parts\n        a = inds[:nc1]\n        b = inds[nc1:]\n        \n        # Fill the input grid with the first color\n        gi = fill(c, c1, a)\n        \n        # Fill the remaining cells with the second color\n        gi = fill(gi, c2, b)\n        \n        # Create output grid with a diagonal line of color 5\n        go = fill(canvas(0, (d, d)), 5, connect((0, 0), (d - 1, d - 1)))\n    \n    # Case: Using three colors\n    elif len(chcols) == 3:\n        c1, c2, c3 = chcols  # Unpack the three chosen colors\n        \n        # Calculate total number of cells\n        kk = d ** 2\n        \n        # Calculate initial split points for three colors\n        a = int(1/3 * kk)\n        b = int(2/3 * kk)\n        \n        # Add some randomness to the split points\n        adev = unifint(diff_lb, diff_ub, (0, a - 1))\n        bdev = unifint(diff_lb, diff_ub, (0, kk - b - 1))\n        a -= adev\n        b -= bdev\n        \n        # Split the shuffled indices into three parts\n        x1, x2, x3 = inds[:a], inds[a:b], inds[b:]\n        \n        # Fill the input grid with the three colors\n        gi = fill(c, c1, x1)\n        gi = fill(gi, c2, x2)\n        gi = fill(gi, c3, x3)\n        \n        # Create output grid with a diagonal line of color 5 (opposite direction)\n        go = fill(canvas(0, (d, d)), 5, connect((d - 1, 0), (0, d - 1)))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6e19193c": {
    "original": "def generate_6e19193c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    dirs = (\n        ((0, 0), (-1, -1)),\n        ((0, 1), (-1, 1)),\n        ((1, 0), (1, -1)),\n        ((1, 1), (1, 1))\n    )\n    base = ((0, 0), (1, 0), (0, 1), (1, 1))\n    candsi = [\n        set(base) - {dr[0]} for dr in dirs\n    ]\n    candso = [\n        (set(base) | shoot(dr[0], dr[1])) - {dr[0]} for dr in dirs\n    ]\n    cands = list(zip(candsi, candso))    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 8))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    fullinds = asindices(gi)\n    inds = asindices(canvas(-1, (h, w)))\n    kk, tr = 0, 0\n    maxtrials = num * 4\n    while kk < num and tr < maxtrials:\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        obji, objo = choice(cands)\n        obji = shift(obji, loc)\n        objo = shift(objo, loc)\n        objo = objo & fullinds\n        if objo.issubset(inds) and obji.issubset(objo):\n            col = choice(remcols)\n            gi = fill(gi, col, obji)\n            go = fill(go, col, objo)\n            inds = (inds - objo) - mapply(dneighbors, obji)\n            kk += 1\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6e19193c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Define four directions and their corresponding diagonal shoot directions\n    dirs = (\n        ((0, 0), (-1, -1)),  # Top-left corner, shoot to top-left\n        ((0, 1), (-1, 1)),   # Top-right corner, shoot to top-right\n        ((1, 0), (1, -1)),   # Bottom-left corner, shoot to bottom-left\n        ((1, 1), (1, 1))     # Bottom-right corner, shoot to bottom-right\n    )\n    \n    # Define the base shape (a 2x2 square)\n    base = ((0, 0), (1, 0), (0, 1), (1, 1))\n    \n    # Create input candidates by removing one corner from the base shape for each direction\n    candsi = [\n        set(base) - {dr[0]} for dr in dirs\n    ]\n    \n    # Create output candidates by adding a diagonal line to the base shape for each direction\n    candso = [\n        (set(base) | shoot(dr[0], dr[1])) - {dr[0]} for dr in dirs\n    ]\n    \n    # Pair input and output candidates\n    cands = list(zip(candsi, candso))    \n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the number of objects to place based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 8))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Create a set of all valid indices in the grid\n    fullinds = asindices(gi)\n    \n    # Create a set of available indices for object placement\n    inds = asindices(canvas(-1, (h, w)))\n    \n    # Initialize counters for placed objects and placement attempts\n    kk, tr = 0, 0\n    \n    # Set maximum number of placement attempts\n    maxtrials = num * 4\n    \n    # Main loop for placing objects\n    while kk < num and tr < maxtrials:\n        # Break if no more available indices\n        if len(inds) == 0:\n            break\n        \n        # Randomly choose a location for the object\n        loc = choice(totuple(inds))\n        \n        # Randomly choose an input-output object pair\n        obji, objo = choice(cands)\n        \n        # Shift the input object to the chosen location\n        obji = shift(obji, loc)\n        \n        # Shift the output object to the chosen location\n        objo = shift(objo, loc)\n        \n        # Ensure the output object stays within the grid boundaries\n        objo = objo & fullinds\n        \n        # Check if the object can be placed without overlapping\n        if objo.issubset(inds) and obji.issubset(objo):\n            # Randomly choose a color for the object\n            col = choice(remcols)\n            \n            # Place the input object on the input grid\n            gi = fill(gi, col, obji)\n            \n            # Place the output object on the output grid\n            go = fill(go, col, objo)\n            \n            # Remove used indices and their neighbors from available indices\n            inds = (inds - objo) - mapply(dneighbors, obji)\n            \n            # Increment the counter for successfully placed objects\n            kk += 1\n        \n        # Increment the trial counter\n        tr += 1\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6e82a1ae": {
    "original": "def generate_6e82a1ae(diff_lb: float, diff_ub: float) -> dict:\n    b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})\n    c = frozenset({\n        frozenset({ORIGIN, DOWN, UNITY}),\n        frozenset({ORIGIN, DOWN, RIGHT}),\n        frozenset({UNITY, DOWN, RIGHT}),\n        frozenset({UNITY, ORIGIN, RIGHT}),\n        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),\n        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)\n    })\n    d = set()\n    for k in range(100):\n        shp = {(0, 0)}\n        for jj in range(3):\n            shp.add(choice(totuple(mapply(dneighbors, shp) - shp)))\n        shp = frozenset(normalize(shp))\n        d.add(shp)\n    d = frozenset(d)\n    d, b, c = totuple(d), totuple(b), totuple(c)\n    prs = [(b, 3), (c, 2), (d, 1)]\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    reminds = asindices(gi)\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 3))\n    maxtr = 10\n    for k in range(nobjs):\n        ntr = 0\n        objs, col = choice(prs)\n        obj = choice(objs)\n        while ntr < maxtr:\n            loc = choice(totuple(reminds))\n            olcd = shift(obj, loc)\n            if olcd.issubset(reminds):\n                gi = fill(gi, fgc, olcd)\n                go = fill(go, col, olcd)\n                reminds = (reminds - olcd) - mapply(dneighbors, olcd)\n                break\n            ntr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6e82a1ae(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of two L-shaped objects (corner pieces)\n    b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})\n    \n    # Define a set of six T-shaped and line objects\n    c = frozenset({\n        frozenset({ORIGIN, DOWN, UNITY}),  # T-shape\n        frozenset({ORIGIN, DOWN, RIGHT}),  # T-shape\n        frozenset({UNITY, DOWN, RIGHT}),   # T-shape\n        frozenset({UNITY, ORIGIN, RIGHT}), # T-shape\n        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),  # Vertical line\n        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)  # Horizontal line\n    })\n    \n    # Generate a set of 100 random 4-cell shapes\n    d = set()\n    for k in range(100):\n        shp = {(0, 0)}  # Start with origin\n        for jj in range(3):\n            # Add a random neighboring cell to the shape\n            shp.add(choice(totuple(mapply(dneighbors, shp) - shp)))\n        shp = frozenset(normalize(shp))  # Normalize and freeze the shape\n        d.add(shp)\n    d = frozenset(d)\n    \n    # Convert sets to tuples for easier random selection\n    d, b, c = totuple(d), totuple(b), totuple(c)\n    \n    # Define shape categories with their respective \"scores\"\n    prs = [(b, 3), (c, 2), (d, 1)]\n    \n    # Define available colors (excluding 1, 2, 3 which are reserved for shape scores)\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    \n    # Randomly determine grid height and width based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose background and foreground colors\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    \n    # Create input and output grids with background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Initialize set of available indices\n    reminds = asindices(gi)\n    \n    # Determine number of objects to place based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 3))\n    \n    maxtr = 10  # Maximum number of placement attempts per object\n    for k in range(nobjs):\n        ntr = 0\n        # Randomly choose a shape category and a shape from it\n        objs, col = choice(prs)\n        obj = choice(objs)\n        while ntr < maxtr:\n            # Try to place the object at a random location\n            loc = choice(totuple(reminds))\n            olcd = shift(obj, loc)\n            if olcd.issubset(reminds):\n                # If placement is valid, update input and output grids\n                gi = fill(gi, fgc, olcd)  # Fill input grid with foreground color\n                go = fill(go, col, olcd)  # Fill output grid with shape's score\n                # Remove placed cells and their neighbors from available indices\n                reminds = (reminds - olcd) - mapply(dneighbors, olcd)\n                break\n            ntr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6ecd11f4": {
    "original": "def generate_6ecd11f4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 7))\n    w = unifint(diff_lb, diff_ub, (2, 7))\n    bgc, fgc = sample(cols, 2)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, ncols)\n    inds = asindices(canvas(bgc, (h, w)))\n    nlocsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nlocs = choice((nlocsd, h * w - nlocsd))\n    nlocs = min(max(3, nlocs), h * w - 1)\n    sp = choice(totuple(inds))\n    inds = remove(sp, inds)\n    shp = {sp}\n    for j in range(nlocs):\n        ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    shp = normalize(shp)\n    h, w = shape(shp)\n    canv = canvas(bgc, (h, w))\n    objbase = fill(canv, fgc, shp)\n    maxhscf = (2*h+h+1) // h\n    maxwscf = (2*w+w+1) // w\n    hscf = unifint(diff_lb, diff_ub, (2, maxhscf))\n    wscf = unifint(diff_lb, diff_ub, (2, maxwscf))\n    obj = asobject(hupscale(vupscale(objbase, hscf), wscf))\n    oh, ow = shape(obj)\n    inds = asindices(canv)\n    objx = {(choice(ccols), ij) for ij in inds}\n    if len(palette(objx)) == 1:\n        objxodo = first(objx)\n        objx = insert((choice(remove(objxodo[0], ccols)), objxodo[1]), remove(objxodo, objx))\n    fullh = unifint(diff_lb, diff_ub, (hscf*h+h+1, 30))\n    fullw = unifint(diff_lb, diff_ub, (wscf*w+w+1, 30))\n    gi = canvas(bgc, (fullh, fullw))\n    fullinds = asindices(gi)\n    while True:\n        loci = randint(0, fullh - oh)\n        locj = randint(0, fullw - ow)\n        loc = (loci, locj)\n        gix = paint(gi, shift(obj, loc))\n        ofc = ofcolor(gix, fgc)\n        delt = (fullinds - ofc)\n        delt2 = delt - mapply(neighbors, ofc)\n        scands = sfilter(\n            delt2,\n            lambda ij: ij[0] <= fullh - oh and ij[1] <= fullw - ow\n        )\n        if len(scands) == 0:\n            continue\n        locc = choice(totuple(scands))\n        shftd = shift(objx, locc)\n        if toindices(shftd).issubset(delt2):\n            gi = paint(gix, shftd)\n            break\n    go = paint(canv, objx)\n    go = fill(go, bgc, ofcolor(objbase, bgc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6ecd11f4(diff_lb: float, diff_ub: float) -> dict:\n    # Generate a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the base shape (2 to 7)\n    h = unifint(diff_lb, diff_ub, (2, 7))\n    \n    # Randomly determine the width of the base shape (2 to 7)\n    w = unifint(diff_lb, diff_ub, (2, 7))\n    \n    # Choose two distinct colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Remove the background color from the color pool\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (2 to 9)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly select colors from the remaining color pool\n    ccols = sample(remcols, ncols)\n    \n    # Generate all possible indices for the canvas\n    inds = asindices(canvas(bgc, (h, w)))\n    \n    # Randomly determine the number of locations for the shape (0 to half of total cells)\n    nlocsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose between nlocsd and its complement, ensuring at least 3 locations\n    nlocs = choice((nlocsd, h * w - nlocsd))\n    nlocs = min(max(3, nlocs), h * w - 1)\n    \n    # Choose a starting point for the shape\n    sp = choice(totuple(inds))\n    \n    # Remove the starting point from available indices\n    inds = remove(sp, inds)\n    \n    # Initialize the shape with the starting point\n    shp = {sp}\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nlocs):\n        ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the normalized shape\n    h, w = shape(shp)\n    \n    # Create a canvas with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Fill the shape with the foreground color on the canvas\n    objbase = fill(canv, fgc, shp)\n    \n    # Calculate maximum possible scaling factors\n    maxhscf = (2*h+h+1) // h\n    maxwscf = (2*w+w+1) // w\n    \n    # Randomly choose scaling factors for height and width\n    hscf = unifint(diff_lb, diff_ub, (2, maxhscf))\n    wscf = unifint(diff_lb, diff_ub, (2, maxwscf))\n    \n    # Scale up the base object\n    obj = asobject(hupscale(vupscale(objbase, hscf), wscf))\n    \n    # Get the dimensions of the scaled object\n    oh, ow = shape(obj)\n    \n    # Generate all possible indices for the canvas\n    inds = asindices(canv)\n    \n    # Create a new object with random colors from ccols\n    objx = {(choice(ccols), ij) for ij in inds}\n    \n    # Ensure at least two colors are used in objx\n    if len(palette(objx)) == 1:\n        objxodo = first(objx)\n        objx = insert((choice(remove(objxodo[0], ccols)), objxodo[1]), remove(objxodo, objx))\n    \n    # Randomly determine the full height and width of the input grid\n    fullh = unifint(diff_lb, diff_ub, (hscf*h+h+1, 30))\n    fullw = unifint(diff_lb, diff_ub, (wscf*w+w+1, 30))\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (fullh, fullw))\n    \n    # Generate all possible indices for the full grid\n    fullinds = asindices(gi)\n    \n    # Loop to place the scaled object and the new object on the input grid\n    while True:\n        # Choose a random location for the scaled object\n        loci = randint(0, fullh - oh)\n        locj = randint(0, fullw - ow)\n        loc = (loci, locj)\n        \n        # Place the scaled object on the input grid\n        gix = paint(gi, shift(obj, loc))\n        \n        # Get the indices of the foreground color\n        ofc = ofcolor(gix, fgc)\n        \n        # Calculate the remaining space\n        delt = (fullinds - ofc)\n        \n        # Calculate the space not adjacent to the scaled object\n        delt2 = delt - mapply(neighbors, ofc)\n        \n        # Find valid locations for placing the new object\n        scands = sfilter(\n            delt2,\n            lambda ij: ij[0] <= fullh - oh and ij[1] <= fullw - ow\n        )\n        \n        # If no valid locations, try again\n        if len(scands) == 0:\n            continue\n        \n        # Choose a random location for the new object\n        locc = choice(totuple(scands))\n        \n        # Shift the new object to the chosen location\n        shftd = shift(objx, locc)\n        \n        # If the new object fits, place it and break the loop\n        if toindices(shftd).issubset(delt2):\n            gi = paint(gix, shftd)\n            break\n    \n    # Create the output grid by painting the new object on the canvas\n    go = paint(canv, objx)\n    \n    # Fill the background of the output grid\n    go = fill(go, bgc, ofcolor(objbase, bgc))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "6f8cd79b": {
    "original": "def generate_6f8cd79b(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    ncells = unifint(diff_lb, diff_ub, (0, h * w))\n    inds = asindices(gi)\n    cells = sample(totuple(inds), ncells)\n    obj = {(choice(ccols), ij) for ij in cells}\n    gi = paint(gi, obj)\n    brd = box(inds)\n    go = fill(gi, 8, brd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6f8cd79b(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create an empty grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Choose a random number of colors to use (1-8) based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Choose a random number of cells to color, based on difficulty\n    ncells = unifint(diff_lb, diff_ub, (0, h * w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Randomly select cells to be colored\n    cells = sample(totuple(inds), ncells)\n    \n    # Create an object with randomly colored cells\n    obj = {(choice(ccols), ij) for ij in cells}\n    \n    # Paint the randomly colored cells onto the input grid\n    gi = paint(gi, obj)\n    \n    # Get the indices for the border of the grid\n    brd = box(inds)\n    \n    # Create the output grid by filling the border with color 8\n    go = fill(gi, 8, brd)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "6fa7a44f": {
    "original": "def generate_6fa7a44f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = vconcat(gi, hmirror(gi))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_6fa7a44f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 1 and 15 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Generate a random width between 1 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of unique colors to use (excluding background)\n    # Limited by either 9 or the total number of cells, whichever is smaller\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select the colors to be used\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the input grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        # At least 1, at most all remaining cells divided by number of colors\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select the cells to be filled\n        chos = sample(inds, num)\n        \n        # Fill the selected cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by vertically concatenating the input grid\n    # with its horizontal mirror image\n    go = vconcat(gi, hmirror(gi))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "72322fa7": {
    "original": "def generate_72322fa7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nobjs = unifint(diff_lb, diff_ub, (1, 4))\n    ccols = sample(remcols, 2*nobjs)\n    cpairs = list(zip(ccols[:nobjs], ccols[nobjs:]))\n    objs = []\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    for ca, cb in cpairs:\n        oh = unifint(diff_lb, diff_ub, (1, 4))\n        ow = unifint(diff_lb, diff_ub, (2 if oh == 1 else 1, 4))\n        if choice((True, False)):\n            oh, ow = ow, oh\n        bounds = asindices(canvas(-1, (oh, ow)))\n        obj = {choice(totuple(bounds))}\n        ncells = randint(2, oh * ow)\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        objn = normalize(obj)\n        objt = totuple(objn)\n        apart = sample(objt, randint(1, len(objt) - 1))\n        bpart = difference(objt, apart)\n        obj = recolor(ca, set(apart)) | recolor(cb, set(bpart))\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: shift(objn, ij).issubset(inds))\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        gi = paint(gi, plcd)\n        plcdi = toindices(plcd)\n        inds = (inds - plcdi) - mapply(neighbors, plcdi)\n        objs.append(obj)\n    avgs = sum([len(o) for o in objs]) / len(objs)\n    ub = max(1, (h * w) // (avgs * 2))\n    noccs = unifint(diff_lb, diff_ub, (1, ub))\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    go = tuple(e for e in gi)\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        obj = choice(objs)\n        ca, cb = list(palette(obj))\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            succ += 1\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n            go = paint(go, plcd)\n            col = choice((ca, cb))\n            gi = paint(gi, sfilter(plcd, lambda cij: cij[0] == col))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_72322fa7(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Generate random number of objects (1 to 4) based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # Sample colors for objects (2 colors per object)\n    ccols = sample(remcols, 2*nobjs)\n    \n    # Pair the colors for each object\n    cpairs = list(zip(ccols[:nobjs], ccols[nobjs:]))\n    \n    # Initialize empty list to store objects\n    objs = []\n    \n    # Create initial grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Loop through each color pair to create objects\n    for ca, cb in cpairs:\n        # Generate random height for object (1 to 4)\n        oh = unifint(diff_lb, diff_ub, (1, 4))\n        \n        # Generate random width for object (1 to 4, but at least 2 if height is 1)\n        ow = unifint(diff_lb, diff_ub, (2 if oh == 1 else 1, 4))\n        \n        # 50% chance to swap height and width\n        if choice((True, False)):\n            oh, ow = ow, oh\n        \n        # Create bounds for the object\n        bounds = asindices(canvas(-1, (oh, ow)))\n        \n        # Start with a single random cell for the object\n        obj = {choice(totuple(bounds))}\n        \n        # Randomly determine number of cells for the object\n        ncells = randint(2, oh * ow)\n        \n        # Grow the object by adding neighboring cells\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        \n        # Normalize the object's position\n        objn = normalize(obj)\n        objt = totuple(objn)\n        \n        # Split the object into two parts for two colors\n        apart = sample(objt, randint(1, len(objt) - 1))\n        bpart = difference(objt, apart)\n        \n        # Color the two parts of the object\n        obj = recolor(ca, set(apart)) | recolor(cb, set(bpart))\n        \n        # Get the shape of the object\n        oh, ow = shape(obj)\n        \n        # Find valid positions to place the object\n        cands = sfilter(inds, lambda ij: shift(objn, ij).issubset(inds))\n        \n        # If no valid positions, skip this object\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        \n        # Place the object on the grid\n        plcd = shift(obj, loc)\n        gi = paint(gi, plcd)\n        \n        # Update available indices\n        plcdi = toindices(plcd)\n        inds = (inds - plcdi) - mapply(neighbors, plcdi)\n        \n        # Add the object to the list\n        objs.append(obj)\n    \n    # Calculate average size of objects\n    avgs = sum([len(o) for o in objs]) / len(objs)\n    \n    # Calculate upper bound for number of occurrences\n    ub = max(1, (h * w) // (avgs * 2))\n    \n    # Generate random number of occurrences based on difficulty\n    noccs = unifint(diff_lb, diff_ub, (1, ub))\n    \n    # Initialize counters for successful placements and trials\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    \n    # Create output grid\n    go = tuple(e for e in gi)\n    \n    # Loop to place additional occurrences of objects\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        \n        # Choose a random object\n        obj = choice(objs)\n        \n        # Get the two colors of the object\n        ca, cb = list(palette(obj))\n        \n        # Get the shape of the object\n        oh, ow = shape(obj)\n        \n        # Find valid positions to place the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, try again\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        \n        # Place the object\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        \n        # If placement is valid, update grids and counters\n        if plcdi.issubset(inds):\n            succ += 1\n            inds = (inds - plcdi) - mapply(neighbors, plcdi)\n            go = paint(go, plcd)\n            \n            # Choose one of the object's colors randomly\n            col = choice((ca, cb))\n            \n            # Paint only cells of the chosen color on the input grid\n            gi = paint(gi, sfilter(plcd, lambda cij: cij[0] == col))\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "72ca375d": {
    "original": "def generate_72ca375d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    srcobjh = unifint(diff_lb, diff_ub, (2, 8))\n    srcobjwh = unifint(diff_lb, diff_ub, (1, 4))\n    bnds = asindices(canvas(-1, (srcobjh, srcobjwh)))\n    spi = randint(0, srcobjh - 1)\n    sp = (spi, srcobjwh - 1)\n    srcobj = {sp}\n    bnds = remove(sp, bnds)\n    ncellsd = unifint(diff_lb, diff_ub, (0, (srcobjh * srcobjwh) // 2))\n    ncells1 = choice((ncellsd, srcobjh * srcobjwh - ncellsd))\n    ncells2 = unifint(diff_lb, diff_ub, (1, srcobjh * srcobjwh))\n    ncells = (ncells1 + ncells2) // 2\n    ncells = min(max(1, ncells), srcobjh * srcobjwh, (h * w) // 2 - 1)\n    for k in range(ncells - 1):\n        srcobj.add(choice(totuple((bnds - srcobj) & mapply(neighbors, srcobj))))\n    srcobj = normalize(srcobj)\n    srcobj = srcobj | shift(vmirror(srcobj), (0, width(srcobj)))\n    srcobjh, srcobjw = shape(srcobj)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    trgc = choice(remcols)\n    go = canvas(bgc, (srcobjh, srcobjw))\n    go = fill(go, trgc, srcobj)\n    loci = randint(0, h - srcobjh)\n    locj = randint(0, w - srcobjw)\n    locc = (loci, locj)\n    gi = canvas(bgc, (h, w))\n    shftd = shift(srcobj, locc)\n    gi = fill(gi, trgc, shftd)\n    indss = asindices(gi)\n    indss = (indss - shftd) - mapply(neighbors, shftd)\n    maxtrials = 4 * nobjs\n    tr = 0\n    succ = 0\n    remcands = asindices(canvas(-1, (8, 8))) - srcobj\n    while succ < nobjs and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        while True:\n            newobj = {e for e in srcobj}\n            numperti = unifint(diff_lb, diff_ub, (1, 63))\n            numpert = 64 - numperti\n            for np in range(numpert):\n                isadd = choice((True, False))\n                if isadd and len(newobj) < 64:\n                    cndds = totuple((remcands - newobj) & mapply(neighbors, newobj))\n                    if len(cndds) == 0:\n                        break\n                    newobj.add(choice(cndds))\n                if not isadd and len(newobj) > 2:\n                    newobj = remove(choice(totuple(newobj)), newobj)\n            newobj = normalize(newobj)\n            a, b = shape(newobj)\n            cc = canvas(-1, (a+2, b+2))\n            cc2 = compress(fill(cc, -2, shift(newobj, (1, 1))))\n            newobj = toindices(argmax(colorfilter(objects(cc2, T, T, F), -2), size))\n            if newobj != vmirror(newobj):\n                break\n        col = choice(remcols)\n        loccands = sfilter(indss, lambda ij: shift(newobj, ij).issubset(indss))\n        if len(loccands) == 0:\n            tr += 1\n            continue\n        locc = choice(totuple(loccands))\n        newobj = shift(newobj, locc)\n        gi = fill(gi, col, newobj)\n        succ += 1\n        indss = (indss - newobj) - mapply(neighbors, newobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_72ca375d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Randomly choose height between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Randomly choose width between 10 and 30\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))  # Determine number of objects to place on the grid\n    srcobjh = unifint(diff_lb, diff_ub, (2, 8))  # Choose height for the source object between 2 and 8\n    srcobjwh = unifint(diff_lb, diff_ub, (1, 4))  # Choose width for the source object between 1 and 4\n    bnds = asindices(canvas(-1, (srcobjh, srcobjwh)))  # Create a set of all possible indices for the source object\n    spi = randint(0, srcobjh - 1)  # Choose a random starting point for the source object (row)\n    sp = (spi, srcobjwh - 1)  # Set the starting point (rightmost column of the chosen row)\n    srcobj = {sp}  # Initialize the source object with the starting point\n    bnds = remove(sp, bnds)  # Remove the starting point from the available indices\n    ncellsd = unifint(diff_lb, diff_ub, (0, (srcobjh * srcobjwh) // 2))  # Choose a number for difficulty calculation\n    ncells1 = choice((ncellsd, srcobjh * srcobjwh - ncellsd))  # Choose between two options for number of cells\n    ncells2 = unifint(diff_lb, diff_ub, (1, srcobjh * srcobjwh))  # Choose another number of cells\n    ncells = (ncells1 + ncells2) // 2  # Calculate average of the two cell counts\n    ncells = min(max(1, ncells), srcobjh * srcobjwh, (h * w) // 2 - 1)  # Ensure ncells is within valid range\n    for k in range(ncells - 1):\n        # Grow the source object by adding neighboring cells\n        srcobj.add(choice(totuple((bnds - srcobj) & mapply(neighbors, srcobj))))\n    srcobj = normalize(srcobj)  # Move the source object to the origin\n    srcobj = srcobj | shift(vmirror(srcobj), (0, width(srcobj)))  # Make the object symmetric by mirroring\n    srcobjh, srcobjw = shape(srcobj)  # Get the final dimensions of the source object\n    bgc = choice(cols)  # Choose a background color\n    remcols = remove(bgc, cols)  # Remove the background color from available colors\n    trgc = choice(remcols)  # Choose a target color different from the background\n    go = canvas(bgc, (srcobjh, srcobjw))  # Create the output grid with background color\n    go = fill(go, trgc, srcobj)  # Fill the source object shape with the target color in the output grid\n    loci = randint(0, h - srcobjh)  # Choose a random vertical position for the source object in the input grid\n    locj = randint(0, w - srcobjw)  # Choose a random horizontal position for the source object in the input grid\n    locc = (loci, locj)  # Combine the chosen position coordinates\n    gi = canvas(bgc, (h, w))  # Create the input grid with background color\n    shftd = shift(srcobj, locc)  # Move the source object to its position in the input grid\n    gi = fill(gi, trgc, shftd)  # Place the source object in the input grid\n    indss = asindices(gi)  # Get all indices of the input grid\n    indss = (indss - shftd) - mapply(neighbors, shftd)  # Remove the source object and its neighbors from available indices\n    maxtrials = 4 * nobjs  # Set maximum number of attempts to place objects\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize successful placements counter\n    remcands = asindices(canvas(-1, (8, 8))) - srcobj  # Calculate remaining candidates for object modification\n    while succ < nobjs and tr <= maxtrials:\n        if len(indss) == 0:\n            break  # Stop if no more space is available\n        while True:\n            newobj = {e for e in srcobj}  # Create a copy of the source object\n            numperti = unifint(diff_lb, diff_ub, (1, 63))  # Choose number of perturbations\n            numpert = 64 - numperti  # Calculate complementary number of perturbations\n            for np in range(numpert):\n                isadd = choice((True, False))  # Randomly choose to add or remove a cell\n                if isadd and len(newobj) < 64:\n                    # Add a neighboring cell if possible\n                    cndds = totuple((remcands - newobj) & mapply(neighbors, newobj))\n                    if len(cndds) == 0:\n                        break\n                    newobj.add(choice(cndds))\n                if not isadd and len(newobj) > 2:\n                    # Remove a random cell if the object has more than 2 cells\n                    newobj = remove(choice(totuple(newobj)), newobj)\n            newobj = normalize(newobj)  # Move the new object to the origin\n            a, b = shape(newobj)  # Get dimensions of the new object\n            cc = canvas(-1, (a+2, b+2))  # Create a canvas slightly larger than the new object\n            cc2 = compress(fill(cc, -2, shift(newobj, (1, 1))))  # Fill and compress the canvas\n            newobj = toindices(argmax(colorfilter(objects(cc2, T, T, F), -2), size))  # Extract the largest object\n            if newobj != vmirror(newobj):\n                break  # Accept the new object if it's not symmetric\n        col = choice(remcols)  # Choose a color for the new object\n        loccands = sfilter(indss, lambda ij: shift(newobj, ij).issubset(indss))  # Find possible locations for the new object\n        if len(loccands) == 0:\n            tr += 1  # Increment trial counter if no valid location found\n            continue\n        locc = choice(totuple(loccands))  # Choose a random valid location\n        newobj = shift(newobj, locc)  # Move the new object to its chosen location\n        gi = fill(gi, col, newobj)  # Place the new object on the input grid\n        succ += 1  # Increment successful placements counter\n        indss = (indss - newobj) - mapply(neighbors, newobj)  # Update available indices\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "73251a56": {
    "original": "def generate_73251a56(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    while True:\n        d = unifint(diff_lb, diff_ub, (10, 30))\n        h, w = d, d\n        noisec = choice(cols)\n        remcols = remove(noisec, cols)\n        nsl = unifint(diff_lb, diff_ub, (2, min(9, h//2)))\n        slopes = [0] + sorted(sample(interval(1, h-1, 1), nsl - 1))\n        ccols = sample(cols, nsl)\n        gi = canvas(-1, (h, w))\n        inds = asindices(gi)\n        for col, hdelt in zip(ccols, slopes):\n            slope = hdelt / w\n            locs = sfilter(inds, lambda ij: slope * ij[1] <= ij[0])\n            gi = fill(gi, col, locs)\n        ln = connect((0, 0), (d - 1, d - 1))\n        gi = fill(gi, ccols[-2], ln)\n        obj = asobject(gi)\n        obj = sfilter(obj, lambda cij: cij[1][1] >= cij[1][0])\n        gi = paint(gi, dmirror(obj))\n        cf1 = lambda g: ccols[-2] in palette(toobject(ln, g))\n        cf2 = lambda g: len((ofcolor(g, noisec) & frozenset({ij[::-1] for ij in ofcolor(g, noisec)})) - ln) == 0\n        ndist = unifint(diff_lb, diff_ub, (1, (h * w) // 15))\n        tr = 0\n        succ = 0\n        maxtr = 10 * ndist\n        go = tuple(e for e in gi)\n        while tr < maxtr and succ < ndist:\n            tr += 1\n            oh = randint(1, 5)\n            ow = randint(1, 5)\n            loci = randint(1, h - oh - 1)\n            locj = randint(1, w - ow - 1)\n            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n            gi2 = fill(gi, noisec, bd)\n            if cf1(gi2) and cf2(gi2):\n                succ += 1\n                gi = gi2\n        if gi != go:\n            break\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_73251a56(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a tuple of integers from 0 to 9\n    while True:  # Start an infinite loop\n        d = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random integer between 10 and 30 based on difficulty\n        h, w = d, d  # Set height and width of the grid to the same random value\n        noisec = choice(cols)  # Choose a random color for noise\n        remcols = remove(noisec, cols)  # Remove the noise color from the list of available colors\n        nsl = unifint(diff_lb, diff_ub, (2, min(9, h//2)))  # Generate a random number of slopes between 2 and min(9, h//2)\n        slopes = [0] + sorted(sample(interval(1, h-1, 1), nsl - 1))  # Create a list of sorted random slopes\n        ccols = sample(cols, nsl)  # Sample colors for each slope\n        gi = canvas(-1, (h, w))  # Create an empty grid filled with -1\n        inds = asindices(gi)  # Get all indices of the grid\n        for col, hdelt in zip(ccols, slopes):  # Iterate over colors and slopes\n            slope = hdelt / w  # Calculate the actual slope\n            locs = sfilter(inds, lambda ij: slope * ij[1] <= ij[0])  # Find locations below the slope line\n            gi = fill(gi, col, locs)  # Fill the grid with the color below the slope line\n        ln = connect((0, 0), (d - 1, d - 1))  # Create a diagonal line from top-left to bottom-right\n        gi = fill(gi, ccols[-2], ln)  # Fill the diagonal line with the second-to-last color\n        obj = asobject(gi)  # Convert the grid to an object\n        obj = sfilter(obj, lambda cij: cij[1][1] >= cij[1][0])  # Keep only the lower triangle of the grid\n        gi = paint(gi, dmirror(obj))  # Mirror the lower triangle to create the upper triangle\n        cf1 = lambda g: ccols[-2] in palette(toobject(ln, g))  # Condition: diagonal line color is present\n        cf2 = lambda g: len((ofcolor(g, noisec) & frozenset({ij[::-1] for ij in ofcolor(g, noisec)})) - ln) == 0  # Condition: noise doesn't overlap with diagonal\n        ndist = unifint(diff_lb, diff_ub, (1, (h * w) // 15))  # Generate number of noise rectangles\n        tr = 0  # Initialize trial counter\n        succ = 0  # Initialize success counter\n        maxtr = 10 * ndist  # Set maximum number of trials\n        go = tuple(e for e in gi)  # Create a copy of the initial grid\n        while tr < maxtr and succ < ndist:  # Loop to add noise rectangles\n            tr += 1  # Increment trial counter\n            oh = randint(1, 5)  # Generate random height for noise rectangle\n            ow = randint(1, 5)  # Generate random width for noise rectangle\n            loci = randint(1, h - oh - 1)  # Generate random row for noise rectangle\n            locj = randint(1, w - ow - 1)  # Generate random column for noise rectangle\n            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))  # Create backdrop for noise rectangle\n            gi2 = fill(gi, noisec, bd)  # Fill the backdrop with noise color\n            if cf1(gi2) and cf2(gi2):  # Check if conditions are still met after adding noise\n                succ += 1  # Increment success counter\n                gi = gi2  # Update the grid with the new noise\n        if gi != go:  # Check if any noise was successfully added\n            break  # Exit the main loop if noise was added\n    rotf = choice((identity, rot90, rot180, rot270))  # Choose a random rotation function\n    gi = rotf(gi)  # Apply rotation to the input grid\n    go = rotf(go)  # Apply the same rotation to the output grid\n    return {'input': gi, 'output': go}  # Return the input and output grids as a dictionary\n"
  },
  "7447852a": {
    "original": "def generate_7447852a(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    w = unifint(diff_lb, diff_ub, (2, 8))\n    h = unifint(diff_lb, diff_ub, (w+1, 30))\n    bgc, linc = sample(cols, 2)\n    remcols = remove(bgc, remove(linc, cols))\n    c = canvas(bgc, (h, w))\n    sp = (h - 1, 0)\n    gi = fill(c, linc, {sp})\n    direc = 1\n    while True:\n        sp = add(sp, (-1, direc))\n        if sp[1] == w - 1 or sp[1] == 0:\n            direc *= -1\n        gi2 = fill(gi, linc, {sp})\n        if gi2 == gi:\n            break\n        gi = gi2\n    gi = rot90(gi)\n    objs = objects(gi, T, F, F)\n    inds = ofcolor(gi, bgc)\n    numcols = unifint(diff_lb, diff_ub, (1, 7))\n    ccols = sample(remcols, numcols)\n    ncells = unifint(diff_lb, diff_ub, (0, len(inds)))\n    locs = sample(totuple(inds), ncells)\n    obj = {(choice(ccols), ij) for ij in locs}\n    gi = paint(gi, obj)\n    go = tuple(e for e in gi)\n    objs = order(colorfilter(objs, bgc), leftmost)\n    objs = merge(set(objs[0::3]))\n    go = fill(go, 4, objs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7447852a(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 4 from the range of colors 0 to 9\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Randomly choose width between 2 and 8 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 8))\n    \n    # Randomly choose height between w+1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (w+1, 30))\n    \n    # Randomly select two colors: one for background and one for line\n    bgc, linc = sample(cols, 2)\n    \n    # Remove background and line colors from remaining colors\n    remcols = remove(bgc, remove(linc, cols))\n    \n    # Create a canvas with background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Set starting point at bottom-left corner\n    sp = (h - 1, 0)\n    \n    # Fill the starting point with line color\n    gi = fill(c, linc, {sp})\n    \n    # Set initial direction to right\n    direc = 1\n    \n    # Start drawing the zigzag line\n    while True:\n        # Move the point up and in the current direction\n        sp = add(sp, (-1, direc))\n        \n        # If reached right or left edge, change direction\n        if sp[1] == w - 1 or sp[1] == 0:\n            direc *= -1\n        \n        # Fill the new point with line color\n        gi2 = fill(gi, linc, {sp})\n        \n        # If no change (reached top), break the loop\n        if gi2 == gi:\n            break\n        \n        # Update the grid\n        gi = gi2\n    \n    # Rotate the grid 90 degrees clockwise\n    gi = rot90(gi)\n    \n    # Identify objects in the grid (the zigzag line)\n    objs = objects(gi, T, F, F)\n    \n    # Get indices of background color cells\n    inds = ofcolor(gi, bgc)\n    \n    # Randomly choose number of colors to use (1 to 7)\n    numcols = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Randomly select colors from remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Randomly choose number of cells to color\n    ncells = unifint(diff_lb, diff_ub, (0, len(inds)))\n    \n    # Randomly select cells to color\n    locs = sample(totuple(inds), ncells)\n    \n    # Create an object with randomly colored cells\n    obj = {(choice(ccols), ij) for ij in locs}\n    \n    # Paint the randomly colored cells onto the grid\n    gi = paint(gi, obj)\n    \n    # Convert grid to tuple format\n    go = tuple(e for e in gi)\n    \n    # Order background color objects by leftmost position\n    objs = order(colorfilter(objs, bgc), leftmost)\n    \n    # Select every third object and merge them\n    objs = merge(set(objs[0::3]))\n    \n    # Fill selected objects with color 4 (output modification)\n    go = fill(go, 4, objs)\n    \n    # Return input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "7468f01a": {
    "original": "def generate_7468f01a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    sgc, fgc = sample(remcols, 2)\n    oh = unifint(diff_lb, diff_ub, (2, max(2, int(h * (2/3)))))\n    ow = unifint(diff_lb, diff_ub, (2, max(2, int(w * (2/3)))))\n    gi = canvas(bgc, (h, w))\n    go = canvas(sgc, (oh, ow))\n    bounds = asindices(go)\n    shp = {ORIGIN}\n    nc = unifint(diff_lb, diff_ub, (0, max(1, (oh * ow) // 2)))\n    for j in range(nc):\n        shp.add(choice(totuple((bounds - shp) & mapply(dneighbors, shp))))\n    go = fill(go, fgc, shp)\n    objx = asobject(vmirror(go))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    gi = paint(gi, shift(objx, (loci, locj)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7468f01a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select two colors for the shape and its outline\n    sgc, fgc = sample(remcols, 2)\n    \n    # Determine the height of the output grid (smaller than input)\n    oh = unifint(diff_lb, diff_ub, (2, max(2, int(h * (2/3)))))\n    \n    # Determine the width of the output grid (smaller than input)\n    ow = unifint(diff_lb, diff_ub, (2, max(2, int(w * (2/3)))))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the shape color\n    go = canvas(sgc, (oh, ow))\n    \n    # Get all possible indices in the output grid\n    bounds = asindices(go)\n    \n    # Initialize the shape with the origin point\n    shp = {ORIGIN}\n    \n    # Determine the number of cells to add to the shape\n    nc = unifint(diff_lb, diff_ub, (0, max(1, (oh * ow) // 2)))\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc):\n        # Find available adjacent cells and add one randomly to the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(dneighbors, shp))))\n    \n    # Fill the shape in the output grid with the foreground color\n    go = fill(go, fgc, shp)\n    \n    # Create an object by mirroring the output grid vertically\n    objx = asobject(vmirror(go))\n    \n    # Randomly determine the position to place the mirrored object in the input grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Place the mirrored object in the input grid\n    gi = paint(gi, shift(objx, (loci, locj)))\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "746b3537": {
    "original": "def generate_746b3537(diff_lb: float, diff_ub: float) -> dict:\n    fullcols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    cols = []\n    lastc = -1\n    for k in range(h):\n        c = choice(remove(lastc, fullcols))\n        cols.append(c)\n        lastc = c\n    go = tuple((c,) for c in cols)\n    gi = tuple(repeat(c, w) for c in cols)\n    numinserts = unifint(diff_lb, diff_ub, (1, 30 - h))\n    for k in range(numinserts):\n        loc = randint(0, len(gi) - 1)\n        gi = gi[:loc+1] + gi[loc:]\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_746b3537(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of integers from 0 to 9 (inclusive)\n    fullcols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the grid between 2 and 15\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly choose the width of the grid between 1 and 30\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Initialize an empty list to store column colors\n    cols = []\n    \n    # Initialize the last color used to -1 (invalid color)\n    lastc = -1\n    \n    # Loop to generate a sequence of unique colors for each row\n    for k in range(h):\n        # Choose a random color different from the last one used\n        c = choice(remove(lastc, fullcols))\n        # Add the chosen color to the list\n        cols.append(c)\n        # Update the last color used\n        lastc = c\n    \n    # Create the output grid: each row is a single-cell column with the chosen color\n    go = tuple((c,) for c in cols)\n    \n    # Create the input grid: each row is filled with the chosen color across the width\n    gi = tuple(repeat(c, w) for c in cols)\n    \n    # Randomly choose the number of row duplications to perform\n    numinserts = unifint(diff_lb, diff_ub, (1, 30 - h))\n    \n    # Duplicate random rows in the input grid\n    for k in range(numinserts):\n        # Choose a random location to duplicate\n        loc = randint(0, len(gi) - 1)\n        # Insert a duplicate row at the chosen location\n        gi = gi[:loc+1] + gi[loc:]\n    \n    # 50% chance to diagonally mirror both input and output grids\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "74dd1130": {
    "original": "def generate_74dd1130(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = dmirror(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_74dd1130(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of colors (0 to 9)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a width between 1 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly select a background color from the color tuple\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the color options\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (0 to 9, or less if grid is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select the colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select the cells to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by mirroring the input grid along the diagonal\n    go = dmirror(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "75b8110e": {
    "original": "def generate_75b8110e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c1, c2, c3, c4 = sample(remcols, 4)\n    canv = canvas(bgc, (h, w))\n    cels = totuple(asindices(canv))\n    mp = (h * w) // 2\n    nums = []\n    for k in range(4):\n        dev = unifint(diff_lb, diff_ub, (0, mp))\n        if choice((True, False)):\n            num = h * w - dev\n        else:\n            num = dev\n        num = min(max(0, num), h * w - 1)\n        nums.append(num)\n    s1, s2, s3, s4 = [sample(cels, num) for num in nums]\n    gi1 = fill(canv, c1, s1)\n    gi2 = fill(canv, c2, s2)\n    gi3 = fill(canv, c3, s3)\n    gi4 = fill(canv, c4, s4)\n    gi = vconcat(hconcat(gi1, gi2), hconcat(gi3, gi4))\n    go = fill(gi1, c4, s4)\n    go = fill(go, c3, s3)\n    go = fill(go, c2, s2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_75b8110e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select 4 colors from the remaining colors\n    c1, c2, c3, c4 = sample(remcols, 4)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    canv = canvas(bgc, (h, w))\n    \n    # Get all cell coordinates of the canvas as a tuple\n    cels = totuple(asindices(canv))\n    \n    # Calculate half the number of cells in the grid\n    mp = (h * w) // 2\n    \n    # Initialize an empty list to store the number of cells for each color\n    nums = []\n    \n    # For each of the 4 colors:\n    for k in range(4):\n        # Generate a random deviation based on difficulty\n        dev = unifint(diff_lb, diff_ub, (0, mp))\n        \n        # Randomly decide whether to use the deviation or its complement\n        if choice((True, False)):\n            num = h * w - dev\n        else:\n            num = dev\n        \n        # Ensure the number of cells is within valid range\n        num = min(max(0, num), h * w - 1)\n        \n        # Add the number to the list\n        nums.append(num)\n    \n    # Randomly select cells for each color based on the calculated numbers\n    s1, s2, s3, s4 = [sample(cels, num) for num in nums]\n    \n    # Create four sub-grids, each filled with one of the chosen colors\n    gi1 = fill(canv, c1, s1)\n    gi2 = fill(canv, c2, s2)\n    gi3 = fill(canv, c3, s3)\n    gi4 = fill(canv, c4, s4)\n    \n    # Combine the four sub-grids into one large grid (input grid)\n    gi = vconcat(hconcat(gi1, gi2), hconcat(gi3, gi4))\n    \n    # Create the output grid by layering colors on gi1 in reverse order\n    go = fill(gi1, c4, s4)\n    go = fill(go, c3, s3)\n    go = fill(go, c2, s2)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "760b3cac": {
    "original": "def generate_760b3cac(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    objL = frozenset({(0, 0), (1, 0), (1, 1), (1, 2), (2, 1)})\n    objR = vmirror(objL)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    w = 2 * w + 1\n    bgc, objc, indc = sample(cols, 3)\n    objh = unifint(diff_lb, diff_ub, (1, h - 3))\n    objw = unifint(diff_lb, diff_ub, (1, w // 6))\n    objw = 2 * objw + 1\n    c = canvas(-1, (objh, objw))\n    gi = canvas(bgc, (h, w))\n    if choice((True, False)):\n        obj = objL\n        sgn = -1\n    else:\n        obj = objR\n        sgn = 1\n    gi = fill(gi, indc, shift(obj, (h - 3, w//2 - 1)))\n    inds = asindices(c)\n    sp = choice(totuple(inds))\n    objx = {sp}\n    numcd = unifint(diff_lb, diff_ub, (0, (objh * objw) // 2))\n    numc = choice((numcd, objh * objw - numcd))\n    numc = min(max(1, numc), objh * objw)\n    for k in range(numc - 1):\n        objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))\n    while width(objx) != objw:\n        objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))\n    objx = normalize(objx)\n    objh, objw = shape(objx)\n    loci = randint(0, h - 3 - objh)\n    locj = w//2 - objw//2\n    loc = (loci, locj)\n    plcd = shift(objx, loc)\n    gi = fill(gi, objc, plcd)\n    objx2 = vmirror(plcd)\n    plcd2 = shift(objx2, (0, objw * sgn))\n    go = fill(gi, objc, plcd2)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_760b3cac(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a left-facing L-shaped object\n    objL = frozenset({(0, 0), (1, 0), (1, 1), (1, 2), (2, 1)})\n    \n    # Create a right-facing mirror image of the L-shaped object\n    objR = vmirror(objL)\n    \n    # Randomly determine the height of the grid between 5 and 30\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid (ensuring it's odd)\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    w = 2 * w + 1\n    \n    # Randomly select three distinct colors for background, object, and indicator\n    bgc, objc, indc = sample(cols, 3)\n    \n    # Randomly determine the height of the object\n    objh = unifint(diff_lb, diff_ub, (1, h - 3))\n    \n    # Randomly determine the width of the object (ensuring it's odd)\n    objw = unifint(diff_lb, diff_ub, (1, w // 6))\n    objw = 2 * objw + 1\n    \n    # Create a canvas for the object\n    c = canvas(-1, (objh, objw))\n    \n    # Create the initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly choose between left and right facing L-shape\n    if choice((True, False)):\n        obj = objL\n        sgn = -1  # Direction modifier for later use\n    else:\n        obj = objR\n        sgn = 1\n    \n    # Place the indicator L-shape at the bottom center of the grid\n    gi = fill(gi, indc, shift(obj, (h - 3, w//2 - 1)))\n    \n    # Get all indices of the object canvas\n    inds = asindices(c)\n    \n    # Choose a random starting point for the object\n    sp = choice(totuple(inds))\n    objx = {sp}\n    \n    # Determine the number of cells to fill in the object\n    numcd = unifint(diff_lb, diff_ub, (0, (objh * objw) // 2))\n    numc = choice((numcd, objh * objw - numcd))\n    numc = min(max(1, numc), objh * objw)\n    \n    # Grow the object by adding adjacent cells\n    for k in range(numc - 1):\n        objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))\n    \n    # Ensure the object reaches the desired width\n    while width(objx) != objw:\n        objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))\n    \n    # Normalize the object's position\n    objx = normalize(objx)\n    \n    # Get the final shape of the object\n    objh, objw = shape(objx)\n    \n    # Determine the location to place the object\n    loci = randint(0, h - 3 - objh)\n    locj = w//2 - objw//2\n    loc = (loci, locj)\n    \n    # Place the object on the grid\n    plcd = shift(objx, loc)\n    gi = fill(gi, objc, plcd)\n    \n    # Create a mirrored version of the object\n    objx2 = vmirror(plcd)\n    \n    # Place the mirrored object next to the original\n    plcd2 = shift(objx2, (0, objw * sgn))\n    go = fill(gi, objc, plcd2)\n    \n    # Randomly rotate both input and output grids\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "776ffc46": {
    "original": "def generate_776ffc46(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, sqc, inc, outc = sample(cols, 4)\n    gi = canvas(bgc, (h, w))\n    sqh = randint(3, h//3+1)\n    sqw = randint(3, w//3+1)\n    loci = randint(0, 3)\n    locj = randint(0, w - sqw)\n    bx = box(frozenset({(loci, locj), (loci + sqh - 1, locj + sqw - 1)}))\n    bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))\n    obj = {choice(totuple(bounds))}\n    ncells = randint(1, (sqh - 2) * (sqw - 2))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    objp = shift(obj, (loci+1+randint(0, sqh-oh-2), locj+1+randint(0, sqw-ow-2)))\n    gi = fill(gi, sqc, bx)\n    gi = fill(gi, inc, objp)\n    inds = (ofcolor(gi, bgc) - backdrop(bx)) - mapply(neighbors, backdrop(bx))\n    cands = sfilter(inds, lambda ij: shift(obj, ij).issubset(inds))\n    loc = choice(totuple(cands))\n    plcd = shift(obj, loc)\n    gi = fill(gi, outc, plcd)\n    inds = (inds - plcd) - mapply(neighbors, plcd)\n    noccs = unifint(diff_lb, diff_ub, (0, (h * w) // 20))\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    fullinds = asindices(gi)\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        if choice((True, False)):\n            sqh = randint(3, h//3+1)\n            sqw = randint(3, w//3+1)\n            bx = box(frozenset({(0, 0), (sqh - 1, sqw - 1)}))\n            bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))\n            obj2 = {choice(totuple(bounds))}\n            ncells = randint(1, (sqh - 2) * (sqw - 2))\n            for k in range(ncells - 1):\n                obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n            if normalize(obj2) == obj:\n                if len(obj2) < (sqh - 2) * (sqw - 2):\n                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n                else:\n                    continue\n            obj2 = normalize(obj2)\n            ooh, oow = shape(obj2)\n            cands1 = connect((-1, -1), (-1, w - sqw + 1))\n            cands2 = connect((h-sqh+1, -1), (h-sqh+1, w - sqw + 1))\n            cands3 = connect((-1, -1), (h - sqh + 1, -1))\n            cands4 = connect((-1, w-sqw+1), (h - sqh + 1, w-sqw+1))\n            cands = cands1 | cands2 | cands3 | cands4\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            sloci, slocj = loc\n            plcdbx = shift(bx, loc)\n            if (backdrop(plcdbx) & fullinds).issubset(inds):\n                succ += 1\n                oloci = randint(sloci+1, sloci+1+randint(0, sqh-ooh-2))\n                olocj = randint(slocj+1, slocj+1+randint(0, sqw-oow-2))\n                gi = fill(gi, sqc, plcdbx)\n                gi = fill(gi, inc, shift(obj2, (oloci, olocj)))\n                inds = inds - backdrop(outbox(plcdbx))\n        else:\n            ooh = randint(1, h//3-1)\n            oow = randint(1, w//3-1)\n            bounds = asindices(canvas(-1, (ooh, oow)))\n            obj2 = {choice(totuple(bounds))}\n            ncells = randint(1, oow * ooh)\n            for k in range(ncells - 1):\n                obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n            if normalize(obj2) == obj:\n                if len(obj2) < ooh * oow:\n                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n                else:\n                    continue\n        if choice((True, False, False)):\n            obj2 = obj\n        obj2 = normalize(obj2)\n        ooh, oow = shape(obj2)\n        for kk in range(randint(1, 3)):\n            cands = sfilter(inds, lambda ij: ij[0] <= h - ooh and ij[1] <= w - oow)\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            plcd = shift(obj2, loc)\n            if plcd.issubset(inds):\n                succ += 1\n                inds = (inds - plcd) - mapply(neighbors, plcd)\n                gi = fill(gi, outc, plcd)\n    objs = objects(gi, T, F, F)\n    objs = colorfilter(objs, outc)\n    objs = mfilter(objs, lambda o: equality(normalize(toindices(o)), obj))\n    go = fill(gi, inc, objs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_776ffc46(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select 4 unique colors for background, square, inside, and outside\n    bgc, sqc, inc, outc = sample(cols, 4)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the height of the square, between 3 and 1/3 of the grid height\n    sqh = randint(3, h//3+1)\n    # Determine the width of the square, between 3 and 1/3 of the grid width\n    sqw = randint(3, w//3+1)\n    \n    # Choose a random starting row for the square, in the top quarter of the grid\n    loci = randint(0, 3)\n    # Choose a random starting column for the square\n    locj = randint(0, w - sqw)\n    \n    # Create the outline of the square\n    bx = box(frozenset({(loci, locj), (loci + sqh - 1, locj + sqw - 1)}))\n    \n    # Create a set of all possible cell locations within the square (excluding the border)\n    bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))\n    \n    # Start creating the inner object by choosing a random cell\n    obj = {choice(totuple(bounds))}\n    \n    # Determine how many cells the inner object will have\n    ncells = randint(1, (sqh - 2) * (sqw - 2))\n    \n    # Grow the inner object by adding adjacent cells\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n    \n    # Normalize the object's position (move it to the top-left corner)\n    obj = normalize(obj)\n    \n    # Get the dimensions of the normalized object\n    oh, ow = shape(obj)\n    \n    # Place the object randomly within the square\n    objp = shift(obj, (loci+1+randint(0, sqh-oh-2), locj+1+randint(0, sqw-ow-2)))\n    \n    # Draw the square on the grid\n    gi = fill(gi, sqc, bx)\n    \n    # Draw the inner object on the grid\n    gi = fill(gi, inc, objp)\n    \n    # Find all background cells that are not part of or adjacent to the square\n    inds = (ofcolor(gi, bgc) - backdrop(bx)) - mapply(neighbors, backdrop(bx))\n    \n    # Find all valid positions where the object can be placed outside the square\n    cands = sfilter(inds, lambda ij: shift(obj, ij).issubset(inds))\n    \n    # Choose a random valid position and place the object there\n    loc = choice(totuple(cands))\n    plcd = shift(obj, loc)\n    gi = fill(gi, outc, plcd)\n    \n    # Update the available space by removing the placed object and its neighbors\n    inds = (inds - plcd) - mapply(neighbors, plcd)\n    \n    # Determine how many more occurrences to add based on difficulty\n    noccs = unifint(diff_lb, diff_ub, (0, (h * w) // 20))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    \n    # Get all cell indices in the grid\n    fullinds = asindices(gi)\n    \n    # Main loop for adding additional occurrences\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        if choice((True, False)):\n            # Create a new square with a potentially different object inside\n            sqh = randint(3, h//3+1)\n            sqw = randint(3, w//3+1)\n            bx = box(frozenset({(0, 0), (sqh - 1, sqw - 1)}))\n            bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))\n            obj2 = {choice(totuple(bounds))}\n            ncells = randint(1, (sqh - 2) * (sqw - 2))\n            for k in range(ncells - 1):\n                obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n            if normalize(obj2) == obj:\n                if len(obj2) < (sqh - 2) * (sqw - 2):\n                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n                else:\n                    continue\n            obj2 = normalize(obj2)\n            ooh, oow = shape(obj2)\n            \n            # Find valid positions along the edges of the grid to place the new square\n            cands1 = connect((-1, -1), (-1, w - sqw + 1))\n            cands2 = connect((h-sqh+1, -1), (h-sqh+1, w - sqw + 1))\n            cands3 = connect((-1, -1), (h - sqh + 1, -1))\n            cands4 = connect((-1, w-sqw+1), (h - sqh + 1, w-sqw+1))\n            cands = cands1 | cands2 | cands3 | cands4\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            sloci, slocj = loc\n            plcdbx = shift(bx, loc)\n            \n            # If the placement is valid, add the square and object to the grid\n            if (backdrop(plcdbx) & fullinds).issubset(inds):\n                succ += 1\n                oloci = randint(sloci+1, sloci+1+randint(0, sqh-ooh-2))\n                olocj = randint(slocj+1, slocj+1+randint(0, sqw-oow-2))\n                gi = fill(gi, sqc, plcdbx)\n                gi = fill(gi, inc, shift(obj2, (oloci, olocj)))\n                inds = inds - backdrop(outbox(plcdbx))\n        else:\n            # Create a new object without a surrounding square\n            ooh = randint(1, h//3-1)\n            oow = randint(1, w//3-1)\n            bounds = asindices(canvas(-1, (ooh, oow)))\n            obj2 = {choice(totuple(bounds))}\n            ncells = randint(1, oow * ooh)\n            for k in range(ncells - 1):\n                obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n            if normalize(obj2) == obj:\n                if len(obj2) < ooh * oow:\n                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))\n                else:\n                    continue\n        \n        # Sometimes use the original object instead of the new one\n        if choice((True, False, False)):\n            obj2 = obj\n        obj2 = normalize(obj2)\n        ooh, oow = shape(obj2)\n        \n        # Try to place the object 1-3 times\n        for kk in range(randint(1, 3)):\n            cands = sfilter(inds, lambda ij: ij[0] <= h - ooh and ij[1] <= w - oow)\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            plcd = shift(obj2, loc)\n            if plcd.issubset(inds):\n                succ += 1\n                inds = (inds - plcd) - mapply(neighbors, plcd)\n                gi = fill(gi, outc, plcd)\n    \n    # Find all objects of the 'outc' color that match the original object shape\n    objs = objects(gi, T, F, F)\n    objs = colorfilter(objs, outc)\n    objs = mfilter(objs, lambda o: equality(normalize(toindices(o)), obj))\n    \n    # Create the output grid by filling all matching objects with the 'inc' color\n    go = fill(gi, inc, objs)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "77fdfe62": {
    "original": "def generate_77fdfe62(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 13))\n    w = unifint(diff_lb, diff_ub, (1, 13))\n    c1, c2, c3, c4, barc, bgc, inc = sample(cols, 7)\n    qd = canvas(bgc, (h, w))\n    inds = totuple(asindices(qd))\n    fullh = 2 * h + 4\n    fullw = 2 * w + 4\n    n1 = unifint(diff_lb, diff_ub, (1, h * w))\n    n2 = unifint(diff_lb, diff_ub, (1, h * w))\n    n3 = unifint(diff_lb, diff_ub, (1, h * w))\n    n4 = unifint(diff_lb, diff_ub, (1, h * w))\n    i1 = sample(inds, n1)\n    i2 = sample(inds, n2)\n    i3 = sample(inds, n3)\n    i4 = sample(inds, n4)\n    gi = canvas(bgc, (2 * h + 4, 2 * w + 4))\n    gi = fill(gi, barc, connect((1, 0), (1, fullw - 1)))\n    gi = fill(gi, barc, connect((fullh - 2, 0), (fullh - 2, fullw - 1)))\n    gi = fill(gi, barc, connect((0, 1), (fullh - 1, 1)))\n    gi = fill(gi, barc, connect((0, fullw - 2), (fullh - 1, fullw - 2)))\n    gi = fill(gi, c1, {(0, 0)})\n    gi = fill(gi, c2, {(0, fullw - 1)})\n    gi = fill(gi, c3, {(fullh - 1, 0)})\n    gi = fill(gi, c4, {(fullh - 1, fullw - 1)})\n    gi = fill(gi, inc, shift(i1, (2, 2)))\n    gi = fill(gi, inc, shift(i2, (2, 2+w)))\n    gi = fill(gi, inc, shift(i3, (2+h, 2)))\n    gi = fill(gi, inc, shift(i4, (2+h, 2+w)))\n    go = canvas(bgc, (2 * h, 2 * w))\n    go = fill(go, c1, shift(i1, (0, 0)))\n    go = fill(go, c2, shift(i2, (0, w)))\n    go = fill(go, c3, shift(i3, (h, 0)))\n    go = fill(go, c4, shift(i4, (h, w)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_77fdfe62(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate height within range [1, 13] based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 13))\n    \n    # Randomly generate width within range [1, 13] based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 13))\n    \n    # Randomly select 7 unique colors from cols\n    c1, c2, c3, c4, barc, bgc, inc = sample(cols, 7)\n    \n    # Create a canvas filled with background color (bgc) of size h x w\n    qd = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(qd))\n    \n    # Calculate full height and width of the input grid (including border)\n    fullh = 2 * h + 4\n    fullw = 2 * w + 4\n    \n    # Randomly generate number of cells to fill in each quadrant\n    n1 = unifint(diff_lb, diff_ub, (1, h * w))\n    n2 = unifint(diff_lb, diff_ub, (1, h * w))\n    n3 = unifint(diff_lb, diff_ub, (1, h * w))\n    n4 = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Randomly select indices for each quadrant\n    i1 = sample(inds, n1)\n    i2 = sample(inds, n2)\n    i3 = sample(inds, n3)\n    i4 = sample(inds, n4)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (2 * h + 4, 2 * w + 4))\n    \n    # Add horizontal border lines\n    gi = fill(gi, barc, connect((1, 0), (1, fullw - 1)))\n    gi = fill(gi, barc, connect((fullh - 2, 0), (fullh - 2, fullw - 1)))\n    \n    # Add vertical border lines\n    gi = fill(gi, barc, connect((0, 1), (fullh - 1, 1)))\n    gi = fill(gi, barc, connect((0, fullw - 2), (fullh - 1, fullw - 2)))\n    \n    # Add corner colors\n    gi = fill(gi, c1, {(0, 0)})  # Top-left corner\n    gi = fill(gi, c2, {(0, fullw - 1)})  # Top-right corner\n    gi = fill(gi, c3, {(fullh - 1, 0)})  # Bottom-left corner\n    gi = fill(gi, c4, {(fullh - 1, fullw - 1)})  # Bottom-right corner\n    \n    # Fill each quadrant with selected indices using inc color\n    gi = fill(gi, inc, shift(i1, (2, 2)))  # Top-left quadrant\n    gi = fill(gi, inc, shift(i2, (2, 2+w)))  # Top-right quadrant\n    gi = fill(gi, inc, shift(i3, (2+h, 2)))  # Bottom-left quadrant\n    gi = fill(gi, inc, shift(i4, (2+h, 2+w)))  # Bottom-right quadrant\n    \n    # Create output grid with background color\n    go = canvas(bgc, (2 * h, 2 * w))\n    \n    # Fill each quadrant of output grid with corresponding color and indices\n    go = fill(go, c1, shift(i1, (0, 0)))  # Top-left quadrant\n    go = fill(go, c2, shift(i2, (0, w)))  # Top-right quadrant\n    go = fill(go, c3, shift(i3, (h, 0)))  # Bottom-left quadrant\n    go = fill(go, c4, shift(i4, (h, w)))  # Bottom-right quadrant\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "780d0b14": {
    "original": "def generate_780d0b14(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    nh = unifint(diff_lb, diff_ub, (2, 6))\n    nw = unifint(diff_lb, diff_ub, (2, 6))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (3, 9))\n    ccols = sample(remcols, ncols)\n    go = canvas(-1, (nh, nw))\n    obj = {(choice(ccols), ij) for ij in asindices(go)}\n    go = paint(go, obj)\n    while len(dedupe(go)) < nh or len(dedupe(dmirror(go))) < nw:\n        obj = {(choice(ccols), ij) for ij in asindices(go)}\n        go = paint(go, obj)\n    h = unifint(diff_lb, diff_ub, (2*nh+nh-1, 30))\n    w = unifint(diff_lb, diff_ub, (2*nw+nw-1, 30))\n    hdist = [2 for k in range(nh)]\n    for k in range(h - 2 * nh - nh + 1):\n        idx = randint(0, nh - 1)\n        hdist[idx] += 1\n    wdist = [2 for k in range(nw)]\n    for k in range(w - 2 * nw - nw + 1):\n        idx = randint(0, nw - 1)\n        wdist[idx] += 1\n    gi = merge(tuple(repeat(r, c) + (repeat(bgc, nw),) for r, c in zip(go, hdist)))[:-1]\n    gi = dmirror(merge(tuple(repeat(r, c) + (repeat(bgc, h),) for r, c in zip(dmirror(gi), wdist)))[:-1])\n    objs = objects(gi, T, F, F)\n    bgobjs = colorfilter(objs, bgc)\n    objs = objs - bgobjs\n    for obj in objs:\n        gi = fill(gi, bgc, sample(totuple(toindices(obj)), unifint(diff_lb, diff_ub, (1, len(obj) // 2))))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_780d0b14(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the output grid (between 2 and 6)\n    nh = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Randomly determine the width of the output grid (between 2 and 6)\n    nw = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (between 3 and 9)\n    ncols = unifint(diff_lb, diff_ub, (3, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Create an initial output grid filled with -1\n    go = canvas(-1, (nh, nw))\n    \n    # Create an object by assigning random colors to all cells in the output grid\n    obj = {(choice(ccols), ij) for ij in asindices(go)}\n    \n    # Paint the object onto the output grid\n    go = paint(go, obj)\n    \n    # Ensure that each row and column has at least one unique color\n    while len(dedupe(go)) < nh or len(dedupe(dmirror(go))) < nw:\n        # If not, create a new object with random colors\n        obj = {(choice(ccols), ij) for ij in asindices(go)}\n        # Paint the new object onto the output grid\n        go = paint(go, obj)\n    \n    # Randomly determine the height of the input grid (between 2*nh+nh-1 and 30)\n    h = unifint(diff_lb, diff_ub, (2*nh+nh-1, 30))\n    \n    # Randomly determine the width of the input grid (between 2*nw+nw-1 and 30)\n    w = unifint(diff_lb, diff_ub, (2*nw+nw-1, 30))\n    \n    # Initialize vertical spacing between output grid cells in the input grid\n    hdist = [2 for k in range(nh)]\n    \n    # Randomly increase vertical spacing\n    for k in range(h - 2 * nh - nh + 1):\n        idx = randint(0, nh - 1)\n        hdist[idx] += 1\n    \n    # Initialize horizontal spacing between output grid cells in the input grid\n    wdist = [2 for k in range(nw)]\n    \n    # Randomly increase horizontal spacing\n    for k in range(w - 2 * nw - nw + 1):\n        idx = randint(0, nw - 1)\n        wdist[idx] += 1\n    \n    # Create the input grid by expanding the output grid vertically\n    gi = merge(tuple(repeat(r, c) + (repeat(bgc, nw),) for r, c in zip(go, hdist)))[:-1]\n    \n    # Expand the input grid horizontally\n    gi = dmirror(merge(tuple(repeat(r, c) + (repeat(bgc, h),) for r, c in zip(dmirror(gi), wdist)))[:-1])\n    \n    # Identify all objects in the input grid\n    objs = objects(gi, T, F, F)\n    \n    # Identify background objects\n    bgobjs = colorfilter(objs, bgc)\n    \n    # Remove background objects from the set of all objects\n    objs = objs - bgobjs\n    \n    # For each non-background object, randomly replace some of its cells with the background color\n    for obj in objs:\n        gi = fill(gi, bgc, sample(totuple(toindices(obj)), unifint(diff_lb, diff_ub, (1, len(obj) // 2))))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "7837ac64": {
    "original": "def generate_7837ac64(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    oh = unifint(diff_lb, diff_ub, (2, 6))\n    ow = unifint(diff_lb, diff_ub, (2, 6))\n    bgc, linc = sample(cols, 2)\n    remcols = remove(bgc, remove(linc, cols))\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numcols)\n    go = canvas(bgc, (oh, ow))\n    inds = asindices(go)\n    fullinds = asindices(go)\n    nocc = unifint(diff_lb, diff_ub, (1, oh * ow))\n    for k in range(nocc):\n        mpr = {\n            cc: sfilter(\n                inds | mapply(neighbors, ofcolor(go, cc)),\n                lambda ij: (neighbors(ij) & fullinds).issubset(inds | ofcolor(go, cc))\n            ) for cc in ccols\n        }\n        mpr = [(kk, vv) for kk, vv in mpr.items() if len(vv) > 0]\n        if len(mpr) == 0:\n            break\n        col, locs = choice(mpr)\n        loc = choice(totuple(locs))\n        go = fill(go, col, {loc})\n        inds = remove(loc, inds)\n    obj = fullinds - ofcolor(go, bgc)\n    go = subgrid(obj, go)\n    oh, ow = shape(go)\n    sqsizh = unifint(diff_lb, diff_ub, (2, (30 - oh - 1) // oh))\n    sqsizw = unifint(diff_lb, diff_ub, (2, (30 - ow - 1) // ow))\n    fullh = oh + 1 + oh * sqsizh\n    fullw = ow + 1 + ow * sqsizw\n    gi = canvas(linc, (fullh, fullw))\n    sq = backdrop(frozenset({(0, 0), (sqsizh - 1, sqsizw - 1)}))\n    obj = asobject(go)\n    for col, ij in obj:\n        plcd = shift(sq, add((1, 1), multiply(ij, (sqsizh+1, sqsizw+1))))\n        gi = fill(gi, bgc, plcd)\n        if col != bgc:\n            gi = fill(gi, col, corners(outbox(plcd)))\n    gih = unifint(diff_lb, diff_ub, (fullh, 30))\n    giw = unifint(diff_lb, diff_ub, (fullw, 30))\n    loci = randint(0, gih - fullh)\n    locj = randint(0, giw - fullw)\n    gigi = canvas(bgc, (gih, giw))\n    plcd = shift(asobject(gi), (loci, locj))\n    gigi = paint(gigi, plcd)\n    ulci, ulcj = ulcorner(plcd)\n    lrci, lrcj = lrcorner(plcd)\n    for a in range(ulci, gih+1, sqsizh+1):\n        gigi = fill(gigi, linc, hfrontier((a, 0)))\n    for a in range(ulci, -1, -sqsizh-1):\n        gigi = fill(gigi, linc, hfrontier((a, 0)))\n    for b in range(ulcj, giw+1, sqsizw+1):\n        gigi = fill(gigi, linc, vfrontier((0, b)))\n    for b in range(ulcj, -1, -sqsizw-1):\n        gigi = fill(gigi, linc, vfrontier((0, b)))\n    gi = paint(gigi, plcd)\n    gop = palette(go)\n    while True:\n        go2 = identity(go)\n        for c in set(ccols) & gop:\n            o1 = frozenset({(c, ORIGIN), (bgc, RIGHT), (c, (0, 2))})\n            o2 = dmirror(o1)\n            go2 = fill(go2, c, combine(\n                shift(occurrences(go, o1), RIGHT),\n                shift(occurrences(go, o2), DOWN)\n            ))\n        if go2 == go:\n            break\n        go = go2\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7837ac64(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    oh = unifint(diff_lb, diff_ub, (2, 6))  # Randomly select output height between 2 and 6\n    ow = unifint(diff_lb, diff_ub, (2, 6))  # Randomly select output width between 2 and 6\n    bgc, linc = sample(cols, 2)  # Randomly select background and line colors\n    remcols = remove(bgc, remove(linc, cols))  # Remove background and line colors from available colors\n    numcols = unifint(diff_lb, diff_ub, (1, 8))  # Randomly select number of colors to use (1 to 8)\n    ccols = sample(remcols, numcols)  # Randomly select colors to use in the pattern\n    go = canvas(bgc, (oh, ow))  # Create initial output grid with background color\n    inds = asindices(go)  # Get all indices of the output grid\n    fullinds = asindices(go)  # Store a copy of all indices\n    nocc = unifint(diff_lb, diff_ub, (1, oh * ow))  # Randomly select number of cells to color\n    for k in range(nocc):\n        mpr = {\n            cc: sfilter(\n                inds | mapply(neighbors, ofcolor(go, cc)),\n                lambda ij: (neighbors(ij) & fullinds).issubset(inds | ofcolor(go, cc))\n            ) for cc in ccols\n        }  # For each color, find valid positions to place it\n        mpr = [(kk, vv) for kk, vv in mpr.items() if len(vv) > 0]  # Filter out colors with no valid positions\n        if len(mpr) == 0:\n            break  # If no valid positions left, stop coloring\n        col, locs = choice(mpr)  # Randomly select a color and its valid positions\n        loc = choice(totuple(locs))  # Randomly select a position for the chosen color\n        go = fill(go, col, {loc})  # Color the chosen position with the chosen color\n        inds = remove(loc, inds)  # Remove the colored position from available indices\n    obj = fullinds - ofcolor(go, bgc)  # Get indices of non-background cells\n    go = subgrid(obj, go)  # Crop the output grid to the smallest containing subgrid\n    oh, ow = shape(go)  # Get the new dimensions of the cropped output grid\n    sqsizh = unifint(diff_lb, diff_ub, (2, (30 - oh - 1) // oh))  # Randomly select square height\n    sqsizw = unifint(diff_lb, diff_ub, (2, (30 - ow - 1) // ow))  # Randomly select square width\n    fullh = oh + 1 + oh * sqsizh  # Calculate full height of input grid\n    fullw = ow + 1 + ow * sqsizw  # Calculate full width of input grid\n    gi = canvas(linc, (fullh, fullw))  # Create initial input grid with line color\n    sq = backdrop(frozenset({(0, 0), (sqsizh - 1, sqsizw - 1)}))  # Create a square shape\n    obj = asobject(go)  # Convert output grid to object representation\n    for col, ij in obj:\n        plcd = shift(sq, add((1, 1), multiply(ij, (sqsizh+1, sqsizw+1))))  # Calculate position of current square\n        gi = fill(gi, bgc, plcd)  # Fill the square with background color\n        if col != bgc:\n            gi = fill(gi, col, corners(outbox(plcd)))  # Color the corners of the square if not background color\n    gih = unifint(diff_lb, diff_ub, (fullh, 30))  # Randomly select final input grid height\n    giw = unifint(diff_lb, diff_ub, (fullw, 30))  # Randomly select final input grid width\n    loci = randint(0, gih - fullh)  # Randomly select vertical position for pattern\n    locj = randint(0, giw - fullw)  # Randomly select horizontal position for pattern\n    gigi = canvas(bgc, (gih, giw))  # Create final input grid with background color\n    plcd = shift(asobject(gi), (loci, locj))  # Shift pattern to random position\n    gigi = paint(gigi, plcd)  # Paint the pattern onto the final input grid\n    ulci, ulcj = ulcorner(plcd)  # Get upper-left corner of pattern\n    lrci, lrcj = lrcorner(plcd)  # Get lower-right corner of pattern\n    for a in range(ulci, gih+1, sqsizh+1):\n        gigi = fill(gigi, linc, hfrontier((a, 0)))  # Draw horizontal grid lines below pattern\n    for a in range(ulci, -1, -sqsizh-1):\n        gigi = fill(gigi, linc, hfrontier((a, 0)))  # Draw horizontal grid lines above pattern\n    for b in range(ulcj, giw+1, sqsizw+1):\n        gigi = fill(gigi, linc, vfrontier((0, b)))  # Draw vertical grid lines to the right of pattern\n    for b in range(ulcj, -1, -sqsizw-1):\n        gigi = fill(gigi, linc, vfrontier((0, b)))  # Draw vertical grid lines to the left of pattern\n    gi = paint(gigi, plcd)  # Paint the pattern onto the final input grid (overwriting grid lines if necessary)\n    gop = palette(go)  # Get the palette of colors used in the output grid\n    while True:\n        go2 = identity(go)  # Create a copy of the current output grid\n        for c in set(ccols) & gop:\n            o1 = frozenset({(c, ORIGIN), (bgc, RIGHT), (c, (0, 2))})  # Define horizontal pattern\n            o2 = dmirror(o1)  # Create vertical mirror of the pattern\n            go2 = fill(go2, c, combine(\n                shift(occurrences(go, o1), RIGHT),\n                shift(occurrences(go, o2), DOWN)\n            ))  # Fill cells based on pattern occurrences\n        if go2 == go:\n            break  # If no changes made, stop iterating\n        go = go2  # Update output grid with new changes\n    return {'input': gi, 'output': go}  # Return input and output grids as a dictionary\n"
  },
  "794b24be": {
    "original": "def generate_794b24be(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    mpr = {1: (0, 0), 2: (0, 1), 3: (0, 2), 4: (1, 1)}\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    nblue = randint(1, 4)\n    go = canvas(bgc, (3, 3))\n    for k in range(nblue):\n        go = fill(go, 2, {mpr[k+1]})\n    gi = canvas(bgc, (h, w))\n    locs = sample(totuple(asindices(gi)), nblue)\n    gi = fill(gi, 1, locs)\n    remlocs = ofcolor(gi, bgc)\n    namt = unifint(diff_lb, diff_ub, (0, len(remlocs) // 2 - 1))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    ccols = sample(remcols, numc)\n    noise = sample(totuple(remlocs), namt)\n    noise = {(choice(ccols), ij) for ij in noise}\n    gi = paint(gi, noise)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_794b24be(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    \n    # Define a mapping of numbers to 3x3 grid positions\n    mpr = {1: (0, 0), 2: (0, 1), 3: (0, 2), 4: (1, 1)}\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Randomly choose the number of blue cells (1 to 4)\n    nblue = randint(1, 4)\n    \n    # Create a 3x3 grid with the chosen background color\n    go = canvas(bgc, (3, 3))\n    \n    # Fill the output grid with blue cells (color 2) based on the mapping\n    for k in range(nblue):\n        go = fill(go, 2, {mpr[k+1]})\n    \n    # Create the input grid with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly select positions for blue cells in the input grid\n    locs = sample(totuple(asindices(gi)), nblue)\n    \n    # Fill the selected positions with color 1 (representing blue in input)\n    gi = fill(gi, 1, locs)\n    \n    # Get all remaining background color positions\n    remlocs = ofcolor(gi, bgc)\n    \n    # Determine the number of noise cells to add (up to half of remaining cells)\n    namt = unifint(diff_lb, diff_ub, (0, len(remlocs) // 2 - 1))\n    \n    # Create a set of colors for noise, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose the number of colors to use for noise (1 to 7)\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Randomly select colors for noise\n    ccols = sample(remcols, numc)\n    \n    # Randomly select positions for noise\n    noise = sample(totuple(remlocs), namt)\n    \n    # Assign random colors to noise positions\n    noise = {(choice(ccols), ij) for ij in noise}\n    \n    # Add noise to the input grid\n    gi = paint(gi, noise)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "7b6016b9": {
    "original": "def generate_7b6016b9(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, remove(2, interval(0, 10, 1)))\n    while True:\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        w = unifint(diff_lb, diff_ub, (5, 30))\n        bgc, fgc = sample(cols, 2)\n        numl = unifint(diff_lb, diff_ub, (4, min(h, w)))\n        gi = canvas(bgc, (h, w))\n        jint = interval(0, w, 1)\n        iint = interval(0, h, 1)\n        iopts = interval(1, h-1, 1)\n        jopts = interval(1, w-1, 1)\n        numlh = randint(numl//3, numl//3*2)\n        numlw = numl - numlh\n        for k in range(numlh):\n            if len(iopts) == 0:\n                continue\n            loci = choice(iopts)\n            iopts = remove(loci, iopts)\n            iopts = remove(loci+1, iopts)\n            iopts = remove(loci-1, iopts)\n            a, b = sample(jint, 2)\n            a = randint(0, a)\n            b = randint(b, w - 1)\n            gi = fill(gi, fgc, connect((loci, a), (loci, b)))\n        for k in range(numlw):\n            if len(jopts) == 0:\n                continue\n            locj = choice(jopts)\n            jopts = remove(locj, jopts)\n            jopts = remove(locj+1, jopts)\n            jopts = remove(locj-1, jopts)\n            a, b = sample(iint, 2)\n            a = randint(0, a)\n            b = randint(b, h - 1)\n            gi = fill(gi, fgc, connect((a, locj), (b, locj)))\n        objs = objects(gi, T, F, F)\n        bgobjs = colorfilter(objs, bgc)\n        tofill = toindices(mfilter(bgobjs, compose(flip, rbind(bordering, gi))))\n        if len(tofill) > 0:\n            break\n    tofix = mapply(neighbors, tofill) - tofill\n    gi = fill(gi, fgc, tofix)\n    go = fill(gi, 2, tofill)\n    go = replace(go, bgc, 3)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7b6016b9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors excluding 2 and 3\n    cols = remove(3, remove(2, interval(0, 10, 1)))\n    while True:\n        # Generate random height between 5 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (5, 30))\n        # Generate random width between 5 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (5, 30))\n        # Randomly select two colors for background and foreground\n        bgc, fgc = sample(cols, 2)\n        # Determine number of lines to draw (between 4 and min(h,w))\n        numl = unifint(diff_lb, diff_ub, (4, min(h, w)))\n        # Create initial grid with background color\n        gi = canvas(bgc, (h, w))\n        # Create lists of possible x and y coordinates\n        jint = interval(0, w, 1)\n        iint = interval(0, h, 1)\n        # Create lists of possible line positions (excluding edges)\n        iopts = interval(1, h-1, 1)\n        jopts = interval(1, w-1, 1)\n        # Determine number of horizontal and vertical lines\n        numlh = randint(numl//3, numl//3*2)\n        numlw = numl - numlh\n        # Draw horizontal lines\n        for k in range(numlh):\n            if len(iopts) == 0:\n                continue\n            # Choose a random y-coordinate for the line\n            loci = choice(iopts)\n            # Remove chosen y-coordinate and adjacent ones from options\n            iopts = remove(loci, iopts)\n            iopts = remove(loci+1, iopts)\n            iopts = remove(loci-1, iopts)\n            # Choose random start and end x-coordinates\n            a, b = sample(jint, 2)\n            a = randint(0, a)\n            b = randint(b, w - 1)\n            # Draw the horizontal line\n            gi = fill(gi, fgc, connect((loci, a), (loci, b)))\n        # Draw vertical lines\n        for k in range(numlw):\n            if len(jopts) == 0:\n                continue\n            # Choose a random x-coordinate for the line\n            locj = choice(jopts)\n            # Remove chosen x-coordinate and adjacent ones from options\n            jopts = remove(locj, jopts)\n            jopts = remove(locj+1, jopts)\n            jopts = remove(locj-1, jopts)\n            # Choose random start and end y-coordinates\n            a, b = sample(iint, 2)\n            a = randint(0, a)\n            b = randint(b, h - 1)\n            # Draw the vertical line\n            gi = fill(gi, fgc, connect((a, locj), (b, locj)))\n        # Identify all objects in the grid\n        objs = objects(gi, T, F, F)\n        # Filter objects with background color\n        bgobjs = colorfilter(objs, bgc)\n        # Find background cells that border the grid edges\n        tofill = toindices(mfilter(bgobjs, compose(flip, rbind(bordering, gi))))\n        # If there are cells to fill, break the loop\n        if len(tofill) > 0:\n            break\n    # Find cells adjacent to the cells to be filled\n    tofix = mapply(neighbors, tofill) - tofill\n    # Fill adjacent cells with foreground color\n    gi = fill(gi, fgc, tofix)\n    # Fill border cells with color 2 (output grid)\n    go = fill(gi, 2, tofill)\n    # Replace remaining background color with 3 (output grid)\n    go = replace(go, bgc, 3)\n    # Return input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "7b7f7511": {
    "original": "def generate_7b7f7511(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    bgc = choice(cols)\n    go = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w - 1)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(go))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        go = fill(go, col, chos)\n        inds = difference(inds, chos)\n    if choice((True, False)):\n        go = dmirror(go)\n        gi = vconcat(go, go)\n    else:\n        gi = hconcat(go, go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7b7f7511(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid between 2 and 15\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    go = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (between 1 and min(9, h*w-1))\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w - 1)))\n    \n    # Randomly select the colors to use\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(go))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Randomly determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose the cells to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        go = fill(go, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Randomly decide whether to mirror the grid diagonally and concatenate vertically\n    # or concatenate horizontally without mirroring\n    if choice((True, False)):\n        # Mirror the grid diagonally\n        go = dmirror(go)\n        # Concatenate the mirrored grid with itself vertically\n        gi = vconcat(go, go)\n    else:\n        # Concatenate the grid with itself horizontally\n        gi = hconcat(go, go)\n    \n    # Return a dictionary with the input (concatenated grid) and output (original grid)\n    return {'input': gi, 'output': go}\n"
  },
  "7c008303": {
    "original": "def generate_7c008303(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 13))\n    w = unifint(diff_lb, diff_ub, (2, 13))\n    h = h * 2\n    w = w * 2\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    fgc = choice(remcols)\n    remcols = remove(fgc, remcols)\n    fremcols = sample(remcols, unifint(diff_lb, diff_ub, (1, 4)))\n    qc = [choice(fremcols) for j in range(4)]\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc = choice((ncd, h * w - ncd))\n    nc = min(max(0, nc), h * w)\n    cels = sample(inds, nc)\n    go = fill(c, fgc, cels)\n    gi = canvas(bgc, (h + 3, w + 3))\n    gi = paint(gi, shift(asobject(go), (3, 3)))\n    gi = fill(gi, linc, connect((2, 0), (2, w + 2)))\n    gi = fill(gi, linc, connect((0, 2), (h + 2, 2)))\n    gi = fill(gi, qc[0], {(0, 0)})\n    gi = fill(gi, qc[1], {(0, 1)})\n    gi = fill(gi, qc[2], {(1, 0)})\n    gi = fill(gi, qc[3], {(1, 1)})\n    A = lefthalf(tophalf(go))\n    B = righthalf(tophalf(go))\n    C = lefthalf(bottomhalf(go))\n    D = righthalf(bottomhalf(go))\n    A2 = replace(A, fgc, qc[0])\n    B2 = replace(B, fgc, qc[1])\n    C2 = replace(C, fgc, qc[2])\n    D2 = replace(D, fgc, qc[3])\n    go = vconcat(hconcat(A2, B2), hconcat(C2, D2))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7c008303(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height and width based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 13))\n    w = unifint(diff_lb, diff_ub, (2, 13))\n    \n    # Double the height and width\n    h = h * 2\n    w = w * 2\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random line color from remaining colors\n    linc = choice(remcols)\n    \n    # Remove the line color from the list of remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random foreground color from remaining colors\n    fgc = choice(remcols)\n    \n    # Remove the foreground color from the list of remaining colors\n    remcols = remove(fgc, remcols)\n    \n    # Sample 1 to 4 colors from remaining colors based on difficulty\n    fremcols = sample(remcols, unifint(diff_lb, diff_ub, (1, 4)))\n    \n    # Choose 4 random colors for quadrants from the sampled colors\n    qc = [choice(fremcols) for j in range(4)]\n    \n    # Create a canvas with the background color and dimensions (h, w)\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Generate a random number of cells to color, based on difficulty\n    ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose between the generated number and its complement\n    nc = choice((ncd, h * w - ncd))\n    \n    # Ensure nc is within valid range\n    nc = min(max(0, nc), h * w)\n    \n    # Randomly sample nc cells from all indices\n    cels = sample(inds, nc)\n    \n    # Fill the sampled cells with the foreground color\n    go = fill(c, fgc, cels)\n    \n    # Create a larger canvas for input, adding border space\n    gi = canvas(bgc, (h + 3, w + 3))\n    \n    # Paint the original grid onto the larger canvas, shifted by (3, 3)\n    gi = paint(gi, shift(asobject(go), (3, 3)))\n    \n    # Draw horizontal line at the top of the original grid\n    gi = fill(gi, linc, connect((2, 0), (2, w + 2)))\n    \n    # Draw vertical line at the left of the original grid\n    gi = fill(gi, linc, connect((0, 2), (h + 2, 2)))\n    \n    # Fill the top-left corner cells with quadrant colors\n    gi = fill(gi, qc[0], {(0, 0)})\n    gi = fill(gi, qc[1], {(0, 1)})\n    gi = fill(gi, qc[2], {(1, 0)})\n    gi = fill(gi, qc[3], {(1, 1)})\n    \n    # Split the original grid into four quadrants\n    A = lefthalf(tophalf(go))\n    B = righthalf(tophalf(go))\n    C = lefthalf(bottomhalf(go))\n    D = righthalf(bottomhalf(go))\n    \n    # Replace the foreground color in each quadrant with its respective quadrant color\n    A2 = replace(A, fgc, qc[0])\n    B2 = replace(B, fgc, qc[1])\n    C2 = replace(C, fgc, qc[2])\n    D2 = replace(D, fgc, qc[3])\n    \n    # Reconstruct the output grid by concatenating the modified quadrants\n    go = vconcat(hconcat(A2, B2), hconcat(C2, D2))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "7ddcd7ec": {
    "original": "def generate_7ddcd7ec(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    crns = (((0, 0), (-1, -1)), ((0, 1), (-1, 1)), ((1, 0), (1, -1)), ((1, 1), (1, 1)))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (0, 4))\n    chos = sample(crns, num)\n    loci = randint(0, h - 2)\n    locj = randint(0, w - 2)\n    loc = (loci, locj)\n    remcols = remove(bgc, cols)\n    for sp, dr in crns:\n        sp2 = add(loc, sp)\n        col = choice(remcols)\n        gi = fill(gi, col, {sp2})\n        go = fill(go, col, {sp2})\n        if (sp, dr) in chos:\n            gi = fill(gi, col, {add(sp2, dr)})\n            go = fill(go, col, shoot(sp2, dr))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7ddcd7ec(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define corner positions and their corresponding directions\n    crns = (((0, 0), (-1, -1)), ((0, 1), (-1, 1)), ((1, 0), (1, -1)), ((1, 1), (1, 1)))\n    \n    # Generate a random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Choose a random number of corners to modify (0 to 4)\n    num = unifint(diff_lb, diff_ub, (0, 4))\n    \n    # Randomly select 'num' corners to modify\n    chos = sample(crns, num)\n    \n    # Generate a random row index for the starting position\n    loci = randint(0, h - 2)\n    \n    # Generate a random column index for the starting position\n    locj = randint(0, w - 2)\n    \n    # Combine row and column indices into a tuple\n    loc = (loci, locj)\n    \n    # Create a list of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Iterate through each corner position and direction\n    for sp, dr in crns:\n        # Calculate the actual corner position\n        sp2 = add(loc, sp)\n        \n        # Choose a random color different from the background\n        col = choice(remcols)\n        \n        # Set the color of the corner in the input grid\n        gi = fill(gi, col, {sp2})\n        \n        # Set the color of the corner in the output grid\n        go = fill(go, col, {sp2})\n        \n        # If this corner was chosen for modification\n        if (sp, dr) in chos:\n            # Add a pixel of the same color in the direction for the input grid\n            gi = fill(gi, col, {add(sp2, dr)})\n            \n            # Create a line of the same color in the direction for the output grid\n            go = fill(go, col, shoot(sp2, dr))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "7df24a62": {
    "original": "def generate_7df24a62(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (12, 32))\n    w = unifint(diff_lb, diff_ub, (12, 32))\n    oh = unifint(diff_lb, diff_ub, (3, min(7, h//3)))\n    ow = unifint(diff_lb, diff_ub, (3, min(7, w//3)))\n    bgc, noisec, sqc = sample(cols, 3)\n    tmpg = canvas(sqc, (oh, ow))\n    inbounds = backdrop(inbox(asindices(tmpg)))\n    obj = {choice(totuple(inbounds))}\n    while shape(obj) != (oh - 2, ow - 2):\n        obj.add(choice(totuple(inbounds - obj)))\n    pat = fill(tmpg, noisec, obj)\n    targ = asobject(fill(canvas(bgc, (oh, ow)), noisec, obj))\n    sour = asobject(pat)\n    gi = canvas(bgc, (h, w))\n    loci = randint(1, h - oh - 1)\n    locj = randint(1, w - ow - 1)\n    plcddd = shift(sour, (loci, locj))\n    gi = paint(gi, plcddd)\n    inds = ofcolor(gi, bgc) & shift(asindices(canvas(-1, (h-2, w-2))), (1, 1))\n    inds = inds - (toindices(plcddd) | mapply(dneighbors, toindices(plcddd)))\n    namt = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // 4)))\n    noise = sample(totuple(inds), namt)\n    gi = fill(gi, noisec, noise)\n    targs = []\n    sours = []\n    for fn1 in (identity, dmirror, cmirror, hmirror, vmirror):\n        for fn2 in (identity, dmirror, cmirror, hmirror, vmirror):\n            targs.append(normalize(fn1(fn2(targ))))\n            sours.append(normalize(fn1(fn2(sour))))\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // ((oh * ow * 4)))))\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        t = choice(targs)\n        hh, ww = shape(t)\n        cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - hh - 1 and 1 <= ij[1] <= w - ww - 1)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        tp = shift(t, loc)\n        tpi = toindices(tp)\n        if tpi.issubset(inds):\n            succ += 1\n            inds = inds - tpi\n            gi = paint(gi, tp)\n    go = replace(gi, sqc, bgc)\n    go = paint(go, plcddd)\n    res = set()\n    for t, s in zip(targs, sours):\n        res |= mapply(lbind(shift, s), occurrences(go, t))\n    go = paint(go, res)\n    gi = trim(gi)\n    go = trim(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7df24a62(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (12, 32))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (12, 32))\n    \n    # Determine the height of the object, ensuring it's smaller than the grid\n    oh = unifint(diff_lb, diff_ub, (3, min(7, h//3)))\n    # Determine the width of the object, ensuring it's smaller than the grid\n    ow = unifint(diff_lb, diff_ub, (3, min(7, w//3)))\n    \n    # Randomly select three distinct colors for background, noise, and square\n    bgc, noisec, sqc = sample(cols, 3)\n    \n    # Create a temporary grid filled with the square color\n    tmpg = canvas(sqc, (oh, ow))\n    \n    # Get the indices of the inner box of the temporary grid\n    inbounds = backdrop(inbox(asindices(tmpg)))\n    \n    # Start creating the object by choosing a random cell\n    obj = {choice(totuple(inbounds))}\n    \n    # Grow the object until it fills the inner part of the temporary grid\n    while shape(obj) != (oh - 2, ow - 2):\n        obj.add(choice(totuple(inbounds - obj)))\n    \n    # Create the pattern by filling the object with noise color\n    pat = fill(tmpg, noisec, obj)\n    \n    # Create the target object with background color and noise\n    targ = asobject(fill(canvas(bgc, (oh, ow)), noisec, obj))\n    \n    # Convert the pattern to an object\n    sour = asobject(pat)\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Randomly determine the location to place the object\n    loci = randint(1, h - oh - 1)\n    locj = randint(1, w - ow - 1)\n    \n    # Shift the source object to the determined location\n    plcddd = shift(sour, (loci, locj))\n    \n    # Paint the shifted object onto the input grid\n    gi = paint(gi, plcddd)\n    \n    # Get the indices of background-colored cells, excluding borders\n    inds = ofcolor(gi, bgc) & shift(asindices(canvas(-1, (h-2, w-2))), (1, 1))\n    \n    # Remove the indices of the placed object and its neighbors\n    inds = inds - (toindices(plcddd) | mapply(dneighbors, toindices(plcddd)))\n    \n    # Determine the amount of noise to add\n    namt = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // 4)))\n    \n    # Randomly select cells for noise\n    noise = sample(totuple(inds), namt)\n    \n    # Add noise to the input grid\n    gi = fill(gi, noisec, noise)\n    \n    # Initialize lists for target and source objects\n    targs = []\n    sours = []\n    \n    # Generate variations of the target and source objects using different transformations\n    for fn1 in (identity, dmirror, cmirror, hmirror, vmirror):\n        for fn2 in (identity, dmirror, cmirror, hmirror, vmirror):\n            targs.append(normalize(fn1(fn2(targ))))\n            sours.append(normalize(fn1(fn2(sour))))\n    \n    # Determine the number of occurrences to place\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // ((oh * ow * 4)))))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * noccs\n    \n    # Try to place the target objects\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        # Choose a random target\n        t = choice(targs)\n        hh, ww = shape(t)\n        # Find valid positions to place the target\n        cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - hh - 1 and 1 <= ij[1] <= w - ww - 1)\n        if len(cands) == 0:\n            continue\n        # Choose a random location\n        loc = choice(totuple(cands))\n        # Shift the target to the chosen location\n        tp = shift(t, loc)\n        tpi = toindices(tp)\n        # If the placement is valid, add it to the grid\n        if tpi.issubset(inds):\n            succ += 1\n            inds = inds - tpi\n            gi = paint(gi, tp)\n    \n    # Create the output grid by replacing the square color with background color\n    go = replace(gi, sqc, bgc)\n    \n    # Paint the original placed object onto the output grid\n    go = paint(go, plcddd)\n    \n    # Find all occurrences of targets and paint corresponding sources\n    res = set()\n    for t, s in zip(targs, sours):\n        res |= mapply(lbind(shift, s), occurrences(go, t))\n    go = paint(go, res)\n    \n    # Trim the input and output grids\n    gi = trim(gi)\n    go = trim(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "7e0986d6": {
    "original": "def generate_7e0986d6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nsqcols = unifint(diff_lb, diff_ub, (1, 5))\n    sqcols = sample(remcols, nsqcols)\n    remcols = difference(remcols, sqcols)\n    nnoisecols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    noisecols = sample(remcols, nnoisecols)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    succ = 0\n    tr = 0\n    maxtr = 5 * numsq\n    go = canvas(bgc, (h, w))\n    inds = asindices(go)\n    while tr < maxtr and succ < numsq:\n        tr += 1\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        if sq.issubset(inds):\n            succ += 1\n            inds = (inds - sq) - outbox(sq)\n            col = choice(sqcols)\n            go = fill(go, col, sq)\n    gi = tuple(e for e in go)\n    namt = unifint(diff_lb, diff_ub, (1, (h * w) // 9))\n    cands = asindices(gi)\n    for k in range(namt):\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        col = gi[loc[0]][loc[1]]\n        torem = neighbors(loc) & ofcolor(gi, col)\n        cands = cands - torem\n        noisec = choice(noisecols)\n        gi = fill(gi, noisec, {loc})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7e0986d6(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to be used for squares (1 to 5)\n    nsqcols = unifint(diff_lb, diff_ub, (1, 5))\n    \n    # Randomly select colors for squares\n    sqcols = sample(remcols, nsqcols)\n    \n    # Remove the square colors from the remaining colors\n    remcols = difference(remcols, sqcols)\n    \n    # Randomly determine the number of noise colors (1 to the number of remaining colors)\n    nnoisecols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    \n    # Randomly select colors for noise\n    noisecols = sample(remcols, nnoisecols)\n    \n    # Randomly determine the number of squares to generate (1 to 1/25th of the grid area)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Initialize counters for successful square placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * numsq\n    \n    # Create the initial grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(go)\n    \n    # Loop to place squares on the grid\n    while tr < maxtr and succ < numsq:\n        tr += 1\n        # Randomly determine square height (2 to 7)\n        oh = randint(2, 7)\n        # Randomly determine square width (2 to 7)\n        ow = randint(2, 7)\n        \n        # Find valid locations for placing the square\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, continue to next iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the square\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Define the square area\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # If the square fits within the grid\n        if sq.issubset(inds):\n            succ += 1\n            # Remove the square area and its outline from available indices\n            inds = (inds - sq) - outbox(sq)\n            # Choose a random color for the square\n            col = choice(sqcols)\n            # Fill the square area with the chosen color\n            go = fill(go, col, sq)\n    \n    # Convert the grid to a tuple of tuples\n    gi = tuple(e for e in go)\n    \n    # Randomly determine the number of noise points to add (1 to 1/9th of the grid area)\n    namt = unifint(diff_lb, diff_ub, (1, (h * w) // 9))\n    \n    # Get all indices of the grid for noise placement\n    cands = asindices(gi)\n    \n    # Loop to add noise points\n    for k in range(namt):\n        # If no more valid locations, break the loop\n        if len(cands) == 0:\n            break\n        \n        # Choose a random location for noise\n        loc = choice(totuple(cands))\n        \n        # Get the color at the chosen location\n        col = gi[loc[0]][loc[1]]\n        \n        # Find neighboring cells with the same color\n        torem = neighbors(loc) & ofcolor(gi, col)\n        \n        # Remove these neighbors from candidate locations\n        cands = cands - torem\n        \n        # Choose a random noise color\n        noisec = choice(noisecols)\n        \n        # Place the noise point on the grid\n        gi = fill(gi, noisec, {loc})\n    \n    # Return the input (with noise) and output (without noise) grids\n    return {'input': gi, 'output': go}\n"
  },
  "7f4411dc": {
    "original": "def generate_7f4411dc(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, fgc = sample(cols, 2)\n    nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 15))\n    maxtr = 4 * nsq\n    tr = 0\n    succ = 0\n    go = canvas(bgc, (h, w))\n    inds = asindices(go)\n    while tr < maxtr and succ < nsq:\n        oh = randint(2, 6)\n        ow = randint(2, 6)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        obj = shift(obj, loc)\n        if obj.issubset(inds):\n            go = fill(go, fgc, obj)\n            succ += 1\n            inds = (inds - obj) - outbox(obj)\n        tr += 1\n    inds = ofcolor(go, bgc)\n    nnoise = unifint(diff_lb, diff_ub, (0, len(inds) // 2 - 1))\n    gi = tuple(e for e in go)\n    for k in range(nnoise):\n        loc = choice(totuple(inds))\n        inds = inds - dneighbors(loc)\n        gi = fill(gi, fgc, {loc})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7f4411dc(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select two different colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Calculate the number of squares to add (between 1 and 1/15th of the grid area)\n    nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 15))\n    \n    # Set the maximum number of attempts to 4 times the number of squares\n    maxtr = 4 * nsq\n    \n    # Initialize counters for attempts and successful placements\n    tr = 0\n    succ = 0\n    \n    # Create an initial grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(go)\n    \n    # Begin loop to place squares\n    while tr < maxtr and succ < nsq:\n        # Randomly choose the height of the square (between 2 and 6)\n        oh = randint(2, 6)\n        \n        # Randomly choose the width of the square (between 2 and 6)\n        ow = randint(2, 6)\n        \n        # Find all valid positions where the square can be placed\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions are left, exit the loop\n        if len(cands) == 0:\n            break\n        \n        # Choose a random valid position for the square\n        loc = choice(totuple(cands))\n        \n        # Extract the i and j coordinates of the chosen location\n        loci, locj = loc\n        \n        # Create the square object\n        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Shift the square to the chosen location\n        obj = shift(obj, loc)\n        \n        # If the square fits within the grid\n        if obj.issubset(inds):\n            # Fill the square with the foreground color\n            go = fill(go, fgc, obj)\n            \n            # Increment the success counter\n            succ += 1\n            \n            # Remove the square and its surrounding area from available indices\n            inds = (inds - obj) - outbox(obj)\n        \n        # Increment the attempt counter\n        tr += 1\n    \n    # Get all remaining background color indices\n    inds = ofcolor(go, bgc)\n    \n    # Determine the number of noise pixels to add (up to half of remaining background)\n    nnoise = unifint(diff_lb, diff_ub, (0, len(inds) // 2 - 1))\n    \n    # Convert the grid to a mutable format\n    gi = tuple(e for e in go)\n    \n    # Add noise pixels\n    for k in range(nnoise):\n        # Choose a random location for the noise pixel\n        loc = choice(totuple(inds))\n        \n        # Remove the chosen location and its neighbors from available indices\n        inds = inds - dneighbors(loc)\n        \n        # Add the noise pixel to the input grid\n        gi = fill(gi, fgc, {loc})\n    \n    # Return the input grid (with noise) and the output grid (without noise)\n    return {'input': gi, 'output': go}\n"
  },
  "7fe24cdd": {
    "original": "def generate_7fe24cdd(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = h\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go1 = hconcat(gi, rot90(gi))\n    go2 = hconcat(rot270(gi), rot180(gi))\n    go = vconcat(go1, go2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_7fe24cdd(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random integer between 1 and 15 for height, based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Set width equal to height, creating a square grid\n    w = h\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a square canvas filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use, based on difficulty (max 9 or h*w, whichever is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the input grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine number of cells to fill with this color, based on difficulty\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose indices to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the top half of the output grid:\n    # Concatenate the input grid with its 90-degree rotated version\n    go1 = hconcat(gi, rot90(gi))\n    \n    # Create the bottom half of the output grid:\n    # Concatenate the 270-degree rotated input with the 180-degree rotated input\n    go2 = hconcat(rot270(gi), rot180(gi))\n    \n    # Combine top and bottom halves to create the final output grid\n    go = vconcat(go1, go2)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "80af3007": {
    "original": "def generate_80af3007(diff_lb: float, diff_ub: float) -> dict:\n    fullcols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    bgc = choice(fullcols)\n    cols = remove(bgc, fullcols)\n    c = canvas(bgc, (h, w))\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numc = choice((numcd, h * w - numcd))\n    numc = min(max(0, numc), h * w)\n    inds = totuple(asindices(c))\n    locs = tuple(set(sample(inds, numc)) | set(sample(totuple(corners(inds)), 3)))\n    fgc = choice(cols)\n    gi = fill(c, fgc, locs)\n    go = canvas(bgc, (h**2, w**2))\n    for loc in locs:\n        go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))\n    fullh = unifint(diff_lb, diff_ub, (h**2+2, 30))\n    fullw = unifint(diff_lb, diff_ub, (w**2+2, 30))\n    fullg = canvas(bgc, (fullh, fullw))\n    loci = randint(1, fullh - h**2 - 1)\n    locj = randint(1, fullw - w**2 - 1)\n    loc = (loci, locj)\n    giups = hupscale(vupscale(gi, h), w)\n    gi = paint(fullg, shift(asobject(giups), loc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_80af3007(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    fullcols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid between 2 and 5\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly determine the width of the input grid between 2 and 5\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly choose a background color from the full color set\n    bgc = choice(fullcols)\n    \n    # Create a new color set without the background color\n    cols = remove(bgc, fullcols)\n    \n    # Create a canvas (grid) with the background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of cells to color, up to half of the total cells\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose between coloring numcd cells or the complement of numcd cells\n    numc = choice((numcd, h * w - numcd))\n    \n    # Ensure numc is within the valid range (0 to total number of cells)\n    numc = min(max(0, numc), h * w)\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select numc locations, ensuring at least 3 corners are included\n    # This creates the pattern of colored cells in the input grid\n    locs = tuple(set(sample(inds, numc)) | set(sample(totuple(corners(inds)), 3)))\n    \n    # Choose a foreground color different from the background color\n    fgc = choice(cols)\n    \n    # Create the input grid by filling the selected locations with the foreground color\n    gi = fill(c, fgc, locs)\n    \n    # Create a larger output canvas, h^2 x w^2, with the background color\n    go = canvas(bgc, (h**2, w**2))\n    \n    # For each colored location in the input, color a corresponding h x w block in the output\n    # This creates the expanded pattern in the output grid\n    for loc in locs:\n        go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))\n    \n    # Randomly determine the full height of the final input grid (larger than h^2)\n    fullh = unifint(diff_lb, diff_ub, (h**2+2, 30))\n    \n    # Randomly determine the full width of the final input grid (larger than w^2)\n    fullw = unifint(diff_lb, diff_ub, (w**2+2, 30))\n    \n    # Create the full input grid with the background color\n    fullg = canvas(bgc, (fullh, fullw))\n    \n    # Randomly determine the vertical position of the pattern in the full grid\n    loci = randint(1, fullh - h**2 - 1)\n    \n    # Randomly determine the horizontal position of the pattern in the full grid\n    locj = randint(1, fullw - w**2 - 1)\n    \n    # Combine the vertical and horizontal positions\n    loc = (loci, locj)\n    \n    # Upscale the input grid pattern to match the size in the output grid\n    giups = hupscale(vupscale(gi, h), w)\n    \n    # Place the upscaled pattern into the full input grid at the random location\n    gi = paint(fullg, shift(asobject(giups), loc))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "810b9b61": {
    "original": "def generate_810b9b61(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3,))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, 6))\n    ccols = sample(remcols, ncols)\n    nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(3, 5)\n        ow = randint(3, 5)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        obj = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1  )}))\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror)\n        nmfs = choice((1, 2))\n        for fn in sample(mfs, nmfs):\n            obj = fn(obj)\n            obj = normalize(obj)\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if choice((True, False)):\n            ninobjc = unifint(diff_lb, diff_ub, (1, len(plcd) - 1))\n            inobj = frozenset(sample(totuple(plcd), ninobjc))\n        else:\n            inobj = plcd\n        if inobj.issubset(inds):\n            succ += 1\n            inds = (inds - inobj) - mapply(dneighbors, inobj)\n            col = choice(ccols)\n            gi = fill(gi, col, inobj)\n            go = fill(go, 3 if box(inobj) == inobj and min(shape(inobj)) > 2 else col, inobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_810b9b61(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 3\n    cols = difference(interval(0, 10, 1), (3,))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove the background color from the set of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (1 to 6) based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (1, 6))\n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Choose a random number of objects to place (3 to 10% of grid area) based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    # Set maximum number of attempts to 5 times the number of objects\n    maxtr = 5 * nobjs\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Start placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        # Choose random height (3 to 5) for the object\n        oh = randint(3, 5)\n        # Choose random width (3 to 5) for the object\n        ow = randint(3, 5)\n        \n        # Find valid placement locations for the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create a box object\n        obj = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1  )}))\n        \n        # List of possible mirror transformations\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror)\n        # Choose to apply either 1 or 2 mirror transformations\n        nmfs = choice((1, 2))\n        \n        # Apply chosen number of random mirror transformations\n        for fn in sample(mfs, nmfs):\n            obj = fn(obj)\n            obj = normalize(obj)\n        \n        # Get new dimensions after transformations\n        oh, ow = shape(obj)\n        \n        # Find valid placement locations for the transformed object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the transformed object\n        loc = choice(totuple(cands))\n        # Shift the object to the chosen location\n        plcd = shift(obj, loc)\n        \n        # Randomly decide whether to use full object or partial object\n        if choice((True, False)):\n            # Choose random number of cells to include from the object\n            ninobjc = unifint(diff_lb, diff_ub, (1, len(plcd) - 1))\n            # Randomly sample cells from the object\n            inobj = frozenset(sample(totuple(plcd), ninobjc))\n        else:\n            # Use the full object\n            inobj = plcd\n        \n        # If the object can be placed without overlap\n        if inobj.issubset(inds):\n            succ += 1\n            # Remove object cells and their neighbors from available indices\n            inds = (inds - inobj) - mapply(dneighbors, inobj)\n            \n            # Choose a random color for the object\n            col = choice(ccols)\n            \n            # Place the object on the input grid\n            gi = fill(gi, col, inobj)\n            \n            # Place the object on the output grid, using color 3 if it's a complete box\n            go = fill(go, 3 if box(inobj) == inobj and min(shape(inobj)) > 2 else col, inobj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "82819916": {
    "original": "def generate_82819916(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ass, bss = sample(remcols, 2)\n    itv = interval(0, w, 1)\n    na = randint(2, w - 2)\n    alocs = sample(itv, na)\n    blocs = difference(itv, alocs)\n    if min(alocs) > min(blocs):\n        alocs, blocs = blocs, alocs\n    llocs = randint(0, h - 1)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, ass, {(llocs, j) for j in alocs})\n    gi = fill(gi, bss, {(llocs, j) for j in blocs})\n    numl = unifint(diff_lb, diff_ub, (1, max(1, (h-1)//2)))\n    remlocs = remove(llocs, interval(0, h, 1))\n    for k in range(numl):\n        lloc = choice(remlocs)\n        remlocs = remove(lloc, remlocs)\n        a, b = sample(remcols, 2)\n        gi = fill(gi, a, {(lloc, j) for j in alocs})\n        gi = fill(gi, b, {(lloc, j) for j in blocs})\n    cutoff = min(blocs) + 1\n    go = tuple(e for e in gi)\n    gi = fill(gi, bgc, backdrop(frozenset({(0, cutoff), (h - 1, w - 1)})))\n    gi = fill(gi, ass, {(llocs, j) for j in alocs})\n    gi = fill(gi, bss, {(llocs, j) for j in blocs})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_82819916(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 5 and 30, based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 30, based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Create a new tuple of colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose two distinct colors for the special rows\n    ass, bss = sample(remcols, 2)\n    \n    # Create a tuple of integers from 0 to w-1 (inclusive)\n    itv = interval(0, w, 1)\n    \n    # Choose a random number of 'a' locations between 2 and w-2\n    na = randint(2, w - 2)\n    \n    # Randomly select 'na' locations for 'a' color\n    alocs = sample(itv, na)\n    \n    # The remaining locations will be for 'b' color\n    blocs = difference(itv, alocs)\n    \n    # Ensure 'a' locations start before 'b' locations\n    if min(alocs) > min(blocs):\n        alocs, blocs = blocs, alocs\n    \n    # Choose a random row for the special line\n    llocs = randint(0, h - 1)\n    \n    # Create a canvas filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill 'a' locations in the special line with 'ass' color\n    gi = fill(gi, ass, {(llocs, j) for j in alocs})\n    \n    # Fill 'b' locations in the special line with 'bss' color\n    gi = fill(gi, bss, {(llocs, j) for j in blocs})\n    \n    # Choose a random number of additional special lines to add\n    numl = unifint(diff_lb, diff_ub, (1, max(1, (h-1)//2)))\n    \n    # Create a list of remaining row indices, excluding the first special line\n    remlocs = remove(llocs, interval(0, h, 1))\n    \n    # Add additional special lines\n    for k in range(numl):\n        # Choose a random row for the new special line\n        lloc = choice(remlocs)\n        # Remove the chosen row from available rows\n        remlocs = remove(lloc, remlocs)\n        # Choose two new colors for this line\n        a, b = sample(remcols, 2)\n        # Fill 'a' locations in this line\n        gi = fill(gi, a, {(lloc, j) for j in alocs})\n        # Fill 'b' locations in this line\n        gi = fill(gi, b, {(lloc, j) for j in blocs})\n    \n    # Determine where to cut the grid\n    cutoff = min(blocs) + 1\n    \n    # Create a copy of the input grid as the output grid\n    go = tuple(e for e in gi)\n    \n    # Fill the right side of the input grid with background color\n    gi = fill(gi, bgc, backdrop(frozenset({(0, cutoff), (h - 1, w - 1)})))\n    \n    # Redraw the original special line on the input grid\n    gi = fill(gi, ass, {(llocs, j) for j in alocs})\n    gi = fill(gi, bss, {(llocs, j) for j in blocs})\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "83302e8f": {
    "original": "def generate_83302e8f(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3, 4))\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nh = unifint(diff_lb, diff_ub, (3, 30 // (h + 1)))\n    nw = unifint(diff_lb, diff_ub, (3, 30 // (w + 1)))\n    bgc, linc = sample(cols, 2)\n    fullh = h * nh + nh - 1\n    fullw = w * nw + nw - 1\n    gi = canvas(bgc, (fullh, fullw))\n    for iloc in range(h, fullh, h+1):\n        gi = fill(gi, linc, hfrontier((iloc, 0)))\n    for jloc in range(w, fullw, w+1):\n        gi = fill(gi, linc, vfrontier((0, jloc)))\n    ofc = ofcolor(gi, linc)\n    dots = sfilter(ofc, lambda ij: dneighbors(ij).issubset(ofc))\n    tmp = fill(gi, bgc, dots)\n    lns = apply(toindices, colorfilter(objects(tmp, T, F, F), linc))\n    dts = apply(initset, dots)\n    cands = lns | dts\n    nbreaks = unifint(diff_lb, diff_ub, (0, len(cands) // 2))\n    breaklocs = set()\n    breakobjs = sample(totuple(cands), nbreaks)\n    for breakobj in breakobjs:\n        loc = choice(totuple(breakobj))\n        breaklocs.add(loc)\n    gi = fill(gi, bgc, breaklocs)\n    objs = objects(gi, T, F, F)\n    objs = colorfilter(objs, bgc)\n    objs = sfilter(objs, lambda o: len(o) == h * w)\n    res = toindices(merge(objs))\n    go = fill(gi, 3, res)\n    go = replace(go, bgc, 4)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_83302e8f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of integers from 0 to 9, excluding 3 and 4\n    cols = difference(interval(0, 10, 1), (3, 4))\n    \n    # Randomly generate height of each cell block\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly generate width of each cell block\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly generate number of cell blocks vertically\n    # Ensure the total height doesn't exceed 30\n    nh = unifint(diff_lb, diff_ub, (3, 30 // (h + 1)))\n    \n    # Randomly generate number of cell blocks horizontally\n    # Ensure the total width doesn't exceed 30\n    nw = unifint(diff_lb, diff_ub, (3, 30 // (w + 1)))\n    \n    # Randomly select two different colors for background and lines\n    bgc, linc = sample(cols, 2)\n    \n    # Calculate total height of the grid including separator lines\n    fullh = h * nh + nh - 1\n    \n    # Calculate total width of the grid including separator lines\n    fullw = w * nw + nw - 1\n    \n    # Create initial grid filled with background color\n    gi = canvas(bgc, (fullh, fullw))\n    \n    # Draw horizontal separator lines\n    for iloc in range(h, fullh, h+1):\n        gi = fill(gi, linc, hfrontier((iloc, 0)))\n    \n    # Draw vertical separator lines\n    for jloc in range(w, fullw, w+1):\n        gi = fill(gi, linc, vfrontier((0, jloc)))\n    \n    # Find all cells with the line color\n    ofc = ofcolor(gi, linc)\n    \n    # Find intersection points of horizontal and vertical lines\n    dots = sfilter(ofc, lambda ij: dneighbors(ij).issubset(ofc))\n    \n    # Remove intersection points from the grid\n    tmp = fill(gi, bgc, dots)\n    \n    # Get all line segments (excluding intersection points)\n    lns = apply(toindices, colorfilter(objects(tmp, T, F, F), linc))\n    \n    # Convert intersection points to a set of single-element sets\n    dts = apply(initset, dots)\n    \n    # Combine line segments and intersection points\n    cands = lns | dts\n    \n    # Randomly decide how many breaks to introduce in the grid lines\n    nbreaks = unifint(diff_lb, diff_ub, (0, len(cands) // 2))\n    \n    # Initialize set to store break locations\n    breaklocs = set()\n    \n    # Randomly select objects (line segments or intersection points) to break\n    breakobjs = sample(totuple(cands), nbreaks)\n    \n    # For each selected object, choose a random point to break\n    for breakobj in breakobjs:\n        loc = choice(totuple(breakobj))\n        breaklocs.add(loc)\n    \n    # Apply breaks to the grid\n    gi = fill(gi, bgc, breaklocs)\n    \n    # Find all objects in the grid\n    objs = objects(gi, T, F, F)\n    \n    # Filter objects to only include those with background color\n    objs = colorfilter(objs, bgc)\n    \n    # Keep only objects that have the size of a complete cell (h * w)\n    objs = sfilter(objs, lambda o: len(o) == h * w)\n    \n    # Merge all remaining objects into a single set of indices\n    res = toindices(merge(objs))\n    \n    # Create output grid: fill selected cells with color 3\n    go = fill(gi, 3, res)\n    \n    # Replace background color with 4 in the output grid\n    go = replace(go, bgc, 4)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "834ec97d": {
    "original": "def generate_834ec97d(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    loci = unifint(diff_lb, diff_ub, (0, h - 2))\n    locjd = unifint(diff_lb, diff_ub, (0, w // 2))\n    locj = choice((locjd, w - locjd))\n    locj = min(max(0, locj), w - 1)\n    loc = (loci, locj)\n    bgc, fgc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    gi = fill(c, fgc, {loc})\n    go = fill(c, fgc, {add(loc, (1, 0))})\n    for jj in range(w//2 + 1):\n        go = fill(go, 4, connect((0, locj + 2 * jj), (loci, locj + 2 * jj)))\n        go = fill(go, 4, connect((0, locj - 2 * jj), (loci, locj - 2 * jj)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_834ec97d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate random vertical position for the starting point, at least 2 rows from bottom\n    loci = unifint(diff_lb, diff_ub, (0, h - 2))\n    \n    # Generate random horizontal distance from left or right edge\n    locjd = unifint(diff_lb, diff_ub, (0, w // 2))\n    \n    # Randomly choose whether the starting point is on the left or right side\n    locj = choice((locjd, w - locjd))\n    \n    # Ensure the horizontal position is within the grid\n    locj = min(max(0, locj), w - 1)\n    \n    # Create the starting point coordinates\n    loc = (loci, locj)\n    \n    # Randomly select two different colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Create input grid: Place a foreground color pixel at the starting point\n    gi = fill(c, fgc, {loc})\n    \n    # Create output grid: Place a foreground color pixel one row below the starting point\n    go = fill(c, fgc, {add(loc, (1, 0))})\n    \n    # Add vertical lines in the output grid\n    for jj in range(w//2 + 1):\n        # Add a line to the right of the starting point\n        go = fill(go, 4, connect((0, locj + 2 * jj), (loci, locj + 2 * jj)))\n        \n        # Add a line to the left of the starting point\n        go = fill(go, 4, connect((0, locj - 2 * jj), (loci, locj - 2 * jj)))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8403a5d5": {
    "original": "def generate_8403a5d5(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    loccinv = unifint(diff_lb, diff_ub, (1, w - 1))\n    locc = w - loccinv\n    bgc, fgc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    idx = (h - 1, locc)\n    gi = fill(c, fgc, {idx})\n    go = canvas(bgc, (h, w))\n    for j in range(locc, w, 2):\n        go = fill(go, fgc, connect((0, j), (h - 1, j)))\n    for j in range(locc+1, w, 4):\n        go = fill(go, 5, {(0, j)})\n    for j in range(locc+3, w, 4):\n        go = fill(go, 5, {(h-1, j)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8403a5d5(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-4 and 6-9 (excluding 5)\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the inverse location of the starting column\n    loccinv = unifint(diff_lb, diff_ub, (1, w - 1))\n    \n    # Calculate the actual starting column location\n    locc = w - loccinv\n    \n    # Randomly select two colors: one for background and one for foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Define the starting point at the bottom of the grid in the 'locc' column\n    idx = (h - 1, locc)\n    \n    # Create the input grid by filling the starting point with the foreground color\n    gi = fill(c, fgc, {idx})\n    \n    # Create a new canvas for the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Fill vertical lines with foreground color in the output grid\n    # Starting from 'locc', draw a line every other column\n    for j in range(locc, w, 2):\n        go = fill(go, fgc, connect((0, j), (h - 1, j)))\n    \n    # Add color 5 to the top of every 4th column starting from 'locc'+1\n    for j in range(locc+1, w, 4):\n        go = fill(go, 5, {(0, j)})\n    \n    # Add color 5 to the bottom of every 4th column starting from 'locc'+3\n    for j in range(locc+3, w, 4):\n        go = fill(go, 5, {(h-1, j)})\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "846bdb03": {
    "original": "def generate_846bdb03(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    oh = unifint(diff_lb, diff_ub, (4, h//2-2))\n    ow = unifint(diff_lb, diff_ub, (4, w//2-2))\n    bgc, dotc, c1, c2 = sample(cols, 4)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (oh, ow))\n    ln1 = connect((1, 0), (oh - 2, 0))\n    ln2 = connect((1, ow - 1), (oh - 2, ow - 1))\n    go = fill(go, c1, ln1)\n    go = fill(go, c2, ln2)\n    go = fill(go, dotc, corners(asindices(go)))\n    objB = asobject(go)\n    bounds = asindices(canvas(-1, (oh - 2, ow - 2)))\n    objA = {choice(totuple(bounds))}\n    ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))\n    for k in range(ncells - 1):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    while shape(objA) != (oh - 2, ow - 2):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    fullinds = asindices(gi)\n    loci = randint(0, h - 2 * oh + 2)\n    locj = randint(0, w - ow)\n    plcdB = shift(objB, (loci, locj))\n    plcdi = toindices(plcdB)\n    rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)\n    loc = choice(totuple(rems))\n    plcdA = shift(objA, loc)\n    mp = center(plcdA)[1]\n    plcdAL = sfilter(plcdA, lambda ij: ij[1] < mp)\n    plcdAR = plcdA - plcdAL\n    plcdA = recolor(c1, plcdAL) | recolor(c2, plcdAR)\n    gi = paint(gi, plcdB)\n    ism = choice((True, False))\n    gi = paint(gi, vmirror(plcdA) if ism else plcdA)\n    objA = shift(normalize(plcdA), (1, 1))\n    objs = objects(go, T, F, T)\n    go = paint(go, objA)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_846bdb03(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid between 12 and 30\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    # Randomly determine the width of the input grid between 12 and 30\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Randomly determine the height of the output grid between 4 and half of input height minus 2\n    oh = unifint(diff_lb, diff_ub, (4, h//2-2))\n    # Randomly determine the width of the output grid between 4 and half of input width minus 2\n    ow = unifint(diff_lb, diff_ub, (4, w//2-2))\n    \n    # Randomly select 4 unique colors for background, dot, and two other colors\n    bgc, dotc, c1, c2 = sample(cols, 4)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create the output grid filled with the background color\n    go = canvas(bgc, (oh, ow))\n    \n    # Create a line from (1,0) to (oh-2,0) for the left border of the output\n    ln1 = connect((1, 0), (oh - 2, 0))\n    # Create a line from (1,ow-1) to (oh-2,ow-1) for the right border of the output\n    ln2 = connect((1, ow - 1), (oh - 2, ow - 1))\n    \n    # Fill the left border of the output grid with color c1\n    go = fill(go, c1, ln1)\n    # Fill the right border of the output grid with color c2\n    go = fill(go, c2, ln2)\n    \n    # Fill the corners of the output grid with the dot color\n    go = fill(go, dotc, corners(asindices(go)))\n    \n    # Convert the output grid to an object\n    objB = asobject(go)\n    \n    # Create a set of indices for the inner part of the output grid\n    bounds = asindices(canvas(-1, (oh - 2, ow - 2)))\n    \n    # Start creating objA by choosing a random cell within the bounds\n    objA = {choice(totuple(bounds))}\n    \n    # Determine the number of cells to add to objA\n    ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))\n    \n    # Add cells to objA, ensuring they're adjacent to existing cells\n    for k in range(ncells - 1):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    \n    # Continue adding cells until objA fills the entire inner part of the output grid\n    while shape(objA) != (oh - 2, ow - 2):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    \n    # Get all indices of the input grid\n    fullinds = asindices(gi)\n    \n    # Choose a random location to place objB in the input grid\n    loci = randint(0, h - 2 * oh + 2)\n    locj = randint(0, w - ow)\n    \n    # Shift objB to the chosen location\n    plcdB = shift(objB, (loci, locj))\n    plcdi = toindices(plcdB)\n    \n    # Find possible locations to place objA in the input grid\n    rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)\n    \n    # Choose a random location for objA from the possible locations\n    loc = choice(totuple(rems))\n    \n    # Shift objA to the chosen location\n    plcdA = shift(objA, loc)\n    \n    # Find the middle point of plcdA\n    mp = center(plcdA)[1]\n    \n    # Split plcdA into left and right parts\n    plcdAL = sfilter(plcdA, lambda ij: ij[1] < mp)\n    plcdAR = plcdA - plcdAL\n    \n    # Color the left part with c1 and the right part with c2\n    plcdA = recolor(c1, plcdAL) | recolor(c2, plcdAR)\n    \n    # Paint objB onto the input grid\n    gi = paint(gi, plcdB)\n    \n    # Randomly decide whether to mirror objA vertically\n    ism = choice((True, False))\n    \n    # Paint the (possibly mirrored) objA onto the input grid\n    gi = paint(gi, vmirror(plcdA) if ism else plcdA)\n    \n    # Normalize and shift objA for the output grid\n    objA = shift(normalize(plcdA), (1, 1))\n    \n    # Get all objects in the output grid\n    objs = objects(go, T, F, T)\n    \n    # Paint objA onto the output grid\n    go = paint(go, objA)\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "855e0971": {
    "original": "def generate_855e0971(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    nbarsd = unifint(diff_lb, diff_ub, (1, 4))\n    nbars = choice((nbarsd, 11 - nbarsd))\n    nbars = max(3, nbars)\n    h = unifint(diff_lb, diff_ub, (nbars, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    barsizes = [2] * nbars\n    while sum(barsizes) < h:\n        j = randint(0, nbars - 1)\n        barsizes[j] += 1\n    gi = tuple()\n    go = tuple()\n    locs = interval(0, w, 1)\n    dotc = choice(cols)\n    remcols = remove(dotc, cols)\n    lastcol = -1\n    nloclbs = [choice((0, 1)) for k in range(len(barsizes))]\n    if sum(nloclbs) < 2:\n        loc1, loc2 = sample(interval(0, len(nloclbs), 1), 2)\n        nloclbs[loc1] = 1\n        nloclbs[loc2] = 1\n    for bs, nloclb in zip(barsizes, nloclbs):\n        col = choice(remove(lastcol, remcols))\n        gim = canvas(col, (bs, w))\n        gom = canvas(col, (bs, w))\n        nl = unifint(diff_lb, diff_ub, (nloclb, w // 2))\n        chlocs = sample(locs, nl)\n        for jj in chlocs:\n            idx = (randint(0, bs - 1), jj)\n            gim = fill(gim, dotc, {idx})\n            gom = fill(gom, dotc, vfrontier(idx))\n        lastcol = col\n        gi = gi + gim\n        go = go + gom\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_855e0971(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the number of bars, ensuring at least 3 bars\n    nbarsd = unifint(diff_lb, diff_ub, (1, 4))\n    nbars = choice((nbarsd, 11 - nbarsd))\n    nbars = max(3, nbars)\n    \n    # Determine the height and width of the grid\n    h = unifint(diff_lb, diff_ub, (nbars, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Initialize bar sizes to 2 for each bar\n    barsizes = [2] * nbars\n    # Randomly increase bar sizes until the total height is reached\n    while sum(barsizes) < h:\n        j = randint(0, nbars - 1)\n        barsizes[j] += 1\n    \n    # Initialize input and output grids\n    gi = tuple()\n    go = tuple()\n    \n    # Define possible locations for dots\n    locs = interval(0, w, 1)\n    \n    # Choose a color for dots and remove it from available colors\n    dotc = choice(cols)\n    remcols = remove(dotc, cols)\n    \n    lastcol = -1  # Initialize last used color\n    \n    # Determine which bars will have at least one dot\n    nloclbs = [choice((0, 1)) for k in range(len(barsizes))]\n    # Ensure at least two bars have dots\n    if sum(nloclbs) < 2:\n        loc1, loc2 = sample(interval(0, len(nloclbs), 1), 2)\n        nloclbs[loc1] = 1\n        nloclbs[loc2] = 1\n    \n    # Generate each bar\n    for bs, nloclb in zip(barsizes, nloclbs):\n        # Choose a color for the bar, different from the last one\n        col = choice(remove(lastcol, remcols))\n        \n        # Create input and output bar grids\n        gim = canvas(col, (bs, w))\n        gom = canvas(col, (bs, w))\n        \n        # Determine number of dots for this bar\n        nl = unifint(diff_lb, diff_ub, (nloclb, w // 2))\n        \n        # Choose locations for dots\n        chlocs = sample(locs, nl)\n        \n        # Place dots in input grid and vertical lines in output grid\n        for jj in chlocs:\n            idx = (randint(0, bs - 1), jj)\n            gim = fill(gim, dotc, {idx})\n            gom = fill(gom, dotc, vfrontier(idx))\n        \n        lastcol = col  # Update last used color\n        \n        # Add bar to input and output grids\n        gi = gi + gim\n        go = go + gom\n    \n    # Randomly mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "85c4e7cd": {
    "original": "def generate_85c4e7cd(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    ncols = unifint(diff_lb, diff_ub, (1, 10))\n    cols = sample(colopts, ncols)\n    colord = [choice(cols) for j in range(min(h, w))]\n    shp = (h*2, w*2)\n    gi = canvas(0, shp)\n    go = canvas(0, shp)\n    for idx, (ci, co) in enumerate(zip(colord, colord[::-1])):\n        ulc = (idx, idx)\n        lrc = (h*2 - 1 - idx, w*2 - 1 - idx)\n        bx = box(frozenset({ulc, lrc}))\n        gi = fill(gi, ci, bx)\n        go = fill(go, co, bx)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_85c4e7cd(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly determine the height of the inner square, between 1 and 15\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly determine the width of the inner square, between 1 and 15\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose the number of colors to use, between 1 and 10\n    ncols = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly sample 'ncols' colors from the color options\n    cols = sample(colopts, ncols)\n    \n    # Create a list of randomly chosen colors for each layer of the square frame\n    # The number of layers is determined by the smaller of h or w\n    colord = [choice(cols) for j in range(min(h, w))]\n    \n    # Define the shape of the entire grid as twice the height and width\n    shp = (h*2, w*2)\n    \n    # Create an input grid filled with zeros (black)\n    gi = canvas(0, shp)\n    \n    # Create an output grid filled with zeros (black)\n    go = canvas(0, shp)\n    \n    # Iterate through each layer of the square frame\n    for idx, (ci, co) in enumerate(zip(colord, colord[::-1])):\n        # Calculate the upper-left corner of the current layer\n        ulc = (idx, idx)\n        \n        # Calculate the lower-right corner of the current layer\n        lrc = (h*2 - 1 - idx, w*2 - 1 - idx)\n        \n        # Create a box (outline) using the upper-left and lower-right corners\n        bx = box(frozenset({ulc, lrc}))\n        \n        # Fill the box in the input grid with the current input color\n        gi = fill(gi, ci, bx)\n        \n        # Fill the box in the output grid with the current output color\n        # Note: The output colors are in reverse order compared to the input\n        go = fill(go, co, bx)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "868de0fa": {
    "original": "def generate_868de0fa(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 7))    \n    h = unifint(diff_lb, diff_ub, (9, 30))\n    w = unifint(diff_lb, diff_ub, (9, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        oh = randint(3, 8)\n        ow = oh\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            gi = fill(gi, col, box(bd))\n            if oh % 2 == 1:\n                go = fill(go, 7, bd)\n            else:\n                go = fill(go, 2, bd)\n            go = fill(go, col, box(bd))\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_868de0fa(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 2 and 7\n    cols = difference(interval(0, 10, 1), (2, 7))    \n    \n    # Randomly determine the height of the grid between 9 and 30\n    h = unifint(diff_lb, diff_ub, (9, 30))\n    # Randomly determine the width of the grid between 9 and 30\n    w = unifint(diff_lb, diff_ub, (9, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    # Remove the chosen background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of objects to place (between 1 and 9)\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize successful placements counter\n    \n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if no more available indices\n        if len(indss) == 0:\n            break\n        \n        # Randomly determine object height (and width) between 3 and 8\n        oh = randint(3, 8)\n        ow = oh  # Objects are square, so width equals height\n        \n        # Find valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position for the object\n        loci, locj = choice(subs)\n        \n        # Create the object (defined by its corners)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get all cells within the object's bounding box\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # If the object fits within the available space\n        if bd.issubset(indss):\n            # Draw the object's outline on the input grid\n            gi = fill(gi, col, box(bd))\n            \n            # On the output grid:\n            if oh % 2 == 1:\n                # If object size is odd, fill with color 7\n                go = fill(go, 7, bd)\n            else:\n                # If object size is even, fill with color 2\n                go = fill(go, 2, bd)\n            # Draw the object's outline on the output grid\n            go = fill(go, col, box(bd))\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Remove used indices and surrounding area from available indices\n            indss = (indss - bd) - outbox(bd)\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8731374e": {
    "original": "def generate_8731374e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    inh = randint(5, h - 2)\n    inw = randint(5, w - 2)\n    bgc, fgc = sample(cols, 2)\n    num = unifint(diff_lb, diff_ub, (1, min(inh, inw)))\n    mat = canvas(bgc, (inh - 2, inw - 2))\n    tol = lambda g: list(list(e) for e in g)\n    tot = lambda g: tuple(tuple(e) for e in g)\n    mat = fill(mat, fgc, connect((0, 0), (num - 1, num - 1)))\n    mat = tol(mat)\n    shuffle(mat)\n    mat = tol(dmirror(tot(mat)))\n    shuffle(mat)\n    mat = dmirror(tot(mat))\n    sgi = paint(canvas(bgc, (inh, inw)), shift(asobject(mat), (1, 1)))\n    inds = ofcolor(sgi, fgc)\n    lins = mapply(fork(combine, vfrontier, hfrontier), inds)\n    go = fill(sgi, fgc, lins)\n    numci = unifint(diff_lb, diff_ub, (3, 10))\n    numc = 13 - numci\n    ccols = sample(cols, numc)\n    c = canvas(-1, (h, w))\n    inds = asindices(c)\n    obj = {(choice(ccols), ij) for ij in inds}\n    gi = paint(c, obj)\n    loci = randint(1, h - inh - 1)\n    locj = randint(1, w - inw - 1)\n    loc = (loci, locj)\n    plcd = shift(asobject(sgi), loc)\n    gi = paint(gi, plcd)\n    a, b = ulcorner(plcd)\n    c, d = lrcorner(plcd)\n    p1 = choice(totuple(connect((a - 1, b), (a - 1, d))))\n    p2 = choice(totuple(connect((a, b - 1), (c, b - 1))))\n    p3 = choice(totuple(connect((c + 1, b), (c + 1, d))))\n    p4 = choice(totuple(connect((a, d + 1), (c, d + 1))))\n    remcols = remove(bgc, ccols)\n    fixobj = {\n        (choice(remcols), p1), (choice(remcols), p2),\n        (choice(remcols), p3), (choice(remcols), p4)\n    }\n    gi = paint(gi, fixobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8731374e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly generate height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly generate width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate inner height between 5 and h-2\n    inh = randint(5, h - 2)\n    # Generate inner width between 5 and w-2\n    inw = randint(5, w - 2)\n    \n    # Randomly select two different colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Generate a number between 1 and min(inh, inw) based on difficulty\n    # This will determine the size of the diagonal line\n    num = unifint(diff_lb, diff_ub, (1, min(inh, inw)))\n    \n    # Create a canvas with background color and size (inh-2, inw-2)\n    mat = canvas(bgc, (inh - 2, inw - 2))\n    \n    # Define helper functions to convert between list and tuple representations\n    tol = lambda g: list(list(e) for e in g)\n    tot = lambda g: tuple(tuple(e) for e in g)\n    \n    # Draw a diagonal line with foreground color on the canvas\n    mat = fill(mat, fgc, connect((0, 0), (num - 1, num - 1)))\n    \n    # Convert mat to list of lists for shuffling\n    mat = tol(mat)\n    # Shuffle rows of the matrix\n    shuffle(mat)\n    # Mirror the matrix diagonally and convert back to list of lists\n    mat = tol(dmirror(tot(mat)))\n    # Shuffle rows again\n    shuffle(mat)\n    # Mirror the matrix diagonally again\n    mat = dmirror(tot(mat))\n    \n    # Create a larger grid with the shuffled and mirrored pattern, shifted by (1,1)\n    sgi = paint(canvas(bgc, (inh, inw)), shift(asobject(mat), (1, 1)))\n    \n    # Get indices of all foreground color cells\n    inds = ofcolor(sgi, fgc)\n    # Create lines (horizontal and vertical) from these indices\n    lins = mapply(fork(combine, vfrontier, hfrontier), inds)\n    # Fill these lines with foreground color to create the output grid\n    go = fill(sgi, fgc, lins)\n    \n    # Generate a number between 3 and 10 based on difficulty\n    numci = unifint(diff_lb, diff_ub, (3, 10))\n    # Calculate the number of colors to use (13 - numci)\n    numc = 13 - numci\n    # Randomly select colors for the input grid\n    ccols = sample(cols, numc)\n    \n    # Create a canvas for the input grid with placeholder color -1\n    c = canvas(-1, (h, w))\n    # Get all indices of the canvas\n    inds = asindices(c)\n    # Create an object with random colors at each index\n    obj = {(choice(ccols), ij) for ij in inds}\n    # Paint the canvas with this random color object\n    gi = paint(c, obj)\n    \n    # Generate random location to place the pattern\n    loci = randint(1, h - inh - 1)\n    locj = randint(1, w - inw - 1)\n    loc = (loci, locj)\n    \n    # Shift the pattern to the random location\n    plcd = shift(asobject(sgi), loc)\n    # Paint the pattern onto the input grid\n    gi = paint(gi, plcd)\n    \n    # Get corners of the placed pattern\n    a, b = ulcorner(plcd)\n    c, d = lrcorner(plcd)\n    \n    # Choose random points on each side of the pattern\n    p1 = choice(totuple(connect((a - 1, b), (a - 1, d))))\n    p2 = choice(totuple(connect((a, b - 1), (c, b - 1))))\n    p3 = choice(totuple(connect((c + 1, b), (c + 1, d))))\n    p4 = choice(totuple(connect((a, d + 1), (c, d + 1))))\n    \n    # Get colors not used for background\n    remcols = remove(bgc, ccols)\n    # Create an object with random colors at the chosen points\n    fixobj = {\n        (choice(remcols), p1), (choice(remcols), p2),\n        (choice(remcols), p3), (choice(remcols), p4)\n    }\n    # Paint these points onto the input grid\n    gi = paint(gi, fixobj)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "88a10436": {
    "original": "def generate_88a10436(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    objh = unifint(diff_lb, diff_ub, (0, 2))\n    objw = unifint(diff_lb, diff_ub, (0 if objh > 0 else 1, 2))\n    objh = objh * 2 + 1\n    objw = objw * 2 + 1\n    bb = asindices(canvas(-1, (objh, objw)))\n    sp = (objh // 2, objw // 2)\n    obj = {sp}\n    bb = remove(sp, bb)\n    ncells = unifint(diff_lb, diff_ub, (max(objh, objw), objh * objw))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    while height(obj) != objh or width(obj) != objw:\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    bgc, fgc = sample(cols, 2)\n    remcols = remove(bgc, remove(fgc, cols))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    obj = {(choice(ccols), ij) for ij in obj}\n    obj = normalize(obj)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    loci = randint(0, h - objh)\n    locj = randint(0, w - objw)\n    loc = (loci, locj)\n    plcd = shift(obj, loc)\n    gi = paint(gi, plcd)\n    go = paint(go, plcd)\n    inds = (asindices(gi) - toindices(plcd)) - mapply(neighbors, toindices(plcd))\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * ncells)))\n    maxtrials = 4 * nobjs\n    tr = 0\n    succ = 0\n    while succ < nobjs and tr <= maxtrials:\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        plcd = shift(obj, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(inds):\n            go = paint(go, plcd)\n            gi = fill(gi, fgc, {center(plcdi)})\n            succ += 1\n            inds = (inds - plcdi) - mapply(dneighbors, plcdi)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_88a10436(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (8, 30))  # Randomly choose grid height between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))  # Randomly choose grid width between 8 and 30\n    objh = unifint(diff_lb, diff_ub, (0, 2))  # Randomly choose object height (will be multiplied by 2 and added 1)\n    objw = unifint(diff_lb, diff_ub, (0 if objh > 0 else 1, 2))  # Randomly choose object width (will be multiplied by 2 and added 1)\n    objh = objh * 2 + 1  # Calculate final object height (always odd)\n    objw = objw * 2 + 1  # Calculate final object width (always odd)\n    bb = asindices(canvas(-1, (objh, objw)))  # Create a set of all indices for the object's bounding box\n    sp = (objh // 2, objw // 2)  # Calculate the center point of the object\n    obj = {sp}  # Initialize the object with its center point\n    bb = remove(sp, bb)  # Remove the center point from the bounding box indices\n    ncells = unifint(diff_lb, diff_ub, (max(objh, objw), objh * objw))  # Choose number of cells for the object\n    for k in range(ncells - 1):\n        # Add cells to the object, ensuring they're adjacent to existing cells and within the bounding box\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    while height(obj) != objh or width(obj) != objw:\n        # Ensure the object fills its intended dimensions by adding more cells if necessary\n        obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))\n    bgc, fgc = sample(cols, 2)  # Choose background and foreground colors\n    remcols = remove(bgc, remove(fgc, cols))  # Remove bg and fg colors from available colors\n    ncols = unifint(diff_lb, diff_ub, (1, 8))  # Choose number of colors for the object\n    ccols = sample(remcols, ncols)  # Select colors for the object\n    obj = {(choice(ccols), ij) for ij in obj}  # Assign random colors to each cell of the object\n    obj = normalize(obj)  # Normalize the object's position (move to origin)\n    gi = canvas(bgc, (h, w))  # Create input grid with background color\n    go = canvas(bgc, (h, w))  # Create output grid with background color\n    loci = randint(0, h - objh)  # Choose random vertical position for the object\n    locj = randint(0, w - objw)  # Choose random horizontal position for the object\n    loc = (loci, locj)  # Combine into a single location tuple\n    plcd = shift(obj, loc)  # Place the object at the chosen location\n    gi = paint(gi, plcd)  # Paint the object onto the input grid\n    go = paint(go, plcd)  # Paint the object onto the output grid\n    inds = (asindices(gi) - toindices(plcd)) - mapply(neighbors, toindices(plcd))  # Calculate available positions for new objects\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * ncells)))  # Choose number of additional objects to add\n    maxtrials = 4 * nobjs  # Set maximum number of attempts to place objects\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize successful placements counter\n    while succ < nobjs and tr <= maxtrials:\n        if len(inds) == 0:\n            break  # Stop if no more valid positions are available\n        loc = choice(totuple(inds))  # Choose a random position for a new object\n        plcd = shift(obj, loc)  # Place the object at the chosen position\n        plcdi = toindices(plcd)  # Get the indices of the placed object\n        if plcdi.issubset(inds):\n            # If the object fits in the available space:\n            go = paint(go, plcd)  # Paint the object onto the output grid\n            gi = fill(gi, fgc, {center(plcdi)})  # Place a foreground color dot at the center of the object in the input grid\n            succ += 1  # Increment successful placements counter\n            inds = (inds - plcdi) - mapply(dneighbors, plcdi)  # Update available positions\n        tr += 1  # Increment trial counter\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "88a62173": {
    "original": "def generate_88a62173(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    bgc = choice(cols)\n    gib = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gib))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gib = fill(gib, col, chos)\n        inds = difference(inds, chos)\n    numchinv = unifint(diff_lb, diff_ub, (0, h * w - 1))\n    numch = h * w - numchinv\n    inds2 = totuple(asindices(gib))\n    subs = sample(inds2, numch)\n    go = hmirror(hmirror(gib))\n    for x, y in subs:\n        go = fill(go, choice(remove(go[x][y], colsch + [bgc])), {(x, y)})\n    gi = canvas(bgc, (h*2+1, w*2+1))\n    idxes = ((0, 0), (h+1, w+1), (h+1, 0), (0, w+1))\n    trgloc = choice(idxes)\n    remidxes = remove(trgloc, idxes)\n    trgobj = asobject(go)\n    otherobj = asobject(gib)\n    gi = paint(gi, shift(trgobj, trgloc))\n    for ij in remidxes:\n        gi = paint(gi, shift(otherobj, ij))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_88a62173(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (1, 30)\n    # Create a tuple of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose a height between 1 and 14 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    # Randomly choose a width between 1 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    # Randomly choose a background color\n    bgc = choice(cols)\n    # Create an initial grid filled with the background color\n    gib = canvas(bgc, (h, w))\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Choose a number of colors to use, between 1 and min(9, h*w)\n    numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))\n    # Randomly select colors from the remaining colors\n    colsch = sample(remcols, numc)\n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gib))\n    # For each chosen color:\n    for col in colsch:\n        # Choose a number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        # Randomly select cells to fill\n        chos = sample(inds, num)\n        # Fill the chosen cells with the current color\n        gib = fill(gib, col, chos)\n        # Remove the filled cells from the available indices\n        inds = difference(inds, chos)\n    # Choose number of cells to keep unchanged in the output grid\n    numchinv = unifint(diff_lb, diff_ub, (0, h * w - 1))\n    # Calculate number of cells to change in the output grid\n    numch = h * w - numchinv\n    # Get all indices of the grid as a tuple (again)\n    inds2 = totuple(asindices(gib))\n    # Randomly select cells to change in the output grid\n    subs = sample(inds2, numch)\n    # Create the output grid by horizontally mirroring the input grid twice (effectively no change)\n    go = hmirror(hmirror(gib))\n    # For each cell to be changed:\n    for x, y in subs:\n        # Change the cell to a random color different from its current color, chosen colors, and background\n        go = fill(go, choice(remove(go[x][y], colsch + [bgc])), {(x, y)})\n    # Create a larger grid (2h+1 x 2w+1) with the background color\n    gi = canvas(bgc, (h*2+1, w*2+1))\n    # Define possible locations for grids in the larger grid\n    idxes = ((0, 0), (h+1, w+1), (h+1, 0), (0, w+1))\n    # Choose a random location for the target (output) grid\n    trgloc = choice(idxes)\n    # Remove the chosen location from the list of locations\n    remidxes = remove(trgloc, idxes)\n    # Convert the output grid to an object\n    trgobj = asobject(go)\n    # Convert the input grid to an object\n    otherobj = asobject(gib)\n    # Place the output grid in the chosen location of the larger grid\n    gi = paint(gi, shift(trgobj, trgloc))\n    # Place the input grid in the remaining locations of the larger grid\n    for ij in remidxes:\n        gi = paint(gi, shift(otherobj, ij))\n    # Return a dictionary with the input (larger grid) and output (transformed small grid)\n    return {'input': gi, 'output': go}\n"
  },
  "890034e9": {
    "original": "def generate_890034e9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = randint(2, h//4)\n    ow = randint(2, w//4)\n    markercol = choice(cols)\n    remcols = remove(markercol, cols)\n    numbgc = unifint(diff_lb, diff_ub, (1, 8))\n    bgcols = sample(remcols, numbgc)\n    gi = canvas(0, (h, w))\n    inds = asindices(gi)\n    obj = {(choice(bgcols), ij) for ij in inds}\n    gi = paint(gi, obj)\n    numbl = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    blacks = sample(totuple(inds), numbl)\n    gi = fill(gi, 0, blacks)\n    patt = asindices(canvas(-1, (oh, ow)))\n    tocover = set()\n    for occ in occurrences(gi, recolor(0, patt)):\n        tocover.add(choice(totuple(shift(patt, occ))))\n    tocover = {(choice(bgcols), ij) for ij in tocover}\n    gi = paint(gi, tocover)\n    noccs = unifint(diff_lb, diff_ub, (2, (h * w) // ((oh + 2) * (ow + 2))))\n    tr = 0\n    succ = 0\n    maxtr = 5 * noccs\n    go = tuple(e for e in gi)\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        bd = shift(patt, loc)\n        plcd = outbox(bd)\n        if plcd.issubset(inds):\n            succ += 1\n            inds = inds - plcd\n            gi = fill(gi, 0, bd)\n            go = fill(go, 0, bd)\n            if succ == 1:\n                gi = fill(gi, markercol, plcd)\n            go = fill(go, markercol, plcd)\n            loci, locj = loc\n            ln1 = connect((loci-1, locj), (loci-1, locj+ow-1))\n            ln2 = connect((loci+oh, locj), (loci+oh, locj+ow-1))\n            ln3 = connect((loci, locj-1), (loci+oh-1, locj-1))\n            ln4 = connect((loci, locj+ow), (loci+oh-1, locj+ow))\n            if succ > 1:\n                fixxer = {\n                    (choice(bgcols), choice(totuple(xx))) for xx in [ln1, ln2, ln3, ln4]\n                }\n                gi = paint(gi, fixxer)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_890034e9(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly determine the height of the grid (between 10 and 30)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid (between 10 and 30)\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the height of the object (between 2 and 1/4 of the grid height)\n    oh = randint(2, h//4)\n    \n    # Randomly determine the width of the object (between 2 and 1/4 of the grid width)\n    ow = randint(2, w//4)\n    \n    # Randomly choose a color for the marker\n    markercol = choice(cols)\n    \n    # Remove the marker color from the list of available colors\n    remcols = remove(markercol, cols)\n    \n    # Randomly determine the number of background colors (between 1 and 8)\n    numbgc = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly choose background colors from the remaining colors\n    bgcols = sample(remcols, numbgc)\n    \n    # Create an initial grid filled with zeros\n    gi = canvas(0, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Create an object with random background colors at each grid position\n    obj = {(choice(bgcols), ij) for ij in inds}\n    \n    # Paint the initial grid with the random background colors\n    gi = paint(gi, obj)\n    \n    # Randomly determine the number of black cells (up to half the grid size)\n    numbl = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly choose positions for black cells\n    blacks = sample(totuple(inds), numbl)\n    \n    # Fill the chosen positions with black (color 0)\n    gi = fill(gi, 0, blacks)\n    \n    # Create a pattern for the object to be placed\n    patt = asindices(canvas(-1, (oh, ow)))\n    \n    # Initialize a set to store positions to be covered\n    tocover = set()\n    \n    # For each occurrence of the pattern in the grid\n    for occ in occurrences(gi, recolor(0, patt)):\n        # Choose a random position within the pattern to cover\n        tocover.add(choice(totuple(shift(patt, occ))))\n    \n    # Assign random background colors to the positions to be covered\n    tocover = {(choice(bgcols), ij) for ij in tocover}\n    \n    # Paint the chosen positions with their assigned colors\n    gi = paint(gi, tocover)\n    \n    # Randomly determine the number of occurrences of the object\n    noccs = unifint(diff_lb, diff_ub, (2, (h * w) // ((oh + 2) * (ow + 2))))\n    \n    # Initialize counters for attempts and successful placements\n    tr = 0\n    succ = 0\n    \n    # Set maximum number of attempts\n    maxtr = 5 * noccs\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Main loop for placing objects\n    while tr < maxtr and succ < noccs:\n        tr += 1  # Increment attempt counter\n        \n        # Find valid positions for object placement\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, break the loop\n        if len(cands) == 0:\n            break\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        \n        # Shift the pattern to the chosen location\n        bd = shift(patt, loc)\n        \n        # Get the outline of the shifted pattern\n        plcd = outbox(bd)\n        \n        # If the outline is within the grid\n        if plcd.issubset(inds):\n            succ += 1  # Increment success counter\n            \n            # Remove the placed object area from available indices\n            inds = inds - plcd\n            \n            # Fill the object area with black in both input and output grids\n            gi = fill(gi, 0, bd)\n            go = fill(go, 0, bd)\n            \n            # For the first successful placement, mark the outline in the input grid\n            if succ == 1:\n                gi = fill(gi, markercol, plcd)\n            \n            # Mark the outline in the output grid for all placements\n            go = fill(go, markercol, plcd)\n            \n            # Extract the coordinates of the placed object\n            loci, locj = loc\n            \n            # Define the four sides of the object\n            ln1 = connect((loci-1, locj), (loci-1, locj+ow-1))  # Top\n            ln2 = connect((loci+oh, locj), (loci+oh, locj+ow-1))  # Bottom\n            ln3 = connect((loci, locj-1), (loci+oh-1, locj-1))  # Left\n            ln4 = connect((loci, locj+ow), (loci+oh-1, locj+ow))  # Right\n            \n            # For all but the first placement, add random background color to one side\n            if succ > 1:\n                fixxer = {\n                    (choice(bgcols), choice(totuple(xx))) for xx in [ln1, ln2, ln3, ln4]\n                }\n                gi = paint(gi, fixxer)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8a004b2b": {
    "original": "def generate_8a004b2b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    oh = unifint(diff_lb, diff_ub, (2, h//5))\n    ow = unifint(diff_lb, diff_ub, (2, w//5))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    bgc, cornc, ac1, ac2, objc = sample(cols, 5)\n    gi = canvas(bgc, (h, w))\n    obj = {choice(totuple(bounds))}\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(3, ncells), oh * ow)\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    oh, ow = shape(obj)\n    fp1 = choice(totuple(obj))\n    fp2 = choice(remove(fp1, totuple(obj)))\n    remobj = obj - {fp1, fp2}\n    obj = recolor(objc, remobj) | {(ac1, fp1), (ac2, fp2)}\n    maxhscf = (h - oh - 4) // oh\n    maxwscf = (w - ow - 4) // ow\n    hscf = unifint(diff_lb, diff_ub, (1, maxhscf))\n    wscf = unifint(diff_lb, diff_ub, (1, maxwscf))\n    loci = randint(0, 2)\n    locj = randint(0, 2)\n    oplcd = shift(obj, (loci, locj))\n    gi = paint(gi, oplcd)\n    inh = hscf * oh\n    inw = wscf * ow\n    sqh = unifint(diff_lb, diff_ub, (inh + 2, h - oh - 2))\n    sqw = unifint(diff_lb, diff_ub, (inw + 2, w))\n    sqloci = randint(loci+oh, h - sqh)\n    sqlocj = randint(0, w - sqw)\n    crns = corners(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))\n    gi = fill(gi, cornc, crns)\n    gomini = subgrid(oplcd, gi)\n    goo = vupscale(hupscale(gomini, wscf), hscf)\n    goo = asobject(goo)\n    gloci = randint(sqloci+1, sqloci+sqh-1-height(goo))\n    glocj = randint(sqlocj+1, sqlocj+sqw-1-width(goo))\n    gooplcd = shift(goo, (gloci, glocj))\n    go = paint(gi, gooplcd)\n    go = subgrid(crns, go)\n    indic = sfilter(gooplcd, lambda cij: cij[0] in (ac1, ac2))\n    gi = paint(gi, indic)\n    if choice((True, False)) and len(obj) > 3:\n        idx = choice(totuple(toindices(sfilter(obj, lambda cij: cij[0] == objc))))\n        idxi, idxj = idx\n        xx = shift(asindices(canvas(-1, (hscf, wscf))), (gloci+idxi*hscf, glocj+idxj*wscf))\n        gi = fill(gi, objc, xx)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8a004b2b(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly determine the width of the input grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Determine the height of the object, between 2 and 1/5 of the grid height\n    oh = unifint(diff_lb, diff_ub, (2, h//5))\n    # Determine the width of the object, between 2 and 1/5 of the grid width\n    ow = unifint(diff_lb, diff_ub, (2, w//5))\n    \n    # Create a set of all possible coordinates for the object\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Randomly select 5 unique colors for background, corners, and object parts\n    bgc, cornc, ac1, ac2, objc = sample(cols, 5)\n    \n    # Create the initial input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Start creating the object by selecting a random cell\n    obj = {choice(totuple(bounds))}\n    \n    # Determine the number of cells in the object\n    ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n    ncells = choice((ncellsd, oh * ow - ncellsd))\n    ncells = min(max(3, ncells), oh * ow)\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n    \n    # Normalize the object's position (move to origin)\n    obj = normalize(obj)\n    \n    # Update object dimensions after normalization\n    oh, ow = shape(obj)\n    \n    # Choose two special cells in the object for different colors\n    fp1 = choice(totuple(obj))\n    fp2 = choice(remove(fp1, totuple(obj)))\n    \n    # Remove the special cells from the main object\n    remobj = obj - {fp1, fp2}\n    \n    # Color the object: main color for most cells, special colors for two cells\n    obj = recolor(objc, remobj) | {(ac1, fp1), (ac2, fp2)}\n    \n    # Calculate maximum possible scaling factors\n    maxhscf = (h - oh - 4) // oh\n    maxwscf = (w - ow - 4) // ow\n    \n    # Determine actual scaling factors\n    hscf = unifint(diff_lb, diff_ub, (1, maxhscf))\n    wscf = unifint(diff_lb, diff_ub, (1, maxwscf))\n    \n    # Choose a random location to place the original object\n    loci = randint(0, 2)\n    locj = randint(0, 2)\n    \n    # Place the original object on the input grid\n    oplcd = shift(obj, (loci, locj))\n    gi = paint(gi, oplcd)\n    \n    # Calculate dimensions of the scaled object\n    inh = hscf * oh\n    inw = wscf * ow\n    \n    # Determine dimensions of the output square\n    sqh = unifint(diff_lb, diff_ub, (inh + 2, h - oh - 2))\n    sqw = unifint(diff_lb, diff_ub, (inw + 2, w))\n    \n    # Choose location for the output square\n    sqloci = randint(loci+oh, h - sqh)\n    sqlocj = randint(0, w - sqw)\n    \n    # Mark the corners of the output square\n    crns = corners(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))\n    gi = fill(gi, cornc, crns)\n    \n    # Extract the original object from the input grid\n    gomini = subgrid(oplcd, gi)\n    \n    # Scale up the original object\n    goo = vupscale(hupscale(gomini, wscf), hscf)\n    goo = asobject(goo)\n    \n    # Choose location for the scaled object within the output square\n    gloci = randint(sqloci+1, sqloci+sqh-1-height(goo))\n    glocj = randint(sqlocj+1, sqlocj+sqw-1-width(goo))\n    \n    # Place the scaled object in the output grid\n    gooplcd = shift(goo, (gloci, glocj))\n    go = paint(gi, gooplcd)\n    \n    # Crop the output grid to just the marked square\n    go = subgrid(crns, go)\n    \n    # Mark the special cells in the input grid\n    indic = sfilter(gooplcd, lambda cij: cij[0] in (ac1, ac2))\n    gi = paint(gi, indic)\n    \n    # Optionally add extra markings in the input grid\n    if choice((True, False)) and len(obj) > 3:\n        # Choose a random cell from the original object\n        idx = choice(totuple(toindices(sfilter(obj, lambda cij: cij[0] == objc))))\n        idxi, idxj = idx\n        # Create a square of cells at the corresponding location in the scaled object\n        xx = shift(asindices(canvas(-1, (hscf, wscf))), (gloci+idxi*hscf, glocj+idxj*wscf))\n        # Color this square with the main object color\n        gi = fill(gi, objc, xx)\n    \n    # List of possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8be77c9e": {
    "original": "def generate_8be77c9e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(cols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = vconcat(gi, hmirror(gi))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8be77c9e(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate the height of the input grid (between 1 and 15)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly generate the width of the input grid (between 1 and 30)\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create a new tuple of colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (between 0 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select 'numc' colors from the available colors\n    colsch = sample(cols, numc)\n    \n    # Create a tuple of all grid indices\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Randomly determine the number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select 'num' indices from the available indices\n        chos = sample(inds, num)\n        \n        # Fill the selected indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by vertically concatenating the input grid with its horizontal mirror\n    go = vconcat(gi, hmirror(gi))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8d5021e8": {
    "original": "def generate_8d5021e8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 10))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go1 = hconcat(vmirror(gi), gi)\n    go2 = vconcat(go1, hmirror(go1))\n    go = vconcat(hmirror(go1), go2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8d5021e8(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid (between 1 and 10)\n    h = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly determine the width of the input grid (between 1 and 15)\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (between 0 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the input grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose cells to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled cells from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the first part of the output by mirroring the input horizontally and concatenating\n    go1 = hconcat(vmirror(gi), gi)\n    \n    # Create the second part of the output by mirroring go1 vertically and concatenating\n    go2 = vconcat(go1, hmirror(go1))\n    \n    # Create the final output by mirroring go1 horizontally and concatenating with go2\n    go = vconcat(hmirror(go1), go2)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8d510a79": {
    "original": "def generate_8d510a79(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    barloci = randint(2, h - 3)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    bar = connect((barloci, 0), (barloci, w - 1))\n    gi = fill(gi, barcol, bar)\n    go = tuple(e for e in gi)\n    jinds = interval(0, w, 1)\n    numtop = unifint(diff_lb, diff_ub, (1, w - 1))\n    numbot = unifint(diff_lb, diff_ub, (1, w - 1))\n    tops = sample(jinds, numtop)\n    bots = sample(jinds, numbot)\n    for t in tops:\n        loci = randint(0, barloci - 2)\n        col = choice((1, 2))\n        loc = (loci, t)\n        gi = fill(gi, col, {loc})\n        if col == 1:\n            go = fill(go, col, connect(loc, (0, t)))\n        else:\n            go = fill(go, col, connect(loc, (barloci - 1, t)))\n    for t in bots:\n        loci = randint(barloci + 2, h - 1)\n        col = choice((1, 2))\n        loc = (loci, t)\n        gi = fill(gi, col, {loc})\n        if col == 1:\n            go = fill(go, col, connect(loc, (h - 1, t)))\n        else:\n            go = fill(go, col, connect(loc, (barloci + 1, t)))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8d510a79(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of color indices 0-9, excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    \n    # Randomly determine the height of the grid between 5 and 30\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose the vertical position of the horizontal bar\n    barloci = randint(2, h - 3)\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a set of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly select a color for the horizontal bar\n    barcol = choice(remcols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create a set of coordinates for the horizontal bar\n    bar = connect((barloci, 0), (barloci, w - 1))\n    \n    # Fill the horizontal bar with the selected bar color\n    gi = fill(gi, barcol, bar)\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Create a range of column indices\n    jinds = interval(0, w, 1)\n    \n    # Randomly determine the number of top markers\n    numtop = unifint(diff_lb, diff_ub, (1, w - 1))\n    \n    # Randomly determine the number of bottom markers\n    numbot = unifint(diff_lb, diff_ub, (1, w - 1))\n    \n    # Randomly select columns for top markers\n    tops = sample(jinds, numtop)\n    \n    # Randomly select columns for bottom markers\n    bots = sample(jinds, numbot)\n    \n    # Process top markers\n    for t in tops:\n        # Randomly select a row index above the bar\n        loci = randint(0, barloci - 2)\n        \n        # Randomly choose color 1 or 2 for the marker\n        col = choice((1, 2))\n        \n        # Create a tuple for the marker location\n        loc = (loci, t)\n        \n        # Place the marker on the input grid\n        gi = fill(gi, col, {loc})\n        \n        # For color 1, draw a line from marker to top edge on output grid\n        if col == 1:\n            go = fill(go, col, connect(loc, (0, t)))\n        # For color 2, draw a line from marker to the bar on output grid\n        else:\n            go = fill(go, col, connect(loc, (barloci - 1, t)))\n    \n    # Process bottom markers\n    for t in bots:\n        # Randomly select a row index below the bar\n        loci = randint(barloci + 2, h - 1)\n        \n        # Randomly choose color 1 or 2 for the marker\n        col = choice((1, 2))\n        \n        # Create a tuple for the marker location\n        loc = (loci, t)\n        \n        # Place the marker on the input grid\n        gi = fill(gi, col, {loc})\n        \n        # For color 1, draw a line from marker to bottom edge on output grid\n        if col == 1:\n            go = fill(go, col, connect(loc, (h - 1, t)))\n        # For color 2, draw a line from marker to the bar on output grid\n        else:\n            go = fill(go, col, connect(loc, (barloci + 1, t)))\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8e1813be": {
    "original": "def generate_8e1813be(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    bgc, sqc = sample(cols, 2)\n    remcols = remove(bgc, remove(sqc, cols))\n    nbars = unifint(diff_lb, diff_ub, (3, 8))\n    ccols = sample(remcols, nbars)\n    w = unifint(diff_lb, diff_ub, (nbars+3, 30))\n    hmarg = unifint(diff_lb, diff_ub, (2 * nbars, 30 - nbars))\n    ccols = list(ccols)\n    go = tuple(repeat(col, nbars) for col in ccols)\n    gi = tuple(repeat(col, w) for col in ccols)\n    r = repeat(bgc, w)\n    for k in range(hmarg):\n        idx = randint(0, len(go) - 1)\n        gi = gi[:idx] + (r,) + gi[idx:]\n    h2 = nbars + hmarg\n    oh, ow = nbars, nbars\n    loci = randint(1, h2 - oh - 2)\n    locj = randint(1, w - ow - 2)\n    sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    gi = fill(gi, sqc, sq)\n    gi = fill(gi, bgc, outbox(sq))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8e1813be(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly select two distinct colors: one for background and one for square\n    bgc, sqc = sample(cols, 2)\n    \n    # Remove background and square colors from the color list\n    remcols = remove(bgc, remove(sqc, cols))\n    \n    # Randomly choose the number of bars (between 3 and 8) based on difficulty\n    nbars = unifint(diff_lb, diff_ub, (3, 8))\n    \n    # Randomly select colors for the bars from the remaining colors\n    ccols = sample(remcols, nbars)\n    \n    # Determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (nbars+3, 30))\n    \n    # Calculate the vertical margin based on difficulty\n    hmarg = unifint(diff_lb, diff_ub, (2 * nbars, 30 - nbars))\n    \n    # Convert ccols to a list for easier manipulation\n    ccols = list(ccols)\n    \n    # Create the output grid: each row is a color repeated nbars times\n    go = tuple(repeat(col, nbars) for col in ccols)\n    \n    # Create the initial input grid: each row is a color repeated w times\n    gi = tuple(repeat(col, w) for col in ccols)\n    \n    # Create a row of background color\n    r = repeat(bgc, w)\n    \n    # Insert random background rows into the input grid\n    for k in range(hmarg):\n        idx = randint(0, len(go) - 1)\n        gi = gi[:idx] + (r,) + gi[idx:]\n    \n    # Calculate the height of the input grid\n    h2 = nbars + hmarg\n    \n    # Set the dimensions of the square\n    oh, ow = nbars, nbars\n    \n    # Randomly determine the position of the square\n    loci = randint(1, h2 - oh - 2)\n    locj = randint(1, w - ow - 2)\n    \n    # Create the square area\n    sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Fill the square area with the square color\n    gi = fill(gi, sqc, sq)\n    \n    # Fill the area around the square with the background color\n    gi = fill(gi, bgc, outbox(sq))\n    \n    # Randomly decide whether to mirror the input and output grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "8e5a5113": {
    "original": "def generate_8e5a5113(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    d = unifint(diff_lb, diff_ub, (2, 9))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    k = 4 if d < 7 else 3\n    nbound = (2, k)\n    num = unifint(diff_lb, diff_ub, nbound)\n    rotfs = (identity, rot90, rot180, rot270)\n    barc = choice(remcols)\n    remcols = remove(barc, remcols)\n    colbnds = (1, 8)\n    ncols = unifint(diff_lb, diff_ub, colbnds)\n    patcols = sample(remcols, ncols)\n    bgcanv = canvas(bgc, (d, d))\n    c = canvas(bgc, (d, d))\n    inds = totuple(asindices(c))\n    ncolbnds = (1, d ** 2 - 1)\n    ncells = unifint(diff_lb, diff_ub, ncolbnds)\n    indsss = sample(inds, ncells)\n    for ij in indsss:\n        c = fill(c, choice(patcols), {ij})\n    barr = canvas(barc, (d, 1))\n    fillinidx = choice(interval(0, num, 1))\n    gi = rot90(rot270(c if fillinidx == 0 else bgcanv))\n    go = rot90(rot270(c))\n    for j in range(num - 1):\n        c = rot90(c)\n        gi = hconcat(hconcat(gi, barr), c if j + 1 == fillinidx else bgcanv)\n        go = hconcat(hconcat(go, barr), c)\n    if choice((True, False)):\n        gi = rot90(gi)\n        go = rot90(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8e5a5113(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color options from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Determine the size of the grid (d x d) based on difficulty\n    d = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Choose a background color randomly\n    bgc = choice(colopts)\n    \n    # Remove the background color from the color options\n    remcols = remove(bgc, colopts)\n    \n    # Determine the number of rotations based on difficulty\n    k = 4 if d < 7 else 3\n    \n    # Set the bounds for the number of rotations\n    nbound = (2, k)\n    \n    # Determine the number of rotations based on difficulty\n    num = unifint(diff_lb, diff_ub, nbound)\n    \n    # Define rotation functions\n    rotfs = (identity, rot90, rot180, rot270)\n    \n    # Choose a color for the separating bar\n    barc = choice(remcols)\n    \n    # Remove the bar color from the remaining colors\n    remcols = remove(barc, remcols)\n    \n    # Set bounds for the number of colors to be used in the pattern\n    colbnds = (1, 8)\n    \n    # Determine the number of colors to be used in the pattern\n    ncols = unifint(diff_lb, diff_ub, colbnds)\n    \n    # Randomly select colors for the pattern\n    patcols = sample(remcols, ncols)\n    \n    # Create a background canvas with the chosen background color\n    bgcanv = canvas(bgc, (d, d))\n    \n    # Create a canvas for the pattern\n    c = canvas(bgc, (d, d))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Set bounds for the number of cells to be colored\n    ncolbnds = (1, d ** 2 - 1)\n    \n    # Determine the number of cells to be colored\n    ncells = unifint(diff_lb, diff_ub, ncolbnds)\n    \n    # Randomly select indices to be colored\n    indsss = sample(inds, ncells)\n    \n    # Color the selected indices with randomly chosen pattern colors\n    for ij in indsss:\n        c = fill(c, choice(patcols), {ij})\n    \n    # Create a separating bar with the chosen bar color\n    barr = canvas(barc, (d, 1))\n    \n    # Randomly choose which rotation will be filled in the input\n    fillinidx = choice(interval(0, num, 1))\n    \n    # Initialize the input grid with the first rotation (or background if it's not the filled one)\n    gi = rot90(rot270(c if fillinidx == 0 else bgcanv))\n    \n    # Initialize the output grid with the first rotation\n    go = rot90(rot270(c))\n    \n    # Add remaining rotations to both input and output grids\n    for j in range(num - 1):\n        # Rotate the pattern\n        c = rot90(c)\n        # Add to input grid (filled or background)\n        gi = hconcat(hconcat(gi, barr), c if j + 1 == fillinidx else bgcanv)\n        # Add to output grid (always filled)\n        go = hconcat(hconcat(go, barr), c)\n    \n    # Randomly decide whether to rotate the entire grid 90 degrees\n    if choice((True, False)):\n        gi = rot90(gi)\n        go = rot90(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "8eb1be9a": {
    "original": "def generate_8eb1be9a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    oh = unifint(diff_lb, diff_ub, (2, h // 3))\n    ow = unifint(diff_lb, diff_ub, (2, w))\n    bounds = asindices(canvas(-1, (oh, ow)))\n    ncells = unifint(diff_lb, diff_ub, (2, (oh * ow) // 3 * 2))\n    obj = normalize(frozenset(sample(totuple(bounds), ncells)))\n    oh, ow = shape(obj)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, ncols)\n    obj = frozenset({(choice(ccols), ij) for ij in obj})\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    obj = shift(obj, (loci, locj))\n    c = canvas(bgc, (h, w))\n    gi = paint(c, obj)\n    go = paint(c, obj)\n    for k in range(h // oh + 1):\n        go = paint(go, shift(obj, (-oh*k, 0)))\n        go = paint(go, shift(obj, (oh*k, 0)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8eb1be9a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 8 and 30\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the width of the grid between 4 and 30\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the height of the object, between 2 and 1/3 of the grid height\n    oh = unifint(diff_lb, diff_ub, (2, h // 3))\n    \n    # Randomly determine the width of the object, between 2 and the grid width\n    ow = unifint(diff_lb, diff_ub, (2, w))\n    \n    # Create a set of all possible indices for the object\n    bounds = asindices(canvas(-1, (oh, ow)))\n    \n    # Randomly determine the number of cells in the object, between 2 and 2/3 of the object's area\n    ncells = unifint(diff_lb, diff_ub, (2, (oh * ow) // 3 * 2))\n    \n    # Randomly select indices to create the object's shape\n    obj = normalize(frozenset(sample(totuple(bounds), ncells)))\n    \n    # Update object dimensions based on its actual shape\n    oh, ow = shape(obj)\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use in the object\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select colors for the object\n    ccols = sample(remcols, ncols)\n    \n    # Assign random colors to each cell in the object\n    obj = frozenset({(choice(ccols), ij) for ij in obj})\n    \n    # Randomly determine the object's position in the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Shift the object to its position in the grid\n    obj = shift(obj, (loci, locj))\n    \n    # Create the input grid with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Paint the object onto the input grid\n    gi = paint(c, obj)\n    \n    # Initialize the output grid with the same background and object\n    go = paint(c, obj)\n    \n    # Repeat the object vertically in both directions on the output grid\n    for k in range(h // oh + 1):\n        # Paint the object above the original position\n        go = paint(go, shift(obj, (-oh*k, 0)))\n        # Paint the object below the original position\n        go = paint(go, shift(obj, (oh*k, 0)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8efcae92": {
    "original": "def generate_8efcae92(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, sqc, dotc = sample(cols, 3)\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    succ = 0\n    maxtr = 4 * num\n    tr = 0\n    gi = canvas(bgc, (h, w))\n    go = None\n    inds = asindices(gi)\n    oho, owo = None, None\n    while succ < num and tr < maxtr:\n        if oho is None and owo is None:\n            oh = randint(2, h - 1)\n            ow = randint(2, w - 1)\n            oho = oh\n            owo = ow\n        else:\n            ohd = unifint(diff_lb, diff_ub, (0, min(oho, h - 1 - oho)))\n            owd = unifint(diff_lb, diff_ub, (0, min(owo, w - 1 - owo)))\n            ohd = min(oho, h - 1 - oho) - ohd\n            owd = min(owo, w - 1 - owo) - owd\n            oh = choice((oho - ohd, oho + ohd))\n            ow = choice((owo - owd, owo + owd))\n            oh = min(max(2, oh), h - 1)\n            ow = min(max(2, ow), w - 1)\n        minig = canvas(sqc, (oh, ow))\n        mini = asindices(minig)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        tr += 1\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        if not shift(mini, loc).issubset(inds):\n            continue\n        succ += 1\n        if go is None:\n            numdots = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2 - 1))\n            nd = numdots\n        else:\n            nd = unifint(diff_lb, diff_ub, (0, min((oh * ow) // 2 - 1, numdots - 1)))\n        locs = sample(totuple(mini), nd)\n        minig = fill(minig, dotc, locs)\n        if go is None:\n            go = minig\n        obj = asobject(minig)\n        plcd = shift(obj, loc)\n        gi = paint(gi, plcd)\n        inds = (inds - toindices(plcd)) - mapply(dneighbors, toindices(plcd))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8efcae92(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly choose width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Randomly select 3 distinct colors for background, square, and dot\n    bgc, sqc, dotc = sample(cols, 3)\n    # Choose number of squares to place, between 1 and 1/25th of grid area\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    # Counter for successfully placed squares\n    succ = 0\n    # Maximum number of placement attempts (4 times the desired number)\n    maxtr = 4 * num\n    # Counter for placement attempts\n    tr = 0\n    # Create initial input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Initialize output grid (will be set to first successfully placed square)\n    go = None\n    # Get all possible indices in the input grid\n    inds = asindices(gi)\n    # Initialize variables to track previous square dimensions\n    oho, owo = None, None\n\n    # Main loop for placing squares\n    while succ < num and tr < maxtr:\n        # If it's the first square, choose random dimensions\n        if oho is None and owo is None:\n            oh = randint(2, h - 1)\n            ow = randint(2, w - 1)\n            oho = oh\n            owo = ow\n        # For subsequent squares, vary dimensions based on previous square\n        else:\n            # Choose vertical variation\n            ohd = unifint(diff_lb, diff_ub, (0, min(oho, h - 1 - oho)))\n            # Choose horizontal variation\n            owd = unifint(diff_lb, diff_ub, (0, min(owo, w - 1 - owo)))\n            # Adjust variations to ensure square fits within grid\n            ohd = min(oho, h - 1 - oho) - ohd\n            owd = min(owo, w - 1 - owo) - owd\n            # Randomly increase or decrease height\n            oh = choice((oho - ohd, oho + ohd))\n            # Randomly increase or decrease width\n            ow = choice((owo - owd, owo + owd))\n            # Ensure new dimensions are within valid range\n            oh = min(max(2, oh), h - 1)\n            ow = min(max(2, ow), w - 1)\n\n        # Create a new square of the chosen size\n        minig = canvas(sqc, (oh, ow))\n        # Get all indices within the new square\n        mini = asindices(minig)\n        # Find all valid placement locations for the new square\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # Increment attempt counter\n        tr += 1\n        # If no valid placements, try again with new dimensions\n        if len(cands) == 0:\n            continue\n        # Choose a random valid placement location\n        loc = choice(totuple(cands))\n        # If square doesn't fit at chosen location, try again\n        if not shift(mini, loc).issubset(inds):\n            continue\n\n        # Square successfully placed, increment success counter\n        succ += 1\n        # If it's the first square, determine number of dots for output\n        if go is None:\n            numdots = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2 - 1))\n            nd = numdots\n        # For subsequent squares, vary number of dots\n        else:\n            nd = unifint(diff_lb, diff_ub, (0, min((oh * ow) // 2 - 1, numdots - 1)))\n\n        # Randomly choose locations for dots within the square\n        locs = sample(totuple(mini), nd)\n        # Place dots on the square\n        minig = fill(minig, dotc, locs)\n        # If it's the first square, set it as the output\n        if go is None:\n            go = minig\n        # Convert square to object representation\n        obj = asobject(minig)\n        # Shift object to its placement location\n        plcd = shift(obj, loc)\n        # Paint the square onto the input grid\n        gi = paint(gi, plcd)\n        # Update available indices, removing placed square and its neighbors\n        inds = (inds - toindices(plcd)) - mapply(dneighbors, toindices(plcd))\n\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "8f2ea7aa": {
    "original": "def generate_8f2ea7aa(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    d = unifint(diff_lb, diff_ub, (2, 5))\n    bgc = choice(colopts)\n    remcols = remove(bgc, colopts)\n    d2 = d ** 2\n    gi = canvas(bgc, (d2, d2))\n    go = canvas(bgc, (d2, d2))\n    minig = canvas(bgc, (d, d))\n    inds = totuple(asindices(minig))\n    mp = d2 // 2\n    devrng = (0, mp)\n    dev = unifint(diff_lb, diff_ub, devrng)\n    devs = choice((+1, -1))\n    num = mp + devs * dev\n    num = max(min(num, d2), 0)\n    locs = set(sample(inds, num))\n    while shape(locs) != (d, d):\n        locs.add(choice(totuple(set(inds) - locs)))\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    cols = sample(remcols, ncols)\n    for ij in locs:\n        minig = fill(minig, choice(cols), {ij})\n    itv = interval(0, d2, d)\n    plcopts = totuple(product(itv, itv))\n    plc = choice(plcopts)\n    minigo = asobject(minig)\n    gi = paint(gi, shift(minigo, plc))\n    for ij in locs:\n        go = paint(go, shift(minigo, multiply(ij, d)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_8f2ea7aa(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Determine the size of the mini-grid (d x d) based on difficulty\n    d = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Choose a background color randomly\n    bgc = choice(colopts)\n    \n    # Remove the background color from the color options\n    remcols = remove(bgc, colopts)\n    \n    # Calculate the size of the full grid (d^2 x d^2)\n    d2 = d ** 2\n    \n    # Create input and output grids with background color\n    gi = canvas(bgc, (d2, d2))\n    go = canvas(bgc, (d2, d2))\n    \n    # Create a mini-grid with background color\n    minig = canvas(bgc, (d, d))\n    \n    # Get all indices of the mini-grid as a tuple\n    inds = totuple(asindices(minig))\n    \n    # Calculate the midpoint of the full grid\n    mp = d2 // 2\n    \n    # Define the range for deviation\n    devrng = (0, mp)\n    \n    # Determine the deviation based on difficulty\n    dev = unifint(diff_lb, diff_ub, devrng)\n    \n    # Randomly choose whether to add or subtract the deviation\n    devs = choice((+1, -1))\n    \n    # Calculate the number of cells to color in the mini-grid\n    num = mp + devs * dev\n    \n    # Ensure num is within the valid range [0, d^2]\n    num = max(min(num, d2), 0)\n    \n    # Randomly select 'num' locations in the mini-grid to color\n    locs = set(sample(inds, num))\n    \n    # Ensure all rows and columns in the mini-grid have at least one colored cell\n    while shape(locs) != (d, d):\n        locs.add(choice(totuple(set(inds) - locs)))\n    \n    # Determine the number of colors to use (excluding background) based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select colors to use\n    cols = sample(remcols, ncols)\n    \n    # Color the selected locations in the mini-grid with random colors\n    for ij in locs:\n        minig = fill(minig, choice(cols), {ij})\n    \n    # Define possible positions for the mini-grid in the input grid\n    itv = interval(0, d2, d)\n    plcopts = totuple(product(itv, itv))\n    \n    # Choose a random position for the mini-grid in the input grid\n    plc = choice(plcopts)\n    \n    # Convert mini-grid to an object representation\n    minigo = asobject(minig)\n    \n    # Place the mini-grid in the input grid at the chosen position\n    gi = paint(gi, shift(minigo, plc))\n    \n    # Create the output grid by repeating the mini-grid pattern\n    for ij in locs:\n        go = paint(go, shift(minigo, multiply(ij, d)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "90c28cc7": {
    "original": "def generate_90c28cc7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 10))\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    nc = unifint(diff_lb, diff_ub, (2, 9))\n    gi = canvas(-1, (h, w))\n    inds = totuple(asindices(gi))\n    colss = sample(cols, nc)\n    for ij in inds:\n        gi = fill(gi, choice(colss), {ij})\n    gi = dmirror(dedupe(dmirror(dedupe(gi))))\n    go = tuple(e for e in gi)\n    h, w = shape(gi)\n    fullh = unifint(diff_lb, diff_ub, (h, 30))\n    fullw = unifint(diff_lb, diff_ub, (w, 30))\n    inh = unifint(diff_lb, diff_ub, (h, fullh))\n    inw = unifint(diff_lb, diff_ub, (w, fullw))\n    while h < inh or w < inw:\n        opts = []\n        if h < inh:\n            opts.append((h, identity))\n        elif w < inw:\n            opts.append((w, dmirror))\n        dim, mirrf = choice(opts)\n        idx = randint(0, dim - 1)\n        gi = mirrf(gi)\n        gi = gi[:idx+1] + gi[idx:]\n        gi = mirrf(gi)\n        h, w = shape(gi)\n    while h < fullh or w < fullw:\n        opts = []\n        if h < fullh:\n            opts.append(identity)\n        elif w < fullw:\n            opts.append(dmirror)\n        mirrf = choice(opts)\n        gi = mirrf(gi)\n        gi = merge(tuple(sample((((0,) * width(gi),), gi), 2)))\n        gi = mirrf(gi)\n        h, w = shape(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_90c28cc7(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of column values from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly determine the height of the initial grid (2 to 10)\n    h = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Randomly determine the width of the initial grid (2 to 10)\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Randomly determine the number of colors to use (2 to 9)\n    nc = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Create an initial canvas filled with -1 of size h x w\n    gi = canvas(-1, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Randomly sample 'nc' colors from the 'cols' range\n    colss = sample(cols, nc)\n    \n    # Fill each cell of the grid with a randomly chosen color\n    for ij in inds:\n        gi = fill(gi, choice(colss), {ij})\n    \n    # Apply diagonal mirroring and deduplication twice to create symmetry\n    gi = dmirror(dedupe(dmirror(dedupe(gi))))\n    \n    # Store the original grid as the output\n    go = tuple(e for e in gi)\n    \n    # Get the current shape of the grid after symmetry operations\n    h, w = shape(gi)\n    \n    # Determine the final height of the input grid (between current h and 30)\n    fullh = unifint(diff_lb, diff_ub, (h, 30))\n    \n    # Determine the final width of the input grid (between current w and 30)\n    fullw = unifint(diff_lb, diff_ub, (w, 30))\n    \n    # Determine intermediate height for expansion (between current h and fullh)\n    inh = unifint(diff_lb, diff_ub, (h, fullh))\n    \n    # Determine intermediate width for expansion (between current w and fullw)\n    inw = unifint(diff_lb, diff_ub, (w, fullw))\n    \n    # Expand the grid to reach the intermediate dimensions\n    while h < inh or w < inw:\n        opts = []\n        # If height needs to increase, add vertical expansion option\n        if h < inh:\n            opts.append((h, identity))\n        # If width needs to increase, add horizontal expansion option\n        elif w < inw:\n            opts.append((w, dmirror))\n        \n        # Randomly choose expansion direction\n        dim, mirrf = choice(opts)\n        \n        # Choose a random index for duplication\n        idx = randint(0, dim - 1)\n        \n        # Apply mirroring if necessary\n        gi = mirrf(gi)\n        \n        # Duplicate a row or column\n        gi = gi[:idx+1] + gi[idx:]\n        \n        # Revert mirroring if applied\n        gi = mirrf(gi)\n        \n        # Update current dimensions\n        h, w = shape(gi)\n    \n    # Further expand the grid to reach the final dimensions\n    while h < fullh or w < fullw:\n        opts = []\n        # If height needs to increase, add vertical expansion option\n        if h < fullh:\n            opts.append(identity)\n        # If width needs to increase, add horizontal expansion option\n        elif w < fullw:\n            opts.append(dmirror)\n        \n        # Randomly choose expansion direction\n        mirrf = choice(opts)\n        \n        # Apply mirroring if necessary\n        gi = mirrf(gi)\n        \n        # Merge the grid with either a blank row/column or a copy of itself\n        gi = merge(tuple(sample((((0,) * width(gi),), gi), 2)))\n        \n        # Revert mirroring if applied\n        gi = mirrf(gi)\n        \n        # Update current dimensions\n        h, w = shape(gi)\n    \n    # Return a dictionary with the input grid and the original output grid\n    return {'input': gi, 'output': go}\n"
  },
  "90f3ed37": {
    "original": "def generate_90f3ed37(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    while True:\n        h = unifint(diff_lb, diff_ub, (8, 30))\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        pathh = unifint(diff_lb, diff_ub, (1, max(1, h//4)))\n        pathh = unifint(diff_lb, diff_ub, (pathh, max(1, h//4)))\n        Lpatper = unifint(diff_lb, diff_ub, (1, w//7))\n        Rpatper = unifint(diff_lb, diff_ub, (1, w//7))\n        hh = randint(1, pathh)\n        Linds = asindices(canvas(-1, (hh, Lpatper)))\n        Rinds = asindices(canvas(-1, (hh, Rpatper)))\n        lpatsd = unifint(diff_lb, diff_ub, (0, (hh * Lpatper) // 2))\n        rpatsd = unifint(diff_lb, diff_ub, (0, (hh * Rpatper) // 2))\n        lpats = choice((lpatsd, hh * Lpatper - lpatsd))\n        rpats = choice((rpatsd, hh * Rpatper - rpatsd))\n        lpats = min(max(Lpatper, lpats), hh * Lpatper)\n        rpats = min(max(Rpatper, rpats), hh * Rpatper)\n        lpat = set(sample(totuple(Linds), lpats))\n        rpat = set(sample(totuple(Rinds), rpats))\n        midpatw = randint(0, w-2*Lpatper-2*Rpatper)\n        if midpatw == 0 or Lpatper == hh == 1:\n            midpat = set()\n            midpatw = 0\n        else:\n            midpat = set(sample(totuple(asindices(canvas(-1, (hh, midpatw)))), randint(midpatw, (hh * midpatw))))\n        if shift(midpat, (0, 2*Lpatper-midpatw)).issubset(lpat):\n            midpat = set()\n            midpatw = 0\n        loci = randint(0, h - pathh)\n        lplac = shift(lpat, (loci, 0)) | shift(lpat, (loci, Lpatper))\n        mplac = shift(midpat, (loci, 2*Lpatper))\n        rplac = shift(rpat, (loci, 2*Lpatper+midpatw)) | shift(rpat, (loci, 2*Lpatper+midpatw+Rpatper))\n        sp = 2*Lpatper+midpatw+Rpatper\n        for k in range(w//Lpatper+1):\n            lplac |= shift(lpat, (loci, -k*Lpatper))\n        for k in range(w//Rpatper+1):\n            rplac |= shift(rpat, (loci, sp+k*Rpatper))\n        pat = lplac | mplac | rplac\n        patn = shift(pat, (-loci, 0))\n        bgc, fgc = sample(cols, 2)\n        gi = canvas(bgc, (h, w))\n        gi = fill(gi, fgc, pat)\n        options = interval(0, h - pathh + 1, 1)\n        options = difference(options, interval(loci-pathh-1, loci+2*pathh, 1))\n        nplacements = unifint(diff_lb, diff_ub, (1, max(1, len(options) // pathh)))\n        go = tuple(e for e in gi)\n        for k in range(nplacements):\n            if len(options) == 0:\n                break\n            locii = choice(options)\n            options = difference(options, interval(locii-pathh-1, locii+2*pathh, 1))\n            hoffs = randint(0, max(Rpatper, w-sp-2))\n            cutoffopts = interval(2*Lpatper+midpatw, 2*Lpatper+midpatw+hoffs+1, 1)\n            cutoffopts = cutoffopts[::-1]\n            idx = unifint(diff_lb, diff_ub, (0, len(cutoffopts) - 1))\n            cutoff = cutoffopts[idx]\n            patnc = sfilter(patn, lambda ij: ij[1] <= cutoff)\n            go = fill(go, 1, shift(patn, (locii, hoffs)))\n            gi = fill(gi, fgc, shift(patnc, (locii, hoffs)))\n            go = fill(go, fgc, shift(patnc, (locii, hoffs)))\n        if 1 in palette(go):\n            break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_90f3ed37(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    while True:\n        # Generate random height between 8 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (8, 30))\n        # Generate random width between 8 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        # Generate random path height between 1 and h/4 based on difficulty\n        pathh = unifint(diff_lb, diff_ub, (1, max(1, h//4)))\n        # Possibly increase path height, keeping it between previous value and h/4\n        pathh = unifint(diff_lb, diff_ub, (pathh, max(1, h//4)))\n        # Generate random left pattern period between 1 and w/7 based on difficulty\n        Lpatper = unifint(diff_lb, diff_ub, (1, w//7))\n        # Generate random right pattern period between 1 and w/7 based on difficulty\n        Rpatper = unifint(diff_lb, diff_ub, (1, w//7))\n        # Generate random height for patterns, between 1 and pathh\n        hh = randint(1, pathh)\n        # Create indices for left pattern\n        Linds = asindices(canvas(-1, (hh, Lpatper)))\n        # Create indices for right pattern\n        Rinds = asindices(canvas(-1, (hh, Rpatper)))\n        # Generate random number of cells for left pattern based on difficulty\n        lpatsd = unifint(diff_lb, diff_ub, (0, (hh * Lpatper) // 2))\n        # Generate random number of cells for right pattern based on difficulty\n        rpatsd = unifint(diff_lb, diff_ub, (0, (hh * Rpatper) // 2))\n        # Choose between lpatsd and its complement for left pattern\n        lpats = choice((lpatsd, hh * Lpatper - lpatsd))\n        # Choose between rpatsd and its complement for right pattern\n        rpats = choice((rpatsd, hh * Rpatper - rpatsd))\n        # Ensure lpats is within valid range\n        lpats = min(max(Lpatper, lpats), hh * Lpatper)\n        # Ensure rpats is within valid range\n        rpats = min(max(Rpatper, rpats), hh * Rpatper)\n        # Randomly select cells for left pattern\n        lpat = set(sample(totuple(Linds), lpats))\n        # Randomly select cells for right pattern\n        rpat = set(sample(totuple(Rinds), rpats))\n        # Generate random width for middle pattern\n        midpatw = randint(0, w-2*Lpatper-2*Rpatper)\n        # If no middle pattern or left pattern is 1x1, set middle pattern to empty\n        if midpatw == 0 or Lpatper == hh == 1:\n            midpat = set()\n            midpatw = 0\n        else:\n            # Randomly select cells for middle pattern\n            midpat = set(sample(totuple(asindices(canvas(-1, (hh, midpatw)))), randint(midpatw, (hh * midpatw))))\n        # If middle pattern overlaps with left pattern, set it to empty\n        if shift(midpat, (0, 2*Lpatper-midpatw)).issubset(lpat):\n            midpat = set()\n            midpatw = 0\n        # Generate random vertical position for the pattern\n        loci = randint(0, h - pathh)\n        # Create left pattern placement\n        lplac = shift(lpat, (loci, 0)) | shift(lpat, (loci, Lpatper))\n        # Create middle pattern placement\n        mplac = shift(midpat, (loci, 2*Lpatper))\n        # Create right pattern placement\n        rplac = shift(rpat, (loci, 2*Lpatper+midpatw)) | shift(rpat, (loci, 2*Lpatper+midpatw+Rpatper))\n        # Calculate total span of the pattern\n        sp = 2*Lpatper+midpatw+Rpatper\n        # Extend left pattern to cover entire width\n        for k in range(w//Lpatper+1):\n            lplac |= shift(lpat, (loci, -k*Lpatper))\n        # Extend right pattern to cover entire width\n        for k in range(w//Rpatper+1):\n            rplac |= shift(rpat, (loci, sp+k*Rpatper))\n        # Combine all pattern placements\n        pat = lplac | mplac | rplac\n        # Create normalized pattern (shifted to top)\n        patn = shift(pat, (-loci, 0))\n        # Randomly select background and foreground colors\n        bgc, fgc = sample(cols, 2)\n        # Create input grid with background color\n        gi = canvas(bgc, (h, w))\n        # Fill input grid with foreground color according to pattern\n        gi = fill(gi, fgc, pat)\n        # Generate options for additional pattern placements\n        options = interval(0, h - pathh + 1, 1)\n        options = difference(options, interval(loci-pathh-1, loci+2*pathh, 1))\n        # Determine number of additional pattern placements based on difficulty\n        nplacements = unifint(diff_lb, diff_ub, (1, max(1, len(options) // pathh)))\n        # Create output grid, initially same as input\n        go = tuple(e for e in gi)\n        # Loop to add additional pattern placements\n        for k in range(nplacements):\n            # Break if no more options available\n            if len(options) == 0:\n                break\n            # Choose random vertical position for new placement\n            locii = choice(options)\n            # Update options to avoid overlap\n            options = difference(options, interval(locii-pathh-1, locii+2*pathh, 1))\n            # Generate random horizontal offset\n            hoffs = randint(0, max(Rpatper, w-sp-2))\n            # Generate options for pattern cutoff\n            cutoffopts = interval(2*Lpatper+midpatw, 2*Lpatper+midpatw+hoffs+1, 1)\n            cutoffopts = cutoffopts[::-1]\n            # Choose random cutoff based on difficulty\n            idx = unifint(diff_lb, diff_ub, (0, len(cutoffopts) - 1))\n            cutoff = cutoffopts[idx]\n            # Create cut-off pattern\n            patnc = sfilter(patn, lambda ij: ij[1] <= cutoff)\n            # Add full pattern to output grid (color 1 represents \"to be removed\")\n            go = fill(go, 1, shift(patn, (locii, hoffs)))\n            # Add cut-off pattern to input grid\n            gi = fill(gi, fgc, shift(patnc, (locii, hoffs)))\n            # Add cut-off pattern to output grid\n            go = fill(go, fgc, shift(patnc, (locii, hoffs)))\n        # If output grid contains color 1 (areas to be removed), break the loop\n        if 1 in palette(go):\n            break\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "913fb3ed": {
    "original": "def generate_913fb3ed(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6, 8))\n    sr = (2, 3, 8)\n    tr = (1, 6, 4)\n    prs = list(zip(sr, tr))\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    numc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))\n    inds = asindices(gi)\n    for k in range(numc):\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        a, b = choice(prs)\n        inds = (inds - neighbors(loc)) - outbox(neighbors(loc))\n        inds = remove(loc, inds)\n        gi = fill(gi, a, {loc})\n        go = fill(go, a, {loc})\n        go = fill(go, b, neighbors(loc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_913fb3ed(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (1, 30)\n    \n    # Define possible background colors, excluding 1, 2, 3, 4, 6, and 8\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6, 8))\n    \n    # Define source colors for the pattern\n    sr = (2, 3, 8)\n    \n    # Define target colors for the pattern (colors that will surround the source)\n    tr = (1, 6, 4)\n    \n    # Create pairs of source and target colors\n    prs = list(zip(sr, tr))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create the input grid with the chosen background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the same background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine the number of color patterns to place, based on difficulty and grid size\n    numc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Loop to place color patterns\n    for k in range(numc):\n        # Break if there are no more available indices\n        if len(inds) == 0:\n            break\n        \n        # Choose a random location for the pattern\n        loc = choice(totuple(inds))\n        \n        # Choose a random source-target color pair\n        a, b = choice(prs)\n        \n        # Remove the chosen location and its neighbors from available indices\n        inds = (inds - neighbors(loc)) - outbox(neighbors(loc))\n        inds = remove(loc, inds)\n        \n        # Place the source color in the input grid\n        gi = fill(gi, a, {loc})\n        \n        # Place the source color in the output grid\n        go = fill(go, a, {loc})\n        \n        # Surround the source color with the target color in the output grid\n        go = fill(go, b, neighbors(loc))\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "91413438": {
    "original": "def generate_91413438(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    maxnb = min(h * w - 1, min(30//h, 30//w))\n    minnb = int(0.5 * ((4 * h * w + 1) ** 0.5 - 1)) + 1\n    nbi = unifint(diff_lb, diff_ub, (0, maxnb - minnb))\n    nb = min(max(minnb, maxnb - nbi), maxnb)\n    fgc = choice(cols)\n    c = canvas(0, (h, w))\n    obj = sample(totuple(asindices(c)), h * w - nb)\n    gi = fill(c, fgc, obj)\n    go = canvas(0, (h * nb, w * nb))\n    for j in range(h * w - nb):\n        loc = (j // nb, j % nb)\n        go = fill(go, fgc, shift(obj, multiply((h, w), loc)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_91413438(diff_lb: float, diff_ub: float) -> dict:\n    # Define possible colors (1-9)\n    cols = interval(1, 10, 1)\n    \n    # Randomly determine height of input grid (2-5)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly determine width of input grid (2-5)\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Calculate maximum number of blocks that can be removed\n    # Ensures output grid doesn't exceed 30x30\n    maxnb = min(h * w - 1, min(30//h, 30//w))\n    \n    # Calculate minimum number of blocks that can be removed\n    # Based on the quadratic formula solution for a perfect square\n    minnb = int(0.5 * ((4 * h * w + 1) ** 0.5 - 1)) + 1\n    \n    # Randomly determine how many blocks to remove within the allowed range\n    nbi = unifint(diff_lb, diff_ub, (0, maxnb - minnb))\n    nb = min(max(minnb, maxnb - nbi), maxnb)\n    \n    # Randomly choose a foreground color\n    fgc = choice(cols)\n    \n    # Create an empty input grid (all zeros)\n    c = canvas(0, (h, w))\n    \n    # Randomly select cells to be colored (foreground)\n    obj = sample(totuple(asindices(c)), h * w - nb)\n    \n    # Fill the selected cells with the foreground color\n    gi = fill(c, fgc, obj)\n    \n    # Create an empty output grid\n    go = canvas(0, (h * nb, w * nb))\n    \n    # Iterate over the colored cells in the input\n    for j in range(h * w - nb):\n        # Calculate the position in the output grid\n        loc = (j // nb, j % nb)\n        # Fill the corresponding area in the output grid\n        # This creates a pattern where each colored cell in the input\n        # becomes an h x w block in the output\n        go = fill(go, fgc, shift(obj, multiply((h, w), loc)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "91714a58": {
    "original": "def generate_91714a58(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    bgc, targc = sample(cols, 2)\n    remcols = remove(bgc, cols)\n    nnoise = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    gi = canvas(bgc, (h, w))\n    inds = totuple(asindices(gi))\n    noise = sample(inds, nnoise)\n    ih = randint(2, h // 2)\n    iw = randint(2, w // 2)\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    loc = (loci, locj)\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    go = fill(gi, targc, bd)\n    for ij in noise:\n        col = choice(remcols)\n        gi = fill(gi, col, {ij})\n    gi = fill(gi, targc, bd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_91714a58(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly select two colors: one for background and one for target\n    bgc, targc = sample(cols, 2)\n    \n    # Create a set of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Calculate number of noise points (between 1 and half of grid area)\n    nnoise = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Randomly select indices for noise points\n    noise = sample(inds, nnoise)\n    \n    # Generate random height for inner rectangle (between 2 and half of grid height)\n    ih = randint(2, h // 2)\n    \n    # Generate random width for inner rectangle (between 2 and half of grid width)\n    iw = randint(2, w // 2)\n    \n    # Generate random top-left corner position for inner rectangle\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    loc = (loci, locj)\n    \n    # Create a set of all indices within the inner rectangle\n    bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    \n    # Create the output grid by filling the inner rectangle with the target color\n    go = fill(gi, targc, bd)\n    \n    # Add noise to the input grid\n    for ij in noise:\n        # Choose a random color from remaining colors\n        col = choice(remcols)\n        # Fill the noise point with the chosen color\n        gi = fill(gi, col, {ij})\n    \n    # Fill the inner rectangle of the input grid with the target color\n    gi = fill(gi, targc, bd)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "9172f3a0": {
    "original": "def generate_9172f3a0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 10))\n    w = unifint(diff_lb, diff_ub, (1, 10))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = upscale(gi, 3)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9172f3a0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 10 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly choose a width between 1 and 10 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly select a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create a new tuple of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (0 to 9, but not more than grid size)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select 'numc' colors from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Create a tuple of all indices in the grid\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Choose a random number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select 'num' indices from the available indices\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Upscale the input grid by a factor of 3 to create the output grid\n    go = upscale(gi, 3)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "928ad970": {
    "original": "def generate_928ad970(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    ih = unifint(diff_lb, diff_ub, (9, h))\n    iw = unifint(diff_lb, diff_ub, (9, w))\n    bgc, linc, dotc = sample(cols, 3)\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    ulc = (loci, locj)\n    lrc = (loci + ih - 1, locj + iw - 1)\n    dot1 = choice(totuple(connect(ulc, (loci + ih - 1, locj)) - {ulc, (loci + ih - 1, locj)}))\n    dot2 = choice(totuple(connect(ulc, (loci, locj + iw - 1)) - {ulc, (loci, locj + iw - 1)}))\n    dot3 = choice(totuple(connect(lrc, (loci + ih - 1, locj)) - {lrc, (loci + ih - 1, locj)}))\n    dot4 = choice(totuple(connect(lrc, (loci, locj + iw - 1)) - {lrc, (loci, locj + iw - 1)}))\n    a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))\n    while a + 1 == b:\n        a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))\n    c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))\n    while c + 1 == d:\n        c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))\n    sp = box(frozenset({(a, c), (b, d)}))\n    bx = {dot1, dot2, dot3, dot4}\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    gi = fill(gi, dotc, bx)\n    gi = fill(gi, linc, sp)\n    go = fill(gi, linc, inbox(bx))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_928ad970(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate inner height, slightly smaller than h\n    ih = unifint(diff_lb, diff_ub, (9, h))\n    # Generate inner width, slightly smaller than w\n    iw = unifint(diff_lb, diff_ub, (9, w))\n    \n    # Randomly select 3 colors: background, line, and dot colors\n    bgc, linc, dotc = sample(cols, 3)\n    \n    # Generate random location for the upper-left corner of the inner box\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    \n    # Define upper-left and lower-right corners of the inner box\n    ulc = (loci, locj)\n    lrc = (loci + ih - 1, locj + iw - 1)\n    \n    # Choose random points on each side of the inner box for dots\n    # Left side\n    dot1 = choice(totuple(connect(ulc, (loci + ih - 1, locj)) - {ulc, (loci + ih - 1, locj)}))\n    # Top side\n    dot2 = choice(totuple(connect(ulc, (loci, locj + iw - 1)) - {ulc, (loci, locj + iw - 1)}))\n    # Right side\n    dot3 = choice(totuple(connect(lrc, (loci + ih - 1, locj)) - {lrc, (loci + ih - 1, locj)}))\n    # Bottom side\n    dot4 = choice(totuple(connect(lrc, (loci, locj + iw - 1)) - {lrc, (loci, locj + iw - 1)}))\n    \n    # Choose two random, non-adjacent vertical positions for the inner box\n    a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))\n    while a + 1 == b:\n        a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))\n    \n    # Choose two random, non-adjacent horizontal positions for the inner box\n    c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))\n    while c + 1 == d:\n        c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))\n    \n    # Create the inner box shape\n    sp = box(frozenset({(a, c), (b, d)}))\n    \n    # Create a set of the four dot positions\n    bx = {dot1, dot2, dot3, dot4}\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create the output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Add dots to the input grid\n    gi = fill(gi, dotc, bx)\n    # Add inner box to the input grid\n    gi = fill(gi, linc, sp)\n    \n    # For the output, fill the area inside the dots with the line color\n    go = fill(gi, linc, inbox(bx))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "93b581b8": {
    "original": "def generate_93b581b8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numcols)\n    numocc = unifint(diff_lb, diff_ub, (1, (h * w) // 50))\n    succ = 0\n    tr = 0\n    maxtr = 10 * numocc\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    while tr < maxtr and succ < numocc:\n        tr += 1\n        cands = sfilter(inds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        c1, c2, c3, c4 = [choice(ccols) for k in range(4)]\n        q = {(0, 0), (0, 1), (1, 0), (1, 1)}\n        inobj = {(c1, (0, 0)), (c2, (0, 1)), (c3, (1, 0)), (c4, (1, 1))}\n        outobj = inobj | recolor(c4, shift(q, (-2, -2))) | recolor(c3, shift(q, (-2, 2))) | recolor(c2, shift(q, (2, -2))) | recolor(c1, shift(q, (2, 2)))\n        inobjplcd = shift(inobj, loc)\n        outobjplcd = shift(outobj, loc)\n        outobjplcd = sfilter(outobjplcd, lambda cij: cij[1] in fullinds)\n        outobjplcdi = toindices(outobjplcd)\n        if outobjplcdi.issubset(inds):\n            succ += 1\n            inds = (inds - outobjplcdi) - mapply(dneighbors, toindices(inobjplcd))\n            gi = paint(gi, inobjplcd)\n            go = paint(go, outobjplcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_93b581b8(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly generate width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (1 to 9) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Calculate the number of occurrences based on grid size and difficulty\n    numocc = unifint(diff_lb, diff_ub, (1, (h * w) // 50))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    \n    # Set maximum number of attempts\n    maxtr = 10 * numocc\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Store a copy of all indices\n    fullinds = asindices(gi)\n    \n    # Main loop for placing objects\n    while tr < maxtr and succ < numocc:\n        # Increment attempt counter\n        tr += 1\n        \n        # Filter valid positions for placing 2x2 objects\n        cands = sfilter(inds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)\n        \n        # Break if no valid positions are left\n        if len(cands) == 0:\n            break\n        \n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        \n        # Randomly choose 4 colors for the 2x2 input object\n        c1, c2, c3, c4 = [choice(ccols) for k in range(4)]\n        \n        # Define the 2x2 grid positions\n        q = {(0, 0), (0, 1), (1, 0), (1, 1)}\n        \n        # Create the 2x2 input object\n        inobj = {(c1, (0, 0)), (c2, (0, 1)), (c3, (1, 0)), (c4, (1, 1))}\n        \n        # Create the 5x5 output object by expanding the input object\n        outobj = inobj | recolor(c4, shift(q, (-2, -2))) | recolor(c3, shift(q, (-2, 2))) | recolor(c2, shift(q, (2, -2))) | recolor(c1, shift(q, (2, 2)))\n        \n        # Shift the input object to the chosen location\n        inobjplcd = shift(inobj, loc)\n        \n        # Shift the output object to the chosen location\n        outobjplcd = shift(outobj, loc)\n        \n        # Filter out parts of the output object that are outside the grid\n        outobjplcd = sfilter(outobjplcd, lambda cij: cij[1] in fullinds)\n        \n        # Get the indices of the placed output object\n        outobjplcdi = toindices(outobjplcd)\n        \n        # Check if the output object can be placed without overlap\n        if outobjplcdi.issubset(inds):\n            # Increment success counter\n            succ += 1\n            \n            # Remove used indices and neighboring cells from available positions\n            inds = (inds - outobjplcdi) - mapply(dneighbors, toindices(inobjplcd))\n            \n            # Paint the input object on the input grid\n            gi = paint(gi, inobjplcd)\n            \n            # Paint the output object on the output grid\n            go = paint(go, outobjplcd)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "941d9a10": {
    "original": "def generate_941d9a10(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    opts = interval(2, (h-1)//2 + 1, 2)\n    nhidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))\n    nh = opts[nhidx]\n    opts = interval(2, (w-1)//2 + 1, 2)\n    nwidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))\n    nw = opts[nwidx]\n    bgc, fgc = sample(cols, 2)\n    hgrid = canvas(bgc, (2*nh+1, w))\n    for j in range(1, h, 2):\n        hgrid = fill(hgrid, fgc, connect((j, 0), (j, w)))\n    for k in range(h - (2*nh+1)):\n        loc = randint(0, height(hgrid) - 1)\n        hgrid = hgrid[:loc] + canvas(bgc, (1, w)) + hgrid[loc:]\n    wgrid = canvas(bgc, (2*nw+1, h))\n    for j in range(1, w, 2):\n        wgrid = fill(wgrid, fgc, connect((j, 0), (j, h)))\n    for k in range(w - (2*nw+1)):\n        loc = randint(0, height(wgrid) - 1)\n        wgrid = wgrid[:loc] + canvas(bgc, (1, h)) + wgrid[loc:]\n    wgrid = dmirror(wgrid)\n    gi = canvas(bgc, (h, w))\n    fronts = ofcolor(hgrid, fgc) | ofcolor(wgrid, fgc)\n    gi = fill(gi, fgc, fronts)\n    objs = objects(gi, T, T, F)\n    objs = colorfilter(objs, bgc)\n    blue = argmin(objs, lambda o: leftmost(o) + uppermost(o))\n    green = argmax(objs, lambda o: leftmost(o) + uppermost(o))\n    f1 = lambda o: len(sfilter(objs, lambda o2: leftmost(o2) < leftmost(o))) == len(sfilter(objs, lambda o2: leftmost(o2) > leftmost(o)))\n    f2 = lambda o: len(sfilter(objs, lambda o2: uppermost(o2) < uppermost(o))) == len(sfilter(objs, lambda o2: uppermost(o2) > uppermost(o)))\n    red = extract(objs, lambda o: f1(o) and f2(o))\n    go = fill(gi, 1, blue)\n    go = fill(go, 3, green)\n    go = fill(go, 2, red)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_941d9a10(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1, 2, and 3\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    \n    # Generate random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Create a list of even numbers from 2 to half the height (rounded down)\n    opts = interval(2, (h-1)//2 + 1, 2)\n    \n    # Choose a random index for the number of horizontal lines\n    nhidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))\n    \n    # Get the number of horizontal lines\n    nh = opts[nhidx]\n    \n    # Create a list of even numbers from 2 to half the width (rounded down)\n    opts = interval(2, (w-1)//2 + 1, 2)\n    \n    # Choose a random index for the number of vertical lines\n    nwidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))\n    \n    # Get the number of vertical lines\n    nw = opts[nwidx]\n    \n    # Randomly choose background and foreground colors\n    bgc, fgc = sample(cols, 2)\n    \n    # Create a grid for horizontal lines\n    hgrid = canvas(bgc, (2*nh+1, w))\n    \n    # Draw horizontal lines on odd rows\n    for j in range(1, h, 2):\n        hgrid = fill(hgrid, fgc, connect((j, 0), (j, w)))\n    \n    # Add random empty rows to the horizontal grid\n    for k in range(h - (2*nh+1)):\n        loc = randint(0, height(hgrid) - 1)\n        hgrid = hgrid[:loc] + canvas(bgc, (1, w)) + hgrid[loc:]\n    \n    # Create a grid for vertical lines\n    wgrid = canvas(bgc, (2*nw+1, h))\n    \n    # Draw vertical lines on odd columns\n    for j in range(1, w, 2):\n        wgrid = fill(wgrid, fgc, connect((j, 0), (j, h)))\n    \n    # Add random empty columns to the vertical grid\n    for k in range(w - (2*nw+1)):\n        loc = randint(0, height(wgrid) - 1)\n        wgrid = wgrid[:loc] + canvas(bgc, (1, h)) + wgrid[loc:]\n    \n    # Mirror the vertical grid diagonally\n    wgrid = dmirror(wgrid)\n    \n    # Create the initial input grid\n    gi = canvas(bgc, (h, w))\n    \n    # Combine horizontal and vertical line positions\n    fronts = ofcolor(hgrid, fgc) | ofcolor(wgrid, fgc)\n    \n    # Draw the grid lines on the input grid\n    gi = fill(gi, fgc, fronts)\n    \n    # Identify objects in the grid\n    objs = objects(gi, T, T, F)\n    \n    # Filter objects with background color\n    objs = colorfilter(objs, bgc)\n    \n    # Find the top-left most object (blue)\n    blue = argmin(objs, lambda o: leftmost(o) + uppermost(o))\n    \n    # Find the bottom-right most object (green)\n    green = argmax(objs, lambda o: leftmost(o) + uppermost(o))\n    \n    # Define function to check if object is in the middle horizontally\n    f1 = lambda o: len(sfilter(objs, lambda o2: leftmost(o2) < leftmost(o))) == len(sfilter(objs, lambda o2: leftmost(o2) > leftmost(o)))\n    \n    # Define function to check if object is in the middle vertically\n    f2 = lambda o: len(sfilter(objs, lambda o2: uppermost(o2) < uppermost(o))) == len(sfilter(objs, lambda o2: uppermost(o2) > uppermost(o)))\n    \n    # Find the object in the center (red)\n    red = extract(objs, lambda o: f1(o) and f2(o))\n    \n    # Create the output grid by coloring the identified objects\n    go = fill(gi, 1, blue)  # Color the top-left object blue (1)\n    go = fill(go, 3, green)  # Color the bottom-right object green (3)\n    go = fill(go, 2, red)  # Color the center object red (2)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "94f9d214": {
    "original": "def generate_94f9d214(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(A, B)\n    res = (set(inds) - set(aset)) & (set(inds) - set(bset))\n    go = fill(c, 2, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_94f9d214(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-9, excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly generate height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the first set of cells (A)\n    acol = choice(remcols)\n    \n    # Remove the chosen color for A from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a color for the second set of cells (B)\n    bcol = choice(remcols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly determine the number of deviations for A (cells that will be colored)\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly determine the number of deviations for B (cells that will be colored)\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose whether A will have the deviated amount of cells or the complement\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose whether B will have the deviated amount of cells or the complement\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure numa is between 1 and total cells - 1\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure numb is between 1 and total cells - 1\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly sample indices for A\n    aset = sample(inds, numa)\n    \n    # Randomly sample indices for B\n    bset = sample(inds, numb)\n    \n    # Create grid A by filling the sampled indices with acol\n    A = fill(c, acol, aset)\n    \n    # Create grid B by filling the sampled indices with bcol\n    B = fill(c, bcol, bset)\n    \n    # Concatenate A and B horizontally to create the input grid\n    gi = hconcat(A, B)\n    \n    # Find indices that are neither in A nor in B\n    res = (set(inds) - set(aset)) & (set(inds) - set(bset))\n    \n    # Create the output grid by filling the resulting indices with color 2\n    go = fill(c, 2, res)\n    \n    # 50% chance to mirror both input and output grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "952a094c": {
    "original": "def generate_952a094c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    ih = unifint(diff_lb, diff_ub, (4, h - 2))\n    iw = unifint(diff_lb, diff_ub, (4, w - 2))\n    loci = randint(1, h - ih - 1)\n    locj = randint(1, w - iw - 1)\n    sp = (loci, locj)\n    ep = (loci + ih - 1, locj + iw - 1)\n    bx = box(frozenset({sp, ep}))\n    bgc, fgc, a, b, c, d = sample(cols, 6)\n    canv = canvas(bgc, (h, w))\n    canvv = fill(canv, fgc, bx)\n    gi = tuple(e for e in canvv)\n    go = tuple(e for e in canvv)\n    gi = fill(gi, a, {(loci + 1, locj + 1)})\n    go = fill(go, a, {(loci + ih, locj + iw)})\n    gi = fill(gi, b, {(loci + 1, locj + iw - 2)})\n    go = fill(go, b, {(loci + ih, locj - 1)})\n    gi = fill(gi, c, {(loci + ih - 2, locj + 1)})\n    go = fill(go, c, {(loci - 1, locj + iw)})\n    gi = fill(gi, d, {(loci + ih - 2, locj + iw - 2)})\n    go = fill(go, d, {(loci - 1, locj - 1)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_952a094c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random inner height between 4 and h-2 based on difficulty\n    ih = unifint(diff_lb, diff_ub, (4, h - 2))\n    \n    # Generate random inner width between 4 and w-2 based on difficulty\n    iw = unifint(diff_lb, diff_ub, (4, w - 2))\n    \n    # Generate random vertical location for inner box\n    loci = randint(1, h - ih - 1)\n    \n    # Generate random horizontal location for inner box\n    locj = randint(1, w - iw - 1)\n    \n    # Define start point of the box\n    sp = (loci, locj)\n    \n    # Define end point of the box\n    ep = (loci + ih - 1, locj + iw - 1)\n    \n    # Create a set of coordinates forming a box outline\n    bx = box(frozenset({sp, ep}))\n    \n    # Randomly select 6 unique colors from the color range\n    bgc, fgc, a, b, c, d = sample(cols, 6)\n    \n    # Create a canvas filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Fill the box outline with the foreground color\n    canvv = fill(canv, fgc, bx)\n    \n    # Create input grid by converting the canvas to a tuple\n    gi = tuple(e for e in canvv)\n    \n    # Create output grid by converting the canvas to a tuple\n    go = tuple(e for e in canvv)\n    \n    # Place color 'a' at top-left corner of the box in input grid\n    gi = fill(gi, a, {(loci + 1, locj + 1)})\n    \n    # Place color 'a' at bottom-right corner of the box in output grid\n    go = fill(go, a, {(loci + ih, locj + iw)})\n    \n    # Place color 'b' at top-right corner (minus 1) of the box in input grid\n    gi = fill(gi, b, {(loci + 1, locj + iw - 2)})\n    \n    # Place color 'b' at bottom-left corner (outside) of the box in output grid\n    go = fill(go, b, {(loci + ih, locj - 1)})\n    \n    # Place color 'c' at bottom-left corner (minus 1) of the box in input grid\n    gi = fill(gi, c, {(loci + ih - 2, locj + 1)})\n    \n    # Place color 'c' at top-right corner (outside) of the box in output grid\n    go = fill(go, c, {(loci - 1, locj + iw)})\n    \n    # Place color 'd' at bottom-right corner (minus 1) of the box in input grid\n    gi = fill(gi, d, {(loci + ih - 2, locj + iw - 2)})\n    \n    # Place color 'd' at top-left corner (outside) of the box in output grid\n    go = fill(go, d, {(loci - 1, locj - 1)})\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "9565186b": {
    "original": "def generate_9565186b(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    wg = canvas(5, (h, w))\n    numcols = unifint(diff_lb, diff_ub, (2, min(h * w - 1, 8)))\n    mostcol = choice(cols)\n    nummostcol_lb = (h * w) // numcols + 1\n    nummostcol_ub = h * w - numcols + 1\n    ubmlb = nummostcol_ub - nummostcol_lb\n    nmcdev = unifint(diff_lb, diff_ub, (0, ubmlb))\n    nummostcol = nummostcol_ub - nmcdev\n    nummostcol = min(max(nummostcol, nummostcol_lb), nummostcol_ub)\n    inds = totuple(asindices(wg))\n    mostcollocs = sample(inds, nummostcol)\n    gi = fill(wg, mostcol, mostcollocs)\n    go = fill(wg, mostcol, mostcollocs)\n    remcols = remove(mostcol, cols)\n    othcols = sample(remcols, numcols - 1)\n    reminds = difference(inds, mostcollocs)\n    bufferlocs = sample(reminds, numcols - 1)\n    for c, l in zip(othcols, bufferlocs):\n        gi = fill(gi, c, {l})\n    reminds = difference(reminds, bufferlocs)\n    colcounts = {c: 1 for c in othcols}\n    for ij in reminds:\n        if len(othcols) == 0:\n            gi = fill(gi, mostcol, {ij})\n            go = fill(go, mostcol, {ij})\n        else:\n            chc = choice(othcols)\n            gi = fill(gi, chc, {ij})\n            colcounts[chc] += 1\n            if colcounts[chc] == nummostcol - 1:\n                othcols = remove(chc, othcols)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9565186b(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 5\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Generate random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Create a canvas filled with color 5 of size h x w\n    wg = canvas(5, (h, w))\n    \n    # Determine number of colors to use (between 2 and min(h*w-1, 8))\n    numcols = unifint(diff_lb, diff_ub, (2, min(h * w - 1, 8)))\n    \n    # Choose the most common color randomly from cols\n    mostcol = choice(cols)\n    \n    # Calculate lower bound for the count of most common color\n    nummostcol_lb = (h * w) // numcols + 1\n    \n    # Calculate upper bound for the count of most common color\n    nummostcol_ub = h * w - numcols + 1\n    \n    # Calculate range between upper and lower bounds\n    ubmlb = nummostcol_ub - nummostcol_lb\n    \n    # Generate a random deviation within the range based on difficulty\n    nmcdev = unifint(diff_lb, diff_ub, (0, ubmlb))\n    \n    # Calculate the actual count of most common color\n    nummostcol = nummostcol_ub - nmcdev\n    \n    # Ensure the count is within bounds\n    nummostcol = min(max(nummostcol, nummostcol_lb), nummostcol_ub)\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(wg))\n    \n    # Randomly choose locations for the most common color\n    mostcollocs = sample(inds, nummostcol)\n    \n    # Fill the input grid with the most common color at chosen locations\n    gi = fill(wg, mostcol, mostcollocs)\n    \n    # Fill the output grid with the most common color at chosen locations\n    go = fill(wg, mostcol, mostcollocs)\n    \n    # Create a list of remaining colors (excluding the most common color)\n    remcols = remove(mostcol, cols)\n    \n    # Choose other colors to use\n    othcols = sample(remcols, numcols - 1)\n    \n    # Get remaining indices (not occupied by most common color)\n    reminds = difference(inds, mostcollocs)\n    \n    # Choose locations for buffer cells (one for each other color)\n    bufferlocs = sample(reminds, numcols - 1)\n    \n    # Fill buffer cells with other colors in the input grid\n    for c, l in zip(othcols, bufferlocs):\n        gi = fill(gi, c, {l})\n    \n    # Update remaining indices (excluding buffer cells)\n    reminds = difference(reminds, bufferlocs)\n    \n    # Initialize color counts for other colors\n    colcounts = {c: 1 for c in othcols}\n    \n    # Fill remaining cells in the input grid\n    for ij in reminds:\n        if len(othcols) == 0:\n            # If no other colors left, fill with most common color in both grids\n            gi = fill(gi, mostcol, {ij})\n            go = fill(go, mostcol, {ij})\n        else:\n            # Choose a random color from other colors\n            chc = choice(othcols)\n            # Fill the cell with chosen color in input grid\n            gi = fill(gi, chc, {ij})\n            # Increment the count for the chosen color\n            colcounts[chc] += 1\n            # If the count reaches nummostcol - 1, remove the color from othcols\n            if colcounts[chc] == nummostcol - 1:\n                othcols = remove(chc, othcols)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "95990924": {
    "original": "def generate_95990924(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    bx = box(frozenset({(0, 0), (3, 3)}))\n    bd = backdrop(bx)\n    maxtrials = 4 * num\n    succ = 0\n    tr = 0\n    while succ < num and tr < maxtrials:\n        loc = choice(totuple(inds))\n        bxs = shift(bx, loc)\n        if bxs.issubset(set(inds)):\n            gi = fill(gi, fgc, inbox(bxs))\n            go = fill(go, fgc, inbox(bxs))\n            go = fill(go, 1, {loc})\n            go = fill(go, 2, {add(loc, (0, 3))})\n            go = fill(go, 3, {add(loc, (3, 0))})\n            go = fill(go, 4, {add(loc, (3, 3))})\n            inds = difference(inds, shift(bd, loc))\n            succ += 1\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_95990924(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 1, 2, 3, 4 (these will be used for corner markers)\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 4))\n    \n    # Generate random height between 6 and 30, based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random width between 6 and 30, based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Calculate number of boxes to place, between 1 and 1/16th of total grid area\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    \n    # Randomly select background and foreground colors\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Define a 4x4 box outline\n    bx = box(frozenset({(0, 0), (3, 3)}))\n    \n    # Get all indices within the 4x4 box\n    bd = backdrop(bx)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize counter for successful placements\n    succ = 0\n    \n    # Initialize counter for total placement attempts\n    tr = 0\n    \n    # Loop until desired number of boxes are placed or max attempts reached\n    while succ < num and tr < maxtrials:\n        # Randomly select a location in the grid\n        loc = choice(totuple(inds))\n        \n        # Shift the box to the selected location\n        bxs = shift(bx, loc)\n        \n        # Check if the shifted box fits within the grid\n        if bxs.issubset(set(inds)):\n            # Draw box outline in input grid using foreground color\n            gi = fill(gi, fgc, inbox(bxs))\n            \n            # Draw box outline in output grid using foreground color\n            go = fill(go, fgc, inbox(bxs))\n            \n            # Mark top-left corner with color 1 in output grid\n            go = fill(go, 1, {loc})\n            \n            # Mark top-right corner with color 2 in output grid\n            go = fill(go, 2, {add(loc, (0, 3))})\n            \n            # Mark bottom-left corner with color 3 in output grid\n            go = fill(go, 3, {add(loc, (3, 0))})\n            \n            # Mark bottom-right corner with color 4 in output grid\n            go = fill(go, 4, {add(loc, (3, 3))})\n            \n            # Remove placed box area from available indices\n            inds = difference(inds, shift(bd, loc))\n            \n            # Increment successful placement counter\n            succ += 1\n        \n        # Increment total attempt counter\n        tr += 1\n    \n    # Return dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "963e52fc": {
    "original": "def generate_963e52fc(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (6, 15))\n    p = unifint(diff_lb, diff_ub, (2, w // 2))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numc)\n    obj = set()\n    for j in range(p):\n        ub = unifint(diff_lb, diff_ub, (0, h//2))\n        ub = h//2-ub\n        lb = unifint(diff_lb, diff_ub, (ub, h-1))\n        numcells = unifint(diff_lb, diff_ub, (1, lb-ub+1))\n        for ii in sample(interval(ub, lb+1, 1), numcells):\n            loc = (ii, j)\n            col = choice(ccols)\n            cell = (col, loc)\n            obj.add(cell)\n    go = canvas(bgc, (h, w*2))\n    minobj = obj | shift(obj, (0, p))\n    addonw = randint(0, p)\n    addon = sfilter(obj, lambda cij: cij[1][1] < addonw)\n    fullobj = minobj | addon\n    leftshift = randint(0, addonw)\n    fullobj = shift(fullobj, (0, -leftshift))\n    go = paint(go, fullobj)\n    for j in range((2*w)//(2*p)+1):\n        go = paint(go, shift(fullobj, (0, j * 2 * p)))\n    gi = lefthalf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_963e52fc(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 6 and 15\n    w = unifint(diff_lb, diff_ub, (6, 15))\n    \n    # Randomly determine the period of the pattern between 2 and half the width\n    p = unifint(diff_lb, diff_ub, (2, w // 2))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1 to 9)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Initialize an empty set to store the object cells\n    obj = set()\n    \n    # Loop to create the base pattern\n    for j in range(p):\n        # Determine the upper bound for the pattern height\n        ub = unifint(diff_lb, diff_ub, (0, h//2))\n        ub = h//2-ub\n        \n        # Determine the lower bound for the pattern height\n        lb = unifint(diff_lb, diff_ub, (ub, h-1))\n        \n        # Determine the number of cells in this column of the pattern\n        numcells = unifint(diff_lb, diff_ub, (1, lb-ub+1))\n        \n        # Randomly place cells in this column of the pattern\n        for ii in sample(interval(ub, lb+1, 1), numcells):\n            loc = (ii, j)\n            col = choice(ccols)\n            cell = (col, loc)\n            obj.add(cell)\n    \n    # Create a canvas with the background color, twice the width of the input\n    go = canvas(bgc, (h, w*2))\n    \n    # Create the minimum object by combining the base pattern and its shift\n    minobj = obj | shift(obj, (0, p))\n    \n    # Randomly determine width of additional pattern\n    addonw = randint(0, p)\n    \n    # Create additional pattern based on random width\n    addon = sfilter(obj, lambda cij: cij[1][1] < addonw)\n    \n    # Combine all parts of the pattern\n    fullobj = minobj | addon\n    \n    # Randomly shift the pattern left\n    leftshift = randint(0, addonw)\n    fullobj = shift(fullobj, (0, -leftshift))\n    \n    # Paint the full object onto the output grid\n    go = paint(go, fullobj)\n    \n    # Repeat the pattern across the output grid\n    for j in range((2*w)//(2*p)+1):\n        go = paint(go, shift(fullobj, (0, j * 2 * p)))\n    \n    # Create the input grid by taking the left half of the output grid\n    gi = lefthalf(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "97999447": {
    "original": "def generate_97999447(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    opts = interval(0, h, 1)\n    num = unifint(diff_lb, diff_ub, (1, h))\n    locs = sample(opts, num)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for idx in locs:\n        col = choice(ccols)\n        j = randint(0, w - 1)\n        dot = (idx, j)\n        gi = fill(gi, col, {dot})\n        go = fill(go, col, {(idx, x) for x in range(j, w, 2)})\n        go = fill(go, 5, {(idx, x) for x in range(j+1, w, 2)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_97999447(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color values (0-9) excluding 5\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Create a list of possible row indices (0 to h-1)\n    opts = interval(0, h, 1)\n    \n    # Randomly determine the number of rows to be filled based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, h))\n    \n    # Randomly select 'num' rows from the possible row indices\n    locs = sample(opts, num)\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1-8) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select 'numc' colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Iterate through the selected row indices\n    for idx in locs:\n        # Randomly choose a color from the selected colors\n        col = choice(ccols)\n        \n        # Randomly choose a column index\n        j = randint(0, w - 1)\n        \n        # Create a tuple representing the dot's position\n        dot = (idx, j)\n        \n        # Place the colored dot on the input grid\n        gi = fill(gi, col, {dot})\n        \n        # Fill the output grid with the color in every other column from j to the right\n        go = fill(go, col, {(idx, x) for x in range(j, w, 2)})\n        \n        # Fill the output grid with color 5 in the alternating columns from j+1 to the right\n        go = fill(go, 5, {(idx, x) for x in range(j+1, w, 2)})\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "97a05b5b": {
    "original": "def generate_97a05b5b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (15, 30))\n    w = unifint(diff_lb, diff_ub, (15, 30))\n    sgh = randint(h//3, h//3*2)\n    sgw = randint(w//3, w//3*2)\n    bgc, sqc = sample(cols, 2)\n    remcols = remove(bgc, remove(sqc, cols))\n    gi = canvas(bgc, (h, w))\n    oh = randint(2, sgh//2)\n    ow = randint(2, sgw//2)\n    nobjs = unifint(diff_lb, diff_ub, (1, 8))\n    objs = set()\n    cands = asindices(canvas(-1, (oh, ow)))\n    forbidden = set()\n    tr = 0\n    maxtr = 4 * nobjs\n    while len(objs) != nobjs and tr < maxtr:\n        tr += 1\n        obj = {choice(totuple(cands))}\n        ncells = randint(1, oh * ow - 1)\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))\n        obj |= choice((dmirror, cmirror, vmirror, hmirror))(obj)\n        if len(obj) == height(obj) * width(obj):\n            continue\n        obj = frozenset(obj)\n        objn = normalize(obj)\n        if objn not in forbidden:\n            objs.add(objn)\n        for augmf1 in (identity, dmirror, cmirror, hmirror, vmirror):\n            for augmf2 in (identity, dmirror, cmirror, hmirror, vmirror):\n                forbidden.add(augmf1(augmf2(objn)))\n    tr = 0\n    maxtr = 5 * nobjs\n    succ = 0\n    loci = randint(0, h - sgh)\n    locj = randint(0, w - sgw)\n    bd = backdrop(frozenset({(loci, locj), (loci + sgh - 1, locj + sgw - 1)}))\n    gi = fill(gi, sqc, bd)\n    go = canvas(sqc, (sgh, sgw))\n    goinds = asindices(go)\n    giinds = asindices(gi) - shift(goinds, (loci, locj))\n    giinds = giinds - mapply(neighbors, shift(goinds, (loci, locj)))\n    while succ < nobjs and tr < maxtr and len(objs) > 0:\n        tr += 1\n        obj = choice(totuple(objs))\n        col = choice(remcols)\n        subgi = fill(canvas(col, shape(obj)), sqc, obj)\n        if len(palette(subgi)) == 1:\n            continue\n        f1 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        f2 = choice((identity, dmirror, vmirror, cmirror, hmirror))\n        f = compose(f1, f2)\n        subgo = f(subgi)\n        giobj = asobject(subgi)\n        goobj = asobject(subgo)\n        ohi, owi = shape(giobj)\n        oho, owo = shape(goobj)\n        gocands = sfilter(goinds, lambda ij: ij[0] <= sgh - oho and ij[1] <= sgw - owo)\n        if len(gocands) == 0:\n            continue\n        goloc = choice(totuple(gocands))\n        goplcd = shift(goobj, goloc)\n        goplcdi = toindices(goplcd)\n        if goplcdi.issubset(goinds):\n            gicands = sfilter(giinds, lambda ij: ij[0] <= h - ohi and ij[1] <= owi)\n            if len(gicands) == 0:\n                continue\n            giloc = choice(totuple(gicands))\n            giplcd = shift(giobj, giloc)\n            giplcdi = toindices(giplcd)\n            if giplcdi.issubset(giinds):\n                succ += 1\n                remcols = remove(col, remcols)\n                objs = remove(obj, objs)\n                goinds = goinds - goplcdi\n                giinds = (giinds - giplcdi) - mapply(neighbors, giplcdi)\n                gi = paint(gi, giplcd)\n                gi = fill(gi, bgc, sfilter(shift(goplcd, (loci, locj)), lambda cij: cij[0] == sqc))\n                go = paint(go, goplcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_97a05b5b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (15, 30))  # Randomly select height between 15 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (15, 30))  # Randomly select width between 15 and 30 based on difficulty\n    sgh = randint(h//3, h//3*2)  # Select a subgrid height between 1/3 and 2/3 of the main grid height\n    sgw = randint(w//3, w//3*2)  # Select a subgrid width between 1/3 and 2/3 of the main grid width\n    bgc, sqc = sample(cols, 2)  # Randomly select two colors: one for background and one for square\n    remcols = remove(bgc, remove(sqc, cols))  # Remove background and square colors from available colors\n    gi = canvas(bgc, (h, w))  # Create input grid filled with background color\n    oh = randint(2, sgh//2)  # Select object height between 2 and half of subgrid height\n    ow = randint(2, sgw//2)  # Select object width between 2 and half of subgrid width\n    nobjs = unifint(diff_lb, diff_ub, (1, 8))  # Randomly select number of objects (1-8) based on difficulty\n    objs = set()  # Initialize empty set to store objects\n    cands = asindices(canvas(-1, (oh, ow)))  # Create candidate indices for object creation\n    forbidden = set()  # Initialize set of forbidden object shapes\n    tr = 0  # Initialize trial counter\n    maxtr = 4 * nobjs  # Set maximum number of trials for object creation\n    \n    # Object creation loop\n    while len(objs) != nobjs and tr < maxtr:\n        tr += 1  # Increment trial counter\n        obj = {choice(totuple(cands))}  # Start object with a random cell\n        ncells = randint(1, oh * ow - 1)  # Randomly select number of cells for the object\n        # Add cells to the object\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))  # Add a neighboring cell\n        obj |= choice((dmirror, cmirror, vmirror, hmirror))(obj)  # Apply random mirror transformation\n        if len(obj) == height(obj) * width(obj):  # Skip if object is rectangular\n            continue\n        obj = frozenset(obj)  # Convert object to frozenset\n        objn = normalize(obj)  # Normalize object position\n        if objn not in forbidden:  # Check if object shape is allowed\n            objs.add(objn)  # Add object to set of objects\n        # Add all possible transformations of the object to forbidden set\n        for augmf1 in (identity, dmirror, cmirror, hmirror, vmirror):\n            for augmf2 in (identity, dmirror, cmirror, hmirror, vmirror):\n                forbidden.add(augmf1(augmf2(objn)))\n\n    tr = 0  # Reset trial counter\n    maxtr = 5 * nobjs  # Set maximum number of trials for object placement\n    succ = 0  # Initialize success counter\n    loci = randint(0, h - sgh)  # Select random vertical position for subgrid\n    locj = randint(0, w - sgw)  # Select random horizontal position for subgrid\n    bd = backdrop(frozenset({(loci, locj), (loci + sgh - 1, locj + sgw - 1)}))  # Create backdrop for subgrid\n    gi = fill(gi, sqc, bd)  # Fill subgrid area with square color\n    go = canvas(sqc, (sgh, sgw))  # Create output grid filled with square color\n    goinds = asindices(go)  # Get all indices of output grid\n    giinds = asindices(gi) - shift(goinds, (loci, locj))  # Get available indices in input grid\n    giinds = giinds - mapply(neighbors, shift(goinds, (loci, locj)))  # Remove neighbors of subgrid from available indices\n    \n    # Object placement loop\n    while succ < nobjs and tr < maxtr and len(objs) > 0:\n        tr += 1  # Increment trial counter\n        obj = choice(totuple(objs))  # Select a random object\n        col = choice(remcols)  # Select a random color for the object\n        subgi = fill(canvas(col, shape(obj)), sqc, obj)  # Create a subgrid with the object\n        if len(palette(subgi)) == 1:  # Skip if subgrid has only one color\n            continue\n        f1 = choice((identity, dmirror, vmirror, cmirror, hmirror))  # Select random transformation\n        f2 = choice((identity, dmirror, vmirror, cmirror, hmirror))  # Select another random transformation\n        f = compose(f1, f2)  # Compose the two transformations\n        subgo = f(subgi)  # Apply transformations to create output subgrid\n        giobj = asobject(subgi)  # Convert input subgrid to object\n        goobj = asobject(subgo)  # Convert output subgrid to object\n        ohi, owi = shape(giobj)  # Get shape of input object\n        oho, owo = shape(goobj)  # Get shape of output object\n        gocands = sfilter(goinds, lambda ij: ij[0] <= sgh - oho and ij[1] <= sgw - owo)  # Find candidate positions in output grid\n        if len(gocands) == 0:  # Skip if no valid positions in output grid\n            continue\n        goloc = choice(totuple(gocands))  # Select random position in output grid\n        goplcd = shift(goobj, goloc)  # Place object in output grid\n        goplcdi = toindices(goplcd)  # Get indices of placed object in output grid\n        if goplcdi.issubset(goinds):  # Check if object fits in output grid\n            gicands = sfilter(giinds, lambda ij: ij[0] <= h - ohi and ij[1] <= owi)  # Find candidate positions in input grid\n            if len(gicands) == 0:  # Skip if no valid positions in input grid\n                continue\n            giloc = choice(totuple(gicands))  # Select random position in input grid\n            giplcd = shift(giobj, giloc)  # Place object in input grid\n            giplcdi = toindices(giplcd)  # Get indices of placed object in input grid\n            if giplcdi.issubset(giinds):  # Check if object fits in input grid\n                succ += 1  # Increment success counter\n                remcols = remove(col, remcols)  # Remove used color from available colors\n                objs = remove(obj, objs)  # Remove placed object from set of objects\n                goinds = goinds - goplcdi  # Update available indices in output grid\n                giinds = (giinds - giplcdi) - mapply(neighbors, giplcdi)  # Update available indices in input grid\n                gi = paint(gi, giplcd)  # Paint object in input grid\n                gi = fill(gi, bgc, sfilter(shift(goplcd, (loci, locj)), lambda cij: cij[0] == sqc))  # Fill background in input grid\n                go = paint(go, goplcd)  # Paint object in output grid\n    \n    return {'input': gi, 'output': go}  # Return input and output grids as a dictionary\n"
  },
  "98cf29f8": {
    "original": "def generate_98cf29f8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    objh = unifint(diff_lb, diff_ub, (2, h - 5))\n    objw = unifint(diff_lb, diff_ub, (2, w - 5))\n    loci = randint(0, h - objh)\n    locj = randint(0, w - objw)\n    loc = (loci, locj)\n    obj = backdrop(frozenset({(loci, locj), (loci + objh - 1, locj + objw - 1)}))\n    bgc, objc, otherc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, objc, obj)\n    bmarg = h - (loci + objh)\n    rmarg = w - (locj + objw)\n    tmarg = loci\n    lmarg = locj\n    margs = (bmarg, rmarg, tmarg, lmarg)\n    options = [idx for idx, marg in enumerate(margs) if marg > 2]\n    pos = choice(options)\n    for k in range(pos):\n        gi = rot90(gi)\n    h, w = shape(gi)\n    ofc = ofcolor(gi, objc)\n    locis = randint(lowermost(ofc)+2, h-2)\n    locie = randint(locis+1, h-1)\n    locjs = randint(0, min(w - 2, rightmost(ofc)))\n    locje = randint(max(locjs+1, leftmost(ofc)), w - 1)\n    otherobj = backdrop(frozenset({(locis, locjs), (locie, locje)}))\n    ub = min(rightmost(ofc), rightmost(otherobj))\n    lb = max(leftmost(ofc), leftmost(otherobj))\n    jloc = randint(lb, ub)\n    ln = connect((lowermost(ofc)+1, jloc), (uppermost(otherobj)-1, jloc))\n    gib = tuple(e for e in gi)\n    gi = fill(gi, otherc, otherobj)\n    gi = fill(gi, otherc, ln)\n    go = fill(gib, otherc, shift(otherobj, (-len(ln), 0)))\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_98cf29f8(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random object height between 2 and h-5 based on difficulty\n    objh = unifint(diff_lb, diff_ub, (2, h - 5))\n    \n    # Generate random object width between 2 and w-5 based on difficulty\n    objw = unifint(diff_lb, diff_ub, (2, w - 5))\n    \n    # Generate random row position for the object\n    loci = randint(0, h - objh)\n    \n    # Generate random column position for the object\n    locj = randint(0, w - objw)\n    \n    # Create a tuple for the object's location\n    loc = (loci, locj)\n    \n    # Create a set of indices representing the object's area\n    obj = backdrop(frozenset({(loci, locj), (loci + objh - 1, locj + objw - 1)}))\n    \n    # Randomly select three different colors for background, object, and other elements\n    bgc, objc, otherc = sample(cols, 3)\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill the object area with the object color\n    gi = fill(gi, objc, obj)\n    \n    # Calculate margins around the object\n    bmarg = h - (loci + objh)  # Bottom margin\n    rmarg = w - (locj + objw)  # Right margin\n    tmarg = loci               # Top margin\n    lmarg = locj               # Left margin\n    margs = (bmarg, rmarg, tmarg, lmarg)\n    \n    # Select valid options for rotation (margins > 2)\n    options = [idx for idx, marg in enumerate(margs) if marg > 2]\n    \n    # Randomly choose a rotation option\n    pos = choice(options)\n    \n    # Rotate the grid based on the chosen option\n    for k in range(pos):\n        gi = rot90(gi)\n    \n    # Get the new dimensions after rotation\n    h, w = shape(gi)\n    \n    # Get indices of cells with the object color\n    ofc = ofcolor(gi, objc)\n    \n    # Generate random positions for a new object below the existing object\n    locis = randint(lowermost(ofc)+2, h-2)\n    locie = randint(locis+1, h-1)\n    locjs = randint(0, min(w - 2, rightmost(ofc)))\n    locje = randint(max(locjs+1, leftmost(ofc)), w - 1)\n    \n    # Create a set of indices for the new object\n    otherobj = backdrop(frozenset({(locis, locjs), (locie, locje)}))\n    \n    # Determine horizontal bounds for connecting line\n    ub = min(rightmost(ofc), rightmost(otherobj))\n    lb = max(leftmost(ofc), leftmost(otherobj))\n    \n    # Choose a random horizontal position for the connecting line\n    jloc = randint(lb, ub)\n    \n    # Create a set of indices for the connecting line\n    ln = connect((lowermost(ofc)+1, jloc), (uppermost(otherobj)-1, jloc))\n    \n    # Create a copy of the input grid\n    gib = tuple(e for e in gi)\n    \n    # Add the new object to the input grid\n    gi = fill(gi, otherc, otherobj)\n    \n    # Add the connecting line to the input grid\n    gi = fill(gi, otherc, ln)\n    \n    # Create the output grid by moving the new object up\n    go = fill(gib, otherc, shift(otherobj, (-len(ln), 0)))\n    \n    # Define a list of possible mirror and rotation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply random transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "995c5fa3": {
    "original": "def generate_995c5fa3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    o1 = asindices(canvas(-1, (4, 4)))\n    o2 = box(asindices(canvas(-1, (4, 4))))\n    o3 = asindices(canvas(-1, (4, 4))) - {(1, 0), (2, 0), (1, 3), (2, 3)}\n    o4 = o1 - shift(asindices(canvas(-1, (2, 2))), (2, 1))\n    mpr = [(o1, 2), (o2, 8), (o3, 3), (o4, 4)]\n    num = unifint(diff_lb, diff_ub, (1, 6))\n    h = 4\n    w = 4 * num + num - 1\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    ccols = []\n    for k in range(num):\n        col = choice(remcols)\n        obj, outcol = choice(mpr)\n        locj = 5 * k\n        gi = fill(gi, col, shift(obj, (0, locj)))\n        ccols.append(outcol)\n    go = tuple(repeat(c, num) for c in ccols)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_995c5fa3(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a 4x4 filled square object\n    o1 = asindices(canvas(-1, (4, 4)))\n    \n    # Define a 4x4 hollow square (box) object\n    o2 = box(asindices(canvas(-1, (4, 4))))\n    \n    # Define a 4x4 square with two cells removed from top and bottom\n    o3 = asindices(canvas(-1, (4, 4))) - {(1, 0), (2, 0), (1, 3), (2, 3)}\n    \n    # Define a 4x4 square with a 2x2 hole in the bottom-right\n    o4 = o1 - shift(asindices(canvas(-1, (2, 2))), (2, 1))\n    \n    # Create a list of object-color pairs\n    mpr = [(o1, 2), (o2, 8), (o3, 3), (o4, 4)]\n    \n    # Randomly determine the number of objects to place (1 to 6)\n    num = unifint(diff_lb, diff_ub, (1, 6))\n    \n    # Set the height of the grid\n    h = 4\n    \n    # Calculate the width of the grid based on the number of objects\n    w = 4 * num + num - 1\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Initialize a list to store the output colors\n    ccols = []\n    \n    # For each object to be placed:\n    for k in range(num):\n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # Choose a random object and its corresponding output color\n        obj, outcol = choice(mpr)\n        \n        # Calculate the horizontal position for the object\n        locj = 5 * k\n        \n        # Place the object on the input grid\n        gi = fill(gi, col, shift(obj, (0, locj)))\n        \n        # Add the output color to the list\n        ccols.append(outcol)\n    \n    # Create the output grid as a tuple of repeated output colors\n    go = tuple(repeat(c, num) for c in ccols)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "99b1bc43": {
    "original": "def generate_99b1bc43(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    bar = canvas(linc, (h, 1))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(hconcat(A, bar), B)\n    res = (set(bset) - set(aset)) | (set(aset) - set(bset))\n    go = fill(c, 3, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_99b1bc43(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly generate the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate the width of the grid between 2 and 14\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the dividing line\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random color for set A\n    acol = choice(remcols)\n    \n    # Remove color A from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a random color for set B\n    bcol = choice(remcols)\n    \n    # Create a canvas (grid) with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Create a vertical bar with the line color\n    bar = canvas(linc, (h, 1))\n    \n    # Randomly determine the deviation for the number of A elements\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly determine the deviation for the number of B elements\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose the number of A elements, either numadev or its complement\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose the number of B elements, either numbdev or its complement\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure numa is between 1 and h*w-1\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure numb is between 1 and h*w-1\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly select indices for set A\n    aset = sample(inds, numa)\n    \n    # Randomly select indices for set B\n    bset = sample(inds, numb)\n    \n    # Fill the canvas with color A at the selected A indices\n    A = fill(c, acol, aset)\n    \n    # Fill the canvas with color B at the selected B indices\n    B = fill(c, bcol, bset)\n    \n    # Concatenate A, the dividing bar, and B horizontally to create the input grid\n    gi = hconcat(hconcat(A, bar), B)\n    \n    # Calculate the symmetric difference between sets A and B\n    res = (set(bset) - set(aset)) | (set(aset) - set(bset))\n    \n    # Fill the output canvas with color 3 at the symmetric difference indices\n    go = fill(c, 3, res)\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "99fa7670": {
    "original": "def generate_99fa7670(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    num = unifint(diff_lb, diff_ub, (1, h // 2))\n    inds = interval(0, h, 1)\n    starts = sorted(sample(inds, num))\n    ends = [x - 1 for x in starts[1:]] + [h - 1]\n    nc = unifint(diff_lb, diff_ub, (1, 9))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, nc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for s, e in zip(starts, ends):\n        col = choice(ccols)\n        locj = randint(0, w - 2)\n        l1 = connect((s, locj), (s, w - 1))\n        l2 = connect((s, w - 1), (e, w - 1))\n        gi = fill(gi, col, {(s, locj)})\n        go = fill(go, col, l1 | l2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_99fa7670(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random number of lines to draw, between 1 and half the height\n    num = unifint(diff_lb, diff_ub, (1, h // 2))\n    \n    # Create a tuple of integers from 0 to h-1\n    inds = interval(0, h, 1)\n    \n    # Randomly select 'num' unique starting points and sort them\n    starts = sorted(sample(inds, num))\n    \n    # Calculate ending points for each line (one less than the next start, or the bottom of the grid)\n    ends = [x - 1 for x in starts[1:]] + [h - 1]\n    \n    # Choose a random number of colors to use (between 1 and 9)\n    nc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select 'nc' colors from the remaining colors\n    ccols = sample(remcols, nc)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # For each pair of start and end points:\n    for s, e in zip(starts, ends):\n        # Choose a random color for the line\n        col = choice(ccols)\n        \n        # Choose a random starting column for the line (not on the right edge)\n        locj = randint(0, w - 2)\n        \n        # Create a horizontal line from the start point to the right edge\n        l1 = connect((s, locj), (s, w - 1))\n        \n        # Create a vertical line from the right edge down to the end point\n        l2 = connect((s, w - 1), (e, w - 1))\n        \n        # Place a single colored pixel in the input grid at the start point\n        gi = fill(gi, col, {(s, locj)})\n        \n        # Draw the complete L-shaped line in the output grid\n        go = fill(go, col, l1 | l2)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "9aec4887": {
    "original": "def generate_9aec4887(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    oh = unifint(diff_lb, diff_ub, (4, h//2-2))\n    ow = unifint(diff_lb, diff_ub, (4, w//2-2))\n    bgc, pc, c1, c2, c3, c4 = sample(cols, 6)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (oh, ow))\n    ln1 = connect((1, 0), (oh - 2, 0))\n    ln2 = connect((1, ow - 1), (oh - 2, ow - 1))\n    ln3 = connect((0, 1), (0, ow - 2))\n    ln4 = connect((oh - 1, 1), (oh - 1, ow - 2))\n    go = fill(go, c1, ln1)\n    go = fill(go, c2, ln2)\n    go = fill(go, c3, ln3)\n    go = fill(go, c4, ln4)\n    objB = asobject(go)\n    bounds = asindices(canvas(-1, (oh - 2, ow - 2)))\n    objA = {choice(totuple(bounds))}\n    ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))\n    for k in range(ncells - 1):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    while shape(objA) != (oh - 2, ow - 2):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    fullinds = asindices(gi)\n    loci = randint(0, h - 2 * oh + 2)\n    locj = randint(0, w - ow)\n    plcdB = shift(objB, (loci, locj))\n    plcdi = toindices(plcdB)\n    rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)\n    loc = choice(totuple(rems))\n    plcdA = shift(objA, loc)\n    gi = paint(gi, plcdB)\n    gi = fill(gi, pc, plcdA)\n    objA = shift(objA, (1, 1))\n    objs = objects(go, T, F, T)\n    for ij in objA:\n        manhs = {obj: manhattan(obj, {ij}) for obj in objs}\n        manhsl = list(manhs.values())\n        mmh = min(manhsl)\n        if manhsl.count(mmh) == 1:\n            col = color([o for o, mnh in manhs.items() if mmh == mnh][0])\n        else:\n            col = pc\n        go = fill(go, col, {ij})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9aec4887(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 12 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    # Generate random width between 12 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Generate random output height between 4 and half of input height minus 2\n    oh = unifint(diff_lb, diff_ub, (4, h//2-2))\n    # Generate random output width between 4 and half of input width minus 2\n    ow = unifint(diff_lb, diff_ub, (4, w//2-2))\n    \n    # Select 6 unique colors from the color range\n    bgc, pc, c1, c2, c3, c4 = sample(cols, 6)\n    \n    # Create input grid with background color and dimensions h x w\n    gi = canvas(bgc, (h, w))\n    # Create output grid with background color and dimensions oh x ow\n    go = canvas(bgc, (oh, ow))\n    \n    # Define four lines for the border of the output grid\n    ln1 = connect((1, 0), (oh - 2, 0))  # Top border\n    ln2 = connect((1, ow - 1), (oh - 2, ow - 1))  # Bottom border\n    ln3 = connect((0, 1), (0, ow - 2))  # Left border\n    ln4 = connect((oh - 1, 1), (oh - 1, ow - 2))  # Right border\n    \n    # Fill the border lines with different colors\n    go = fill(go, c1, ln1)\n    go = fill(go, c2, ln2)\n    go = fill(go, c3, ln3)\n    go = fill(go, c4, ln4)\n    \n    # Convert output grid to an object\n    objB = asobject(go)\n    \n    # Create a set of indices for the inner area of the output grid\n    bounds = asindices(canvas(-1, (oh - 2, ow - 2)))\n    \n    # Start creating objA by choosing a random cell from the inner area\n    objA = {choice(totuple(bounds))}\n    \n    # Determine number of cells to add to objA\n    ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))\n    \n    # Add cells to objA, ensuring they are neighbors of existing cells\n    for k in range(ncells - 1):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    \n    # Expand objA until it fills the entire inner area\n    while shape(objA) != (oh - 2, ow - 2):\n        objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))\n    \n    # Get all indices of the input grid\n    fullinds = asindices(gi)\n    \n    # Choose random location for objB in the input grid\n    loci = randint(0, h - 2 * oh + 2)\n    locj = randint(0, w - ow)\n    \n    # Place objB at the chosen location\n    plcdB = shift(objB, (loci, locj))\n    plcdi = toindices(plcdB)\n    \n    # Find valid locations for objA in the input grid\n    rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)\n    \n    # Choose a random location for objA\n    loc = choice(totuple(rems))\n    \n    # Place objA at the chosen location\n    plcdA = shift(objA, loc)\n    \n    # Paint objB and objA onto the input grid\n    gi = paint(gi, plcdB)\n    gi = fill(gi, pc, plcdA)\n    \n    # Shift objA by (1, 1) to align with the inner area of the output grid\n    objA = shift(objA, (1, 1))\n    \n    # Get all objects in the output grid\n    objs = objects(go, T, F, T)\n    \n    # For each cell in objA, determine its color based on proximity to border objects\n    for ij in objA:\n        # Calculate Manhattan distance to each border object\n        manhs = {obj: manhattan(obj, {ij}) for obj in objs}\n        manhsl = list(manhs.values())\n        mmh = min(manhsl)\n        \n        # If there's a unique closest border object, use its color\n        if manhsl.count(mmh) == 1:\n            col = color([o for o, mnh in manhs.items() if mmh == mnh][0])\n        # Otherwise, use the default color pc\n        else:\n            col = pc\n        \n        # Fill the cell with the determined color\n        go = fill(go, col, {ij})\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "9af7a82c": {
    "original": "def generate_9af7a82c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    prods = dict()\n    for a in range(1, 31, 1):\n        for b in range(1, 31, 1):\n            prd = a*b\n            if prd in prods:\n                prods[prd].append((a, b))\n            else:\n                prods[prd] = [(a, b)]\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    leastnc = sum(range(1, ncols + 1, 1))\n    maxnc = sum(range(30, 30 - ncols, -1))\n    cands = {k: v for k, v in prods.items() if leastnc <= k <= maxnc}\n    options = set()\n    for v in cands.values():\n        for opt in v:\n            options.add(opt)\n    options = sorted(options, key=lambda ij: ij[0] * ij[1])\n    idx = unifint(diff_lb, diff_ub, (0, len(options) - 1))\n    h, w = options[idx]\n    ccols = sample(cols, ncols)\n    counts = list(range(1, ncols + 1, 1))\n    eliginds = {ncols - 1}\n    while sum(counts) < h * w:\n        eligindss = sorted(eliginds, reverse=True)\n        idx = unifint(diff_lb, diff_ub, (0, len(eligindss) - 1))\n        idx = eligindss[idx]\n        counts[idx] += 1\n        if idx > 0:\n            eliginds.add(idx - 1)\n        if idx < ncols - 1:\n            if counts[idx] == counts[idx+1] - 1:\n                eliginds = eliginds - {idx}\n        if counts[idx] == 30:\n            eliginds = eliginds - {idx}\n    gi = canvas(-1, (h, w))\n    go = canvas(0, (max(counts), ncols))\n    inds = asindices(gi)\n    counts = counts[::-1]\n    for j, (col, cnt) in enumerate(zip(ccols, counts)):\n        locs = sample(totuple(inds), cnt)\n        gi = fill(gi, col, locs)\n        inds = inds - set(locs)\n        go = fill(go, col, connect((0, j), (cnt - 1, j)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9af7a82c(diff_lb: float, diff_ub: float) -> dict:\n    # Generate a range of integers from 1 to 9 (possible column values)\n    cols = interval(1, 10, 1)\n    \n    # Initialize a dictionary to store products and their factor pairs\n    prods = dict()\n    \n    # Nested loops to generate all possible products up to 30x30\n    for a in range(1, 31, 1):\n        for b in range(1, 31, 1):\n            # Calculate the product\n            prd = a*b\n            # If the product already exists in the dictionary, append the new factor pair\n            if prd in prods:\n                prods[prd].append((a, b))\n            # Otherwise, create a new entry with the factor pair\n            else:\n                prods[prd] = [(a, b)]\n    \n    # Generate a random number of columns between 2 and 9 based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Calculate the minimum possible sum for the given number of columns\n    leastnc = sum(range(1, ncols + 1, 1))\n    # Calculate the maximum possible sum for the given number of columns\n    maxnc = sum(range(30, 30 - ncols, -1))\n    \n    # Filter the products dictionary to only include sums within the valid range\n    cands = {k: v for k, v in prods.items() if leastnc <= k <= maxnc}\n    \n    # Create a set of all possible factor pairs from the filtered products\n    options = set()\n    for v in cands.values():\n        for opt in v:\n            options.add(opt)\n    \n    # Sort the options based on their product (area of the grid)\n    options = sorted(options, key=lambda ij: ij[0] * ij[1])\n    \n    # Choose a random index based on difficulty\n    idx = unifint(diff_lb, diff_ub, (0, len(options) - 1))\n    # Select the grid dimensions (height and width) based on the chosen index\n    h, w = options[idx]\n    \n    # Randomly select column colors from the available colors\n    ccols = sample(cols, ncols)\n    \n    # Initialize the counts for each column\n    counts = list(range(1, ncols + 1, 1))\n    # Set of indices eligible for incrementing (initially only the last column)\n    eliginds = {ncols - 1}\n    \n    # Distribute the remaining cells among the columns\n    while sum(counts) < h * w:\n        # Sort eligible indices in descending order\n        eligindss = sorted(eliginds, reverse=True)\n        # Choose a random index from eligible indices based on difficulty\n        idx = unifint(diff_lb, diff_ub, (0, len(eligindss) - 1))\n        idx = eligindss[idx]\n        # Increment the count for the chosen column\n        counts[idx] += 1\n        # Update eligible indices based on new counts\n        if idx > 0:\n            eliginds.add(idx - 1)\n        if idx < ncols - 1:\n            if counts[idx] == counts[idx+1] - 1:\n                eliginds = eliginds - {idx}\n        if counts[idx] == 30:\n            eliginds = eliginds - {idx}\n    \n    # Create the input grid filled with -1 (empty cells)\n    gi = canvas(-1, (h, w))\n    # Create the output grid filled with 0 (empty cells)\n    go = canvas(0, (max(counts), ncols))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    # Reverse the counts to fill from bottom to top\n    counts = counts[::-1]\n    \n    # Fill the input and output grids\n    for j, (col, cnt) in enumerate(zip(ccols, counts)):\n        # Randomly select locations for the current color in the input grid\n        locs = sample(totuple(inds), cnt)\n        # Fill the selected locations with the current color in the input grid\n        gi = fill(gi, col, locs)\n        # Remove the filled locations from available indices\n        inds = inds - set(locs)\n        # Fill the output grid with the current color as a vertical line\n        go = fill(go, col, connect((0, j), (cnt - 1, j)))\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "9d9215db": {
    "original": "def generate_9d9215db(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (5, 14))\n    w = unifint(diff_lb, diff_ub, (5, 14))\n    h = h * 2 + 1\n    w = w * 2 + 1\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ub = min(h, w)//4\n    nrings = unifint(diff_lb, diff_ub, (1, ub))\n    onlinesbase = tuple([(2*k+1, 2*k+1) for k in range(ub)])\n    onlines = sample(onlinesbase, nrings)\n    onlines = {(choice(remcols), ij) for ij in onlines}\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, onlines)\n    linsbase = apply(rbind(add, (0, 2)), onlinesbase[:-1])\n    nlines = unifint(diff_lb, diff_ub, (1, len(linsbase)))\n    linesps = sample(linsbase, nlines)\n    colors = [choice(remcols) for k in range(nlines)]\n    dots = {(col, ij) for col, ij in zip(colors, linesps)}\n    dots2 = {(col, ij[::-1]) for col, ij in zip(colors, linesps)}\n    gi = paint(gi, dots | dots2)\n    ff = lambda ij: ij[1] % 2 == 1\n    ff2 = lambda ij: ij[0] % 2 == 1\n    linesps2 = tuple(x[::-1] for x in linesps)\n    lines = tuple(sfilter(connect(ij, (ij[0], w - ij[1] - 1)), ff) for ij in linesps)\n    lines2 = tuple(sfilter(connect(ij, (h - ij[0] - 1, ij[1])), ff2) for ij in linesps2)\n    lines = merge({recolor(col, l1 | l2) for col, (l1, l2) in zip(colors, zip(lines, lines2))})\n    gobase = paint(gi, lines)\n    go = paint(gobase, merge(fgpartition(vmirror(gobase))))\n    go = paint(go, merge(fgpartition(hmirror(gobase))))\n    go = paint(go, merge(fgpartition(vmirror(hmirror(gobase)))))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9d9215db(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly choose an odd height between 11 and 29\n    h = unifint(diff_lb, diff_ub, (5, 14))\n    # Randomly choose an odd width between 11 and 29\n    w = unifint(diff_lb, diff_ub, (5, 14))\n    h = h * 2 + 1\n    w = w * 2 + 1\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Calculate the upper bound for the number of rings\n    ub = min(h, w)//4\n    # Randomly choose the number of rings\n    nrings = unifint(diff_lb, diff_ub, (1, ub))\n    \n    # Create base positions for the rings\n    onlinesbase = tuple([(2*k+1, 2*k+1) for k in range(ub)])\n    # Randomly select positions for the rings\n    onlines = sample(onlinesbase, nrings)\n    # Assign random colors to the ring positions\n    onlines = {(choice(remcols), ij) for ij in onlines}\n    \n    # Create the initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    # Paint the rings onto the grid\n    gi = paint(gi, onlines)\n    \n    # Calculate base positions for the lines\n    linsbase = apply(rbind(add, (0, 2)), onlinesbase[:-1])\n    # Randomly choose the number of lines\n    nlines = unifint(diff_lb, diff_ub, (1, len(linsbase)))\n    # Randomly select positions for the lines\n    linesps = sample(linsbase, nlines)\n    # Assign random colors to the lines\n    colors = [choice(remcols) for k in range(nlines)]\n    \n    # Create dots at the line positions\n    dots = {(col, ij) for col, ij in zip(colors, linesps)}\n    # Create mirror dots for the lines\n    dots2 = {(col, ij[::-1]) for col, ij in zip(colors, linesps)}\n    # Paint the dots onto the grid\n    gi = paint(gi, dots | dots2)\n    \n    # Define filter functions for the lines\n    ff = lambda ij: ij[1] % 2 == 1\n    ff2 = lambda ij: ij[0] % 2 == 1\n    \n    # Create mirrored line positions\n    linesps2 = tuple(x[::-1] for x in linesps)\n    \n    # Generate horizontal lines\n    lines = tuple(sfilter(connect(ij, (ij[0], w - ij[1] - 1)), ff) for ij in linesps)\n    # Generate vertical lines\n    lines2 = tuple(sfilter(connect(ij, (h - ij[0] - 1, ij[1])), ff2) for ij in linesps2)\n    \n    # Combine and color the lines\n    lines = merge({recolor(col, l1 | l2) for col, (l1, l2) in zip(colors, zip(lines, lines2))})\n    \n    # Create the base output grid by painting the lines\n    gobase = paint(gi, lines)\n    \n    # Apply vertical mirroring to the foreground\n    go = paint(gobase, merge(fgpartition(vmirror(gobase))))\n    # Apply horizontal mirroring to the foreground\n    go = paint(go, merge(fgpartition(hmirror(gobase))))\n    # Apply both vertical and horizontal mirroring to the foreground\n    go = paint(go, merge(fgpartition(vmirror(hmirror(gobase)))))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply the rotation to the input grid\n    gi = rotf(gi)\n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "9dfd6313": {
    "original": "def generate_9dfd6313(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    dh = unifint(diff_lb, diff_ub, (1, 14))\n    d = 2 * dh + 1\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    gi = canvas(bgc, (d, d))\n    inds = asindices(gi)\n    lni = randint(1, 4)\n    if lni == 1:\n        ln = connect((dh, 0), (dh, d - 1))\n        mirrf = hmirror\n        cands = sfilter(inds, lambda ij: ij[0] > dh)\n    elif lni == 2:\n        ln = connect((0, dh), (d - 1, dh))\n        mirrf = vmirror\n        cands = sfilter(inds, lambda ij: ij[1] > dh)\n    elif lni == 3:\n        ln = connect((0, 0), (d - 1, d - 1))\n        mirrf = dmirror\n        cands = sfilter(inds, lambda ij: ij[0] > ij[1])\n    elif lni == 4:\n        ln = connect((d - 1, 0), (0, d - 1))\n        mirrf = cmirror\n        cands = sfilter(inds, lambda ij: (ij[0] + ij[1]) > d)\n    gi = fill(gi, linc, ln)\n    mp = (d * (d - 1)) // 2\n    numcols = unifint(diff_lb, diff_ub, (1, min(7, mp)))\n    colsch = sample(remcols, numcols)\n    numpix = unifint(diff_lb, diff_ub, (1, len(cands)))\n    pixs = sample(totuple(cands), numpix)\n    for pix in pixs:\n        gi = fill(gi, choice(colsch), {pix})\n    go = mirrf(gi)\n    if choice((True, False)):\n        gi, go = go, gi\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9dfd6313(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random integer for half the dimension, based on difficulty\n    dh = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Calculate full dimension (always odd)\n    d = 2 * dh + 1\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the line\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Create a canvas filled with the background color\n    gi = canvas(bgc, (d, d))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly choose a line type (1-4)\n    lni = randint(1, 4)\n    \n    # Based on the chosen line type, define the line and mirroring function\n    if lni == 1:\n        # Vertical line in the middle\n        ln = connect((dh, 0), (dh, d - 1))\n        mirrf = hmirror\n        # Select candidates to the right of the line\n        cands = sfilter(inds, lambda ij: ij[0] > dh)\n    elif lni == 2:\n        # Horizontal line in the middle\n        ln = connect((0, dh), (d - 1, dh))\n        mirrf = vmirror\n        # Select candidates below the line\n        cands = sfilter(inds, lambda ij: ij[1] > dh)\n    elif lni == 3:\n        # Diagonal line from top-left to bottom-right\n        ln = connect((0, 0), (d - 1, d - 1))\n        mirrf = dmirror\n        # Select candidates below the diagonal\n        cands = sfilter(inds, lambda ij: ij[0] > ij[1])\n    elif lni == 4:\n        # Diagonal line from top-right to bottom-left\n        ln = connect((d - 1, 0), (0, d - 1))\n        mirrf = cmirror\n        # Select candidates below the diagonal\n        cands = sfilter(inds, lambda ij: (ij[0] + ij[1]) > d)\n    \n    # Draw the chosen line on the grid\n    gi = fill(gi, linc, ln)\n    \n    # Calculate maximum possible pixels to color\n    mp = (d * (d - 1)) // 2\n    \n    # Choose a random number of colors to use, based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, min(7, mp)))\n    \n    # Randomly select colors from the remaining colors\n    colsch = sample(remcols, numcols)\n    \n    # Choose a random number of pixels to color, based on difficulty\n    numpix = unifint(diff_lb, diff_ub, (1, len(cands)))\n    \n    # Randomly select pixels to color\n    pixs = sample(totuple(cands), numpix)\n    \n    # Color the selected pixels with random colors\n    for pix in pixs:\n        gi = fill(gi, choice(colsch), {pix})\n    \n    # Mirror the input grid to create the output grid\n    go = mirrf(gi)\n    \n    # Randomly decide whether to swap input and output\n    if choice((True, False)):\n        gi, go = go, gi\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "9ecd008a": {
    "original": "def generate_9ecd008a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    gi = paint(gi, tr)\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    go = subgrid(bd, gi)\n    gi = fill(gi, 0, bd)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9ecd008a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 1 to 9 (possible color values)\n    cols = interval(1, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    # Set width equal to height (square grid)\n    w = h\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (excluding background)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly select colors to use from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas (grid) filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of cells to color\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Get all indices of the canvas as a set\n    bx = asindices(canv)\n    \n    # Create the first colored cell with a random color and position\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Iteratively add more colored cells\n    for kk in range(nc - 1):\n        # Find all neighbors of the existing colored cells\n        dns = mapply(neighbors, toindices(obj))\n        # Choose a random cell from the intersection of available cells and neighbors\n        ch = choice(totuple(bx & dns))\n        # Add the chosen cell with a random color to the object\n        obj.add((choice(remcols), ch))\n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Paint the colored cells onto the canvas\n    gi = paint(canv, obj)\n    \n    # Create a triangular shape by filtering cells above the diagonal\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    # Paint the triangular shape onto the grid\n    gi = paint(gi, tr)\n    \n    # Mirror the grid horizontally and concatenate\n    gi = hconcat(gi, vmirror(gi))\n    # Mirror the resulting grid vertically and concatenate\n    gi = vconcat(gi, hmirror(gi))\n    \n    # Randomly determine the position of a subgrid\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    \n    # Create a backdrop for the subgrid\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    \n    # Extract the subgrid from the main grid\n    go = subgrid(bd, gi)\n    \n    # Fill the subgrid area in the main grid with the background color (0)\n    gi = fill(gi, 0, bd)\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both the main grid and subgrid\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input (main grid) and output (subgrid) as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "9edfc990": {
    "original": "def generate_9edfc990(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(2, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    namt = unifint(diff_lb, diff_ub, (int(0.4 * h * w), int(0.7 * h * w)))\n    gi = canvas(0, (h, w))\n    inds = asindices(gi)\n    locs = sample(totuple(inds), namt)\n    noise = {(choice(cols), ij) for ij in locs}\n    gi = paint(gi, noise)\n    remlocs = inds - set(locs)\n    numc = unifint(diff_lb, diff_ub, (1, max(1, len(remlocs) // 10)))\n    blocs = sample(totuple(remlocs), numc)\n    gi = fill(gi, 1, blocs)\n    objs = objects(gi, T, F, F)\n    objs = colorfilter(objs, 0)\n    res = mfilter(objs, rbind(adjacent, blocs))\n    go = fill(gi, 1, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9edfc990(diff_lb: float, diff_ub: float) -> dict:\n    # Define possible column values (colors) from 2 to 9\n    cols = interval(2, 10, 1)\n    \n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Calculate number of cells to be filled with noise (40-70% of total cells)\n    namt = unifint(diff_lb, diff_ub, (int(0.4 * h * w), int(0.7 * h * w)))\n    \n    # Create an empty grid filled with zeros\n    gi = canvas(0, (h, w))\n    \n    # Get all possible cell indices in the grid\n    inds = asindices(gi)\n    \n    # Randomly select cells to be filled with noise\n    locs = sample(totuple(inds), namt)\n    \n    # Create noise by assigning random colors to selected locations\n    noise = {(choice(cols), ij) for ij in locs}\n    \n    # Paint the noise onto the grid\n    gi = paint(gi, noise)\n    \n    # Calculate remaining empty locations\n    remlocs = inds - set(locs)\n    \n    # Determine number of blue cells to add (max 10% of remaining cells)\n    numc = unifint(diff_lb, diff_ub, (1, max(1, len(remlocs) // 10)))\n    \n    # Randomly select locations for blue cells\n    blocs = sample(totuple(remlocs), numc)\n    \n    # Add blue cells (color 1) to the grid\n    gi = fill(gi, 1, blocs)\n    \n    # Identify all objects in the grid (connected components)\n    objs = objects(gi, T, F, F)\n    \n    # Filter objects to keep only those of color 0 (background)\n    objs = colorfilter(objs, 0)\n    \n    # Find background objects adjacent to blue cells\n    res = mfilter(objs, rbind(adjacent, blocs))\n    \n    # Create output grid by filling adjacent background objects with blue (1)\n    go = fill(gi, 1, res)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "9f236235": {
    "original": "def generate_9f236235(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    numh = unifint(diff_lb, diff_ub, (2, 14))\n    numw = unifint(diff_lb, diff_ub, (2, 14))\n    h = unifint(diff_lb, diff_ub, (1, 31 // numh - 1))\n    w = unifint(diff_lb, diff_ub, (1, 31 // numw - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    frontcol = choice(remcols)\n    remcols = remove(frontcol, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, min(9, numh * numw)))\n    ccols = sample(remcols, numcols)\n    numcells = unifint(diff_lb, diff_ub, (1, numh * numw))\n    cands = asindices(canvas(-1, (numh, numw)))\n    inds = asindices(canvas(-1, (h, w)))\n    locs = sample(totuple(cands), numcells)\n    gi = canvas(frontcol, (h * numh + numh - 1, w * numw + numw - 1))\n    go = canvas(bgc, (numh, numw))\n    for cand in cands:\n        a, b = cand\n        plcd = shift(inds, (a * (h + 1), b * (w + 1)))\n        col = choice(remcols) if cand in locs else bgc\n        gi = fill(gi, col, plcd)\n        go = fill(go, col, {cand})\n    go = vmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_9f236235(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Determine the number of horizontal cells based on difficulty\n    numh = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Determine the number of vertical cells based on difficulty\n    numw = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Determine the height of each cell based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 31 // numh - 1))\n    \n    # Determine the width of each cell based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 31 // numw - 1))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a color for the grid lines\n    frontcol = choice(remcols)\n    \n    # Remove the grid line color from the remaining colors\n    remcols = remove(frontcol, cols)\n    \n    # Determine the number of colors to use for cells, based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, min(9, numh * numw)))\n    \n    # Randomly sample colors for the cells\n    ccols = sample(remcols, numcols)\n    \n    # Determine the number of cells to color, based on difficulty\n    numcells = unifint(diff_lb, diff_ub, (1, numh * numw))\n    \n    # Create a set of all possible cell indices in the output grid\n    cands = asindices(canvas(-1, (numh, numw)))\n    \n    # Create a set of all possible indices within a single cell\n    inds = asindices(canvas(-1, (h, w)))\n    \n    # Randomly choose which cells will be colored\n    locs = sample(totuple(cands), numcells)\n    \n    # Create the input grid with grid lines\n    gi = canvas(frontcol, (h * numh + numh - 1, w * numw + numw - 1))\n    \n    # Create the output grid with the background color\n    go = canvas(bgc, (numh, numw))\n    \n    # Iterate through each cell in the output grid\n    for cand in cands:\n        # Get the row and column of the current cell\n        a, b = cand\n        \n        # Calculate the shifted indices for the current cell in the input grid\n        plcd = shift(inds, (a * (h + 1), b * (w + 1)))\n        \n        # Choose a color for the cell (random if it's a colored cell, background otherwise)\n        col = choice(remcols) if cand in locs else bgc\n        \n        # Fill the cell in the input grid with the chosen color\n        gi = fill(gi, col, plcd)\n        \n        # Fill the corresponding cell in the output grid with the chosen color\n        go = fill(go, col, {cand})\n    \n    # Mirror the output grid vertically\n    go = vmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a1570a43": {
    "original": "def generate_a1570a43(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    oh = unifint(diff_lb, diff_ub, (3, h))\n    ow = unifint(diff_lb, diff_ub, (3, w))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    crns = {(loci, locj), (loci + oh - 1, locj), (loci, locj + ow - 1), (loci + oh - 1, locj + ow - 1)}\n    cands = shift(asindices(canvas(-1, (oh-2, ow-2))), (loci+1, locj+1))\n    bgc, dotc = sample(cols, 2)\n    remcols = remove(bgc, remove(dotc, cols))\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    gipro = canvas(bgc, (h, w))\n    gipro = fill(gipro, dotc, crns)\n    sp = choice(totuple(cands))\n    obj = {sp}\n    cands = remove(sp, cands)\n    ncells = unifint(diff_lb, diff_ub, (oh + ow - 5, max(oh + ow - 5, ((oh - 2) * (ow - 2)) // 2)))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))\n    while shape(obj) != (oh-2, ow-2):\n        obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))\n    obj = {(choice(ccols), ij) for ij in obj}\n    go = paint(gipro, obj)\n    nperts = unifint(diff_lb, diff_ub, (1, max(h, w)))\n    k = 0\n    fullinds = asindices(go)\n    while ulcorner(obj) == (loci+1, locj+1) or k < nperts:\n        k += 1\n        options = sfilter(\n            neighbors((0, 0)),\n            lambda ij: len(crns & shift(toindices(obj), ij)) == 0 and \\\n                shift(toindices(obj), ij).issubset(fullinds)\n        )\n        direc = choice(totuple(options))\n        obj = shift(obj, direc)\n    gi = paint(gipro, obj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a1570a43(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height and width for the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate random height and width for the object, smaller than the grid\n    oh = unifint(diff_lb, diff_ub, (3, h))\n    ow = unifint(diff_lb, diff_ub, (3, w))\n    \n    # Generate random location for the object within the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Define the corners of the object\n    crns = {(loci, locj), (loci + oh - 1, locj), (loci, locj + ow - 1), (loci + oh - 1, locj + ow - 1)}\n    \n    # Generate candidate cells for the object, excluding the border\n    cands = shift(asindices(canvas(-1, (oh-2, ow-2))), (loci+1, locj+1))\n    \n    # Select background and dot colors\n    bgc, dotc = sample(cols, 2)\n    \n    # Get remaining colors, excluding background and dot colors\n    remcols = remove(bgc, remove(dotc, cols))\n    \n    # Select a random number of colors for the object\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    \n    # Create the initial grid with background color\n    gipro = canvas(bgc, (h, w))\n    \n    # Add dots to the corners of the object\n    gipro = fill(gipro, dotc, crns)\n    \n    # Select a starting point for the object\n    sp = choice(totuple(cands))\n    obj = {sp}\n    cands = remove(sp, cands)\n    \n    # Generate a random number of cells for the object\n    ncells = unifint(diff_lb, diff_ub, (oh + ow - 5, max(oh + ow - 5, ((oh - 2) * (ow - 2)) // 2)))\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))\n    \n    # Ensure the object fills the entire area (excluding border)\n    while shape(obj) != (oh-2, ow-2):\n        obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))\n    \n    # Assign random colors to the object cells\n    obj = {(choice(ccols), ij) for ij in obj}\n    \n    # Paint the object onto the grid (final state)\n    go = paint(gipro, obj)\n    \n    # Determine number of perturbations (shifts) to apply\n    nperts = unifint(diff_lb, diff_ub, (1, max(h, w)))\n    k = 0\n    fullinds = asindices(go)\n    \n    # Shift the object randomly, ensuring it stays within grid and doesn't overlap corners\n    while ulcorner(obj) == (loci+1, locj+1) or k < nperts:\n        k += 1\n        options = sfilter(\n            neighbors((0, 0)),\n            lambda ij: len(crns & shift(toindices(obj), ij)) == 0 and \\\n                shift(toindices(obj), ij).issubset(fullinds)\n        )\n        direc = choice(totuple(options))\n        obj = shift(obj, direc)\n    \n    # Paint the shifted object onto the grid (initial state)\n    gi = paint(gipro, obj)\n    \n    # Return the initial and final states of the grid\n    return {'input': gi, 'output': go}\n"
  },
  "a2fd1cf0": {
    "original": "def generate_a2fd1cf0(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 3, 8))    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    gloci = unifint(diff_lb, diff_ub, (1, h - 1))\n    glocj = unifint(diff_lb, diff_ub, (1, w - 1))\n    gloc = (gloci, glocj)\n    bgc = choice(cols)\n    g = canvas(bgc, (h, w))\n    g = fill(g, 3, {gloc})\n    g = rot180(g)\n    glocinv = center(ofcolor(g, 3))\n    glocinvi, glocinvj = glocinv\n    rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))\n    rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))\n    rlocinv = (rloci, rlocj)\n    g = fill(g, 2, {rlocinv})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(g)\n    a, b = center(ofcolor(gi, 2))\n    c, d = center(ofcolor(gi, 3))\n    go = fill(gi, 8, connect((a, b), (a, d)))\n    go = fill(go, 8, connect((a, d), (c, d)))\n    go = fill(go, 2, {(a, b)})\n    go = fill(go, 3, {(c, d)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a2fd1cf0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 2, 3, and 8\n    cols = difference(interval(0, 10, 1), (2, 3, 8))    \n    \n    # Generate random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate random row index for green dot, ensuring it's not on the edge\n    gloci = unifint(diff_lb, diff_ub, (1, h - 1))\n    # Generate random column index for green dot, ensuring it's not on the edge\n    glocj = unifint(diff_lb, diff_ub, (1, w - 1))\n    # Combine row and column indices for green dot location\n    gloc = (gloci, glocj)\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas filled with the chosen background color\n    g = canvas(bgc, (h, w))\n    # Place a green dot (color 3) at the chosen location\n    g = fill(g, 3, {gloc})\n    # Rotate the grid 180 degrees, moving the green dot to the opposite corner\n    g = rot180(g)\n    \n    # Find the new center of the green dot after rotation\n    glocinv = center(ofcolor(g, 3))\n    # Unpack the row and column of the inverted green dot location\n    glocinvi, glocinvj = glocinv\n    \n    # Generate random row index for red dot, ensuring it's below the green dot\n    rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))\n    # Generate random column index for red dot, ensuring it's to the right of the green dot\n    rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))\n    # Combine row and column indices for red dot location\n    rlocinv = (rloci, rlocj)\n    \n    # Place a red dot (color 2) at the chosen location\n    g = fill(g, 2, {rlocinv})\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply the chosen rotation to the grid\n    gi = rotf(g)\n    \n    # Find the center of the red dot in the rotated grid\n    a, b = center(ofcolor(gi, 2))\n    # Find the center of the green dot in the rotated grid\n    c, d = center(ofcolor(gi, 3))\n    \n    # Draw a yellow line (color 8) from the red dot to the green dot's column\n    go = fill(gi, 8, connect((a, b), (a, d)))\n    # Draw a yellow line from the previous endpoint to the green dot\n    go = fill(go, 8, connect((a, d), (c, d)))\n    \n    # Place the red dot (color 2) at its original location\n    go = fill(go, 2, {(a, b)})\n    # Place the green dot (color 3) at its original location\n    go = fill(go, 3, {(c, d)})\n    \n    # Return a dictionary with the input grid and the output grid\n    return {'input': gi, 'output': go}\n"
  },
  "a3325580": {
    "original": "def generate_a3325580(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, 9))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, nobjs)\n    gi = canvas(bgc, (h, w))\n    lmocc = set()\n    inds = asindices(gi)\n    succ = 0\n    tr = 0\n    maxtr = 4 * nobjs\n    seenobjs = set()\n    mxncells = randint(nobjs+1, 30)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(1, 6)\n        ow = randint(1, 6)\n        while oh * ow < mxncells:\n            oh = randint(1, 6)\n            ow = randint(1, 6)\n        bounds = asindices(canvas(-1, (oh, ow)))\n        ncells = randint(1, oh * ow)\n        ncells = unifint(diff_lb, diff_ub, (1, min(oh * ow, mxncells)))\n        ncells = unifint(diff_lb, diff_ub, (ncells, min(oh * ow, mxncells)))\n        sp = choice(totuple(bounds))\n        obj = {sp}\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        if obj in seenobjs:\n            continue\n        obj = normalize(obj)\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and ij[1] not in lmocc)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds):\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            gi = fill(gi, ccols[succ], plcd)\n            succ += 1\n            lmocc.add(loc[1])\n    objs = objects(gi, T, F, T)\n    mxncells = valmax(objs, size)\n    objs = sfilter(objs, matcher(size, mxncells))\n    objs = order(objs, leftmost)\n    go = canvas(-1, (mxncells, len(objs)))\n    for idx, o in enumerate(objs):\n        go = fill(go, color(o), connect((0, idx), (mxncells - 1, idx)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a3325580(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random number of objects between 1 and 9 based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Sample 'nobjs' number of colors from the remaining colors\n    ccols = sample(remcols, nobjs)\n    \n    # Create an initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Initialize a set to keep track of occupied leftmost columns\n    lmocc = set()\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Initialize counters for successful object placements and trials\n    succ = 0\n    tr = 0\n    \n    # Set maximum number of trials to 4 times the number of objects\n    maxtr = 4 * nobjs\n    \n    # Initialize a set to keep track of seen object shapes\n    seenobjs = set()\n    \n    # Generate random maximum number of cells for objects\n    mxncells = randint(nobjs+1, 30)\n    \n    # Main loop for placing objects on the grid\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        \n        # Generate random object height and width\n        oh = randint(1, 6)\n        ow = randint(1, 6)\n        \n        # Ensure object size is less than maximum allowed cells\n        while oh * ow < mxncells:\n            oh = randint(1, 6)\n            ow = randint(1, 6)\n        \n        # Create bounds for the object\n        bounds = asindices(canvas(-1, (oh, ow)))\n        \n        # Generate random number of cells for the object based on difficulty\n        ncells = randint(1, oh * ow)\n        ncells = unifint(diff_lb, diff_ub, (1, min(oh * ow, mxncells)))\n        ncells = unifint(diff_lb, diff_ub, (ncells, min(oh * ow, mxncells)))\n        \n        # Choose a random starting point for the object\n        sp = choice(totuple(bounds))\n        \n        # Initialize the object with the starting point\n        obj = {sp}\n        \n        # Grow the object by adding adjacent cells\n        for k in range(ncells - 1):\n            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))\n        \n        # Skip if this object shape has been seen before\n        if obj in seenobjs:\n            continue\n        \n        # Normalize the object's position\n        obj = normalize(obj)\n        \n        # Get the final shape of the object\n        oh, ow = shape(obj)\n        \n        # Find valid positions to place the object on the grid\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and ij[1] not in lmocc)\n        \n        # If no valid positions, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        \n        # Shift the object to the chosen position\n        plcd = shift(obj, loc)\n        \n        # If the placed object fits within the grid\n        if plcd.issubset(inds):\n            # Remove the object's cells and its neighbors from available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            \n            # Fill the grid with the object's color\n            gi = fill(gi, ccols[succ], plcd)\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Mark the leftmost column as occupied\n            lmocc.add(loc[1])\n    \n    # Identify all objects in the input grid\n    objs = objects(gi, T, F, T)\n    \n    # Find the size of the largest object\n    mxncells = valmax(objs, size)\n    \n    # Filter objects to keep only the largest ones\n    objs = sfilter(objs, matcher(size, mxncells))\n    \n    # Order the objects from left to right\n    objs = order(objs, leftmost)\n    \n    # Create the output grid\n    go = canvas(-1, (mxncells, len(objs)))\n    \n    # Fill the output grid with vertical lines representing each object\n    for idx, o in enumerate(objs):\n        go = fill(go, color(o), connect((0, idx), (mxncells - 1, idx)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a3df8b1e": {
    "original": "def generate_a3df8b1e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    h = unifint(diff_lb, diff_ub, (w+1, 30))\n    bgc, linc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    sp = (h - 1, 0)\n    gi = fill(c, linc, {sp})\n    go = tuple(e for e in gi)\n    changing = True\n    direc = 1\n    while True:\n        sp = add(sp, (-1, direc))\n        if sp[1] == w - 1 or sp[1] == 0:\n            direc *= -1\n        go2 = fill(go, linc, {sp})\n        if go2 == go:\n            break\n        go = go2\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    gix = tuple(e for e in gi)\n    gox = tuple(e for e in go)\n    numlins = unifint(diff_lb, diff_ub, (1, 4))\n    if numlins > 1:\n        gi = fill(gi, linc, ofcolor(hmirror(gix), linc))\n        go = fill(go, linc, ofcolor(hmirror(gox), linc))\n    if numlins > 2:\n        gi = fill(gi, linc, ofcolor(vmirror(gix), linc))\n        go = fill(go, linc, ofcolor(vmirror(gox), linc))\n    if numlins > 3:\n        gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))\n        go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a3df8b1e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    w = unifint(diff_lb, diff_ub, (2, 10))  # Generate a random width between 2 and 10 based on difficulty\n    h = unifint(diff_lb, diff_ub, (w+1, 30))  # Generate a random height between w+1 and 30 based on difficulty\n    bgc, linc = sample(cols, 2)  # Randomly select two different colors for background and line\n    c = canvas(bgc, (h, w))  # Create a canvas of size h x w filled with background color\n    sp = (h - 1, 0)  # Set starting point at bottom-left corner\n    gi = fill(c, linc, {sp})  # Fill the starting point with line color in the input grid\n    go = tuple(e for e in gi)  # Create a copy of the input grid for the output grid\n    changing = True  # Initialize a flag for the loop (unused in this implementation)\n    direc = 1  # Set initial direction to move right\n    while True:\n        sp = add(sp, (-1, direc))  # Move the point up and in the current direction\n        if sp[1] == w - 1 or sp[1] == 0:  # If the point reaches the right or left edge\n            direc *= -1  # Reverse the direction\n        go2 = fill(go, linc, {sp})  # Fill the new point in the output grid\n        if go2 == go:  # If no change occurred (point is out of bounds)\n            break  # Exit the loop\n        go = go2  # Update the output grid\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)  # Define a tuple of transformation functions\n    nmfs = choice((1, 2))  # Randomly choose to apply either 1 or 2 transformations\n    for fn in sample(mfs, nmfs):  # Randomly select 'nmfs' number of transformation functions\n        gi = fn(gi)  # Apply the transformation to the input grid\n        go = fn(go)  # Apply the same transformation to the output grid\n    gix = tuple(e for e in gi)  # Create a copy of the transformed input grid\n    gox = tuple(e for e in go)  # Create a copy of the transformed output grid\n    numlins = unifint(diff_lb, diff_ub, (1, 4))  # Randomly choose number of lines (1-4) based on difficulty\n    if numlins > 1:  # If more than one line is needed\n        gi = fill(gi, linc, ofcolor(hmirror(gix), linc))  # Add horizontally mirrored line to input\n        go = fill(go, linc, ofcolor(hmirror(gox), linc))  # Add horizontally mirrored line to output\n    if numlins > 2:  # If more than two lines are needed\n        gi = fill(gi, linc, ofcolor(vmirror(gix), linc))  # Add vertically mirrored line to input\n        go = fill(go, linc, ofcolor(vmirror(gox), linc))  # Add vertically mirrored line to output\n    if numlins > 3:  # If four lines are needed\n        gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))  # Add diagonally mirrored line to input\n        go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))  # Add diagonally mirrored line to output\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "a416b8f3": {
    "original": "def generate_a416b8f3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = hconcat(gi, gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a416b8f3(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Generate a random width between 1 and 15 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (between 0 and min(9, h*w))\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Create a tuple of all indices in the grid\n    inds = totuple(asindices(gi))\n    \n    # Iterate through each selected color\n    for col in colsch:\n        # Determine the number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose indices to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by horizontally concatenating the input grid with itself\n    go = hconcat(gi, gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a48eeaf7": {
    "original": "def generate_a48eeaf7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    ih = unifint(diff_lb, diff_ub, (2, h//2))\n    iw = unifint(diff_lb, diff_ub, (2, w//2))\n    loci = randint(2, h - ih - 2)\n    locj = randint(2, w - iw - 2)\n    bgc, sqc, dotc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    sq = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    A = [(x, locj - 1) for x in interval(loci, loci + ih, 1)]\n    Ap = [(x, randint(0, locj - 2)) for x in interval(loci, loci + ih, 1)]\n    B = [(x, locj + iw) for x in interval(loci, loci + ih, 1)]\n    Bp = [(x, randint(locj + iw + 1, w - 1)) for x in interval(loci, loci + ih, 1)]\n    C = [(loci - 1, x) for x in interval(locj, locj + iw, 1)]\n    Cp = [(randint(0, loci - 2), x) for x in interval(locj, locj + iw, 1)]\n    D = [(loci + ih, x) for x in interval(locj, locj + iw, 1)]\n    Dp = [(randint(loci + ih + 1, h - 1), x) for x in interval(locj, locj + iw, 1)]\n    srarr = Ap + Bp + Cp + Dp\n    dearr = A + B + C + D\n    inds = interval(0, len(srarr), 1)\n    num = unifint(diff_lb, diff_ub, (1, len(srarr)))\n    locs = sample(inds, num)\n    srarr = [e for j, e in enumerate(srarr) if j in locs]\n    dearr = [e for j, e in enumerate(dearr) if j in locs]\n    gi = fill(gi, sqc, sq)\n    go = fill(go, sqc, sq)\n    for s, d in zip(srarr, dearr):\n        gi = fill(gi, dotc, {s})\n        go = fill(go, dotc, {d})\n    ncorn = unifint(diff_lb, diff_ub, (0, 4))\n    fullinds = asindices(gi)\n    if ncorn > 0:\n        go = fill(go, dotc, {(loci - 1, locj - 1)})\n        cands = shoot((loci - 2, locj - 2), (-1, -1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    if ncorn > 1:\n        go = fill(go, dotc, {(loci - 1, locj + iw)})\n        cands = shoot((loci - 2, locj + iw + 1), (-1, 1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    if ncorn > 2:\n        go = fill(go, dotc, {(loci + ih, locj - 1)})\n        cands = shoot((loci + ih + 1, locj - 2), (1, -1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    if ncorn > 3:\n        go = fill(go, dotc, {(loci + ih, locj + iw)})\n        cands = shoot((loci + ih + 1, locj + iw + 1), (1, 1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a48eeaf7(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the height of the inner square based on difficulty\n    ih = unifint(diff_lb, diff_ub, (2, h//2))\n    # Randomly determine the width of the inner square based on difficulty\n    iw = unifint(diff_lb, diff_ub, (2, w//2))\n    \n    # Randomly choose the row position for the inner square\n    loci = randint(2, h - ih - 2)\n    # Randomly choose the column position for the inner square\n    locj = randint(2, w - iw - 2)\n    \n    # Randomly select three distinct colors for background, square, and dots\n    bgc, sqc, dotc = sample(cols, 3)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    # Create the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Define the area of the inner square\n    sq = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))\n    \n    # Define the left edge of the inner square\n    A = [(x, locj - 1) for x in interval(loci, loci + ih, 1)]\n    # Define random positions to the left of the inner square\n    Ap = [(x, randint(0, locj - 2)) for x in interval(loci, loci + ih, 1)]\n    \n    # Define the right edge of the inner square\n    B = [(x, locj + iw) for x in interval(loci, loci + ih, 1)]\n    # Define random positions to the right of the inner square\n    Bp = [(x, randint(locj + iw + 1, w - 1)) for x in interval(loci, loci + ih, 1)]\n    \n    # Define the top edge of the inner square\n    C = [(loci - 1, x) for x in interval(locj, locj + iw, 1)]\n    # Define random positions above the inner square\n    Cp = [(randint(0, loci - 2), x) for x in interval(locj, locj + iw, 1)]\n    \n    # Define the bottom edge of the inner square\n    D = [(loci + ih, x) for x in interval(locj, locj + iw, 1)]\n    # Define random positions below the inner square\n    Dp = [(randint(loci + ih + 1, h - 1), x) for x in interval(locj, locj + iw, 1)]\n    \n    # Combine all random positions around the inner square\n    srarr = Ap + Bp + Cp + Dp\n    # Combine all edge positions of the inner square\n    dearr = A + B + C + D\n    \n    # Create a range of indices for the number of positions\n    inds = interval(0, len(srarr), 1)\n    # Randomly determine the number of dots to place based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, len(srarr)))\n    # Randomly select which positions to use for dots\n    locs = sample(inds, num)\n    \n    # Filter the random positions based on the selected indices\n    srarr = [e for j, e in enumerate(srarr) if j in locs]\n    # Filter the edge positions based on the selected indices\n    dearr = [e for j, e in enumerate(dearr) if j in locs]\n    \n    # Fill the inner square with its color in both input and output grids\n    gi = fill(gi, sqc, sq)\n    go = fill(go, sqc, sq)\n    \n    # Place dots at random positions in the input grid and corresponding edge positions in the output grid\n    for s, d in zip(srarr, dearr):\n        gi = fill(gi, dotc, {s})\n        go = fill(go, dotc, {d})\n    \n    # Randomly determine the number of corner dots to add based on difficulty\n    ncorn = unifint(diff_lb, diff_ub, (0, 4))\n    # Get all valid indices in the grid\n    fullinds = asindices(gi)\n    \n    # If at least one corner dot is to be added\n    if ncorn > 0:\n        # Add a dot to the top-left corner of the inner square in the output grid\n        go = fill(go, dotc, {(loci - 1, locj - 1)})\n        # Find valid positions for the corresponding dot in the input grid\n        cands = shoot((loci - 2, locj - 2), (-1, -1)) & fullinds\n        # Randomly choose one of these positions\n        locc = choice(totuple(cands))\n        # Add the dot to the chosen position in the input grid\n        gi = fill(gi, dotc, {locc})\n    \n    # Repeat the above process for the top-right corner\n    if ncorn > 1:\n        go = fill(go, dotc, {(loci - 1, locj + iw)})\n        cands = shoot((loci - 2, locj + iw + 1), (-1, 1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    \n    # Repeat the above process for the bottom-left corner\n    if ncorn > 2:\n        go = fill(go, dotc, {(loci + ih, locj - 1)})\n        cands = shoot((loci + ih + 1, locj - 2), (1, -1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    \n    # Repeat the above process for the bottom-right corner\n    if ncorn > 3:\n        go = fill(go, dotc, {(loci + ih, locj + iw)})\n        cands = shoot((loci + ih + 1, locj + iw + 1), (1, 1)) & fullinds\n        locc = choice(totuple(cands))\n        gi = fill(gi, dotc, {locc})\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a5313dff": {
    "original": "def generate_a5313dff(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    succ = 0\n    tr = 0\n    maxtr = 10 * noccs\n    inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))\n    while (tr < maxtr and succ < noccs) or len(sfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))) == 0:\n        tr += 1\n        oh = randint(3, 8)\n        ow = randint(3, 8)\n        bx = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        ins = backdrop(inbox(bx))\n        loc = choice(totuple(inds))\n        plcdins = shift(ins, loc)\n        if len(plcdins & ofcolor(gi, fgc)) == 0:\n            succ += 1\n            gi = fill(gi, fgc, shift(bx, loc))\n            if choice((True, True, False)):\n                ss = sample(totuple(plcdins), randint(1, max(1, len(ins) // 2)))\n                gi = fill(gi, fgc, ss)\n    res = mfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))\n    go = fill(gi, 1, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a5313dff(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 1 from the range 0-9, creating a list of available colors\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select two colors: one for background and one for foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the number of occurrences (objects to place) based on difficulty\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    \n    # Set maximum number of attempts\n    maxtr = 10 * noccs\n    \n    # Create a set of valid indices for object placement, including a 1-cell border\n    inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))\n    \n    # Main loop for placing objects\n    while (tr < maxtr and succ < noccs) or len(sfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))) == 0:\n        # Increment attempt counter\n        tr += 1\n        \n        # Generate random height and width for the new object\n        oh = randint(3, 8)\n        ow = randint(3, 8)\n        \n        # Create a box shape for the new object\n        bx = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n        \n        # Generate the inner area of the box\n        ins = backdrop(inbox(bx))\n        \n        # Choose a random location for placement\n        loc = choice(totuple(inds))\n        \n        # Shift the inner area to the chosen location\n        plcdins = shift(ins, loc)\n        \n        # Check if the placement doesn't overlap with existing foreground objects\n        if len(plcdins & ofcolor(gi, fgc)) == 0:\n            # Increment successful placement counter\n            succ += 1\n            \n            # Place the box outline on the grid\n            gi = fill(gi, fgc, shift(bx, loc))\n            \n            # 2/3 chance to fill some of the inner area of the box\n            if choice((True, True, False)):\n                # Randomly select some cells from the inner area\n                ss = sample(totuple(plcdins), randint(1, max(1, len(ins) // 2)))\n                \n                # Fill the selected cells with the foreground color\n                gi = fill(gi, fgc, ss)\n    \n    # Find all background objects that are not bordering the grid edge\n    res = mfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))\n    \n    # Create the output grid by filling these objects with color 1\n    go = fill(gi, 1, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a5f85a15": {
    "original": "def generate_a5f85a15(diff_lb: float, diff_ub: float) -> dict:\n    colopts = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    startlocs = apply(toivec, interval(h - 1, 0, -1)) + apply(tojvec, interval(0, w, 1))\n    cands = interval(0, h + w - 1, 1)\n    num = unifint(diff_lb, diff_ub, (1, (h + w - 1) // 3))\n    locs = []\n    for k in range(num):\n        if len(cands) == 0:\n            break\n        loc = choice(cands)\n        locs.append(loc)\n        cands = remove(loc, cands)\n        cands = remove(loc - 1, cands)\n        cands = remove(loc + 1, cands)\n    locs = set([startlocs[loc] for loc in locs])\n    bgc, fgc = sample(colopts, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for loc in locs:\n        ln = order(shoot(loc, (1, 1)), first)\n        gi = fill(gi, fgc, ln)\n        go = fill(go, fgc, ln)\n        go = fill(go, 4, ln[1::2])\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a5f85a15(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color options, excluding 4\n    colopts = remove(4, interval(0, 10, 1))\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Create a list of all possible starting locations along the top and left edges\n    startlocs = apply(toivec, interval(h - 1, 0, -1)) + apply(tojvec, interval(0, w, 1))\n    \n    # Create a list of indices representing all possible diagonal lines\n    cands = interval(0, h + w - 1, 1)\n    \n    # Determine the number of diagonal lines to draw (between 1 and 1/3 of total possible)\n    num = unifint(diff_lb, diff_ub, (1, (h + w - 1) // 3))\n    \n    # Initialize an empty list to store selected line indices\n    locs = []\n    \n    # Select line indices, ensuring they're not adjacent\n    for k in range(num):\n        # Break if no more candidates are available\n        if len(cands) == 0:\n            break\n        # Choose a random candidate\n        loc = choice(cands)\n        # Add the chosen location to the list\n        locs.append(loc)\n        # Remove the chosen location and adjacent locations from candidates\n        cands = remove(loc, cands)\n        cands = remove(loc - 1, cands)\n        cands = remove(loc + 1, cands)\n    \n    # Convert selected indices to actual grid coordinates\n    locs = set([startlocs[loc] for loc in locs])\n    \n    # Choose two different colors for background and foreground\n    bgc, fgc = sample(colopts, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Draw diagonal lines on both input and output grids\n    for loc in locs:\n        # Generate a diagonal line from the starting location\n        ln = order(shoot(loc, (1, 1)), first)\n        # Fill the line with foreground color on input grid\n        gi = fill(gi, fgc, ln)\n        # Fill the line with foreground color on output grid\n        go = fill(go, fgc, ln)\n        # Fill every other cell of the line with color 4 on output grid\n        go = fill(go, 4, ln[1::2])\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a61ba2ce": {
    "original": "def generate_a61ba2ce(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 15))\n    w = unifint(diff_lb, diff_ub, (4, 15))\n    lociL = randint(2, h - 2)\n    lociR = randint(2, h - 2)\n    locjT = randint(2, w - 2)\n    locjB = randint(2, w - 2)\n    bgc, c1, c2, c3, c4 = sample(cols, 5)\n    ulco = connect((0, 0), (lociL - 1, 0)) | connect((0, 0), (0, locjT - 1))\n    urco = connect((0, w - 1), (0, locjT)) | connect((0, w - 1), (lociR - 1, w - 1))\n    llco = connect((h - 1, 0), (lociL, 0)) | connect((h - 1, 0), (h - 1, locjB - 1))\n    lrco = connect((h - 1, w - 1), (h - 1, locjB)) | connect((h - 1, w - 1), (lociR, w - 1))\n    go = canvas(bgc, (h, w))\n    go = fill(go, c1, ulco)\n    go = fill(go, c2, urco)\n    go = fill(go, c3, llco)\n    go = fill(go, c4, lrco)\n    fullh = unifint(diff_lb, diff_ub, (2 * h, 30))\n    fullw = unifint(diff_lb, diff_ub, (2 * w, 30))\n    gi = canvas(bgc, (fullh, fullw))\n    objs = (ulco, urco, llco, lrco)\n    ocols = (c1, c2, c3, c4)\n    while True:\n        inds = asindices(gi)\n        locs = []\n        for o, c in zip(objs, ocols):\n            cands = sfilter(inds, lambda ij: shift(o, ij).issubset(inds))\n            if len(cands) == 0:\n                break\n            loc = choice(totuple(cands))\n            locs.append(loc)\n            inds = inds - shift(o, loc)\n        if len(locs) == 4:\n            break\n    for o, c, l in zip(objs, ocols, locs):\n        gi = fill(gi, c, shift(o, l))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a61ba2ce(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the output grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 15))\n    # Randomly determine the width of the output grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 15))\n    \n    # Randomly choose vertical positions for left and right corners\n    lociL = randint(2, h - 2)\n    lociR = randint(2, h - 2)\n    # Randomly choose horizontal positions for top and bottom corners\n    locjT = randint(2, w - 2)\n    locjB = randint(2, w - 2)\n    \n    # Randomly select 5 unique colors: background and 4 corner colors\n    bgc, c1, c2, c3, c4 = sample(cols, 5)\n    \n    # Define the upper-left corner shape\n    ulco = connect((0, 0), (lociL - 1, 0)) | connect((0, 0), (0, locjT - 1))\n    # Define the upper-right corner shape\n    urco = connect((0, w - 1), (0, locjT)) | connect((0, w - 1), (lociR - 1, w - 1))\n    # Define the lower-left corner shape\n    llco = connect((h - 1, 0), (lociL, 0)) | connect((h - 1, 0), (h - 1, locjB - 1))\n    # Define the lower-right corner shape\n    lrco = connect((h - 1, w - 1), (h - 1, locjB)) | connect((h - 1, w - 1), (lociR, w - 1))\n    \n    # Create the output grid with background color\n    go = canvas(bgc, (h, w))\n    # Fill the upper-left corner with its color\n    go = fill(go, c1, ulco)\n    # Fill the upper-right corner with its color\n    go = fill(go, c2, urco)\n    # Fill the lower-left corner with its color\n    go = fill(go, c3, llco)\n    # Fill the lower-right corner with its color\n    go = fill(go, c4, lrco)\n    \n    # Randomly determine the height of the input grid (at least twice the output grid)\n    fullh = unifint(diff_lb, diff_ub, (2 * h, 30))\n    # Randomly determine the width of the input grid (at least twice the output grid)\n    fullw = unifint(diff_lb, diff_ub, (2 * w, 30))\n    # Create the input grid with background color\n    gi = canvas(bgc, (fullh, fullw))\n    \n    # Group corner shapes and their colors\n    objs = (ulco, urco, llco, lrco)\n    ocols = (c1, c2, c3, c4)\n    \n    # Loop until all corner shapes are placed in the input grid\n    while True:\n        # Get all indices of the input grid\n        inds = asindices(gi)\n        locs = []\n        # For each corner shape and its color\n        for o, c in zip(objs, ocols):\n            # Find valid positions to place the corner shape\n            cands = sfilter(inds, lambda ij: shift(o, ij).issubset(inds))\n            # If no valid positions, break the loop\n            if len(cands) == 0:\n                break\n            # Randomly choose a position for the corner shape\n            loc = choice(totuple(cands))\n            locs.append(loc)\n            # Remove the occupied indices\n            inds = inds - shift(o, loc)\n        # If all corner shapes are placed, exit the loop\n        if len(locs) == 4:\n            break\n    \n    # Fill the input grid with corner shapes at their chosen positions\n    for o, c, l in zip(objs, ocols, locs):\n        gi = fill(gi, c, shift(o, l))\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a61f2674": {
    "original": "def generate_a61f2674(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, remove(1, interval(0, 10, 1)))\n    w = unifint(diff_lb, diff_ub, (5, 28))\n    h = unifint(diff_lb, diff_ub, (w // 2 + 1, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nbars = unifint(diff_lb, diff_ub, (2, w // 2))\n    barlocs = []\n    options = interval(0, w, 1)\n    while len(options) > 0 and len(barlocs) < nbars:\n        loc = choice(options)\n        barlocs.append(loc)\n        options = remove(loc, options)\n        options = remove(loc + 1, options)\n        options = remove(loc - 1, options)\n    barheights = sample(interval(0, h, 1), nbars)\n    for j, bh in zip(barlocs, barheights):\n        gi = fill(gi, fgc, connect((0, j), (bh, j)))\n        if bh == max(barheights):\n            go = fill(go, 1, connect((0, j), (bh, j)))\n        if bh == min(barheights):\n            go = fill(go, 2, connect((0, j), (bh, j)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a61f2674(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors excluding 1 and 2\n    cols = remove(2, remove(1, interval(0, 10, 1)))\n    \n    # Randomly determine the width of the grid between 5 and 28\n    w = unifint(diff_lb, diff_ub, (5, 28))\n    \n    # Randomly determine the height of the grid between (w // 2 + 1) and 30\n    h = unifint(diff_lb, diff_ub, (w // 2 + 1, 30))\n    \n    # Randomly select two colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of bars between 2 and w // 2\n    nbars = unifint(diff_lb, diff_ub, (2, w // 2))\n    \n    # Initialize an empty list to store bar locations\n    barlocs = []\n    \n    # Create a list of possible bar locations\n    options = interval(0, w, 1)\n    \n    # Loop to randomly select bar locations\n    while len(options) > 0 and len(barlocs) < nbars:\n        # Randomly choose a location for a bar\n        loc = choice(options)\n        \n        # Add the chosen location to barlocs\n        barlocs.append(loc)\n        \n        # Remove the chosen location and adjacent locations from options\n        options = remove(loc, options)\n        options = remove(loc + 1, options)\n        options = remove(loc - 1, options)\n    \n    # Randomly select heights for each bar\n    barheights = sample(interval(0, h, 1), nbars)\n    \n    # Loop to draw bars on input and output grids\n    for j, bh in zip(barlocs, barheights):\n        # Draw bar on input grid with foreground color\n        gi = fill(gi, fgc, connect((0, j), (bh, j)))\n        \n        # If it's the tallest bar, color it with 1 on output grid\n        if bh == max(barheights):\n            go = fill(go, 1, connect((0, j), (bh, j)))\n        \n        # If it's the shortest bar, color it with 2 on output grid\n        if bh == min(barheights):\n            go = fill(go, 2, connect((0, j), (bh, j)))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to output grid\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a64e4611": {
    "original": "def generate_a64e4611(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (18, 30))\n    w = unifint(diff_lb, diff_ub, (18, 30))\n    bgc, noisec = sample(cols, 2)\n    lb = int(0.4 * h * w)\n    ub = int(0.5 * h * w)\n    nbgc = unifint(diff_lb, diff_ub, (lb, ub))\n    gi = canvas(noisec, (h, w))\n    inds = totuple(asindices(gi))\n    bgcinds = sample(inds, nbgc)\n    gi = fill(gi, bgc, bgcinds)\n    sinds = asindices(canvas(-1, (3, 3)))\n    bgcf = recolor(bgc, sinds)\n    noisecf = recolor(noisec, sinds)\n    addn = set()\n    addb = set()\n    for occ in occurrences(gi, bgcf):\n        occi, occj = occ\n        addn.add((randint(0, 2) + occi, randint(0, 2) + occj))\n    for occ in occurrences(gi, noisecf):\n        occi, occj = occ\n        addb.add((randint(0, 2) + occi, randint(0, 2) + occj))\n    gi = fill(gi, noisec, addn)\n    gi = fill(gi, bgc, addb)\n    go = tuple(e for e in gi)\n    dim = randint(randint(3, 8), 8)\n    locj = randint(3, h - dim - 4)\n    spi = choice((0, randint(3, h//2)))\n    for j in range(locj, locj + dim):\n        ln = connect((spi, j), (h - 1, j))\n        gi = fill(gi, bgc, ln)\n        go = fill(go, bgc, ln)\n    for j in range(locj + 1, locj + dim - 1):\n        ln = connect((spi + 1 if spi > 0 else spi, j), (h - 1, j))\n        go = fill(go, 3, ln)\n    sgns = choice(((-1,), (1,), (-1, 1)))\n    startloc = choice((spi, randint(spi + 3, h - 6)))\n    hh = randint(3, min(8, h - startloc - 3))\n    for sgn in sgns:\n        for ii in range(startloc, startloc + hh, 1):\n            ln = shoot((ii, locj), (0, sgn))\n            gi = fill(gi, bgc, ln)\n            go = fill(go, bgc, ln - ofcolor(go, 3))\n    for sgn in sgns:\n        for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):\n            ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))\n            go = fill(go, 3, ln)\n    if len(sgns) == 1 and unifint(diff_lb, diff_ub, (0, 1)) == 1:\n        sgns = (-sgns[0],)\n        startloc = choice((spi, randint(spi + 3, h - 6)))\n        hh = randint(3, min(8, h - startloc - 3))\n        for sgn in sgns:\n            for ii in range(startloc, startloc + hh, 1):\n                ln = shoot((ii, locj), (0, sgn))\n                gi = fill(gi, bgc, ln)\n                go = fill(go, bgc, ln - ofcolor(go, 3))\n        for sgn in sgns:\n            for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):\n                ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))\n                go = fill(go, 3, ln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a64e4611(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate random height between 18 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (18, 30))\n    # Generate random width between 18 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (18, 30))\n    \n    # Randomly select two colors: one for background and one for noise\n    bgc, noisec = sample(cols, 2)\n    \n    # Calculate lower bound for number of background cells (40% of total cells)\n    lb = int(0.4 * h * w)\n    # Calculate upper bound for number of background cells (50% of total cells)\n    ub = int(0.5 * h * w)\n    # Generate random number of background cells within the calculated bounds\n    nbgc = unifint(diff_lb, diff_ub, (lb, ub))\n    \n    # Create initial grid filled with noise color\n    gi = canvas(noisec, (h, w))\n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    # Randomly select indices for background color\n    bgcinds = sample(inds, nbgc)\n    # Fill selected indices with background color\n    gi = fill(gi, bgc, bgcinds)\n    \n    # Create a 3x3 grid of indices\n    sinds = asindices(canvas(-1, (3, 3)))\n    # Create a 3x3 patch of background color\n    bgcf = recolor(bgc, sinds)\n    # Create a 3x3 patch of noise color\n    noisecf = recolor(noisec, sinds)\n    \n    # Initialize sets for additional noise and background cells\n    addn = set()\n    addb = set()\n    \n    # For each occurrence of the background color patch\n    for occ in occurrences(gi, bgcf):\n        occi, occj = occ\n        # Add a random adjacent cell to be colored with noise\n        addn.add((randint(0, 2) + occi, randint(0, 2) + occj))\n    \n    # For each occurrence of the noise color patch\n    for occ in occurrences(gi, noisecf):\n        occi, occj = occ\n        # Add a random adjacent cell to be colored with background\n        addb.add((randint(0, 2) + occi, randint(0, 2) + occj))\n    \n    # Fill additional cells with noise color\n    gi = fill(gi, noisec, addn)\n    # Fill additional cells with background color\n    gi = fill(gi, bgc, addb)\n    \n    # Create a copy of the input grid for output\n    go = tuple(e for e in gi)\n    \n    # Generate random dimension for the \"door\" structure\n    dim = randint(randint(3, 8), 8)\n    # Generate random column position for the \"door\"\n    locj = randint(3, h - dim - 4)\n    # Generate random starting row for the \"door\" (either 0 or between 3 and h//2)\n    spi = choice((0, randint(3, h//2)))\n    \n    # Create vertical lines for the \"door\" frame in both input and output\n    for j in range(locj, locj + dim):\n        ln = connect((spi, j), (h - 1, j))\n        gi = fill(gi, bgc, ln)\n        go = fill(go, bgc, ln)\n    \n    # Create inner vertical lines for the \"door\" in output only\n    for j in range(locj + 1, locj + dim - 1):\n        ln = connect((spi + 1 if spi > 0 else spi, j), (h - 1, j))\n        go = fill(go, 3, ln)\n    \n    # Randomly choose direction(s) for horizontal lines\n    sgns = choice(((-1,), (1,), (-1, 1)))\n    # Choose starting position for horizontal lines\n    startloc = choice((spi, randint(spi + 3, h - 6)))\n    # Generate random height for horizontal lines\n    hh = randint(3, min(8, h - startloc - 3))\n    \n    # Create horizontal lines in both directions\n    for sgn in sgns:\n        for ii in range(startloc, startloc + hh, 1):\n            ln = shoot((ii, locj), (0, sgn))\n            gi = fill(gi, bgc, ln)\n            go = fill(go, bgc, ln - ofcolor(go, 3))\n    \n    # Create inner horizontal lines in output only\n    for sgn in sgns:\n        for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):\n            ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))\n            go = fill(go, 3, ln)\n    \n    # Randomly decide to add lines in the opposite direction\n    if len(sgns) == 1 and unifint(diff_lb, diff_ub, (0, 1)) == 1:\n        # Reverse the direction\n        sgns = (-sgns[0],)\n        # Choose new starting position\n        startloc = choice((spi, randint(spi + 3, h - 6)))\n        # Generate new random height\n        hh = randint(3, min(8, h - startloc - 3))\n        \n        # Create horizontal lines in the new direction\n        for sgn in sgns:\n            for ii in range(startloc, startloc + hh, 1):\n                ln = shoot((ii, locj), (0, sgn))\n                gi = fill(gi, bgc, ln)\n                go = fill(go, bgc, ln - ofcolor(go, 3))\n        \n        # Create inner horizontal lines in the new direction (output only)\n        for sgn in sgns:\n            for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):\n                ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))\n                go = fill(go, 3, ln)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a65b410d": {
    "original": "def generate_a65b410d(diff_lb: float, diff_ub: float) -> dict:\n    colopts = difference(interval(0, 10, 1), (1, 3))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    mpi = h // 2\n    mpj = w // 2\n    devi = unifint(diff_lb, diff_ub, (0, mpi))\n    devj = unifint(diff_lb, diff_ub, (0, mpj))\n    if choice((True, False)):\n        locj = devj\n        loci = devi\n    else:\n        loci = h - devi\n        locj = w - devj\n    loci = max(min(h - 2, loci), 1)\n    locj = max(min(w - 2, locj), 1)\n    loc = (loci, locj)\n    bgc = choice(colopts)\n    linc = choice(remove(bgc, colopts))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, linc, connect((loci, 0), (loci, locj)))\n    blues = shoot((loci + 1, locj - 1), (1, -1))\n    f = lambda ij: connect(ij, (ij[0], 0)) if ij[1] >= 0 else frozenset({})\n    blues = mapply(f, blues)\n    greens = shoot((loci - 1, locj + 1), (-1, 1))\n    greens = mapply(f, greens)\n    go = fill(gi, 1, blues)\n    go = fill(go, 3, greens)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a65b410d(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options, excluding 1 and 3\n    colopts = difference(interval(0, 10, 1), (1, 3))\n    \n    # Generate random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    # Generate random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Calculate middle point for height\n    mpi = h // 2\n    # Calculate middle point for width\n    mpj = w // 2\n    \n    # Generate random vertical deviation from center\n    devi = unifint(diff_lb, diff_ub, (0, mpi))\n    # Generate random horizontal deviation from center\n    devj = unifint(diff_lb, diff_ub, (0, mpj))\n    \n    # Randomly choose whether to place the point in the top-left or bottom-right quadrant\n    if choice((True, False)):\n        # Place in top-left quadrant\n        locj = devj\n        loci = devi\n    else:\n        # Place in bottom-right quadrant\n        loci = h - devi\n        locj = w - devj\n    \n    # Ensure the point is not on the edge of the grid (vertically)\n    loci = max(min(h - 2, loci), 1)\n    # Ensure the point is not on the edge of the grid (horizontally)\n    locj = max(min(w - 2, locj), 1)\n    # Create a tuple representing the chosen location\n    loc = (loci, locj)\n    \n    # Randomly choose background color\n    bgc = choice(colopts)\n    # Randomly choose line color (different from background)\n    linc = choice(remove(bgc, colopts))\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    # Draw vertical line from top to the chosen point\n    gi = fill(gi, linc, connect((loci, 0), (loci, locj)))\n    \n    # Generate points for blue area (diagonal line going down-left from the chosen point)\n    blues = shoot((loci + 1, locj - 1), (1, -1))\n    # Define function to create vertical lines for each point in blues\n    f = lambda ij: connect(ij, (ij[0], 0)) if ij[1] >= 0 else frozenset({})\n    # Apply the function to create blue area\n    blues = mapply(f, blues)\n    \n    # Generate points for green area (diagonal line going up-right from the chosen point)\n    greens = shoot((loci - 1, locj + 1), (-1, 1))\n    # Apply the same function to create green area\n    greens = mapply(f, greens)\n    \n    # Fill the blue area on the output grid\n    go = fill(gi, 1, blues)\n    # Fill the green area on the output grid\n    go = fill(go, 3, greens)\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply rotation to input grid\n    gi = rotf(gi)\n    # Apply same rotation to output grid\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a68b268e": {
    "original": "def generate_a68b268e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    w = unifint(diff_lb, diff_ub, (2, 4))\n    bgc, linc, c1, c2, c3, c4 = sample(cols, 6)\n    canv = canvas(bgc, (h, w))\n    inds = asindices(canv)\n    nc1d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc1 = choice((nc1d, h * w - nc1d))\n    nc1 = min(max(1, nc1), h * w - 1)\n    nc2d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc2 = choice((nc2d, h * w - nc2d))\n    nc2 = min(max(1, nc2), h * w - 1)\n    nc3d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc3 = choice((nc3d, h * w - nc3d))\n    nc3 = min(max(1, nc3), h * w - 1)\n    nc4d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc4 = choice((nc4d, h * w - nc4d))\n    nc4 = min(max(1, nc4), h * w - 1)\n    ofc1 = sample(totuple(inds), nc1)\n    ofc2 = sample(totuple(inds), nc2)\n    ofc3 = sample(totuple(inds), nc3)\n    ofc4 = sample(totuple(inds), nc4)\n    go = fill(canv, c1, ofc1)\n    go = fill(go, c2, ofc2)\n    go = fill(go, c3, ofc3)\n    go = fill(go, c4, ofc4)\n    LR = asobject(fill(canv, c1, ofc1))\n    LL = asobject(fill(canv, c2, ofc2))\n    UR = asobject(fill(canv, c3, ofc3))\n    UL = asobject(fill(canv, c4, ofc4))\n    gi = canvas(linc, (2*h+1, 2*w+1))\n    gi = paint(gi, shift(LR, (h+1, w+1)))\n    gi = paint(gi, shift(LL, (h+1, 0)))\n    gi = paint(gi, shift(UR, (0, w+1)))\n    gi = paint(gi, shift(UL, (0, 0)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a68b268e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors (0-9)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose height between 2 and 14 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly choose width between 2 and 4 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 4))\n    \n    # Randomly select 6 unique colors from the color range\n    bgc, linc, c1, c2, c3, c4 = sample(cols, 6)\n    \n    # Create a canvas with background color bgc and dimensions h x w\n    canv = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas\n    inds = asindices(canv)\n    \n    # Randomly choose number of cells for color 1, biased towards 0 or h*w\n    nc1d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc1 = choice((nc1d, h * w - nc1d))\n    nc1 = min(max(1, nc1), h * w - 1)  # Ensure at least 1 and at most h*w-1 cells\n    \n    # Repeat the process for colors 2, 3, and 4\n    nc2d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc2 = choice((nc2d, h * w - nc2d))\n    nc2 = min(max(1, nc2), h * w - 1)\n    \n    nc3d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc3 = choice((nc3d, h * w - nc3d))\n    nc3 = min(max(1, nc3), h * w - 1)\n    \n    nc4d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc4 = choice((nc4d, h * w - nc4d))\n    nc4 = min(max(1, nc4), h * w - 1)\n    \n    # Randomly select cells for each color\n    ofc1 = sample(totuple(inds), nc1)\n    ofc2 = sample(totuple(inds), nc2)\n    ofc3 = sample(totuple(inds), nc3)\n    ofc4 = sample(totuple(inds), nc4)\n    \n    # Create the output grid by filling in the selected cells with their respective colors\n    go = fill(canv, c1, ofc1)\n    go = fill(go, c2, ofc2)\n    go = fill(go, c3, ofc3)\n    go = fill(go, c4, ofc4)\n    \n    # Create objects for each color quadrant\n    LR = asobject(fill(canv, c1, ofc1))  # Lower Right quadrant\n    LL = asobject(fill(canv, c2, ofc2))  # Lower Left quadrant\n    UR = asobject(fill(canv, c3, ofc3))  # Upper Right quadrant\n    UL = asobject(fill(canv, c4, ofc4))  # Upper Left quadrant\n    \n    # Create the input grid with dimensions (2h+1) x (2w+1) and fill with linc color\n    gi = canvas(linc, (2*h+1, 2*w+1))\n    \n    # Paint each quadrant object onto the input grid in its respective position\n    gi = paint(gi, shift(LR, (h+1, w+1)))  # Lower Right\n    gi = paint(gi, shift(LL, (h+1, 0)))    # Lower Left\n    gi = paint(gi, shift(UR, (0, w+1)))    # Upper Right\n    gi = paint(gi, shift(UL, (0, 0)))      # Upper Left\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a699fb00": {
    "original": "def generate_a699fb00(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    numls = unifint(diff_lb, diff_ub, (1, h - 1))\n    opts = interval(0, h, 1)\n    locs = sample(opts, numls)\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for ii in locs:\n        endidx = unifint(diff_lb, diff_ub, (2, w - 2))\n        ofs = unifint(diff_lb, diff_ub, (1, endidx//2)) * 2\n        ofs = min(max(2, ofs), endidx)\n        startidx = endidx - ofs\n        ln = connect((ii, startidx), (ii, endidx))\n        go = fill(go, 2, ln)\n        sparseln = {(ii, jj) for jj in range(startidx, endidx + 1, 2)}\n        go = fill(go, fgc, sparseln)\n        gi = fill(gi, fgc, sparseln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a699fb00(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 2 from the range 0-9, creating a list of available colors\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Determine the number of lines to be drawn, between 1 and h-1\n    numls = unifint(diff_lb, diff_ub, (1, h - 1))\n    \n    # Create a list of possible row indices for the lines\n    opts = interval(0, h, 1)\n    \n    # Randomly select row indices for the lines\n    locs = sample(opts, numls)\n    \n    # Choose two different colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Iterate over each selected row to draw lines\n    for ii in locs:\n        # Determine the end index of the line\n        endidx = unifint(diff_lb, diff_ub, (2, w - 2))\n        \n        # Calculate the offset (length of the line), ensuring it's even\n        ofs = unifint(diff_lb, diff_ub, (1, endidx//2)) * 2\n        \n        # Ensure the offset is between 2 and endidx\n        ofs = min(max(2, ofs), endidx)\n        \n        # Calculate the start index of the line\n        startidx = endidx - ofs\n        \n        # Create a set of indices representing the full line\n        ln = connect((ii, startidx), (ii, endidx))\n        \n        # Fill the full line with color 2 in the output grid\n        go = fill(go, 2, ln)\n        \n        # Create a set of indices for every other cell in the line\n        sparseln = {(ii, jj) for jj in range(startidx, endidx + 1, 2)}\n        \n        # Fill every other cell with the foreground color in the output grid\n        go = fill(go, fgc, sparseln)\n        \n        # Fill every other cell with the foreground color in the input grid\n        gi = fill(gi, fgc, sparseln)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a740d043": {
    "original": "def generate_a740d043(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(0, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    ncd = unifint(diff_lb, diff_ub, (1, max(1, ((h-1) * (w-1)) // 2)))\n    nc = choice((ncd, (h-1) * (w-1) - ncd))\n    nc = min(max(1, ncd), (h-1) * (w-1) - 1)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    remcols = sample(remcols, numc)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(canvas(-1, (h - 1, w - 1)))\n    ch = choice(totuple(bounds))\n    shp = {ch}\n    bounds = remove(ch, bounds)\n    for j in range(nc):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    plcd = shift(shp, loc)\n    obj = {(choice(remcols), ij) for ij in plcd}\n    gi = paint(c, obj)\n    go = compress(gi)\n    go = replace(go, bgc, 0)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a740d043(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 0\n    cols = remove(0, interval(0, 10, 1))\n    \n    # Generate random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Calculate number of cells for shape (ncd) based on difficulty\n    # This determines the complexity of the shape to be created\n    ncd = unifint(diff_lb, diff_ub, (1, max(1, ((h-1) * (w-1)) // 2)))\n    \n    # Choose between ncd and its complement for final cell count (nc)\n    # This adds variability to the shape size\n    nc = choice((ncd, (h-1) * (w-1) - ncd))\n    \n    # Ensure nc is within valid bounds\n    nc = min(max(1, ncd), (h-1) * (w-1) - 1)\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use for the shape\n    numc = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    \n    # Sample the chosen number of colors from remaining colors\n    remcols = sample(remcols, numc)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Generate all possible cell positions for the shape\n    bounds = asindices(canvas(-1, (h - 1, w - 1)))\n    \n    # Choose a random starting cell for the shape\n    ch = choice(totuple(bounds))\n    \n    # Initialize the shape with the chosen cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available positions\n    bounds = remove(ch, bounds)\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc):\n        # Add a random neighboring cell to the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the normalized shape\n    oh, ow = shape(shp)\n    \n    # Choose a random location to place the shape on the canvas\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    \n    # Shift the shape to the chosen location\n    plcd = shift(shp, loc)\n    \n    # Create the object by assigning random colors to the shape's cells\n    obj = {(choice(remcols), ij) for ij in plcd}\n    \n    # Paint the object onto the canvas (input grid)\n    gi = paint(c, obj)\n    \n    # Compress the grid by removing any solid rows or columns (output grid)\n    go = compress(gi)\n    \n    # Replace the background color with 0 in the output grid\n    go = replace(go, bgc, 0)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "a78176bb": {
    "original": "def generate_a78176bb(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    nlns = unifint(diff_lb, diff_ub, (1, (h + w) // 8))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    succ = 0\n    tr = 0\n    maxtr = 10 * nlns\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))       \n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    spopts = []\n    for idx in range(h - 5, -1, -1):\n        spopts.append((idx, 0))\n    for idx in range(1, w - 4, 1):\n        spopts.append((0, idx))\n    while succ < nlns and tr < maxtr:\n        tr += 1\n        if len(spopts) == 0:\n            break\n        sp = choice(spopts)\n        ln = shoot(sp, (1, 1)) & fullinds\n        if not ln.issubset(inds):\n            continue\n        lno = sorted(ln, key=lambda x: x[0])\n        trid1 = randint(2, min(5, len(lno)-3))\n        trid2 = randint(2, min(5, len(lno)-3))\n        tri1 = sfilter(asindices(canvas(-1, (trid1, trid1))), lambda ij: ij[1] >= ij[0])\n        triloc1 = add(choice(lno[1:-trid1-1]), (0, 1))\n        tri2 = dmirror(sfilter(asindices(canvas(-1, (trid2, trid2))), lambda ij: ij[1] >= ij[0]))\n        triloc2 = add(choice(lno[1:-trid2-1]), (1, 0))\n        spo2 = add(sp, (0, -trid2-2))\n        nexlin2 = {add(spo2, (k, k)) for k in range(max(h, w))} & fullinds\n        spo1 = add(sp, (-trid1-2, 0))\n        nexlin1 = {add(spo1, (k, k)) for k in range(max(h, w))} & fullinds\n        for idx, (tri, triloc, nexlin) in enumerate(sample([\n            (tri1, triloc1, nexlin1),\n            (tri2, triloc2, nexlin2)\n        ], 2)):\n            tri = shift(tri, triloc)\n            fullobj = ln | tri | nexlin\n            if idx == 0:\n                lncol, tricol = sample(remcols, 2)\n            else:\n                tricol = choice(remove(lncol, remcols))\n            if (\n                fullobj.issubset(inds) if idx == 0 else (tri | nexlin).issubset(fullobj)\n            ):\n                succ += 1\n                inds = (inds - fullobj) - mapply(neighbors, fullobj)\n                gi = fill(gi, tricol, tri)\n                gi = fill(gi, lncol, ln)\n                go = fill(go, lncol, ln)\n                go = fill(go, lncol, nexlin)\n    if choice((True, False)):\n        gi = hmirror(gi)\n        go = hmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a78176bb(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (6, 30))  # Random height between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))  # Random width between 6 and 30 based on difficulty\n    nlns = unifint(diff_lb, diff_ub, (1, (h + w) // 8))  # Random number of lines to draw\n    bgc = choice(cols)  # Choose a random background color\n    remcols = remove(bgc, cols)  # Remove background color from available colors\n    succ = 0  # Counter for successful line placements\n    tr = 0  # Trial counter\n    maxtr = 10 * nlns  # Maximum number of trials allowed\n    gi = canvas(bgc, (h, w))  # Create input grid with background color\n    go = canvas(bgc, (h, w))  # Create output grid with background color\n    inds = asindices(gi)  # Get all indices of the grid\n    fullinds = asindices(gi)  # Keep a copy of all indices\n    spopts = []  # List to store starting point options\n\n    # Add starting points along the left edge (bottom to top)\n    for idx in range(h - 5, -1, -1):\n        spopts.append((idx, 0))\n\n    # Add starting points along the top edge (left to right)\n    for idx in range(1, w - 4, 1):\n        spopts.append((0, idx))\n\n    while succ < nlns and tr < maxtr:\n        tr += 1  # Increment trial counter\n        if len(spopts) == 0:\n            break  # Exit if no starting points are available\n\n        sp = choice(spopts)  # Choose a random starting point\n        ln = shoot(sp, (1, 1)) & fullinds  # Create a diagonal line and intersect with grid indices\n        if not ln.issubset(inds):\n            continue  # Skip if line is not entirely within available indices\n\n        lno = sorted(ln, key=lambda x: x[0])  # Sort line indices by row\n        trid1 = randint(2, min(5, len(lno)-3))  # Random size for first triangle\n        trid2 = randint(2, min(5, len(lno)-3))  # Random size for second triangle\n        \n        # Create first triangle (upper right half)\n        tri1 = sfilter(asindices(canvas(-1, (trid1, trid1))), lambda ij: ij[1] >= ij[0])\n        triloc1 = add(choice(lno[1:-trid1-1]), (0, 1))  # Choose location for first triangle\n        \n        # Create second triangle (lower left half, mirrored)\n        tri2 = dmirror(sfilter(asindices(canvas(-1, (trid2, trid2))), lambda ij: ij[1] >= ij[0]))\n        triloc2 = add(choice(lno[1:-trid2-1]), (1, 0))  # Choose location for second triangle\n\n        spo2 = add(sp, (0, -trid2-2))  # Calculate starting point for next line (left)\n        nexlin2 = {add(spo2, (k, k)) for k in range(max(h, w))} & fullinds  # Create next line (left)\n        spo1 = add(sp, (-trid1-2, 0))  # Calculate starting point for next line (up)\n        nexlin1 = {add(spo1, (k, k)) for k in range(max(h, w))} & fullinds  # Create next line (up)\n\n        for idx, (tri, triloc, nexlin) in enumerate(sample([\n            (tri1, triloc1, nexlin1),\n            (tri2, triloc2, nexlin2)\n        ], 2)):\n            tri = shift(tri, triloc)  # Move triangle to its location\n            fullobj = ln | tri | nexlin  # Combine line, triangle, and next line\n            if idx == 0:\n                lncol, tricol = sample(remcols, 2)  # Choose colors for line and triangle\n            else:\n                tricol = choice(remove(lncol, remcols))  # Choose different color for second triangle\n\n            # Check if object fits in the grid\n            if (\n                fullobj.issubset(inds) if idx == 0 else (tri | nexlin).issubset(fullobj)\n            ):\n                succ += 1  # Increment success counter\n                inds = (inds - fullobj) - mapply(neighbors, fullobj)  # Remove used indices and their neighbors\n                gi = fill(gi, tricol, tri)  # Fill triangle in input grid\n                gi = fill(gi, lncol, ln)  # Fill line in input grid\n                go = fill(go, lncol, ln)  # Fill line in output grid\n                go = fill(go, lncol, nexlin)  # Fill next line in output grid (extends the original line)\n\n    if choice((True, False)):  # Randomly decide to mirror the grids horizontally\n        gi = hmirror(gi)\n        go = hmirror(go)\n\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "a79310a0": {
    "original": "def generate_a79310a0(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(c)\n    ch = choice(totuple(bounds))\n    shp = {ch}\n    bounds = remove(ch, bounds)\n    for j in range(nc - 1):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    plcd = shift(shp, loc)\n    gi = fill(c, fgc, plcd)\n    go = fill(c, 2, shift(plcd, (1, 0)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a79310a0(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random number of cells to be colored, between 1 and half the grid area minus 1\n    nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible cell coordinates in the grid\n    bounds = asindices(c)\n    \n    # Choose a random starting cell for the shape\n    ch = choice(totuple(bounds))\n    \n    # Initialize the shape with the chosen starting cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available cells\n    bounds = remove(ch, bounds)\n    \n    # Grow the shape by adding adjacent cells, up to nc cells\n    for j in range(nc - 1):\n        # Add a random cell that's adjacent to the current shape and within bounds\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape (move it to the origin)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the normalized shape\n    oh, ow = shape(shp)\n    \n    # Choose a random location to place the shape in the grid\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    \n    # Shift the shape to the chosen location\n    plcd = shift(shp, loc)\n    \n    # Create the input grid by filling the shape with the foreground color\n    gi = fill(c, fgc, plcd)\n    \n    # Create the output grid by shifting the shape down by 1 and filling with color 2\n    go = fill(c, 2, shift(plcd, (1, 0)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a85d4709": {
    "original": "def generate_a85d4709(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 3, 4))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w3 = unifint(diff_lb, diff_ub, (1, 10))\n    w = w3 * 3\n    bgc, dotc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for ii in range(h):\n        loc = randint(0, w3 - 1)\n        dev = unifint(diff_lb, diff_ub, (0, w3 // 2 + 1))\n        loc = w3 // 3 + choice((+dev, -dev))\n        loc = min(max(0, loc), w3 - 1)\n        ofs, col = choice(((0, 2), (1, 4), (2, 3)))\n        loc += ofs * w3\n        gi = fill(gi, dotc, {(ii, loc)})\n        ln = connect((ii, 0), (ii, w - 1))\n        go = fill(go, col, ln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a85d4709(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of color indices, excluding 2, 3, and 4\n    cols = difference(interval(0, 10, 1), (2, 3, 4))\n    \n    # Randomly determine the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine one-third of the width of the grid between 1 and 10\n    w3 = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Calculate the full width of the grid (3 times w3)\n    w = w3 * 3\n    \n    # Randomly select two colors from the available colors: one for background, one for dots\n    bgc, dotc = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Iterate over each row of the grid\n    for ii in range(h):\n        # Randomly select an initial location for the dot within the first third of the width\n        loc = randint(0, w3 - 1)\n        \n        # Randomly determine a deviation for the dot's position\n        dev = unifint(diff_lb, diff_ub, (0, w3 // 2 + 1))\n        \n        # Adjust the dot's position based on the deviation\n        loc = w3 // 3 + choice((+dev, -dev))\n        \n        # Ensure the dot's position is within the first third of the width\n        loc = min(max(0, loc), w3 - 1)\n        \n        # Randomly choose an offset and corresponding color for the output\n        ofs, col = choice(((0, 2), (1, 4), (2, 3)))\n        \n        # Apply the offset to the dot's position\n        loc += ofs * w3\n        \n        # Place the dot in the input grid\n        gi = fill(gi, dotc, {(ii, loc)})\n        \n        # Create a horizontal line across the entire row\n        ln = connect((ii, 0), (ii, w - 1))\n        \n        # Fill the horizontal line in the output grid with the chosen color\n        go = fill(go, col, ln)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a87f7484": {
    "original": "def generate_a87f7484(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    num = unifint(diff_lb, diff_ub, (3, min(30 // h, 9)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, num)\n    ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    nc = choice((ncd, h * w - ncd))\n    nc = min(max(1, nc), h * w - 1)\n    c = canvas(bgc, (h, w))\n    inds = asindices(c)\n    origlocs = sample(totuple(inds), nc)\n    canbrem = {l for l in origlocs}\n    canbeadd = inds - set(origlocs)\n    otherlocs = {l for l in origlocs}\n    nchangesinv = unifint(diff_lb, diff_ub, (0, h * w - 1))\n    nchanges = h * w - nchangesinv\n    for k in range(nchanges):\n        if choice((True, False)):\n            if len(canbrem) > 1:\n                ch = choice(totuple(canbrem))\n                otherlocs = remove(ch, otherlocs)\n                canbrem = remove(ch, canbrem)\n            elif len(canbeadd) > 1:\n                ch = choice(totuple(canbeadd))\n                otherlocs = insert(ch, otherlocs)\n                canbeadd = remove(ch, canbeadd)\n        else:\n            if len(canbeadd) > 1:\n                ch = choice(totuple(canbeadd))\n                otherlocs = insert(ch, otherlocs)\n                canbeadd = remove(ch, canbeadd)\n            elif len(canbrem) > 1:\n                ch = choice(totuple(canbrem))\n                otherlocs = remove(ch, otherlocs)\n                canbrem = remove(ch, canbrem)\n    go = fill(c, ccols[0], origlocs)\n    grids = [go]\n    for cc in ccols[1:]:\n        grids.append(fill(c, cc, otherlocs))\n    shuffle(grids)\n    grids = tuple(grids)\n    gi = merge(grids)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a87f7484(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (2, 5))  # Randomly choose height between 2 and 5\n    w = unifint(diff_lb, diff_ub, (2, 30))  # Randomly choose width between 2 and 30\n    num = unifint(diff_lb, diff_ub, (3, min(30 // h, 9)))  # Choose number of colors, at least 3, at most 9 or 30/height\n    bgc = choice(cols)  # Randomly select a background color\n    remcols = remove(bgc, cols)  # Remove the background color from the color list\n    ccols = sample(remcols, num)  # Randomly sample 'num' colors from remaining colors\n    ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))  # Choose a random number between 0 and half the grid size\n    nc = choice((ncd, h * w - ncd))  # Randomly choose either ncd or its complement\n    nc = min(max(1, nc), h * w - 1)  # Ensure nc is between 1 and one less than grid size\n    c = canvas(bgc, (h, w))  # Create a grid filled with the background color\n    inds = asindices(c)  # Get all indices of the grid\n    origlocs = sample(totuple(inds), nc)  # Randomly sample nc locations from the grid\n    canbrem = {l for l in origlocs}  # Set of locations that can be removed (initially all original locations)\n    canbeadd = inds - set(origlocs)  # Set of locations that can be added (initially all non-original locations)\n    otherlocs = {l for l in origlocs}  # Copy of original locations, will be modified\n    nchangesinv = unifint(diff_lb, diff_ub, (0, h * w - 1))  # Number of cells to keep unchanged\n    nchanges = h * w - nchangesinv  # Number of cells to change\n    for k in range(nchanges):\n        if choice((True, False)):  # Randomly choose to remove or add\n            if len(canbrem) > 1:  # If there are locations that can be removed\n                ch = choice(totuple(canbrem))  # Choose a location to remove\n                otherlocs = remove(ch, otherlocs)  # Remove the chosen location from otherlocs\n                canbrem = remove(ch, canbrem)  # Remove the chosen location from canbrem\n            elif len(canbeadd) > 1:  # If can't remove, try to add\n                ch = choice(totuple(canbeadd))  # Choose a location to add\n                otherlocs = insert(ch, otherlocs)  # Add the chosen location to otherlocs\n                canbeadd = remove(ch, canbeadd)  # Remove the chosen location from canbeadd\n        else:  # Try to add first\n            if len(canbeadd) > 1:  # If there are locations that can be added\n                ch = choice(totuple(canbeadd))  # Choose a location to add\n                otherlocs = insert(ch, otherlocs)  # Add the chosen location to otherlocs\n                canbeadd = remove(ch, canbeadd)  # Remove the chosen location from canbeadd\n            elif len(canbrem) > 1:  # If can't add, try to remove\n                ch = choice(totuple(canbrem))  # Choose a location to remove\n                otherlocs = remove(ch, otherlocs)  # Remove the chosen location from otherlocs\n                canbrem = remove(ch, canbrem)  # Remove the chosen location from canbrem\n    go = fill(c, ccols[0], origlocs)  # Fill original locations with the first color\n    grids = [go]  # Start list of grids with the output grid\n    for cc in ccols[1:]:  # For each remaining color\n        grids.append(fill(c, cc, otherlocs))  # Create a new grid with otherlocs filled with this color\n    shuffle(grids)  # Randomly shuffle the order of grids\n    grids = tuple(grids)  # Convert list of grids to tuple\n    gi = merge(grids)  # Merge all grids into one input grid\n    if choice((True, False)):  # Randomly decide whether to mirror diagonally\n        gi = dmirror(gi)  # Mirror input grid diagonally\n        go = dmirror(go)  # Mirror output grid diagonally\n    return {'input': gi, 'output': go}  # Return dictionary with input and output grids\n"
  },
  "a8c38be5": {
    "original": "def generate_a8c38be5(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    goh = unifint(diff_lb, diff_ub, (9, 20))\n    gow = unifint(diff_lb, diff_ub, (9, 20))\n    h = unifint(diff_lb, diff_ub, (goh+4, 30))\n    w = unifint(diff_lb, diff_ub, (gow+4, 30))\n    bgc, sqc = sample(cols, 2)\n    remcols = remove(bgc, remove(sqc, cols))\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numc)\n    go = canvas(sqc, (goh, gow))\n    go = fill(go, bgc, box(asindices(go)))\n    loci1 = randint(2, goh-7)\n    loci2 = randint(loci1+4, goh-3)\n    locj1 = randint(2, gow-7)\n    locj2 = randint(locj1+4, gow-3)\n    f1 = hfrontier((loci1, 0))\n    f2 = hfrontier((loci2, 0))\n    f3 = vfrontier((0, locj1))\n    f4 = vfrontier((0, locj2))\n    fs = f1 | f2 | f3 | f4\n    go = fill(go, sqc, fs)\n    go = fill(go, bgc, {((loci1 + loci2) // 2, 1)})\n    go = fill(go, bgc, {((loci1 + loci2) // 2, gow - 2)})\n    go = fill(go, bgc, {(1, (locj1 + locj2) // 2)})\n    go = fill(go, bgc, {(goh - 2, (locj1 + locj2) // 2)})\n    objs = objects(go, T, F, T)\n    objs = merge(set(recolor(choice(ccols), obj) for obj in objs))\n    go = paint(go, objs)\n    gi = go\n    hdelt = h - goh\n    hdelt1 = randint(1, hdelt - 3)\n    hdelt2 = randint(1, hdelt - hdelt1 - 2)\n    hdelt3 = randint(1, hdelt - hdelt1 - hdelt2 - 1)\n    hdelt4 = hdelt - hdelt1 - hdelt2 - hdelt3\n    wdelt = w - gow\n    wdelt1 = randint(1, wdelt - 3)\n    wdelt2 = randint(1, wdelt - wdelt1 - 2)\n    wdelt3 = randint(1, wdelt - wdelt1 - wdelt2 - 1)\n    wdelt4 = wdelt - wdelt1 - wdelt2 - wdelt3\n    gi = gi[:loci2] + repeat(repeat(bgc, gow), hdelt2) + gi[loci2:]\n    gi = gi[:loci1+1] + repeat(repeat(bgc, gow), hdelt3) + gi[loci1+1:]\n    gi = repeat(repeat(bgc, gow), hdelt1) + gi + repeat(repeat(bgc, gow), hdelt4)\n    gi = dmirror(gi)\n    gi = gi[:locj2] + repeat(repeat(bgc, h), wdelt2) + gi[locj2:]\n    gi = gi[:locj1+1] + repeat(repeat(bgc, h), wdelt3) + gi[locj1+1:]\n    gi = repeat(repeat(bgc, h), wdelt1) + gi + repeat(repeat(bgc, h), wdelt4)\n    gi = dmirror(gi)\n    nswitcheroos = unifint(diff_lb, diff_ub, (0, 10))\n    if choice((True, False)):\n        gi = gi[loci1+hdelt1+1:] + gi[:loci1+hdelt1+1]\n    if choice((True, False)):\n        gi = dmirror(gi)\n        gi = gi[locj1+wdelt1+1:] + gi[:locj1+wdelt1+1]\n        gi = dmirror(gi)\n    for k in range(nswitcheroos):\n        o = asobject(gi)\n        tmpc = canvas(bgc, (h+12, w+12))\n        tmpc = paint(tmpc, shift(o, (6, 6)))\n        objs = objects(tmpc, F, T, T)\n        objs = apply(rbind(shift, (-6, -6)), objs)\n        mpr = dict()\n        for obj in objs:\n            shp = shape(obj)\n            if shp in mpr:\n                mpr[shp].append(obj)\n            else:\n                mpr[shp] = [obj]\n        if max([len(x) for x in mpr.values()]) == 1:\n            break\n        ress = [(kk, v) for kk, v in mpr.items() if len(v) > 1]\n        res, abc = choice(ress)\n        a, b = sample(abc, 2)\n        ulca = ulcorner(a)\n        ulcb = ulcorner(b)\n        ap = shift(normalize(a), ulcb)\n        bp = shift(normalize(b), ulca)\n        gi = paint(gi, ap | bp)\n    nshifts = unifint(diff_lb, diff_ub, (0, 30))\n    for k in range(nshifts):\n        o = asobject(gi)\n        tmpc = canvas(bgc, (h+12, w+12))\n        tmpc = paint(tmpc, shift(o, (6, 6)))\n        objs = objects(tmpc, F, F, T)\n        objs = apply(rbind(shift, (-6, -6)), objs)\n        objs = sfilter(objs, compose(flip, rbind(bordering, gi)))\n        if len(objs) == 0:\n            break\n        obj = choice(totuple(objs))\n        direc1 = (randint(-1, 1), randint(-1, 1))\n        direc2 = position({(h//2, w//2)}, {center(obj)})\n        direc = choice((direc1, direc2))\n        gi = fill(gi, bgc, obj)\n        gi = paint(gi, shift(obj, direc))\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a8c38be5(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    goh = unifint(diff_lb, diff_ub, (9, 20))  # Generate a random height for the output grid between 9 and 20\n    gow = unifint(diff_lb, diff_ub, (9, 20))  # Generate a random width for the output grid between 9 and 20\n    h = unifint(diff_lb, diff_ub, (goh+4, 30))  # Generate a random height for the input grid, larger than the output grid\n    w = unifint(diff_lb, diff_ub, (gow+4, 30))  # Generate a random width for the input grid, larger than the output grid\n    bgc, sqc = sample(cols, 2)  # Randomly select two colors: one for background and one for squares\n    remcols = remove(bgc, remove(sqc, cols))  # Remove background and square colors from the color list\n    numc = unifint(diff_lb, diff_ub, (1, 8))  # Randomly decide how many additional colors to use (1 to 8)\n    ccols = sample(remcols, numc)  # Randomly select the additional colors\n    go = canvas(sqc, (goh, gow))  # Create the output grid filled with the square color\n    go = fill(go, bgc, box(asindices(go)))  # Create a border around the output grid with the background color\n    loci1 = randint(2, goh-7)  # Choose a random row for the first horizontal line\n    loci2 = randint(loci1+4, goh-3)  # Choose a random row for the second horizontal line, below the first\n    locj1 = randint(2, gow-7)  # Choose a random column for the first vertical line\n    locj2 = randint(locj1+4, gow-3)  # Choose a random column for the second vertical line, to the right of the first\n    f1 = hfrontier((loci1, 0))  # Create the first horizontal line\n    f2 = hfrontier((loci2, 0))  # Create the second horizontal line\n    f3 = vfrontier((0, locj1))  # Create the first vertical line\n    f4 = vfrontier((0, locj2))  # Create the second vertical line\n    fs = f1 | f2 | f3 | f4  # Combine all lines\n    go = fill(go, sqc, fs)  # Draw the lines on the output grid with the square color\n    go = fill(go, bgc, {((loci1 + loci2) // 2, 1)})  # Create a gap in the left side of the box\n    go = fill(go, bgc, {((loci1 + loci2) // 2, gow - 2)})  # Create a gap in the right side of the box\n    go = fill(go, bgc, {(1, (locj1 + locj2) // 2)})  # Create a gap in the top of the box\n    go = fill(go, bgc, {(goh - 2, (locj1 + locj2) // 2)})  # Create a gap in the bottom of the box\n    objs = objects(go, T, F, T)  # Identify all objects in the output grid\n    objs = merge(set(recolor(choice(ccols), obj) for obj in objs))  # Randomly recolor each object\n    go = paint(go, objs)  # Paint the recolored objects onto the output grid\n    gi = go  # Initialize the input grid as a copy of the output grid\n    hdelt = h - goh  # Calculate the difference in height between input and output grids\n    hdelt1 = randint(1, hdelt - 3)  # Randomly divide the extra height into four parts\n    hdelt2 = randint(1, hdelt - hdelt1 - 2)\n    hdelt3 = randint(1, hdelt - hdelt1 - hdelt2 - 1)\n    hdelt4 = hdelt - hdelt1 - hdelt2 - hdelt3\n    wdelt = w - gow  # Calculate the difference in width between input and output grids\n    wdelt1 = randint(1, wdelt - 3)  # Randomly divide the extra width into four parts\n    wdelt2 = randint(1, wdelt - wdelt1 - 2)\n    wdelt3 = randint(1, wdelt - wdelt1 - wdelt2 - 1)\n    wdelt4 = wdelt - wdelt1 - wdelt2 - wdelt3\n    gi = gi[:loci2] + repeat(repeat(bgc, gow), hdelt2) + gi[loci2:]  # Insert extra rows in the middle of the grid\n    gi = gi[:loci1+1] + repeat(repeat(bgc, gow), hdelt3) + gi[loci1+1:]  # Insert more extra rows\n    gi = repeat(repeat(bgc, gow), hdelt1) + gi + repeat(repeat(bgc, gow), hdelt4)  # Add extra rows to top and bottom\n    gi = dmirror(gi)  # Transpose the grid\n    gi = gi[:locj2] + repeat(repeat(bgc, h), wdelt2) + gi[locj2:]  # Insert extra columns in the middle of the grid\n    gi = gi[:locj1+1] + repeat(repeat(bgc, h), wdelt3) + gi[locj1+1:]  # Insert more extra columns\n    gi = repeat(repeat(bgc, h), wdelt1) + gi + repeat(repeat(bgc, h), wdelt4)  # Add extra columns to left and right\n    gi = dmirror(gi)  # Transpose the grid back\n    nswitcheroos = unifint(diff_lb, diff_ub, (0, 10))  # Decide how many object swaps to perform\n    if choice((True, False)):  # 50% chance to shift the top part of the grid to the bottom\n        gi = gi[loci1+hdelt1+1:] + gi[:loci1+hdelt1+1]\n    if choice((True, False)):  # 50% chance to shift the left part of the grid to the right\n        gi = dmirror(gi)\n        gi = gi[locj1+wdelt1+1:] + gi[:locj1+wdelt1+1]\n        gi = dmirror(gi)\n    for k in range(nswitcheroos):  # Perform the decided number of object swaps\n        o = asobject(gi)  # Convert the entire grid to an object\n        tmpc = canvas(bgc, (h+12, w+12))  # Create a temporary larger canvas\n        tmpc = paint(tmpc, shift(o, (6, 6)))  # Paint the grid onto the temporary canvas\n        objs = objects(tmpc, F, T, T)  # Identify all objects in the temporary canvas\n        objs = apply(rbind(shift, (-6, -6)), objs)  # Shift the objects back to their original positions\n        mpr = dict()  # Create a dictionary to group objects by shape\n        for obj in objs:\n            shp = shape(obj)\n            if shp in mpr:\n                mpr[shp].append(obj)\n            else:\n                mpr[shp] = [obj]\n        if max([len(x) for x in mpr.values()]) == 1:  # If no objects have the same shape, break the loop\n            break\n        ress = [(kk, v) for kk, v in mpr.items() if len(v) > 1]  # Find shapes with multiple objects\n        res, abc = choice(ress)  # Choose a random shape with multiple objects\n        a, b = sample(abc, 2)  # Choose two random objects of that shape\n        ulca = ulcorner(a)  # Get the upper left corner of the first object\n        ulcb = ulcorner(b)  # Get the upper left corner of the second object\n        ap = shift(normalize(a), ulcb)  # Shift the first object to the position of the second\n        bp = shift(normalize(b), ulca)  # Shift the second object to the position of the first\n        gi = paint(gi, ap | bp)  # Paint the swapped objects onto the input grid\n    nshifts = unifint(diff_lb, diff_ub, (0, 30))  # Decide how many object shifts to perform\n    for k in range(nshifts):  # Perform the decided number of object shifts\n        o = asobject(gi)  # Convert the entire grid to an object\n        tmpc = canvas(bgc, (h+12, w+12))  # Create a temporary larger canvas\n        tmpc = paint(tmpc, shift(o, (6, 6)))  # Paint the grid onto the temporary canvas\n        objs = objects(tmpc, F, F, T)  # Identify all objects in the temporary canvas\n        objs = apply(rbind(shift, (-6, -6)), objs)  # Shift the objects back to their original positions\n        objs = sfilter(objs, compose(flip, rbind(bordering, gi)))  # Filter for objects not bordering the grid\n        if len(objs) == 0:  # If no objects are found, break the loop\n            break\n        obj = choice(totuple(objs))  # Choose a random object\n        direc1 = (randint(-1, 1), randint(-1, 1))  # Generate a random direction\n        direc2 = position({(h//2, w//2)}, {center(obj)})  # Generate a direction towards the center of the grid\n        direc = choice((direc1, direc2))  # Choose between the random and center-directed directions\n        gi = fill(gi, bgc, obj)  # Remove the object from its current position\n        gi = paint(gi, shift(obj, direc))  # Paint the object in its new position\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)  # List of possible transformations\n    nmfs = choice((1, 2))  # Decide to apply either 1 or 2 transformations\n    for fn in sample(mfs, nmfs):  # Apply the chosen number of random transformations\n        gi = fn(gi)  # Apply the transformation to the input grid\n        go = fn(go)  # Apply the same transformation to the output grid\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "a8d7556c": {
    "original": "def generate_a8d7556c(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (0, 2))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    fgc = choice(cols)\n    c = canvas(fgc, (h, w))\n    numblacks = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))\n    inds = totuple(asindices(c))\n    blacks = sample(inds, numblacks)\n    gi = fill(c, 0, blacks)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    sqlocs = sample(inds, numsq)\n    gi = fill(gi, 0, shift(sqlocs, (0, 0)))\n    gi = fill(gi, 0, shift(sqlocs, (0, 1)))\n    gi = fill(gi, 0, shift(sqlocs, (1, 0)))\n    gi = fill(gi, 0, shift(sqlocs, (1, 1)))\n    go = tuple(e for e in gi)\n    for a in range(h - 1):\n        for b in range(w - 1):\n            if gi[a][b] == 0 and gi[a+1][b] == 0 and gi[a][b+1] == 0 and gi[a+1][b+1] == 0:\n                go = fill(go, 2, {(a, b), (a+1, b), (a, b+1), (a+1, b+1)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a8d7556c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors, excluding 0 and 2\n    cols = difference(interval(0, 10, 1), (0, 2))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly choose a foreground color from the defined set\n    fgc = choice(cols)\n    \n    # Create a canvas (grid) filled with the chosen foreground color\n    c = canvas(fgc, (h, w))\n    \n    # Determine the number of black cells to be placed, between 1 and 2/3 of the grid size\n    numblacks = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select locations for black cells\n    blacks = sample(inds, numblacks)\n    \n    # Fill the selected locations with black (color 0) to create the input grid\n    gi = fill(c, 0, blacks)\n    \n    # Determine the number of 2x2 squares to be placed\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    \n    # Randomly select locations for the top-left corners of 2x2 squares\n    sqlocs = sample(inds, numsq)\n    \n    # Fill the 2x2 squares with black (color 0)\n    gi = fill(gi, 0, shift(sqlocs, (0, 0)))  # Top-left cell\n    gi = fill(gi, 0, shift(sqlocs, (0, 1)))  # Top-right cell\n    gi = fill(gi, 0, shift(sqlocs, (1, 0)))  # Bottom-left cell\n    gi = fill(gi, 0, shift(sqlocs, (1, 1)))  # Bottom-right cell\n    \n    # Create a copy of the input grid to generate the output\n    go = tuple(e for e in gi)\n    \n    # Iterate through the grid to find and fill 2x2 black squares\n    for a in range(h - 1):\n        for b in range(w - 1):\n            # Check if current 2x2 area is all black\n            if gi[a][b] == 0 and gi[a+1][b] == 0 and gi[a][b+1] == 0 and gi[a+1][b+1] == 0:\n                # Fill the 2x2 area with color 2 in the output grid\n                go = fill(go, 2, {(a, b), (a+1, b), (a, b+1), (a+1, b+1)})\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "a9f96cdd": {
    "original": "def generate_a9f96cdd(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (3, 6, 7, 8))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    fgc = choice(remove(bgc, cols))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    locs = asindices(gi)\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))\n    for k in range(noccs):\n        if len(locs) == 0:\n            break\n        loc = choice(totuple(locs))\n        locs = locs - mapply(neighbors, neighbors(loc))\n        plcd = {loc}\n        gi = fill(gi, fgc, plcd)\n        go = fill(go, 3, shift(plcd, (-1, -1)))\n        go = fill(go, 7, shift(plcd, (1, 1)))\n        go = fill(go, 8, shift(plcd, (1, -1)))\n        go = fill(go, 6, shift(plcd, (-1, 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_a9f96cdd(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 3, 6, 7, and 8\n    cols = difference(interval(0, 10, 1), (3, 6, 7, 8))\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Randomly choose a foreground color, different from the background color\n    fgc = choice(remove(bgc, cols))\n    \n    # Create the input grid with the chosen background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the same background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible cell locations in the grid\n    locs = asindices(gi)\n    \n    # Determine the number of occurrences (shapes) to place, between 1 and 10% of grid size\n    noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))\n    \n    # Loop to place shapes on the grid\n    for k in range(noccs):\n        # Break if no more valid locations are available\n        if len(locs) == 0:\n            break\n        \n        # Choose a random location from available locations\n        loc = choice(totuple(locs))\n        \n        # Remove the chosen location and its neighbors from available locations\n        locs = locs - mapply(neighbors, neighbors(loc))\n        \n        # Create a set with the chosen location\n        plcd = {loc}\n        \n        # Place the foreground color at the chosen location in the input grid\n        gi = fill(gi, fgc, plcd)\n        \n        # In the output grid, place color 3 at the top-left of the original location\n        go = fill(go, 3, shift(plcd, (-1, -1)))\n        \n        # Place color 7 at the bottom-right of the original location\n        go = fill(go, 7, shift(plcd, (1, 1)))\n        \n        # Place color 8 at the bottom-left of the original location\n        go = fill(go, 8, shift(plcd, (1, -1)))\n        \n        # Place color 6 at the top-right of the original location\n        go = fill(go, 6, shift(plcd, (-1, 1)))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "aabf363d": {
    "original": "def generate_aabf363d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 28))\n    w = unifint(diff_lb, diff_ub, (3, 28))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    cola = choice(remcols)\n    remcols = remove(cola, remcols)\n    colb = choice(remcols)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(c)\n    sp = choice(totuple(bounds))\n    ub = min(h * w - 1, max(1, (2/3) * h * w))\n    ncells = unifint(diff_lb, diff_ub, (1, ub))\n    shp = {sp}\n    for k in range(ncells):\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        shp.add(ij)\n    shp = shift(shp, (1, 1))\n    c2 = canvas(bgc, (h+2, w+2))\n    gi = fill(c2, cola, shp)\n    go = fill(c2, colb, shp)\n    gi = fill(gi, colb, {choice(totuple(ofcolor(gi, bgc)))})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_aabf363d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 3 and 28 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 28))\n    \n    # Randomly choose a width between 3 and 28 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 28))\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the shape\n    cola = choice(remcols)\n    \n    # Remove the shape color from the remaining colors\n    remcols = remove(cola, remcols)\n    \n    # Choose a color for the single cell that will be changed\n    colb = choice(remcols)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the canvas\n    bounds = asindices(c)\n    \n    # Choose a random starting point for the shape\n    sp = choice(totuple(bounds))\n    \n    # Calculate the upper bound for the number of cells in the shape\n    # It's either 2/3 of the total cells or all cells except one, whichever is smaller\n    ub = min(h * w - 1, max(1, (2/3) * h * w))\n    \n    # Randomly choose the number of cells for the shape based on difficulty\n    ncells = unifint(diff_lb, diff_ub, (1, ub))\n    \n    # Initialize the shape with the starting point\n    shp = {sp}\n    \n    # Grow the shape by adding adjacent cells\n    for k in range(ncells):\n        # Choose a cell adjacent to the current shape but not in it\n        ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n        # Add the chosen cell to the shape\n        shp.add(ij)\n    \n    # Shift the shape by (1, 1) to create a border around it\n    shp = shift(shp, (1, 1))\n    \n    # Create a new canvas with a border around it\n    c2 = canvas(bgc, (h+2, w+2))\n    \n    # Fill the shape with color 'cola' on the input grid\n    gi = fill(c2, cola, shp)\n    \n    # Fill the shape with color 'colb' on the output grid\n    go = fill(c2, colb, shp)\n    \n    # Choose a random background cell and change it to 'colb' on the input grid\n    # This creates the cell that needs to be changed to solve the puzzle\n    gi = fill(gi, colb, {choice(totuple(ofcolor(gi, bgc)))})\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "aba27056": {
    "original": "def generate_aba27056(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    bgc, sqc = sample(cols, 2)\n    canv = canvas(bgc, (h, w))\n    oh = randint(3, h)\n    ow = unifint(diff_lb, diff_ub, (5, w - 1))\n    loci = unifint(diff_lb, diff_ub, (0, h - oh))\n    locj = randint(0, w - ow)\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    maxk = (ow - 4) // 2\n    k = randint(0, maxk)\n    hole = connect((loci, locj + 2 + k), (loci, locj + ow - 3 - k))\n    gi = fill(canv, sqc, bx)\n    gi = fill(gi, bgc, hole)\n    go = fill(canv, 4, backdrop(bx))\n    go = fill(go, sqc, bx)\n    bar = mapply(rbind(shoot, (-1, 0)), hole)\n    go = fill(go, 4, bar)\n    go = fill(go, 4, shoot(add((-1, 1), urcorner(hole)), (-1, 1)))\n    go = fill(go, 4, shoot(add((-1, -1), ulcorner(hole)), (-1, -1)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_aba27056(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly select two colors: one for background and one for square\n    bgc, sqc = sample(cols, 2)\n    \n    # Create a canvas (grid) with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Generate random height for the box (between 3 and h)\n    oh = randint(3, h)\n    \n    # Generate random width for the box based on difficulty (between 5 and w-1)\n    ow = unifint(diff_lb, diff_ub, (5, w - 1))\n    \n    # Generate random vertical position for the box based on difficulty\n    loci = unifint(diff_lb, diff_ub, (0, h - oh))\n    \n    # Generate random horizontal position for the box\n    locj = randint(0, w - ow)\n    \n    # Create the box outline\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Calculate maximum possible hole width\n    maxk = (ow - 4) // 2\n    \n    # Generate random hole width\n    k = randint(0, maxk)\n    \n    # Create the hole (horizontal line) in the box\n    hole = connect((loci, locj + 2 + k), (loci, locj + ow - 3 - k))\n    \n    # Fill the input grid: draw the box with square color\n    gi = fill(canv, sqc, bx)\n    \n    # Create the hole in the input grid\n    gi = fill(gi, bgc, hole)\n    \n    # Start creating the output grid: fill the box area with color 4\n    go = fill(canv, 4, backdrop(bx))\n    \n    # Draw the box outline with square color in the output grid\n    go = fill(go, sqc, bx)\n    \n    # Create vertical bars above the hole\n    bar = mapply(rbind(shoot, (-1, 0)), hole)\n    \n    # Draw the vertical bars with color 4\n    go = fill(go, 4, bar)\n    \n    # Draw diagonal line from upper right corner of the hole\n    go = fill(go, 4, shoot(add((-1, 1), urcorner(hole)), (-1, 1)))\n    \n    # Draw diagonal line from upper left corner of the hole\n    go = fill(go, 4, shoot(add((-1, -1), ulcorner(hole)), (-1, -1)))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ac0a08a4": {
    "original": "def generate_ac0a08a4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    num = unifint(diff_lb, diff_ub, (1, min(min(9, h * w - 2), min(30//h, 30//w))))\n    bgc = choice(cols)\n    c = canvas(bgc, (h, w))\n    inds = asindices(c)\n    locs = sample(totuple(inds), num)\n    remcols = remove(bgc, cols)\n    obj = {(col, loc) for col, loc in zip(sample(remcols, num), locs)}\n    gi = paint(c, obj)\n    go = upscale(gi, num)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ac0a08a4(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 2 and 5 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Generate a random width between 2 and 5 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Generate a random number of colored cells to place\n    # It's constrained by several factors including difficulty and grid size\n    num = unifint(diff_lb, diff_ub, (1, min(min(9, h * w - 2), min(30//h, 30//w))))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible indices (cell positions) in the grid\n    inds = asindices(c)\n    \n    # Randomly sample 'num' locations from all possible indices\n    locs = sample(totuple(inds), num)\n    \n    # Create a list of colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create a set of colored cells (objects) by pairing random colors with the chosen locations\n    obj = {(col, loc) for col, loc in zip(sample(remcols, num), locs)}\n    \n    # Paint the objects onto the canvas to create the input grid\n    gi = paint(c, obj)\n    \n    # Create the output grid by upscaling the input grid by a factor of 'num'\n    go = upscale(gi, num)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ae3edfdc": {
    "original": "def generate_ae3edfdc(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 7))\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(cols)\n    go = canvas(bgc, (h, w))\n    inds = asindices(go)\n    rdi = randint(1, h - 2)\n    rdj = randint(1, w - 2)\n    rd = (rdi, rdj)\n    reminds = inds - ({rd} | neighbors(rd))\n    reminds = sfilter(reminds, lambda ij: 1 <= ij[0] <= h - 2 and 1 <= ij[1] <= w - 2)\n    bd = choice(totuple(reminds))\n    bdi, bdj = bd\n    go = fill(go, 2, {rd})\n    go = fill(go, 1, {bd})\n    ngd = unifint(diff_lb, diff_ub, (1, 8))\n    gd = sample(totuple(neighbors(rd)), ngd)\n    nod = unifint(diff_lb, diff_ub, (1, 8))\n    od = sample(totuple(neighbors(bd)), nod)\n    go = fill(go, 3, gd)\n    go = fill(go, 7, od)\n    gdmapper = {d: (3, position({rd}, {d})) for d in gd}\n    odmapper = {d: (7, position({bd}, {d})) for d in od}\n    mpr = {**gdmapper, **odmapper}\n    ub = (len(gd) + len(od)) * ((h + w) // 5)\n    ndist = unifint(diff_lb, diff_ub, (1, ub))\n    gi = tuple(e for e in go)\n    fullinds = asindices(gi)\n    for k in range(ndist):\n        options = []\n        for loc, (col, direc) in mpr.items():\n            ii, jj = add(loc, direc)\n            if (ii, jj) in fullinds and gi[ii][jj] == bgc:\n                options.append((loc, col, direc))\n        if len(options) == 0:\n            break\n        loc, col, direc = choice(options)\n        del mpr[loc]\n        newloc = add(loc, direc)\n        mpr[newloc] = (col, direc)\n        gi = fill(gi, bgc, {loc})\n        gi = fill(gi, col, {newloc})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ae3edfdc(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1, 2, 3, and 7\n    cols = difference(interval(0, 10, 1), (1, 2, 3, 7))\n    \n    # Generate a random height between 8 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Generate a random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Choose a random background color from the defined set\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(go)\n    \n    # Choose a random row index between 1 and h-2 for the red dot\n    rdi = randint(1, h - 2)\n    \n    # Choose a random column index between 1 and w-2 for the red dot\n    rdj = randint(1, w - 2)\n    \n    # Combine the row and column indices for the red dot position\n    rd = (rdi, rdj)\n    \n    # Remove the red dot and its neighbors from the available indices\n    reminds = inds - ({rd} | neighbors(rd))\n    \n    # Filter remaining indices to ensure they're not on the border\n    reminds = sfilter(reminds, lambda ij: 1 <= ij[0] <= h - 2 and 1 <= ij[1] <= w - 2)\n    \n    # Choose a random position for the blue dot from the remaining indices\n    bd = choice(totuple(reminds))\n    \n    # Unpack the blue dot position\n    bdi, bdj = bd\n    \n    # Place the red dot (color 2) on the grid\n    go = fill(go, 2, {rd})\n    \n    # Place the blue dot (color 1) on the grid\n    go = fill(go, 1, {bd})\n    \n    # Choose a random number of green dots (1-8) based on difficulty\n    ngd = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Place green dots around the red dot\n    gd = sample(totuple(neighbors(rd)), ngd)\n    \n    # Choose a random number of orange dots (1-8) based on difficulty\n    nod = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Place orange dots around the blue dot\n    od = sample(totuple(neighbors(bd)), nod)\n    \n    # Fill in the green dots (color 3) on the grid\n    go = fill(go, 3, gd)\n    \n    # Fill in the orange dots (color 7) on the grid\n    go = fill(go, 7, od)\n    \n    # Create a mapper for green dots with their positions relative to the red dot\n    gdmapper = {d: (3, position({rd}, {d})) for d in gd}\n    \n    # Create a mapper for orange dots with their positions relative to the blue dot\n    odmapper = {d: (7, position({bd}, {d})) for d in od}\n    \n    # Combine both mappers\n    mpr = {**gdmapper, **odmapper}\n    \n    # Calculate an upper bound for the number of moves\n    ub = (len(gd) + len(od)) * ((h + w) // 5)\n    \n    # Choose a random number of moves based on difficulty and upper bound\n    ndist = unifint(diff_lb, diff_ub, (1, ub))\n    \n    # Create a mutable copy of the grid\n    gi = tuple(e for e in go)\n    \n    # Get all indices of the grid\n    fullinds = asindices(gi)\n    \n    # Perform the random walks for green and orange dots\n    for k in range(ndist):\n        options = []\n        # Check all possible moves for each dot\n        for loc, (col, direc) in mpr.items():\n            ii, jj = add(loc, direc)\n            # If the next position is valid and empty, add it to options\n            if (ii, jj) in fullinds and gi[ii][jj] == bgc:\n                options.append((loc, col, direc))\n        # If no moves are possible, end the loop\n        if len(options) == 0:\n            break\n        # Choose a random move from the available options\n        loc, col, direc = choice(options)\n        # Remove the old position from the mapper\n        del mpr[loc]\n        # Calculate the new position\n        newloc = add(loc, direc)\n        # Add the new position to the mapper\n        mpr[newloc] = (col, direc)\n        # Remove the dot from its old position\n        gi = fill(gi, bgc, {loc})\n        # Place the dot in its new position\n        gi = fill(gi, col, {newloc})\n    \n    # Return the input (final state after moves) and output (initial state)\n    return {'input': gi, 'output': go}\n"
  },
  "ae4f1146": {
    "original": "def generate_ae4f1146(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    dh = unifint(diff_lb, diff_ub, (2, h // 3))\n    dw = unifint(diff_lb, diff_ub, (2, w // 3))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * dh * dw)))\n    cards = interval(0, dh * dw, 1)\n    ccards = sorted(sample(cards, min(num, len(cards))))\n    sgs = []\n    c1 = canvas(fgc, (dh, dw))\n    inds = totuple(asindices(c1))\n    for card in ccards:\n        x = sample(inds, card)\n        x1 = fill(c1, 1, x)\n        sgs.append(asobject(x1))\n    go = paint(c1, sgs[-1])\n    gi = canvas(bgc, (h, w))\n    inds2 = asindices(canvas(bgc, (h - dh, w - dw)))\n    maxtr = 10\n    for sg in sgs[::-1]:\n        if len(inds2) == 0:\n            break\n        loc = choice(totuple(inds2))\n        plcd = shift(sg, loc)\n        tr = 0    \n        while (not toindices(plcd).issubset(inds2)) and tr < maxtr:\n            loc = choice(totuple(inds2))\n            plcd = shift(sg, loc)\n            tr += 1\n        if tr < maxtr:\n            inds2 = difference(inds2, toindices(plcd) | outbox(plcd))\n            gi = paint(gi, plcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ae4f1146(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors 0-9, excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the foreground\n    fgc = choice(remcols)\n    \n    # Generate a random height between 6 and 30, based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random width between 6 and 30, based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random height for the small grid, between 2 and 1/3 of the main grid height\n    dh = unifint(diff_lb, diff_ub, (2, h // 3))\n    \n    # Generate a random width for the small grid, between 2 and 1/3 of the main grid width\n    dw = unifint(diff_lb, diff_ub, (2, w // 3))\n    \n    # Calculate the number of small grids to generate, based on difficulty and main grid size\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * dh * dw)))\n    \n    # Create a list of all possible cell indices in the small grid\n    cards = interval(0, dh * dw, 1)\n    \n    # Randomly sample and sort a subset of these indices\n    ccards = sorted(sample(cards, min(num, len(cards))))\n    \n    # Initialize an empty list to store the generated small grids\n    sgs = []\n    \n    # Create a small grid filled with the foreground color\n    c1 = canvas(fgc, (dh, dw))\n    \n    # Get all indices of the small grid as a tuple\n    inds = totuple(asindices(c1))\n    \n    # Generate a series of small grids with increasing number of cells filled with color 1\n    for card in ccards:\n        # Randomly select 'card' number of cells\n        x = sample(inds, card)\n        # Fill these cells with color 1\n        x1 = fill(c1, 1, x)\n        # Add the resulting object to the list of small grids\n        sgs.append(asobject(x1))\n    \n    # Set the output grid as the last (most filled) small grid\n    go = paint(c1, sgs[-1])\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Calculate the valid placement area for small grids\n    inds2 = asindices(canvas(bgc, (h - dh, w - dw)))\n    \n    # Set maximum number of placement attempts\n    maxtr = 10\n    \n    # Place the small grids onto the input grid, starting from the most filled one\n    for sg in sgs[::-1]:\n        # If no valid placement area left, stop placing\n        if len(inds2) == 0:\n            break\n        \n        # Choose a random location for placement\n        loc = choice(totuple(inds2))\n        \n        # Shift the small grid to the chosen location\n        plcd = shift(sg, loc)\n        \n        # Initialize attempt counter\n        tr = 0    \n        \n        # Try to find a valid placement within maxtr attempts\n        while (not toindices(plcd).issubset(inds2)) and tr < maxtr:\n            loc = choice(totuple(inds2))\n            plcd = shift(sg, loc)\n            tr += 1\n        \n        # If a valid placement is found\n        if tr < maxtr:\n            # Remove the placement area and its surroundings from valid indices\n            inds2 = difference(inds2, toindices(plcd) | outbox(plcd))\n            # Paint the small grid onto the input grid\n            gi = paint(gi, plcd)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "aedd82e4": {
    "original": "def generate_aedd82e4(diff_lb: float, diff_ub: float) -> dict:\n    colopts = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = 0\n    remcols = remove(bgc, colopts)\n    c = canvas(bgc, (h, w))\n    card_bounds = (0, max(0, (h * w) // 2 - 1))\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    numcols = unifint(diff_lb, diff_ub, (0, min(8, num)))\n    inds = totuple(asindices(c))\n    chosinds = sample(inds, num)\n    choscols = sample(remcols, numcols)\n    locs = interval(0, len(chosinds), 1)\n    choslocs = sample(locs, numcols)\n    gi = canvas(bgc, (h, w))\n    for col, endidx in zip(choscols, sorted(choslocs)[::-1]):\n        gi = fill(gi, col, chosinds[:endidx])\n    objs = objects(gi, F, F, T)\n    res = merge(sizefilter(objs, 1))\n    go = fill(gi, 1, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_aedd82e4(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color options excluding 1\n    colopts = remove(1, interval(0, 10, 1))\n    \n    # Randomly generate height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly generate width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Set background color to 0 (black)\n    bgc = 0\n    \n    # Create a list of remaining colors excluding the background color\n    remcols = remove(bgc, colopts)\n    \n    # Create a canvas (grid) with background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Calculate upper bound for number of cells to color (up to half of total cells)\n    card_bounds = (0, max(0, (h * w) // 2 - 1))\n    \n    # Randomly choose number of cells to color based on difficulty\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    \n    # Randomly choose number of colors to use (up to 8 or num, whichever is smaller)\n    numcols = unifint(diff_lb, diff_ub, (0, min(8, num)))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly sample 'num' indices from all indices\n    chosinds = sample(inds, num)\n    \n    # Randomly sample 'numcols' colors from remaining colors\n    choscols = sample(remcols, numcols)\n    \n    # Create a list of indices for chosen locations\n    locs = interval(0, len(chosinds), 1)\n    \n    # Randomly sample 'numcols' locations\n    choslocs = sample(locs, numcols)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Fill the input grid with chosen colors at chosen locations\n    # This creates a pattern of colored cells on the black background\n    for col, endidx in zip(choscols, sorted(choslocs)[::-1]):\n        gi = fill(gi, col, chosinds[:endidx])\n    \n    # Identify objects in the input grid (connected components of same color)\n    objs = objects(gi, F, F, T)\n    \n    # Merge all single-cell objects into one set\n    res = merge(sizefilter(objs, 1))\n    \n    # Create output grid by filling all single-cell objects with color 1 (blue)\n    # This transforms all isolated colored cells to blue\n    go = fill(gi, 1, res)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "af902bf9": {
    "original": "def generate_af902bf9(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numcols)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    succ = 0\n    maxtr = 5 * numsq\n    tr = 0\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while tr < maxtr and succ < numsq:\n        tr += 1\n        oh = randint(3, 5)\n        ow = randint(3, 5)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        if sq.issubset(inds):\n            inds = inds - sq\n            succ += 1\n            col = choice(ccols)\n            crns = corners(sq)\n            gi = fill(gi, col, crns)\n            go = fill(go, col, crns)\n            ins = backdrop(inbox(crns))\n            go = fill(go, 2, ins)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_af902bf9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (10-30)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid (10-30)\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1-8)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Randomly determine the number of squares to create (1 to 5% of grid area)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    \n    # Initialize counters for successful square placements and attempts\n    succ = 0\n    maxtr = 5 * numsq\n    tr = 0\n    \n    # Create input and output grids with the background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Main loop for creating squares\n    while tr < maxtr and succ < numsq:\n        tr += 1\n        \n        # Randomly determine square height (3-5)\n        oh = randint(3, 5)\n        \n        # Randomly determine square width (3-5)\n        ow = randint(3, 5)\n        \n        # Find valid locations for placing the square\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip to next iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the square\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create the square as a set of indices\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # If the square fits in the available space\n        if sq.issubset(inds):\n            # Remove the square's indices from available indices\n            inds = inds - sq\n            succ += 1\n            \n            # Choose a random color for the square\n            col = choice(ccols)\n            \n            # Get the corners of the square\n            crns = corners(sq)\n            \n            # Fill the corners with the chosen color in both input and output\n            gi = fill(gi, col, crns)\n            go = fill(go, col, crns)\n            \n            # Get the inner box of the square\n            ins = backdrop(inbox(crns))\n            \n            # Fill the inner box with color 2 in the output grid\n            go = fill(go, 2, ins)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b0c4d837": {
    "original": "def generate_b0c4d837(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    oh = unifint(diff_lb, diff_ub, (3, h - 1))\n    ow = unifint(diff_lb, diff_ub, (3, w - 1))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    bgc, boxc, fillc = sample(cols, 3)\n    subg = canvas(boxc, (oh, ow))\n    subg2 = canvas(fillc, (oh-1, ow-2))\n    ntofill = unifint(diff_lb, diff_ub, (1, min(9, oh-2)))\n    for j in range(ntofill):\n        subg2 = fill(subg2, bgc, connect((j, 0), (j, ow-2)))\n    subg = paint(subg, shift(asobject(subg2), (0, 1)))\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, shift(asobject(subg), (loci, locj)))\n    go = repeat(fillc, ntofill) + repeat(bgc, 9 - ntofill)\n    go = (go[:3], go[3:6][::-1], go[6:])\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b0c4d837(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random object height between 3 and h-1 based on difficulty\n    oh = unifint(diff_lb, diff_ub, (3, h - 1))\n    \n    # Generate random object width between 3 and w-1 based on difficulty\n    ow = unifint(diff_lb, diff_ub, (3, w - 1))\n    \n    # Choose random vertical position for the object\n    loci = randint(0, h - oh)\n    \n    # Choose random horizontal position for the object\n    locj = randint(0, w - ow)\n    \n    # Randomly select 3 different colors for background, box, and fill\n    bgc, boxc, fillc = sample(cols, 3)\n    \n    # Create a canvas (grid) filled with the box color\n    subg = canvas(boxc, (oh, ow))\n    \n    # Create a smaller canvas filled with the fill color\n    subg2 = canvas(fillc, (oh-1, ow-2))\n    \n    # Determine number of rows to fill with background color (1 to 9, or up to oh-2)\n    ntofill = unifint(diff_lb, diff_ub, (1, min(9, oh-2)))\n    \n    # Fill 'ntofill' rows of subg2 with background color\n    for j in range(ntofill):\n        subg2 = fill(subg2, bgc, connect((j, 0), (j, ow-2)))\n    \n    # Paint subg2 onto subg, shifted right by 1\n    subg = paint(subg, shift(asobject(subg2), (0, 1)))\n    \n    # Create the main input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Paint the created object (subg) onto the main grid at the chosen location\n    gi = paint(gi, shift(asobject(subg), (loci, locj)))\n    \n    # Create the output grid: filled rows, then empty rows, total 9\n    go = repeat(fillc, ntofill) + repeat(bgc, 9 - ntofill)\n    \n    # Rearrange the output grid into a 3x3 format with middle row reversed\n    go = (go[:3], go[3:6][::-1], go[6:])\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b190f7f5": {
    "original": "def generate_b190f7f5(diff_lb: float, diff_ub: float) -> dict:\n    fullcols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    bgc = choice(fullcols)\n    cols = remove(bgc, fullcols)\n    c = canvas(bgc, (h, w))\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numc = choice((numcd, h * w - numcd))\n    numc = min(max(1, numc), h * w - 1)\n    numcd2 = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numc2 = choice((numcd2, h * w - numcd2))\n    numc2 = min(max(2, numc2), h * w - 1)\n    inds = totuple(asindices(c))\n    srclocs = sample(inds, numc)\n    srccol = choice(cols)\n    remcols = remove(srccol, cols)\n    numcols = unifint(diff_lb, diff_ub, (2, 8))\n    trglocs = sample(inds, numc2)\n    ccols = sample(remcols, numcols)\n    fixc1 = choice(ccols)\n    trgobj = [(fixc1, trglocs[0]), (choice(remove(fixc1, ccols)), trglocs[1])] + [(choice(ccols), ij) for ij in trglocs[2:]]\n    trgobj = frozenset(trgobj)\n    gisrc = fill(c, srccol, srclocs)\n    gitrg = paint(c, trgobj)\n    catf = choice((hconcat, vconcat))\n    ordd = choice(([gisrc, gitrg], [gitrg, gisrc]))\n    gi = catf(*ordd)\n    go = canvas(bgc, (h**2, w**2))\n    for loc in trglocs:\n        a, b = loc\n        go = fill(go, gitrg[a][b], shift(srclocs, multiply(loc, (h, w))))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b190f7f5(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 0 to 9 (all possible colors)\n    fullcols = interval(0, 10, 1)\n    \n    # Randomly choose the height of the grid between 2 and 5\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly choose the width of the grid between 2 and 5\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly select a background color from all possible colors\n    bgc = choice(fullcols)\n    \n    # Create a list of colors excluding the background color\n    cols = remove(bgc, fullcols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Randomly choose a number between 0 and half the grid size\n    numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly choose either numcd or its complement (grid size - numcd)\n    numc = choice((numcd, h * w - numcd))\n    \n    # Ensure numc is between 1 and one less than the grid size\n    numc = min(max(1, numc), h * w - 1)\n    \n    # Similar to numcd, but for a second set of locations\n    numcd2 = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Similar to numc, but for the second set of locations\n    numc2 = choice((numcd2, h * w - numcd2))\n    \n    # Ensure numc2 is between 2 and one less than the grid size\n    numc2 = min(max(2, numc2), h * w - 1)\n    \n    # Get all grid indices as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select numc locations from the grid\n    srclocs = sample(inds, numc)\n    \n    # Choose a color for the source locations\n    srccol = choice(cols)\n    \n    # Create a list of colors excluding the source color\n    remcols = remove(srccol, cols)\n    \n    # Choose a random number of colors between 2 and 8\n    numcols = unifint(diff_lb, diff_ub, (2, 8))\n    \n    # Randomly select numc2 locations from the grid\n    trglocs = sample(inds, numc2)\n    \n    # Randomly select numcols colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Choose a fixed color from the selected colors\n    fixc1 = choice(ccols)\n    \n    # Create the target object:\n    # First two cells have fixed colors, rest are random\n    trgobj = [(fixc1, trglocs[0]), (choice(remove(fixc1, ccols)), trglocs[1])] + [(choice(ccols), ij) for ij in trglocs[2:]]\n    \n    # Convert the target object to a frozenset\n    trgobj = frozenset(trgobj)\n    \n    # Fill the source locations with the source color\n    gisrc = fill(c, srccol, srclocs)\n    \n    # Paint the target object onto the canvas\n    gitrg = paint(c, trgobj)\n    \n    # Randomly choose between horizontal and vertical concatenation\n    catf = choice((hconcat, vconcat))\n    \n    # Randomly choose the order of concatenation\n    ordd = choice(([gisrc, gitrg], [gitrg, gisrc]))\n    \n    # Concatenate the source and target grids\n    gi = catf(*ordd)\n    \n    # Create a larger output canvas\n    go = canvas(bgc, (h**2, w**2))\n    \n    # For each target location:\n    for loc in trglocs:\n        a, b = loc\n        # Fill the corresponding area in the output grid\n        # with the color from the target grid,\n        # using the pattern from the source locations\n        go = fill(go, gitrg[a][b], shift(srclocs, multiply(loc, (h, w))))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b1948b0a": {
    "original": "def generate_b1948b0a(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(6, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    npd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    np = choice((npd, h * w - npd))\n    np = min(max(0, npd), h * w)\n    gi = canvas(6, (h, w))\n    inds = totuple(asindices(gi))\n    pp = sample(inds, np)\n    npp = difference(inds, pp)\n    for ij in npp:\n        gi = fill(gi, choice(cols), {ij})\n    go = fill(gi, 2, pp)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b1948b0a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of colors 0-5 and 7-9 (excluding 6)\n    cols = remove(6, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Calculate a random number of pixels to potentially change, up to half the grid size\n    npd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly choose between npd and (total pixels - npd)\n    # This determines whether we'll change a minority or majority of pixels\n    np = choice((npd, h * w - npd))\n    \n    # Ensure np is within valid range (0 to total number of pixels)\n    np = min(max(0, npd), h * w)\n    \n    # Create an initial grid filled with color 6 (light gray)\n    gi = canvas(6, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Randomly select 'np' number of pixels to change to color 2\n    pp = sample(inds, np)\n    \n    # Get the remaining pixels that won't be changed to color 2\n    npp = difference(inds, pp)\n    \n    # For each pixel not in pp, change its color to a random color from cols\n    for ij in npp:\n        gi = fill(gi, choice(cols), {ij})\n    \n    # Create the output grid by changing all pixels in pp to color 2 (red)\n    go = fill(gi, 2, pp)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b230c067": {
    "original": "def generate_b230c067(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    while True:\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        oh = unifint(diff_lb, diff_ub, (2, h // 3 - 1))\n        ow = unifint(diff_lb, diff_ub, (2, w // 3 - 1))\n        numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        numc = choice((numcd, oh * ow - numcd))\n        numca = min(max(2, numc), oh * ow - 2)\n        bounds = asindices(canvas(-1, (oh, ow)))\n        sp = choice(totuple(bounds))\n        shp = {sp}\n        for k in range(numca):\n            ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n            shp.add(ij)\n        shpa = normalize(shp)\n        shpb = set(normalize(shp))\n        mxnch = oh * ow - len(shpa)\n        nchinv = unifint(diff_lb, diff_ub, (1, mxnch))\n        nch = mxnch - nchinv\n        nch = min(max(1, nch), mxnch)\n        for k in range(nch):\n            ij = choice(totuple((bounds - shpb) & mapply(neighbors, shpb)))\n            shpb.add(ij)\n        if choice((True, False)):\n            shpa, shpb = shpb, shpa\n        bgc, fgc = sample(cols, 2)\n        c = canvas(bgc, (h, w))\n        inds = asindices(c)\n        acands = sfilter(inds, lambda ij: ij[0] <= h - height(shpa) and ij[1] <= w - width(shpa))\n        aloc = choice(totuple(acands))\n        aplcd = shift(shpa, aloc)\n        gi = fill(c, fgc, aplcd)\n        go = fill(c, 2, aplcd)\n        maxtrials = 10\n        tr = 0\n        succ = 0\n        inds = (inds - aplcd) - mapply(neighbors, aplcd)\n        inds = sfilter(inds, lambda ij: ij[0] <= h - height(shpb) and ij[1] <= w - width(shpb))\n        while succ < 2 and tr <= maxtrials:\n            if len(inds) == 0:\n                break\n            loc = choice(totuple(inds))\n            plcbd = shift(shpb, loc)\n            if plcbd.issubset(inds):\n                gi = fill(gi, fgc, plcbd)\n                go = fill(go, 1, plcbd)\n                succ += 1\n                inds = (inds - plcbd) - mapply(neighbors, plcbd)\n            tr += 1\n        if succ == 2:\n            break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b230c067(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    while True:\n        # Generate random height between 10 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        # Generate random width between 10 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        # Generate random object height between 2 and 1/3 of grid height\n        oh = unifint(diff_lb, diff_ub, (2, h // 3 - 1))\n        # Generate random object width between 2 and 1/3 of grid width\n        ow = unifint(diff_lb, diff_ub, (2, w // 3 - 1))\n        # Generate random number of cells for shape difference\n        numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        # Randomly choose between numcd and its complement for shape creation\n        numc = choice((numcd, oh * ow - numcd))\n        # Ensure at least 2 cells and at most all but 2 cells are used\n        numca = min(max(2, numc), oh * ow - 2)\n        # Create a set of all possible coordinates for the object\n        bounds = asindices(canvas(-1, (oh, ow)))\n        # Choose a random starting point for the shape\n        sp = choice(totuple(bounds))\n        # Initialize the shape with the starting point\n        shp = {sp}\n        # Grow the shape by adding adjacent cells\n        for k in range(numca):\n            # Choose a cell adjacent to the current shape but not in it\n            ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))\n            shp.add(ij)\n        # Normalize the shape (move it to the origin)\n        shpa = normalize(shp)\n        # Create a copy of the normalized shape for modification\n        shpb = set(normalize(shp))\n        # Calculate maximum number of cells that can be added/removed\n        mxnch = oh * ow - len(shpa)\n        # Generate random number of cells to change\n        nchinv = unifint(diff_lb, diff_ub, (1, mxnch))\n        nch = mxnch - nchinv\n        # Ensure at least 1 cell is changed\n        nch = min(max(1, nch), mxnch)\n        # Modify shpb by adding cells\n        for k in range(nch):\n            # Choose a cell adjacent to shpb but not in it\n            ij = choice(totuple((bounds - shpb) & mapply(neighbors, shpb)))\n            shpb.add(ij)\n        # Randomly swap shpa and shpb\n        if choice((True, False)):\n            shpa, shpb = shpb, shpa\n        # Choose background and foreground colors\n        bgc, fgc = sample(cols, 2)\n        # Create the canvas with background color\n        c = canvas(bgc, (h, w))\n        # Get all indices of the canvas\n        inds = asindices(c)\n        # Find valid locations for placing shpa\n        acands = sfilter(inds, lambda ij: ij[0] <= h - height(shpa) and ij[1] <= w - width(shpa))\n        # Choose a random location for shpa\n        aloc = choice(totuple(acands))\n        # Shift shpa to its chosen location\n        aplcd = shift(shpa, aloc)\n        # Create input grid by filling shpa with foreground color\n        gi = fill(c, fgc, aplcd)\n        # Create output grid by filling shpa with color 2\n        go = fill(c, 2, aplcd)\n        # Initialize variables for placing shpb\n        maxtrials = 10\n        tr = 0\n        succ = 0\n        # Remove placed shpa and its neighbors from available indices\n        inds = (inds - aplcd) - mapply(neighbors, aplcd)\n        # Filter valid locations for shpb\n        inds = sfilter(inds, lambda ij: ij[0] <= h - height(shpb) and ij[1] <= w - width(shpb))\n        # Try to place shpb twice\n        while succ < 2 and tr <= maxtrials:\n            if len(inds) == 0:\n                break\n            # Choose a random location for shpb\n            loc = choice(totuple(inds))\n            # Shift shpb to the chosen location\n            plcbd = shift(shpb, loc)\n            # If shpb fits in the available space\n            if plcbd.issubset(inds):\n                # Update input grid with shpb\n                gi = fill(gi, fgc, plcbd)\n                # Update output grid with shpb (color 1)\n                go = fill(go, 1, plcbd)\n                succ += 1\n                # Remove placed shpb and its neighbors from available indices\n                inds = (inds - plcbd) - mapply(neighbors, plcbd)\n            tr += 1\n        # If two instances of shpb were successfully placed, break the main loop\n        if succ == 2:\n            break\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b27ca6d3": {
    "original": "def generate_b27ca6d3(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, dotc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    ndots = unifint(diff_lb, diff_ub, (0, (h * w) // 5))\n    nbars = unifint(diff_lb, diff_ub, (0, (h * w) // 12))\n    dot = frozenset({(dotc, (1, 1))}) | recolor(bgc, dneighbors((1, 1)))\n    bar1 = fill(canvas(bgc, (4, 3)), dotc, {(1, 1), (2, 1)})\n    bar2 = dmirror(bar1)\n    bar1 = asobject(bar1)\n    bar2 = asobject(bar2)\n    opts = [dot] * ndots + [choice((bar1, bar2)) for k in range(nbars)]\n    shuffle(opts)\n    inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))\n    for elem in opts:\n        loc = (-1, -1)\n        tr = 0\n        while not toindices(shift(elem, loc)).issubset(inds) and tr < 5:\n            loc = choice(totuple(inds))\n            tr += 1\n        xx = shift(elem, loc)\n        if toindices(xx).issubset(inds):\n            gi = paint(gi, xx)\n            if len(elem) == 12:\n                go = paint(go, {cel if cel[0] != bgc else (3, cel[1]) for cel in xx})\n            else:\n                go = paint(go, xx)\n            inds = inds - toindices(xx)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b27ca6d3(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range 0-9, creating a list of available colors\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select two colors: one for background and one for dots\n    bgc, dotc = sample(cols, 2)\n    \n    # Create a canvas (input grid) with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Create an input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Generate a random number of dots (0 to 20% of grid area) based on difficulty\n    ndots = unifint(diff_lb, diff_ub, (0, (h * w) // 5))\n    \n    # Generate a random number of bars (0 to 8.33% of grid area) based on difficulty\n    nbars = unifint(diff_lb, diff_ub, (0, (h * w) // 12))\n    \n    # Create a dot shape: a colored center with background-colored neighbors\n    dot = frozenset({(dotc, (1, 1))}) | recolor(bgc, dneighbors((1, 1)))\n    \n    # Create a vertical bar shape\n    bar1 = fill(canvas(bgc, (4, 3)), dotc, {(1, 1), (2, 1)})\n    \n    # Create a horizontal bar shape by mirroring the vertical bar\n    bar2 = dmirror(bar1)\n    \n    # Convert bar1 to an object representation\n    bar1 = asobject(bar1)\n    \n    # Convert bar2 to an object representation\n    bar2 = asobject(bar2)\n    \n    # Create a list of shapes to be placed, with the specified number of dots and bars\n    opts = [dot] * ndots + [choice((bar1, bar2)) for k in range(nbars)]\n    \n    # Randomly shuffle the list of shapes\n    shuffle(opts)\n    \n    # Create a set of all possible placement locations, including a 1-cell border\n    inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))\n    \n    # Iterate through each shape to be placed\n    for elem in opts:\n        loc = (-1, -1)  # Initialize placement location\n        tr = 0  # Initialize try counter\n        \n        # Try to find a valid placement location up to 5 times\n        while not toindices(shift(elem, loc)).issubset(inds) and tr < 5:\n            loc = choice(totuple(inds))  # Choose a random location\n            tr += 1\n        \n        # Shift the shape to the chosen location\n        xx = shift(elem, loc)\n        \n        # If the shape fits within the grid\n        if toindices(xx).issubset(inds):\n            # Paint the shape onto the input grid\n            gi = paint(gi, xx)\n            \n            # If the shape is a bar (12 cells)\n            if len(elem) == 12:\n                # Paint the shape onto the output grid, changing background cells to color 3\n                go = paint(go, {cel if cel[0] != bgc else (3, cel[1]) for cel in xx})\n            else:\n                # Paint the shape (dot) onto the output grid without changes\n                go = paint(go, xx)\n            \n            # Remove the occupied cells from the available locations\n            inds = inds - toindices(xx)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b2862040": {
    "original": "def generate_b2862040(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (8,))\n    while True:\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n        succ = 0\n        tr = 0\n        maxtr = 10 * nobjs\n        bgc = choice(cols)\n        remcols = remove(bgc, cols)\n        gi = canvas(bgc, (h, w))\n        inds = asindices(gi)\n        while succ < nobjs and tr < maxtr:\n            tr += 1\n            oh = randint(3, 6)\n            ow = randint(3, 6)\n            obj = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n            if choice((True, False)):\n                nkeep = unifint(diff_lb, diff_ub, (2, len(obj) - 1))\n                nrem = len(obj) - nkeep\n                obj = remove(choice(totuple(obj - corners(obj))), obj)\n                for k in range(nrem - 1):\n                    xx = sfilter(obj, lambda ij: len(dneighbors(ij) & obj) == 1)\n                    if len(xx) == 0:\n                        break\n                    obj = remove(choice(totuple(xx)), obj)\n            npert = unifint(diff_lb, diff_ub, (0, oh + ow))\n            objcands = outbox(obj) | outbox(outbox(obj)) | outbox(outbox(outbox(obj)))\n            obj = set(obj)\n            for k in range(npert):\n                obj.add(choice(totuple((objcands - obj) & (mapply(dneighbors, obj) & objcands))))\n            obj = normalize(obj)\n            oh, ow = shape(obj)\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            plcd = shift(obj, loc)\n            if plcd.issubset(inds):\n                gi = fill(gi, choice(remcols), plcd)\n                succ += 1\n                inds = (inds - plcd) - mapply(neighbors, plcd)\n        objs = objects(gi, T, F, F)\n        bobjs = colorfilter(objs, bgc)\n        objsm = mfilter(bobjs, compose(flip, rbind(bordering, gi)))\n        if len(objsm) > 0:\n            res = mfilter(objs - bobjs, rbind(adjacent, objsm))\n            go = fill(gi, 8, res)\n            break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b2862040(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 8\n    cols = difference(interval(0, 10, 1), (8,))\n    \n    while True:\n        # Randomly determine grid height (10-30)\n        h = unifint(diff_lb, diff_ub, (10, 30))\n        # Randomly determine grid width (10-30)\n        w = unifint(diff_lb, diff_ub, (10, 30))\n        # Determine number of objects to place (1 to 1/16th of grid area)\n        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n        \n        succ = 0  # Counter for successfully placed objects\n        tr = 0  # Trial counter\n        maxtr = 10 * nobjs  # Maximum number of placement attempts\n        \n        bgc = choice(cols)  # Randomly select background color\n        remcols = remove(bgc, cols)  # Remove background color from available colors\n        \n        gi = canvas(bgc, (h, w))  # Create initial grid filled with background color\n        inds = asindices(gi)  # Get all grid indices\n        \n        while succ < nobjs and tr < maxtr:\n            tr += 1\n            oh = randint(3, 6)  # Random object height (3-6)\n            ow = randint(3, 6)  # Random object width (3-6)\n            \n            # Create a box-shaped object\n            obj = box(frozenset({(0, 0), (oh - 1, ow - 1)}))\n            \n            if choice((True, False)):  # 50% chance to modify the object\n                # Determine number of cells to keep\n                nkeep = unifint(diff_lb, diff_ub, (2, len(obj) - 1))\n                nrem = len(obj) - nkeep  # Number of cells to remove\n                \n                # Remove a random non-corner cell\n                obj = remove(choice(totuple(obj - corners(obj))), obj)\n                \n                # Remove additional cells, prioritizing those with only one neighbor\n                for k in range(nrem - 1):\n                    xx = sfilter(obj, lambda ij: len(dneighbors(ij) & obj) == 1)\n                    if len(xx) == 0:\n                        break\n                    obj = remove(choice(totuple(xx)), obj)\n            \n            # Randomly perturb the object by adding nearby cells\n            npert = unifint(diff_lb, diff_ub, (0, oh + ow))\n            objcands = outbox(obj) | outbox(outbox(obj)) | outbox(outbox(outbox(obj)))\n            obj = set(obj)\n            for k in range(npert):\n                obj.add(choice(totuple((objcands - obj) & (mapply(dneighbors, obj) & objcands))))\n            \n            obj = normalize(obj)  # Normalize object position\n            oh, ow = shape(obj)  # Get final object dimensions\n            \n            # Find valid placement locations\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) == 0:\n                continue  # Skip if no valid placement found\n            \n            loc = choice(totuple(cands))  # Choose random placement location\n            plcd = shift(obj, loc)  # Shift object to chosen location\n            \n            if plcd.issubset(inds):  # If object fits within grid\n                # Place object with random color\n                gi = fill(gi, choice(remcols), plcd)\n                succ += 1  # Increment successful placements\n                # Remove placed cells and their neighbors from available indices\n                inds = (inds - plcd) - mapply(neighbors, plcd)\n        \n        objs = objects(gi, T, F, F)  # Get all objects in the grid\n        bobjs = colorfilter(objs, bgc)  # Filter background-colored objects\n        # Find background objects not bordering the grid edge\n        objsm = mfilter(bobjs, compose(flip, rbind(bordering, gi)))\n        \n        if len(objsm) > 0:\n            # Find non-background objects adjacent to selected background objects\n            res = mfilter(objs - bobjs, rbind(adjacent, objsm))\n            go = fill(gi, 8, res)  # Fill these objects with color 8\n            break  # Exit loop if valid puzzle created\n    \n    return {'input': gi, 'output': go}  # Return input and output grids\n"
  },
  "b527c5c6": {
    "original": "def generate_b527c5c6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    noccs = unifint(diff_lb, diff_ub, (1, 10))\n    tr = 0\n    succ = 0\n    maxtr = 10 * noccs\n    while succ < noccs and tr < maxtr:\n        tr += 1\n        d1 = randint(3, randint(3, (min(h, w)) // 2 - 1))\n        d2 = randint(d1*2+1, randint(d1*2+1, min(h, w) - 1))\n        oh, ow = sample([d1, d2], 2)\n        cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - oh - 1 and 1 <= ij[1] <= w - ow - 1)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        bd = backdrop(bx)\n        if ow < oh:\n            lrflag = True\n            dcands1 = connect((loci+ow-1, locj), (loci+oh-1-ow+1, locj))\n            dcands2 = shift(dcands1, (0, ow-1))\n        else:\n            lrflag = False\n            dcands1 = connect((loci, locj+oh-1), (loci, locj+ow-1-oh+1))\n            dcands2 = shift(dcands1, (oh-1, 0))\n        dcands = dcands1 | dcands2\n        loc = choice(totuple(dcands))\n        sgnflag = -1 if loc in dcands1 else 1\n        direc = (sgnflag * (0 if lrflag else 1), sgnflag * (0 if not lrflag else 1))\n        ln = shoot(loc, direc)\n        shell = set()\n        for k in range(min(oh, ow)-1):\n            shell |= power(outbox, k+1)(ln)\n        sqc, dotc = sample(ccols, 2)\n        giobj = recolor(sqc, remove(loc, bd)) | {(dotc, loc)}\n        goobj = recolor(sqc, (bd | shell) - ln) | recolor(dotc, ln)\n        goobj = sfilter(goobj, lambda cij: cij[1] in fullinds)\n        goobji = toindices(goobj)\n        if goobji.issubset(inds):\n            succ += 1\n            inds = (inds - goobji) - mapply(dneighbors, bd)\n            gi = paint(gi, giobj)\n            go = paint(go, goobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b527c5c6(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate the height of the grid between 8 and 30\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly generate the width of the grid between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a new tuple of colors without the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (between 2 and 9)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Create a copy of all indices\n    fullinds = asindices(gi)\n    \n    # Randomly choose the number of occurrences (between 1 and 10)\n    noccs = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize success counter\n    succ = 0\n    \n    # Set maximum number of trials\n    maxtr = 10 * noccs\n    \n    # Loop to create objects on the grid\n    while succ < noccs and tr < maxtr:\n        # Increment trial counter\n        tr += 1\n        \n        # Randomly choose the first dimension of the object (between 3 and half of the smaller grid dimension)\n        d1 = randint(3, randint(3, (min(h, w)) // 2 - 1))\n        \n        # Randomly choose the second dimension of the object (larger than d1*2+1)\n        d2 = randint(d1*2+1, randint(d1*2+1, min(h, w) - 1))\n        \n        # Randomly assign d1 and d2 to object height and width\n        oh, ow = sample([d1, d2], 2)\n        \n        # Find valid positions for the object\n        cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - oh - 1 and 1 <= ij[1] <= w - ow - 1)\n        \n        # If no valid positions, continue to next iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random position for the object\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create a box around the object\n        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Create a backdrop for the box\n        bd = backdrop(bx)\n        \n        # Determine if the object is taller or wider\n        if ow < oh:\n            lrflag = True\n            # Create candidates for the diagonal line (vertical object)\n            dcands1 = connect((loci+ow-1, locj), (loci+oh-1-ow+1, locj))\n            dcands2 = shift(dcands1, (0, ow-1))\n        else:\n            lrflag = False\n            # Create candidates for the diagonal line (horizontal object)\n            dcands1 = connect((loci, locj+oh-1), (loci, locj+ow-1-oh+1))\n            dcands2 = shift(dcands1, (oh-1, 0))\n        \n        # Combine diagonal candidates\n        dcands = dcands1 | dcands2\n        \n        # Choose a random location for the diagonal line\n        loc = choice(totuple(dcands))\n        \n        # Determine the direction of the diagonal line\n        sgnflag = -1 if loc in dcands1 else 1\n        direc = (sgnflag * (0 if lrflag else 1), sgnflag * (0 if not lrflag else 1))\n        \n        # Create the diagonal line\n        ln = shoot(loc, direc)\n        \n        # Create a shell around the diagonal line\n        shell = set()\n        for k in range(min(oh, ow)-1):\n            shell |= power(outbox, k+1)(ln)\n        \n        # Choose colors for the square and dot\n        sqc, dotc = sample(ccols, 2)\n        \n        # Create the input object (square with dot)\n        giobj = recolor(sqc, remove(loc, bd)) | {(dotc, loc)}\n        \n        # Create the output object (expanded square with diagonal line)\n        goobj = recolor(sqc, (bd | shell) - ln) | recolor(dotc, ln)\n        \n        # Filter out any parts of the output object that are outside the grid\n        goobj = sfilter(goobj, lambda cij: cij[1] in fullinds)\n        \n        # Get the indices of the output object\n        goobji = toindices(goobj)\n        \n        # Check if the output object fits within the available space\n        if goobji.issubset(inds):\n            # Increment success counter\n            succ += 1\n            \n            # Update available indices\n            inds = (inds - goobji) - mapply(dneighbors, bd)\n            \n            # Paint the input and output grids\n            gi = paint(gi, giobj)\n            go = paint(go, goobj)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b548a754": {
    "original": "def generate_b548a754(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    hi = unifint(diff_lb, diff_ub, (4, h - 1))\n    wi = unifint(diff_lb, diff_ub, (3, w - 1))\n    loci = randint(0, h - hi)\n    locj = randint(0, w - wi)\n    bx = box(frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)}))\n    ins = backdrop(inbox(bx))\n    bgc, boxc, inc, dotc = sample(cols, 4)\n    c = canvas(bgc, (h, w))\n    go = fill(c, boxc, bx)\n    go = fill(go, inc, ins)\n    cutoff = randint(loci + 2, loci + hi - 2)\n    bx2 = box(frozenset({(loci, locj), (cutoff, locj + wi - 1)}))\n    ins2 = backdrop(inbox(bx2))\n    gi = fill(c, boxc, bx2)\n    gi = fill(gi, inc, ins2)\n    locc = choice(totuple(connect((loci+hi-1, locj), (loci+hi-1, locj+wi-1))))\n    gi = fill(gi, dotc, {locc})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b548a754(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the height of the inner box based on difficulty\n    hi = unifint(diff_lb, diff_ub, (4, h - 1))\n    \n    # Randomly determine the width of the inner box based on difficulty\n    wi = unifint(diff_lb, diff_ub, (3, w - 1))\n    \n    # Randomly choose the row index for the top-left corner of the box\n    loci = randint(0, h - hi)\n    \n    # Randomly choose the column index for the top-left corner of the box\n    locj = randint(0, w - wi)\n    \n    # Create the outline of the box\n    bx = box(frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)}))\n    \n    # Define the area inside the box\n    ins = backdrop(inbox(bx))\n    \n    # Randomly choose 4 distinct colors for background, box outline, inside box, and dot\n    bgc, boxc, inc, dotc = sample(cols, 4)\n    \n    # Create a canvas with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Draw the box outline on the canvas\n    go = fill(c, boxc, bx)\n    \n    # Fill the inside of the box with the chosen color\n    go = fill(go, inc, ins)\n    \n    # Randomly choose a cutoff point for the partial box in the input\n    cutoff = randint(loci + 2, loci + hi - 2)\n    \n    # Create the outline of the partial box for the input\n    bx2 = box(frozenset({(loci, locj), (cutoff, locj + wi - 1)}))\n    \n    # Define the area inside the partial box\n    ins2 = backdrop(inbox(bx2))\n    \n    # Draw the partial box outline on a new canvas for the input\n    gi = fill(c, boxc, bx2)\n    \n    # Fill the inside of the partial box with the chosen color\n    gi = fill(gi, inc, ins2)\n    \n    # Choose a random location on the bottom edge of the full box for the dot\n    locc = choice(totuple(connect((loci+hi-1, locj), (loci+hi-1, locj+wi-1))))\n    \n    # Place the dot on the input grid\n    gi = fill(gi, dotc, {locc})\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b60334d2": {
    "original": "def generate_b60334d2(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 9))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    bx = box(frozenset({(0, 0), (2, 2)}))\n    bd = backdrop(bx)\n    maxtrials = 4 * num\n    succ = 0\n    tr = 0\n    while succ < num and tr < maxtrials:\n        loc = choice(totuple(inds))\n        bxs = shift(bx, loc)\n        if bxs.issubset(set(inds)):\n            cen = center(bxs)\n            gi = fill(gi, fgc, {cen})\n            go = fill(go, fgc, ineighbors(cen))\n            go = fill(go, 1, dneighbors(cen))\n            inds = difference(inds, shift(bd, loc))\n            succ += 1\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b60334d2(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Generate a random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Calculate number of objects to place, between 1 and 1/9 of total grid area\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 9))\n    \n    # Randomly choose two distinct colors for background and foreground\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Define a 3x3 box shape\n    bx = box(frozenset({(0, 0), (2, 2)}))\n    \n    # Get all indices within and including the box\n    bd = backdrop(bx)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize counter for successful placements\n    succ = 0\n    \n    # Initialize counter for total trials\n    tr = 0\n    \n    # Loop until all objects are placed or max trials reached\n    while succ < num and tr < maxtrials:\n        # Randomly choose a location in the grid\n        loc = choice(totuple(inds))\n        \n        # Shift the box to the chosen location\n        bxs = shift(bx, loc)\n        \n        # Check if the shifted box fits within the grid\n        if bxs.issubset(set(inds)):\n            # Find the center of the shifted box\n            cen = center(bxs)\n            \n            # Place foreground color at the center in input grid\n            gi = fill(gi, fgc, {cen})\n            \n            # Fill diagonal neighbors with foreground color in output grid\n            go = fill(go, fgc, ineighbors(cen))\n            \n            # Fill direct neighbors with color 1 in output grid\n            go = fill(go, 1, dneighbors(cen))\n            \n            # Remove used indices from available positions\n            inds = difference(inds, shift(bd, loc))\n            \n            # Increment successful placements counter\n            succ += 1\n        \n        # Increment total trials counter\n        tr += 1\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b6afb2da": {
    "original": "def generate_b6afb2da(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 4))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            go = fill(go, 2, bd)\n            go = fill(go, 4, box(bd))\n            go = fill(go, 1, corners(bd))\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b6afb2da(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1, 2, and 4\n    cols = difference(interval(0, 10, 1), (1, 2, 4))    \n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    # Remove the chosen background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine number of objects to place (between 1 and 9) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize success counter\n\n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we run out of colors or available spaces\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        \n        # Generate random object height between 3 and 7\n        oh = randint(3, 7)\n        # Generate random object width between 3 and 7\n        ow = randint(3, 7)\n        \n        # Filter valid starting positions for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position for the object\n        loci, locj = choice(subs)\n        \n        # Create object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get all cells that the object would occupy\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # Check if the object fits within the available space\n        if bd.issubset(indss):\n            # Remove used color from available colors\n            remcols = remove(col, remcols)\n            \n            # Fill the object area with chosen color in input grid\n            gi = fill(gi, col, bd)\n            \n            # In output grid:\n            # Fill object area with color 2\n            go = fill(go, 2, bd)\n            # Draw object border with color 4\n            go = fill(go, 4, box(bd))\n            # Mark object corners with color 1\n            go = fill(go, 1, corners(bd))\n            \n            # Increment success counter\n            succ += 1\n            \n            # Remove used cells from available indices\n            indss = indss - bd\n        \n        # Increment trial counter\n        tr += 1\n\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b7249182": {
    "original": "def generate_b7249182(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    ih = unifint(diff_lb, diff_ub, (3, (h-1)//2))\n    bgc, ca, cb = sample(cols, 3)\n    subg = canvas(bgc, (ih, 5))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    subg = fill(subg, ca, connect((0, 2), (ih-2, 2)))\n    subg = fill(subg, ca, connect((ih-2, 0), (ih-2, 4)))\n    subg = fill(subg, ca, {(ih-1, 0)})\n    subga = fill(subg, ca, {(ih-1, 4)})\n    subgb = replace(subga, ca, cb)\n    subg = vconcat(subga, hmirror(subgb))\n    loci = randint(0, h-2*ih)\n    locj = randint(0, w-5)\n    obj = asobject(subg)\n    obj = shift(obj, (loci, locj))\n    gi = fill(gi, ca, {(loci, locj+2)})\n    gi = fill(gi, cb, {(loci+2*ih-1, locj+2)})\n    go = paint(go, obj)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b7249182(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate the height of the grid between 7 and 30\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly generate the width of the grid between 5 and 30\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly generate the height of the subgrid between 3 and half of the main grid's height\n    ih = unifint(diff_lb, diff_ub, (3, (h-1)//2))\n    \n    # Randomly select three distinct colors: background, color A, and color B\n    bgc, ca, cb = sample(cols, 3)\n    \n    # Create a subgrid filled with the background color, with height ih and width 5\n    subg = canvas(bgc, (ih, 5))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Draw a vertical line in the subgrid with color A\n    subg = fill(subg, ca, connect((0, 2), (ih-2, 2)))\n    \n    # Draw a horizontal line at the bottom of the subgrid with color A\n    subg = fill(subg, ca, connect((ih-2, 0), (ih-2, 4)))\n    \n    # Fill the bottom-left corner of the subgrid with color A\n    subg = fill(subg, ca, {(ih-1, 0)})\n    \n    # Fill the bottom-right corner of the subgrid with color A\n    subga = fill(subg, ca, {(ih-1, 4)})\n    \n    # Create a copy of the subgrid, replacing color A with color B\n    subgb = replace(subga, ca, cb)\n    \n    # Combine the original subgrid with its mirrored and color-swapped version\n    subg = vconcat(subga, hmirror(subgb))\n    \n    # Randomly choose a vertical position for the subgrid in the main grid\n    loci = randint(0, h-2*ih)\n    \n    # Randomly choose a horizontal position for the subgrid in the main grid\n    locj = randint(0, w-5)\n    \n    # Convert the subgrid to an object\n    obj = asobject(subg)\n    \n    # Move the subgrid object to its position in the main grid\n    obj = shift(obj, (loci, locj))\n    \n    # Place a marker of color A in the input grid\n    gi = fill(gi, ca, {(loci, locj+2)})\n    \n    # Place a marker of color B in the input grid\n    gi = fill(gi, cb, {(loci+2*ih-1, locj+2)})\n    \n    # Paint the subgrid object onto the output grid\n    go = paint(go, obj)\n    \n    # Randomly decide whether to diagonally mirror both input and output grids\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b775ac94": {
    "original": "def generate_b775ac94(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    gi = canvas(0, (1, 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        oh = randint(2, 5)\n        ow = randint(2, 5)\n        canv = canvas(bgc, (oh, ow))\n        c1, c2, c3, c4 = sample(remcols, 4)\n        obj = {(0, 0)}\n        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        ncells = min(max(1, ncells), oh * ow - 1)\n        bounds = asindices(canv)\n        for k in range(ncells):\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        gLR = fill(canv, c1, obj)\n        gLL = replace(vmirror(gLR), c1, c2)\n        gUR = replace(hmirror(gLR), c1, c3)\n        gUL = replace(vmirror(hmirror(gLR)), c1, c4)\n        gU = hconcat(gUL, gUR)\n        gL = hconcat(gLL, gLR)\n        g = vconcat(gU, gL)\n        g2 = canvas(bgc, (oh * 2, ow * 2))\n        g2 = fill(g2, c1, shift(obj, (oh, ow)))\n        nkeepcols = unifint(diff_lb, diff_ub, (1, 3))\n        keepcols = sample((c2, c3, c4), nkeepcols)\n        for cc in (c2, c3, c4):\n            if cc not in keepcols:\n                g = replace(g, cc, bgc)\n            else:\n                ofsi = -1 if cc in (c3, c4) else 0\n                ofsj = -1 if cc in (c2, c4) else 0\n                g2 = fill(g2, cc, {(oh + ofsi, ow + ofsj)})\n        rotf = choice((identity, rot90, rot180, rot270))\n        g = rotf(g)\n        g2 = rotf(g2)\n        obji = asobject(g2)\n        objo = asobject(g)\n        objo = sfilter(objo, lambda cij: cij[0] != bgc)\n        obji = sfilter(obji, lambda cij: cij[0] != bgc)\n        tonorm = invert(ulcorner(objo))\n        obji = shift(obji, tonorm)\n        objo = shift(objo, tonorm)\n        oh, ow = shape(objo)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcdi = shift(obji, loc)\n        plcdo = shift(objo, loc)\n        plcdoi = toindices(plcdo)\n        if plcdoi.issubset(inds):\n            succ += 1\n            inds = (inds - plcdoi) - mapply(neighbors, plcdoi)\n            gi = paint(gi, plcdi)\n            go = paint(go, plcdo)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b775ac94(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Choose a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Create a 1x1 canvas with color 0 (temporary initialization)\n    gi = canvas(0, (1, 1))\n    # Choose a random background color\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Choose a random number of objects to place on the grid based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    # Initialize counter for successfully placed objects\n    succ = 0\n    # Initialize counter for placement attempts\n    tr = 0\n    # Set maximum number of placement attempts\n    maxtr = 5 * nobjs\n    # Create input grid with chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    # Create output grid with chosen background color and dimensions\n    go = canvas(bgc, (h, w))\n    # Get all indices of the grid\n    inds = asindices(gi)\n\n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        # Increment attempt counter\n        tr += 1\n        # Choose random height for the object (2 to 5)\n        oh = randint(2, 5)\n        # Choose random width for the object (2 to 5)\n        ow = randint(2, 5)\n        # Create a canvas for the object with background color\n        canv = canvas(bgc, (oh, ow))\n        # Choose 4 random colors for the object\n        c1, c2, c3, c4 = sample(remcols, 4)\n        # Initialize object with one cell\n        obj = {(0, 0)}\n        # Choose random number of cells to add or remove from the object\n        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        # Decide whether to add or remove cells\n        ncells = choice((ncellsd, oh * ow - ncellsd))\n        # Ensure at least one cell and not all cells are colored\n        ncells = min(max(1, ncells), oh * ow - 1)\n        # Get all indices of the object canvas\n        bounds = asindices(canv)\n        # Add cells to the object\n        for k in range(ncells):\n            # Add a random neighboring cell to the object\n            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))\n        \n        # Create lower right quadrant of the object\n        gLR = fill(canv, c1, obj)\n        # Create lower left quadrant by mirroring and changing color\n        gLL = replace(vmirror(gLR), c1, c2)\n        # Create upper right quadrant by mirroring and changing color\n        gUR = replace(hmirror(gLR), c1, c3)\n        # Create upper left quadrant by mirroring and changing color\n        gUL = replace(vmirror(hmirror(gLR)), c1, c4)\n        # Combine upper quadrants\n        gU = hconcat(gUL, gUR)\n        # Combine lower quadrants\n        gL = hconcat(gLL, gLR)\n        # Combine all quadrants to form the complete object\n        g = vconcat(gU, gL)\n        \n        # Create a canvas for the input object\n        g2 = canvas(bgc, (oh * 2, ow * 2))\n        # Fill the lower right quadrant of the input object\n        g2 = fill(g2, c1, shift(obj, (oh, ow)))\n        # Choose random number of colors to keep (1 to 3)\n        nkeepcols = unifint(diff_lb, diff_ub, (1, 3))\n        # Choose which colors to keep\n        keepcols = sample((c2, c3, c4), nkeepcols)\n        \n        # Process each color in the object\n        for cc in (c2, c3, c4):\n            if cc not in keepcols:\n                # Replace non-kept colors with background color in output\n                g = replace(g, cc, bgc)\n            else:\n                # Determine offset for kept colors in input\n                ofsi = -1 if cc in (c3, c4) else 0\n                ofsj = -1 if cc in (c2, c4) else 0\n                # Add a single cell of the kept color to the input\n                g2 = fill(g2, cc, {(oh + ofsi, ow + ofsj)})\n        \n        # Choose a random rotation function\n        rotf = choice((identity, rot90, rot180, rot270))\n        # Apply rotation to output object\n        g = rotf(g)\n        # Apply same rotation to input object\n        g2 = rotf(g2)\n        \n        # Convert input object to set of colored cells\n        obji = asobject(g2)\n        # Convert output object to set of colored cells\n        objo = asobject(g)\n        # Remove background color cells from output object\n        objo = sfilter(objo, lambda cij: cij[0] != bgc)\n        # Remove background color cells from input object\n        obji = sfilter(obji, lambda cij: cij[0] != bgc)\n        # Calculate shift to normalize object position\n        tonorm = invert(ulcorner(objo))\n        # Normalize input object position\n        obji = shift(obji, tonorm)\n        # Normalize output object position\n        objo = shift(objo, tonorm)\n        \n        # Get dimensions of normalized output object\n        oh, ow = shape(objo)\n        # Find valid placement positions on the grid\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        # If no valid positions, skip this object\n        if len(cands) == 0:\n            continue\n        # Choose a random valid position\n        loc = choice(totuple(cands))\n        # Shift input object to chosen position\n        plcdi = shift(obji, loc)\n        # Shift output object to chosen position\n        plcdo = shift(objo, loc)\n        # Get indices of placed output object\n        plcdoi = toindices(plcdo)\n        \n        # Check if placed object fits within the grid\n        if plcdoi.issubset(inds):\n            # Increment success counter\n            succ += 1\n            # Remove placed object and its neighbors from available positions\n            inds = (inds - plcdoi) - mapply(neighbors, plcdoi)\n            # Paint input object on input grid\n            gi = paint(gi, plcdi)\n            # Paint output object on output grid\n            go = paint(go, plcdo)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b782dc8a": {
    "original": "def generate_b782dc8a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    wall_pairs = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    dlt = [('W', (-1, 0)), ('E', (1, 0)), ('S', (0, 1)), ('N', (0, -1))]\n    walls = {'N': True, 'S': True, 'E': True, 'W': True}\n    fullsucc = False\n    while True:\n        h = unifint(diff_lb, diff_ub, (3, 15))\n        w = unifint(diff_lb, diff_ub, (3, 15))\n        maze = [[{'x': x, 'y': y, 'walls': {**walls}} for y in range(h)] for x in range(w)]\n        kk = h * w\n        stck = []\n        cc = maze[0][0]\n        nv = 1\n        while nv < kk:\n            nbhs = []\n            for direc, (dx, dy) in dlt:\n                x2, y2 = cc['x'] + dx, cc['y'] + dy\n                if 0 <= x2 < w and 0 <= y2 < h:\n                    neighbour = maze[x2][y2]\n                    if all(neighbour['walls'].values()):\n                        nbhs.append((direc, neighbour))\n            if not nbhs:\n                cc = stck.pop()\n                continue\n            direc, next_cell = choice(nbhs)\n            cc['walls'][direc] = False\n            next_cell['walls'][wall_pairs[direc]] = False\n            stck.append(cc)\n            cc = next_cell\n            nv += 1\n        pathcol, wallcol, dotcol, ncol = sample(cols, 4)\n        grid = [[pathcol for x in range(w * 2)]]\n        for y in range(h):\n            row = [pathcol]\n            for x in range(w):\n                row.append(wallcol)\n                row.append(pathcol if maze[x][y]['walls']['E'] else wallcol)\n            grid.append(row)\n            row = [pathcol]\n            for x in range(w):\n                row.append(pathcol if maze[x][y]['walls']['S'] else wallcol)\n                row.append(pathcol)\n            grid.append(row)\n        gi = tuple(tuple(r[1:-1]) for r in grid[1:-1])\n        objs = objects(gi, T, F, F)\n        objs = colorfilter(objs, pathcol)\n        objs = sfilter(objs, lambda obj: size(obj) > 4)\n        if len(objs) == 0:\n            continue\n        objs = order(objs, size)\n        nobjs = len(objs)\n        idx = unifint(diff_lb, diff_ub, (0, nobjs - 1))\n        obj = toindices(objs[idx])\n        cell = choice(totuple(obj))\n        gi = fill(gi, dotcol, {cell})\n        nbhs = dneighbors(cell) & ofcolor(gi, pathcol)\n        gi = fill(gi, ncol, nbhs)\n        obj1 = sfilter(obj, lambda ij: even(manhattan({ij}, {cell})))\n        obj2 = obj - obj1\n        go = fill(gi, dotcol, obj1)\n        go = fill(go, ncol, obj2)\n        break\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b782dc8a(diff_lb: float, diff_ub: float) -> dict:\n    # Define possible colors for the maze\n    cols = interval(0, 10, 1)\n    # Define pairs of opposite walls\n    wall_pairs = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    # Define direction vectors for neighboring cells\n    dlt = [('W', (-1, 0)), ('E', (1, 0)), ('S', (0, 1)), ('N', (0, -1))]\n    # Initialize all walls as present\n    walls = {'N': True, 'S': True, 'E': True, 'W': True}\n    # Flag to indicate successful maze generation\n    fullsucc = False\n    # Loop until a valid maze is generated\n    while True:\n        # Generate random height between 3 and 15 based on difficulty\n        h = unifint(diff_lb, diff_ub, (3, 15))\n        # Generate random width between 3 and 15 based on difficulty\n        w = unifint(diff_lb, diff_ub, (3, 15))\n        # Initialize the maze grid with all walls present\n        maze = [[{'x': x, 'y': y, 'walls': {**walls}} for y in range(h)] for x in range(w)]\n        # Calculate total number of cells in the maze\n        kk = h * w\n        # Initialize stack for depth-first search\n        stck = []\n        # Start from the top-left cell\n        cc = maze[0][0]\n        # Number of visited cells\n        nv = 1\n        # Generate maze using depth-first search\n        while nv < kk:\n            # List to store unvisited neighbors\n            nbhs = []\n            # Check all four directions\n            for direc, (dx, dy) in dlt:\n                x2, y2 = cc['x'] + dx, cc['y'] + dy\n                # If neighbor is within maze bounds\n                if 0 <= x2 < w and 0 <= y2 < h:\n                    neighbour = maze[x2][y2]\n                    # If neighbor has all walls intact (unvisited)\n                    if all(neighbour['walls'].values()):\n                        nbhs.append((direc, neighbour))\n            # If no unvisited neighbors, backtrack\n            if not nbhs:\n                cc = stck.pop()\n                continue\n            # Choose a random unvisited neighbor\n            direc, next_cell = choice(nbhs)\n            # Remove wall between current cell and chosen neighbor\n            cc['walls'][direc] = False\n            next_cell['walls'][wall_pairs[direc]] = False\n            # Push current cell to stack and move to next cell\n            stck.append(cc)\n            cc = next_cell\n            nv += 1\n        # Randomly select colors for path, wall, dot, and number\n        pathcol, wallcol, dotcol, ncol = sample(cols, 4)\n        # Initialize the visual grid with path color\n        grid = [[pathcol for x in range(w * 2)]]\n        # Convert maze structure to visual grid\n        for y in range(h):\n            # Create horizontal walls\n            row = [pathcol]\n            for x in range(w):\n                row.append(wallcol)\n                row.append(pathcol if maze[x][y]['walls']['E'] else wallcol)\n            grid.append(row)\n            # Create vertical walls\n            row = [pathcol]\n            for x in range(w):\n                row.append(pathcol if maze[x][y]['walls']['S'] else wallcol)\n                row.append(pathcol)\n            grid.append(row)\n        # Remove border cells from the grid\n        gi = tuple(tuple(r[1:-1]) for r in grid[1:-1])\n        # Identify all objects in the grid\n        objs = objects(gi, T, F, F)\n        # Filter objects to keep only path-colored ones\n        objs = colorfilter(objs, pathcol)\n        # Keep only objects larger than 4 cells\n        objs = sfilter(objs, lambda obj: size(obj) > 4)\n        # If no valid objects, restart maze generation\n        if len(objs) == 0:\n            continue\n        # Sort objects by size\n        objs = order(objs, size)\n        # Count number of objects\n        nobjs = len(objs)\n        # Randomly select an object based on difficulty\n        idx = unifint(diff_lb, diff_ub, (0, nobjs - 1))\n        # Get the indices of the selected object\n        obj = toindices(objs[idx])\n        # Choose a random cell from the object\n        cell = choice(totuple(obj))\n        # Place a dot on the chosen cell\n        gi = fill(gi, dotcol, {cell})\n        # Find path-colored neighbors of the dot\n        nbhs = dneighbors(cell) & ofcolor(gi, pathcol)\n        # Color the neighbors with the number color\n        gi = fill(gi, ncol, nbhs)\n        # Divide the object into two sets based on Manhattan distance from the dot\n        obj1 = sfilter(obj, lambda ij: even(manhattan({ij}, {cell})))\n        obj2 = obj - obj1\n        # Create the output grid by filling obj1 with dots and obj2 with numbers\n        go = fill(gi, dotcol, obj1)\n        go = fill(go, ncol, obj2)\n        # Exit the loop as a valid maze has been generated\n        break\n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b8825c91": {
    "original": "def generate_b8825c91(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    gi = paint(gi, tr)\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    go = tuple(e for e in gi)\n    for alph in (2, 1):\n        locidev = unifint(diff_lb, diff_ub, (1, alph*h))\n        locjdev = unifint(diff_lb, diff_ub, (1, w))\n        loci = alph*h - locidev\n        locj = w - locjdev\n        loci2 = unifint(diff_lb, diff_ub, (loci, alph*h - 1))\n        locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n        bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n        gi = fill(gi, 4, bd)\n        gi, go = rot180(gi), rot180(go)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b8825c91(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Randomly determine the height (and width) of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h  # Set width equal to height (square grid)\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (excluding background)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors to use\n    remcols = sample(remcols, numcols)\n    \n    # Create an initial canvas filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of cells to color\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Get all indices of the canvas\n    bx = asindices(canv)\n    \n    # Create the first colored cell with a random color and position\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Color additional cells, ensuring they're adjacent to existing colored cells\n    for kk in range(nc - 1):\n        # Get all neighbors of existing colored cells\n        dns = mapply(neighbors, toindices(obj))\n        \n        # Choose a random uncolored cell that's adjacent to a colored cell\n        ch = choice(totuple(bx & dns))\n        \n        # Add the new colored cell to the object\n        obj.add((choice(remcols), ch))\n        \n        # Remove the newly colored cell from available positions\n        bx = bx - {ch}\n    \n    # Paint the colored cells onto the canvas\n    gi = paint(canv, obj)\n    \n    # Mirror the grid diagonally and keep only the upper triangle\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    \n    # Paint the upper triangle onto the grid\n    gi = paint(gi, tr)\n    \n    # Mirror the grid horizontally and vertically to create a symmetric pattern\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    \n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    \n    # Add rectangles filled with color 4 to two opposite corners\n    for alph in (2, 1):\n        # Determine the size and position of the rectangle\n        locidev = unifint(diff_lb, diff_ub, (1, alph*h))\n        locjdev = unifint(diff_lb, diff_ub, (1, w))\n        loci = alph*h - locidev\n        locj = w - locjdev\n        loci2 = unifint(diff_lb, diff_ub, (loci, alph*h - 1))\n        locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n        \n        # Create the rectangle\n        bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n        \n        # Fill the rectangle with color 4\n        gi = fill(gi, 4, bd)\n        \n        # Rotate both input and output grids 180 degrees\n        gi, go = rot180(gi), rot180(go)\n    \n    # Define a list of possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Randomly choose to apply 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the chosen transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b8cdaf2b": {
    "original": "def generate_b8cdaf2b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc, linc, dotc = sample(cols, 3)\n    lin = connect((0, 0), (0, w - 1))\n    winv = unifint(diff_lb, diff_ub, (2, w - 1))\n    w2 = w - winv\n    w2 = min(max(w2, 1), w - 2)\n    locj = randint(1, w - w2 - 1)\n    bar2 = connect((0, locj), (0, locj + w2 - 1))\n    c = canvas(bgc, (h, w))\n    gi = fill(c, linc, lin)\n    gi = fill(gi, dotc, bar2)\n    gi = fill(gi, linc, shift(bar2, (1, 0)))\n    go = fill(gi, dotc, shoot((2, locj - 1), (1, -1)))\n    go = fill(go, dotc, shoot((2, locj + w2), (1, 1)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b8cdaf2b(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select 3 distinct colors for background, line, and dot\n    bgc, linc, dotc = sample(cols, 3)\n    \n    # Create a horizontal line at the top of the grid\n    lin = connect((0, 0), (0, w - 1))\n    \n    # Randomly determine the width of the inverted part\n    winv = unifint(diff_lb, diff_ub, (2, w - 1))\n    \n    # Calculate the width of the second bar\n    w2 = w - winv\n    # Ensure w2 is between 1 and w-2\n    w2 = min(max(w2, 1), w - 2)\n    \n    # Randomly determine the starting position of the second bar\n    locj = randint(1, w - w2 - 1)\n    \n    # Create the second bar\n    bar2 = connect((0, locj), (0, locj + w2 - 1))\n    \n    # Create the initial grid with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Add the top horizontal line to the grid\n    gi = fill(c, linc, lin)\n    \n    # Add the second bar (dots) to the grid\n    gi = fill(gi, dotc, bar2)\n    \n    # Add a line below the second bar\n    gi = fill(gi, linc, shift(bar2, (1, 0)))\n    \n    # Create the output grid by adding diagonal lines of dots\n    go = fill(gi, dotc, shoot((2, locj - 1), (1, -1)))\n    go = fill(go, dotc, shoot((2, locj + w2), (1, 1)))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "b91ae062": {
    "original": "def generate_b91ae062(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    numc = unifint(diff_lb, diff_ub, (3, min(h * w, min(10, 30 // max(h, w)))))\n    ccols = sample(cols, numc)\n    c = canvas(-1, (h, w))\n    inds = totuple(asindices(c))\n    fixinds = sample(inds, numc)\n    obj = {(cc, ij) for cc, ij in zip(ccols, fixinds)}\n    for ij in difference(inds, fixinds):\n        obj.add((choice(ccols), ij))\n    gi = paint(c, obj)\n    go = upscale(gi, numc - 1)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b91ae062(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Determine the number of colors to use, constrained by grid size and max allowed\n    numc = unifint(diff_lb, diff_ub, (3, min(h * w, min(10, 30 // max(h, w)))))\n    \n    # Randomly select 'numc' colors from the color range\n    ccols = sample(cols, numc)\n    \n    # Create an empty canvas of size h x w filled with -1\n    c = canvas(-1, (h, w))\n    \n    # Get all possible indices in the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select 'numc' fixed positions in the grid\n    fixinds = sample(inds, numc)\n    \n    # Create an object by pairing each selected color with a fixed position\n    obj = {(cc, ij) for cc, ij in zip(ccols, fixinds)}\n    \n    # For all other positions in the grid:\n    for ij in difference(inds, fixinds):\n        # Add a randomly chosen color from ccols to the object at this position\n        obj.add((choice(ccols), ij))\n    \n    # Paint the canvas with the created object, forming the input grid\n    gi = paint(c, obj)\n    \n    # Upscale the input grid by a factor of (numc - 1) to create the output grid\n    go = upscale(gi, numc - 1)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b94a9452": {
    "original": "def generate_b94a9452(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, outer, inner = sample(cols, 3)\n    c = canvas(bgc, (h, w))\n    oh = unifint(diff_lb, diff_ub, (3, h - 1))\n    ow = unifint(diff_lb, diff_ub, (3, w - 1))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    oh2d = unifint(diff_lb, diff_ub, (0, oh // 2))\n    ow2d = unifint(diff_lb, diff_ub, (0, ow // 2))\n    oh2 = choice((oh2d, oh - oh2d))\n    oh2 = min(max(1, oh2), oh - 2)\n    ow2 = choice((ow2d, ow - ow2d))\n    ow2 = min(max(1, ow2), ow - 2)\n    loci2 = randint(loci+1, loci+oh-oh2-1)\n    locj2 = randint(locj+1, locj+ow-ow2-1)\n    obj1 = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    obj2 = backdrop(frozenset({(loci2, locj2), (loci2 + oh2 - 1, locj2 + ow2 - 1)}))\n    gi = fill(c, outer, obj1)\n    gi = fill(gi, inner, obj2)\n    go = compress(gi)\n    go = switch(go, outer, inner)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b94a9452(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select three unique colors for background, outer rectangle, and inner rectangle\n    bgc, outer, inner = sample(cols, 3)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Randomly determine the height of the outer rectangle\n    oh = unifint(diff_lb, diff_ub, (3, h - 1))\n    \n    # Randomly determine the width of the outer rectangle\n    ow = unifint(diff_lb, diff_ub, (3, w - 1))\n    \n    # Randomly select the row index for the top-left corner of the outer rectangle\n    loci = randint(0, h - oh)\n    \n    # Randomly select the column index for the top-left corner of the outer rectangle\n    locj = randint(0, w - ow)\n    \n    # Randomly determine a value for potential inner rectangle height\n    oh2d = unifint(diff_lb, diff_ub, (0, oh // 2))\n    \n    # Randomly determine a value for potential inner rectangle width\n    ow2d = unifint(diff_lb, diff_ub, (0, ow // 2))\n    \n    # Randomly choose between oh2d and (oh - oh2d) for inner rectangle height\n    oh2 = choice((oh2d, oh - oh2d))\n    \n    # Ensure inner rectangle height is within valid range\n    oh2 = min(max(1, oh2), oh - 2)\n    \n    # Randomly choose between ow2d and (ow - ow2d) for inner rectangle width\n    ow2 = choice((ow2d, ow - ow2d))\n    \n    # Ensure inner rectangle width is within valid range\n    ow2 = min(max(1, ow2), ow - 2)\n    \n    # Randomly select the row index for the top-left corner of the inner rectangle\n    loci2 = randint(loci+1, loci+oh-oh2-1)\n    \n    # Randomly select the column index for the top-left corner of the inner rectangle\n    locj2 = randint(locj+1, locj+ow-ow2-1)\n    \n    # Create a set of indices for the outer rectangle\n    obj1 = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Create a set of indices for the inner rectangle\n    obj2 = backdrop(frozenset({(loci2, locj2), (loci2 + oh2 - 1, locj2 + ow2 - 1)}))\n    \n    # Fill the outer rectangle with its color on the canvas\n    gi = fill(c, outer, obj1)\n    \n    # Fill the inner rectangle with its color on the canvas\n    gi = fill(gi, inner, obj2)\n    \n    # Remove any single-color rows or columns from the grid\n    go = compress(gi)\n    \n    # Swap the colors of the outer and inner rectangles\n    go = switch(go, outer, inner)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "b9b7f026": {
    "original": "def generate_b9b7f026(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 9))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    succ = 0\n    tr = 0\n    outcol = None\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            succ += 1\n            indss = indss - bd\n            if outcol is None:\n                outcol = col\n                cands = totuple(backdrop(inbox(bd)))\n                bd2 = backdrop(\n                    frozenset(sample(cands, 2)) if len(cands) > 2 else frozenset(cands)\n                )\n                gi = fill(gi, bgc, bd2)\n        tr += 1\n    go = canvas(outcol, (1, 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_b9b7f026(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random height between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random width between 10 and 30 based on difficulty\n    bgc = choice(cols)  # Randomly select a background color from the available colors\n    remcols = remove(bgc, cols)  # Remove the background color from the available colors\n    gi = canvas(bgc, (h, w))  # Create an initial grid filled with the background color\n    num = unifint(diff_lb, diff_ub, (1, 9))  # Determine the number of objects to place, between 1 and 9\n    indss = asindices(gi)  # Get all possible indices in the grid\n    maxtrials = 4 * num  # Set maximum number of attempts to place objects\n    succ = 0  # Counter for successfully placed objects\n    tr = 0  # Counter for placement attempts\n    outcol = None  # Variable to store the color of the last successfully placed object\n    while succ < num and tr <= maxtrials:  # Loop until all objects are placed or max trials reached\n        if len(remcols) == 0 or len(indss) == 0:  # Check if we've run out of colors or available positions\n            break  # Exit the loop if no more colors or positions are available\n        oh = randint(3, 7)  # Generate a random height for the object between 3 and 7\n        ow = randint(3, 7)  # Generate a random width for the object between 3 and 7\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))  # Find valid positions for the object\n        if len(subs) == 0:  # If no valid positions are found\n            tr += 1  # Increment the trial counter\n            continue  # Skip to the next iteration\n        loci, locj = choice(subs)  # Randomly choose a position for the object\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})  # Create the object as a frozenset of its corners\n        bd = backdrop(obj)  # Get the indices of all cells within the object's bounding box\n        col = choice(remcols)  # Randomly choose a color for the object\n        if bd.issubset(indss):  # If the object fits within the available space\n            remcols = remove(col, remcols)  # Remove the chosen color from available colors\n            gi = fill(gi, col, bd)  # Fill the object area with the chosen color\n            succ += 1  # Increment the success counter\n            indss = indss - bd  # Remove the object's area from available positions\n            if outcol is None:  # If this is the first successfully placed object\n                outcol = col  # Set the output color to this object's color\n                cands = totuple(backdrop(inbox(bd)))  # Get candidate positions for the inner box\n                bd2 = backdrop(\n                    frozenset(sample(cands, 2)) if len(cands) > 2 else frozenset(cands)\n                )  # Choose 2 random positions (or all if less than 2) for the inner box\n                gi = fill(gi, bgc, bd2)  # Fill the inner box with the background color\n        tr += 1  # Increment the trial counter\n    go = canvas(outcol, (1, 1))  # Create a 1x1 grid with the output color\n    return {'input': gi, 'output': go}  # Return the input grid and output grid as a dictionary\n"
  },
  "ba26e723": {
    "original": "def generate_ba26e723(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (0, 6))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    gi = canvas(0, (h, w))\n    go = canvas(0, (h, w))\n    opts = interval(0, h, 1)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(cols, ncols)\n    for j in range(w):\n        nc = unifint(diff_lb, diff_ub, (1, h - 1))\n        locs = sample(opts, nc)\n        obj = frozenset({(choice(ccols), (ii, j)) for ii in locs})\n        gi = paint(gi, obj)\n        if j % 3 == 0:\n            obj = recolor(6, obj)\n        go = paint(go, obj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ba26e723(diff_lb: float, diff_ub: float) -> dict:\n    # Define available colors, excluding 0 and 6\n    cols = difference(interval(0, 10, 1), (0, 6))\n    \n    # Randomly determine the height of the grid (between 2 and 30)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid (between 2 and 30)\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Create an empty input grid filled with zeros\n    gi = canvas(0, (h, w))\n    \n    # Create an empty output grid filled with zeros\n    go = canvas(0, (h, w))\n    \n    # Create a range of possible row indices\n    opts = interval(0, h, 1)\n    \n    # Randomly determine the number of colors to use (between 1 and 8)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors from the available colors\n    ccols = sample(cols, ncols)\n    \n    # Iterate through each column of the grid\n    for j in range(w):\n        # Randomly determine the number of cells to color in this column (between 1 and h-1)\n        nc = unifint(diff_lb, diff_ub, (1, h - 1))\n        \n        # Randomly select row indices for the cells to be colored\n        locs = sample(opts, nc)\n        \n        # Create an object (set of colored cells) for this column\n        # Each cell is assigned a random color from the selected colors\n        obj = frozenset({(choice(ccols), (ii, j)) for ii in locs})\n        \n        # Paint the object onto the input grid\n        gi = paint(gi, obj)\n        \n        # For every third column (j % 3 == 0), change the color to 6 in the output grid\n        if j % 3 == 0:\n            obj = recolor(6, obj)\n        \n        # Paint the (potentially recolored) object onto the output grid\n        go = paint(go, obj)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ba97ae07": {
    "original": "def generate_ba97ae07(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    lineh = unifint(diff_lb, diff_ub, (1, h // 3))\n    linew = unifint(diff_lb, diff_ub, (1, w // 3))\n    loci = randint(1, h - lineh - 1)\n    locj = randint(1, w - linew - 1)\n    acol = choice(remcols)\n    bcol = choice(remove(acol, remcols))\n    for a in range(lineh):\n        gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))\n    for b in range(linew):\n        gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))\n    for b in range(linew):\n        go = fill(go, bcol, connect((0, locj+b), (h-1, locj+b)))\n    for a in range(lineh):\n        go = fill(go, acol, connect((loci+a, 0), (loci+a, w-1)))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ba97ae07(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly generate width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a tuple of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly generate line height between 1 and 1/3 of grid height\n    lineh = unifint(diff_lb, diff_ub, (1, h // 3))\n    \n    # Randomly generate line width between 1 and 1/3 of grid width\n    linew = unifint(diff_lb, diff_ub, (1, w // 3))\n    \n    # Randomly choose starting row for the horizontal lines\n    loci = randint(1, h - lineh - 1)\n    \n    # Randomly choose starting column for the vertical lines\n    locj = randint(1, w - linew - 1)\n    \n    # Randomly choose color for horizontal lines\n    acol = choice(remcols)\n    \n    # Randomly choose color for vertical lines (different from horizontal)\n    bcol = choice(remove(acol, remcols))\n    \n    # Draw horizontal lines on input grid\n    for a in range(lineh):\n        # Fill a horizontal line with color 'acol'\n        gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))\n    \n    # Draw vertical lines on input grid\n    for b in range(linew):\n        # Fill a vertical line with color 'bcol'\n        gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))\n    \n    # Draw vertical lines on output grid\n    for b in range(linew):\n        # Fill a vertical line with color 'bcol'\n        go = fill(go, bcol, connect((0, locj+b), (h-1, locj+b)))\n    \n    # Draw horizontal lines on output grid\n    for a in range(lineh):\n        # Fill a horizontal line with color 'acol'\n        go = fill(go, acol, connect((loci+a, 0), (loci+a, w-1)))\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        # Mirror input grid diagonally\n        gi = dmirror(gi)\n        # Mirror output grid diagonally\n        go = dmirror(go)\n    \n    # Return dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "bb43febb": {
    "original": "def generate_bb43febb(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            remcols = remove(col, remcols)\n            gi = fill(gi, col, bd)\n            go = fill(go, 2, bd)\n            go = fill(go, col, box(obj))\n            succ += 1\n            indss = indss - bd\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bb43febb(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Generate random number of objects to place (1-8) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placement counter\n    succ = 0\n    \n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we run out of colors or available positions\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        \n        # Generate random object height (3-7)\n        oh = randint(3, 7)\n        \n        # Generate random object width (3-7)\n        ow = randint(3, 7)\n        \n        # Find valid positions where the object can be placed\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random valid position\n        loci, locj = choice(subs)\n        \n        # Create object (represented by its corners)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        \n        # Get the backdrop (all cells) of the object\n        bd = backdrop(obj)\n        \n        # Choose a random color for the object\n        col = choice(remcols)\n        \n        # Check if the object can be placed without overlapping\n        if bd.issubset(indss):\n            # Remove used color from available colors\n            remcols = remove(col, remcols)\n            \n            # Fill the object area with chosen color in input grid\n            gi = fill(gi, col, bd)\n            \n            # Fill the object area with color 2 in output grid\n            go = fill(go, 2, bd)\n            \n            # Draw the outline of the object with its color in output grid\n            go = fill(go, col, box(obj))\n            \n            # Increment successful placement counter\n            succ += 1\n            \n            # Remove used positions from available positions\n            indss = indss - bd\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "bbc9ae5d": {
    "original": "def generate_bbc9ae5d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    w = w * 2\n    locinv = unifint(diff_lb, diff_ub, (2, w))\n    locj = w - locinv\n    loc = (0, locj)\n    c1 = choice(cols)\n    remcols = remove(c1, cols)\n    ln1 = connect((0, 0), (0, locj))\n    remobj = connect((0, locj+1), (0, w - 1))\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numc)\n    remobj = {(choice(ccols), ij) for ij in remobj}\n    gi = canvas(-1, (1, w))\n    go = canvas(-1, (w//2, w))\n    ln2 = shoot(loc, (1, 1))\n    gi = fill(gi, c1, ln1)\n    gi = paint(gi, remobj)\n    go = fill(go, c1, mapply(rbind(shoot, (0, -1)), ln2))\n    for c, ij in remobj:\n        go = fill(go, c, shoot(ij, (1, 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bbc9ae5d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random even width between 4 and 30\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    w = w * 2\n    \n    # Generate a random location for the inverse point\n    locinv = unifint(diff_lb, diff_ub, (2, w))\n    locj = w - locinv\n    loc = (0, locj)\n    \n    # Choose a random color for the main line\n    c1 = choice(cols)\n    # Remove the chosen color from the available colors\n    remcols = remove(c1, cols)\n    \n    # Create a line from (0,0) to the inverse point\n    ln1 = connect((0, 0), (0, locj))\n    # Create a set of points for the remaining part of the top row\n    remobj = connect((0, locj+1), (0, w - 1))\n    \n    # Choose a random number of colors to use (1 to 9)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Assign random colors to the remaining points in the top row\n    remobj = {(choice(ccols), ij) for ij in remobj}\n    \n    # Create the input grid (1xw) filled with -1\n    gi = canvas(-1, (1, w))\n    # Create the output grid (w/2 x w) filled with -1\n    go = canvas(-1, (w//2, w))\n    \n    # Create a diagonal line from the inverse point\n    ln2 = shoot(loc, (1, 1))\n    \n    # Fill the main line in the input grid with color c1\n    gi = fill(gi, c1, ln1)\n    # Paint the remaining objects in the input grid\n    gi = paint(gi, remobj)\n    \n    # Fill the diagonal lines in the output grid with color c1\n    go = fill(go, c1, mapply(rbind(shoot, (0, -1)), ln2))\n    \n    # For each colored point in the input, create a diagonal line in the output\n    for c, ij in remobj:\n        go = fill(go, c, shoot(ij, (1, 1)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "bc1d5164": {
    "original": "def generate_bc1d5164(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    fullh = 2 * h - 1\n    fullw = 2 * w + 1\n    bgc, objc = sample(cols, 2)\n    inds = asindices(canvas(-1, (h, w)))\n    nA = randint(1, (h - 1) * (w - 1) - 1)\n    nB = randint(1, (h - 1) * (w - 1) - 1)\n    nC = randint(1, (h - 1) * (w - 1) - 1)\n    nD = randint(1, (h - 1) * (w - 1) - 1)\n    A = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] < w - 1)), nA)\n    B = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] > 0)), nB)\n    C = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] < w - 1)), nC)\n    D = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] > 0)), nD)\n    gi = canvas(bgc, (fullh, fullw))\n    gi = fill(gi, objc, A)\n    gi = fill(gi, objc, shift(B, (0, fullw - w)))\n    gi = fill(gi, objc, shift(C, (fullh - h, 0)))\n    gi = fill(gi, objc, shift(D, (fullh - h, fullw - w)))\n    go = canvas(bgc, (h, w))\n    go = fill(go, objc, set(A) | set(B) | set(C) | set(D))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bc1d5164(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 3 and 15 based on difficulty parameters\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Generate a random width between 2 and 14 based on difficulty parameters\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Calculate the full height of the input grid (double the output height minus 1)\n    fullh = 2 * h - 1\n    \n    # Calculate the full width of the input grid (double the output width plus 1)\n    fullw = 2 * w + 1\n    \n    # Randomly select two different colors: one for background and one for objects\n    bgc, objc = sample(cols, 2)\n    \n    # Generate all possible indices for the output grid\n    inds = asindices(canvas(-1, (h, w)))\n    \n    # Randomly determine the number of cells to be filled in each quadrant\n    nA = randint(1, (h - 1) * (w - 1) - 1)  # Top-left quadrant\n    nB = randint(1, (h - 1) * (w - 1) - 1)  # Top-right quadrant\n    nC = randint(1, (h - 1) * (w - 1) - 1)  # Bottom-left quadrant\n    nD = randint(1, (h - 1) * (w - 1) - 1)  # Bottom-right quadrant\n    \n    # Randomly select cells to be filled in each quadrant of the output grid\n    A = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] < w - 1)), nA)  # Top-left\n    B = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] > 0)), nB)      # Top-right\n    C = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] < w - 1)), nC)      # Bottom-left\n    D = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] > 0)), nD)          # Bottom-right\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (fullh, fullw))\n    \n    # Fill the top-left quadrant of the input grid\n    gi = fill(gi, objc, A)\n    \n    # Fill the top-right quadrant of the input grid (shifted to the right)\n    gi = fill(gi, objc, shift(B, (0, fullw - w)))\n    \n    # Fill the bottom-left quadrant of the input grid (shifted down)\n    gi = fill(gi, objc, shift(C, (fullh - h, 0)))\n    \n    # Fill the bottom-right quadrant of the input grid (shifted down and right)\n    gi = fill(gi, objc, shift(D, (fullh - h, fullw - w)))\n    \n    # Create the output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Fill the output grid with all selected cells from all quadrants\n    go = fill(go, objc, set(A) | set(B) | set(C) | set(D))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "bd4472b8": {
    "original": "def generate_bd4472b8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 28))\n    w = unifint(diff_lb, diff_ub, (2, 8))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    ccols = sample(remcols, w)\n    cc = (tuple(ccols),)\n    br = canvas(linc, (1, w))\n    lp = canvas(bgc, (h, w))\n    gi = vconcat(vconcat(cc, br), lp)\n    go = vconcat(vconcat(cc, br), lp)\n    pt = hupscale(dmirror(cc), w)\n    pto = asobject(pt)\n    idx = 2\n    while idx < h+3:\n        go = paint(go, shift(pto, (idx, 0)))\n        idx += w\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bd4472b8(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 1 to 9 (inclusive) with step 1\n    cols = interval(1, 10, 1)\n    \n    # Generate a random height between 1 and 28, based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 28))\n    \n    # Generate a random width between 2 and 8, based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 8))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the horizontal line\n    linc = choice(remcols)\n    \n    # Randomly sample 'w' colors from the remaining colors for the color row\n    ccols = sample(remcols, w)\n    \n    # Create a tuple of tuples containing the color row\n    cc = (tuple(ccols),)\n    \n    # Create a horizontal line (border) with the chosen line color\n    br = canvas(linc, (1, w))\n    \n    # Create the lower part of the grid with the background color\n    lp = canvas(bgc, (h, w))\n    \n    # Combine the color row, border, and lower part to create the input grid\n    gi = vconcat(vconcat(cc, br), lp)\n    \n    # Create an initial output grid identical to the input grid\n    go = vconcat(vconcat(cc, br), lp)\n    \n    # Create a pattern by mirroring the color row diagonally and upscaling horizontally\n    pt = hupscale(dmirror(cc), w)\n    \n    # Convert the pattern to an object representation\n    pto = asobject(pt)\n    \n    # Initialize the index for placing patterns\n    idx = 2\n    \n    # Loop to place the pattern multiple times in the output grid\n    while idx < h+3:\n        # Paint the shifted pattern onto the output grid\n        go = paint(go, shift(pto, (idx, 0)))\n        # Move the index by the width of the pattern\n        idx += w\n    \n    # Choose a random rotation function (including identity)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "bda2d7a6": {
    "original": "def generate_bda2d7a6(diff_lb: float, diff_ub: float) -> dict:\n    colopts = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    ncols = unifint(diff_lb, diff_ub, (2, 10))\n    cols = sample(colopts, ncols)\n    colord = [choice(cols) for j in range(min(h, w))]\n    shp = (h*2, w*2)\n    gi = canvas(0, shp)\n    for idx, (ci, co) in enumerate(zip(colord, colord[-1:] + colord[:-1])):\n        ulc = (idx, idx)\n        lrc = (h*2 - 1 - idx, w*2 - 1 - idx)\n        bx = box(frozenset({ulc, lrc}))\n        gi = fill(gi, ci, bx)\n    I = gi\n    objso = order(objects(I, T, F, F), compose(maximum, shape))\n    if color(objso[0]) == color(objso[-1]):\n        objso = (combine(objso[0], objso[-1]),) + objso[1:-1]\n    res = mpapply(recolor, apply(color, objso), (objso[-1],) + objso[:-1])\n    go = paint(gi, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bda2d7a6(diff_lb: float, diff_ub: float) -> dict:\n    # Define color options as integers from 0 to 9\n    colopts = interval(0, 10, 1)\n    \n    # Randomly determine height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly determine width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Randomly determine number of colors to use based on difficulty\n    ncols = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Randomly select 'ncols' colors from color options\n    cols = sample(colopts, ncols)\n    \n    # Create a list of colors for each layer, cycling if necessary\n    # This determines the color order of the concentric boxes\n    colord = [choice(cols) for j in range(min(h, w))]\n    \n    # Define the shape of the grid (doubled in both dimensions)\n    shp = (h*2, w*2)\n    \n    # Create an initial canvas filled with zeros (black)\n    gi = canvas(0, shp)\n    \n    # Iterate through colors to create concentric boxes\n    for idx, (ci, co) in enumerate(zip(colord, colord[-1:] + colord[:-1])):\n        # Define upper-left corner of the box\n        ulc = (idx, idx)\n        # Define lower-right corner of the box\n        lrc = (h*2 - 1 - idx, w*2 - 1 - idx)\n        # Create a box using these corners\n        bx = box(frozenset({ulc, lrc}))\n        # Fill the box with the current color\n        gi = fill(gi, ci, bx)\n    \n    # Set the input grid\n    I = gi\n    \n    # Identify objects in the input grid, sort them by size (largest first)\n    objso = order(objects(I, T, F, F), compose(maximum, shape))\n    \n    # If the largest and smallest objects have the same color, combine them\n    if color(objso[0]) == color(objso[-1]):\n        objso = (combine(objso[0], objso[-1]),) + objso[1:-1]\n    \n    # Recolor objects: each object gets the color of the next object (cyclically)\n    res = mpapply(recolor, apply(color, objso), (objso[-1],) + objso[:-1])\n    \n    # Paint the recolored objects onto the original grid to create the output\n    go = paint(gi, res)\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "bdad9b1f": {
    "original": "def generate_bdad9b1f(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    numh = unifint(diff_lb, diff_ub, (1, h // 2 - 1))\n    numw = unifint(diff_lb, diff_ub, (1, w // 2 - 1))\n    hlocs = sample(interval(2, h - 1, 1), numh)\n    wlocs = sample(interval(2, w - 1, 1), numw)\n    numcols = unifint(diff_lb, diff_ub, (2, 8))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, numcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    fc = -1\n    for ii in sorted(hlocs):\n        col = choice(remove(fc, ccols))\n        fc = col\n        objw = randint(2, ii)\n        gi = fill(gi, col, connect((ii, 0), (ii, objw - 1)))\n        go = fill(go, col, connect((ii, 0), (ii, w - 1)))\n    fc = -1\n    for jj in sorted(wlocs):\n        col = choice(remove(fc, ccols))\n        fc = col\n        objh = randint(2, jj)\n        gi = fill(gi, col, connect((0, jj), (objh - 1, jj)))\n        go = fill(go, col, connect((0, jj), (h - 1, jj)))\n    yells = product(set(hlocs), set(wlocs))\n    go = fill(go, 4, yells)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_bdad9b1f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Determine number of horizontal lines (1 to half the height minus 1)\n    numh = unifint(diff_lb, diff_ub, (1, h // 2 - 1))\n    \n    # Determine number of vertical lines (1 to half the width minus 1)\n    numw = unifint(diff_lb, diff_ub, (1, w // 2 - 1))\n    \n    # Randomly select positions for horizontal lines (excluding edges)\n    hlocs = sample(interval(2, h - 1, 1), numh)\n    \n    # Randomly select positions for vertical lines (excluding edges)\n    wlocs = sample(interval(2, w - 1, 1), numw)\n    \n    # Choose number of colors to use (2 to 8)\n    numcols = unifint(diff_lb, diff_ub, (2, 8))\n    \n    # Select a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Randomly select colors to use for lines\n    ccols = sample(remcols, numcols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Initialize previous color\n    fc = -1\n    \n    # For each horizontal line position (sorted)\n    for ii in sorted(hlocs):\n        # Choose a color different from the previous one\n        col = choice(remove(fc, ccols))\n        # Update previous color\n        fc = col\n        # Generate a random width for the line in input grid\n        objw = randint(2, ii)\n        # Draw partial horizontal line in input grid\n        gi = fill(gi, col, connect((ii, 0), (ii, objw - 1)))\n        # Draw full horizontal line in output grid\n        go = fill(go, col, connect((ii, 0), (ii, w - 1)))\n    \n    # Reset previous color\n    fc = -1\n    \n    # For each vertical line position (sorted)\n    for jj in sorted(wlocs):\n        # Choose a color different from the previous one\n        col = choice(remove(fc, ccols))\n        # Update previous color\n        fc = col\n        # Generate a random height for the line in input grid\n        objh = randint(2, jj)\n        # Draw partial vertical line in input grid\n        gi = fill(gi, col, connect((0, jj), (objh - 1, jj)))\n        # Draw full vertical line in output grid\n        go = fill(go, col, connect((0, jj), (h - 1, jj)))\n    \n    # Calculate intersection points of horizontal and vertical lines\n    yells = product(set(hlocs), set(wlocs))\n    # Fill intersection points with color 4 in output grid\n    go = fill(go, 4, yells)\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply rotation to input grid\n    gi = rotf(gi)\n    # Apply same rotation to output grid\n    go = rotf(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "be94b721": {
    "original": "def generate_be94b721(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    no = unifint(diff_lb, diff_ub, (3, max(3, (h * w) // 16)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (no+1, max(no+1, 2*no)))\n    inds = asindices(c)\n    ch = choice(totuple(inds))\n    shp = {ch}\n    inds = remove(ch, inds)\n    for k in range(nc - 1):\n        shp.add(choice(totuple((inds - shp) & mapply(dneighbors, shp))))\n    inds = (inds - shp) - mapply(neighbors, shp)\n    trgc = choice(remcols)\n    gi = fill(c, trgc, shp)\n    go = fill(canvas(bgc, shape(shp)), trgc, normalize(shp))\n    for k in range(no):\n        if len(inds) == 0:\n            break\n        ch = choice(totuple(inds))\n        shp = {ch}\n        nc2 = unifint(diff_lb, diff_ub, (1, nc - 1))\n        for k in range(nc2 - 1):\n            cands = totuple((inds - shp) & mapply(dneighbors, shp))\n            if len(cands) == 0:\n                break\n            shp.add(choice(cands))\n        col = choice(remcols)\n        gi = fill(gi, col, shp)\n        inds = (inds - shp) - mapply(neighbors, shp)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_be94b721(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Determine the number of objects to generate based on difficulty and grid size\n    no = unifint(diff_lb, diff_ub, (3, max(3, (h * w) // 16)))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Determine the number of cells for the main shape based on difficulty\n    nc = unifint(diff_lb, diff_ub, (no+1, max(no+1, 2*no)))\n    \n    # Get all indices of the canvas\n    inds = asindices(c)\n    \n    # Choose a random starting cell for the main shape\n    ch = choice(totuple(inds))\n    \n    # Initialize the main shape with the chosen cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available indices\n    inds = remove(ch, inds)\n    \n    # Grow the main shape by adding adjacent cells\n    for k in range(nc - 1):\n        # Add a random cell that is adjacent to the shape and not already in the shape\n        shp.add(choice(totuple((inds - shp) & mapply(dneighbors, shp))))\n    \n    # Remove the shape and its neighbors from available indices\n    inds = (inds - shp) - mapply(neighbors, shp)\n    \n    # Choose a target color for the main shape\n    trgc = choice(remcols)\n    \n    # Create the input grid by filling the main shape with the target color\n    gi = fill(c, trgc, shp)\n    \n    # Create the output grid by filling a normalized version of the main shape\n    go = fill(canvas(bgc, shape(shp)), trgc, normalize(shp))\n    \n    # Generate additional random shapes\n    for k in range(no):\n        # Break if no more available indices\n        if len(inds) == 0:\n            break\n        \n        # Choose a random starting cell for the new shape\n        ch = choice(totuple(inds))\n        \n        # Initialize the new shape with the chosen cell\n        shp = {ch}\n        \n        # Determine the size of the new shape based on difficulty\n        nc2 = unifint(diff_lb, diff_ub, (1, nc - 1))\n        \n        # Grow the new shape by adding adjacent cells\n        for k in range(nc2 - 1):\n            cands = totuple((inds - shp) & mapply(dneighbors, shp))\n            # Break if no more candidates to add\n            if len(cands) == 0:\n                break\n            shp.add(choice(cands))\n        \n        # Choose a random color for the new shape\n        col = choice(remcols)\n        \n        # Add the new shape to the input grid\n        gi = fill(gi, col, shp)\n        \n        # Remove the new shape and its neighbors from available indices\n        inds = (inds - shp) - mapply(neighbors, shp)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "beb8660c": {
    "original": "def generate_beb8660c(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    h = unifint(diff_lb, diff_ub, (w, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    k = min(8, w - 1)\n    k = unifint(diff_lb, diff_ub, (1, k))\n    co = sample(remcols, k)\n    wds = sorted(sample(interval(1, w, 1), k))\n    for j, (c, l) in enumerate(zip(co, wds)):\n        j = h - k - 1 + j\n        gi = fill(gi, c, connect((j, 0), (j, l - 1)))\n    gi = fill(gi, 8, connect((h - 1, 0), (h - 1, w - 1)))\n    go = vmirror(gi)\n    gi = list(list(r) for r in gi[:-1])\n    shuffle(gi)\n    gi = tuple(tuple(r) for r in gi)\n    gi = gi + go[-1:]\n    gif = tuple()\n    for r in gi:\n        nbc = r.count(bgc)\n        ofs = randint(0, nbc)\n        gif = gif + (r[-ofs:] + r[:-ofs],)\n    gi = vmirror(gif)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_beb8660c(diff_lb: float, diff_ub: float) -> dict:\n    # Remove 8 from the range 0-9 to create a list of available colors\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random height between w and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (w, 30))\n    \n    # Choose a random background color from available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Calculate the maximum number of colored lines (up to 8 or width-1)\n    k = min(8, w - 1)\n    \n    # Choose a random number of colored lines based on difficulty\n    k = unifint(diff_lb, diff_ub, (1, k))\n    \n    # Randomly select k colors for the lines\n    co = sample(remcols, k)\n    \n    # Randomly select k widths for the lines (sorted in ascending order)\n    wds = sorted(sample(interval(1, w, 1), k))\n    \n    # Draw colored lines on the grid\n    for j, (c, l) in enumerate(zip(co, wds)):\n        # Calculate the row position for each line\n        j = h - k - 1 + j\n        # Draw a horizontal line of color c with length l\n        gi = fill(gi, c, connect((j, 0), (j, l - 1)))\n    \n    # Add a black line at the bottom of the grid\n    gi = fill(gi, 8, connect((h - 1, 0), (h - 1, w - 1)))\n    \n    # Create the output grid by vertically mirroring the input grid\n    go = vmirror(gi)\n    \n    # Convert the input grid (except the last row) to a list of lists\n    gi = list(list(r) for r in gi[:-1])\n    \n    # Shuffle the rows of the input grid (except the last row)\n    shuffle(gi)\n    \n    # Convert the shuffled grid back to a tuple of tuples\n    gi = tuple(tuple(r) for r in gi)\n    \n    # Add the last row (black line) back to the shuffled grid\n    gi = gi + go[-1:]\n    \n    # Initialize an empty tuple for the final input grid\n    gif = tuple()\n    \n    # For each row in the input grid\n    for r in gi:\n        # Count the number of background color cells in the row\n        nbc = r.count(bgc)\n        # Choose a random offset for circular shift\n        ofs = randint(0, nbc)\n        # Perform a circular shift on the row and add it to the final grid\n        gif = gif + (r[-ofs:] + r[:-ofs],)\n    \n    # Vertically mirror the final input grid\n    gi = vmirror(gif)\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "c0f76784": {
    "original": "def generate_c0f76784(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (6, 7, 8))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    ccols = sample(remcols, numcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        oh = choice((3, 4, 5))\n        ow = oh\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(ccols)\n        if bd.issubset(indss):\n            gi = fill(gi, col, bd)\n            go = fill(go, col, bd)\n            ccc = oh + 3\n            bdx = backdrop(inbox(obj))\n            gi = fill(gi, bgc, bdx)\n            go = fill(go, ccc, bdx)\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c0f76784(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 6, 7, and 8\n    cols = difference(interval(0, 10, 1), (6, 7, 8))    \n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (between 1 and the number of remaining colors)\n    numcols = unifint(diff_lb, diff_ub, (1, len(remcols)))\n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numcols)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Determine number of objects to place (between 1 and 5% of grid area)\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))\n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    tr = 0  # Trial counter\n    succ = 0  # Successful placements counter\n    \n    # Loop to place objects\n    while succ < num and tr <= maxtrials:\n        # Break if no more available indices\n        if len(indss) == 0:\n            break\n        \n        # Choose random object height (3, 4, or 5)\n        oh = choice((3, 4, 5))\n        ow = oh  # Set object width equal to height (square objects)\n        \n        # Filter valid starting positions for object placement\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose random starting position for object\n        loci, locj = choice(subs)\n        # Create object (defined by its corners)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get all cells within object's bounding box\n        bd = backdrop(obj)\n        \n        # Choose random color for object\n        col = choice(ccols)\n        \n        # If object fits within available indices\n        if bd.issubset(indss):\n            # Fill object area with chosen color in input grid\n            gi = fill(gi, col, bd)\n            # Fill object area with chosen color in output grid\n            go = fill(go, col, bd)\n            \n            # Calculate color for inner box (object size + 3)\n            ccc = oh + 3\n            # Get cells for inner box\n            bdx = backdrop(inbox(obj))\n            # Clear inner box area in input grid\n            gi = fill(gi, bgc, bdx)\n            # Fill inner box area with new color in output grid\n            go = fill(go, ccc, bdx)\n            \n            # Increment successful placements counter\n            succ += 1\n            # Remove used cells and surrounding area from available indices\n            indss = (indss - bd) - outbox(bd)\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "c1d99e64": {
    "original": "def generate_c1d99e64(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (4, 30)\n    colopts = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    nofrontcol = choice(colopts)\n    noisefrontcol = choice(remove(nofrontcol, colopts))\n    gi = canvas(nofrontcol, (h, w))\n    cands = totuple(asindices(gi))\n    horifront_bounds = (1, h//4)\n    vertifront_bounds = (1, w//4)\n    nhf = unifint(diff_lb, diff_ub, horifront_bounds)\n    nvf = unifint(diff_lb, diff_ub, vertifront_bounds)\n    vfs = mapply(compose(vfrontier, tojvec), sample(interval(0, w, 1), nvf))\n    hfs = mapply(compose(hfrontier, toivec), sample(interval(0, h, 1), nhf))\n    gi = fill(gi, noisefrontcol, combine(vfs, hfs))\n    cands = totuple(ofcolor(gi, nofrontcol))\n    kk = size(cands)\n    midp = (h * w) // 2\n    noise_bounds = (0, max(0, kk - midp - 1))\n    num_noise = unifint(diff_lb, diff_ub, noise_bounds)\n    noise = sample(cands, num_noise)\n    gi = fill(gi, noisefrontcol, noise)\n    go = fill(gi, 2, merge(colorfilter(frontiers(gi), noisefrontcol)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c1d99e64(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (4, 30)\n    # Create a list of color options, excluding 2\n    colopts = remove(2, interval(0, 10, 1))\n    # Randomly choose height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Choose a color for non-frontier areas\n    nofrontcol = choice(colopts)\n    # Choose a different color for frontier areas\n    noisefrontcol = choice(remove(nofrontcol, colopts))\n    # Create initial grid filled with non-frontier color\n    gi = canvas(nofrontcol, (h, w))\n    # Get all grid indices as candidates\n    cands = totuple(asindices(gi))\n    # Define bounds for number of horizontal frontiers\n    horifront_bounds = (1, h//4)\n    # Define bounds for number of vertical frontiers\n    vertifront_bounds = (1, w//4)\n    # Choose number of horizontal frontiers based on difficulty\n    nhf = unifint(diff_lb, diff_ub, horifront_bounds)\n    # Choose number of vertical frontiers based on difficulty\n    nvf = unifint(diff_lb, diff_ub, vertifront_bounds)\n    # Create vertical frontiers at random positions\n    vfs = mapply(compose(vfrontier, tojvec), sample(interval(0, w, 1), nvf))\n    # Create horizontal frontiers at random positions\n    hfs = mapply(compose(hfrontier, toivec), sample(interval(0, h, 1), nhf))\n    # Fill the frontiers with the frontier color\n    gi = fill(gi, noisefrontcol, combine(vfs, hfs))\n    # Get all non-frontier cells as candidates for noise\n    cands = totuple(ofcolor(gi, nofrontcol))\n    # Count the number of non-frontier cells\n    kk = size(cands)\n    # Calculate midpoint of total grid cells\n    midp = (h * w) // 2\n    # Define bounds for number of noise cells\n    noise_bounds = (0, max(0, kk - midp - 1))\n    # Choose number of noise cells based on difficulty\n    num_noise = unifint(diff_lb, diff_ub, noise_bounds)\n    # Randomly select cells for noise\n    noise = sample(cands, num_noise)\n    # Add noise to the grid\n    gi = fill(gi, noisefrontcol, noise)\n    # Create output grid: fill frontiers with color 2\n    go = fill(gi, 2, merge(colorfilter(frontiers(gi), noisefrontcol)))\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "c3e719e8": {
    "original": "def generate_c3e719e8(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(0, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    gob = canvas(-1, (h**2, w**2))\n    wg = canvas(-1, (h, w))\n    ncols = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))\n    nmc = randint(max(1, (h * w) // (ncols + 1) + 1), h * w)\n    inds = totuple(asindices(wg))\n    mc = choice(cols)\n    remcols = remove(mc, cols)\n    mcc = sample(inds, nmc)\n    inds = difference(inds, mcc)\n    gi = fill(wg, mc, mcc)\n    ocols = sample(remcols, ncols)\n    k = len(inds) // ncols + 1\n    for ocol in ocols:\n        if len(inds) == 0:\n            break\n        ub = min(nmc - 1, len(inds))\n        ub = min(ub, k)\n        ub = max(ub, 1)\n        locs = sample(inds, unifint(diff_lb, diff_ub, (1, ub)))\n        inds = difference(inds, locs)\n        gi = fill(gi, ocol, locs)\n    gi = replace(gi, -1, mc)\n    o = asobject(gi)\n    gob = replace(gob, -1, 0)\n    go = paint(gob, mapply(lbind(shift, o), apply(rbind(multiply, (h, w)), ofcolor(gi, mc))))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c3e719e8(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of colors 1-9 (removing 0)\n    cols = remove(0, interval(0, 10, 1))\n    \n    # Generate random height between 2 and 5 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    # Generate random width between 2 and 5 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Create a large canvas filled with -1, size is square of h and w\n    gob = canvas(-1, (h**2, w**2))\n    # Create a smaller working grid filled with -1, size h x w\n    wg = canvas(-1, (h, w))\n    \n    # Determine number of colors to use (between 1 and min of (h*w-1, 8))\n    ncols = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))\n    # Determine number of cells for main color (ensuring it's the majority)\n    nmc = randint(max(1, (h * w) // (ncols + 1) + 1), h * w)\n    \n    # Get all indices of the working grid\n    inds = totuple(asindices(wg))\n    # Choose a random color as the main color\n    mc = choice(cols)\n    # Remove the main color from the color list\n    remcols = remove(mc, cols)\n    \n    # Randomly select cells for the main color\n    mcc = sample(inds, nmc)\n    # Remove the main color cells from available indices\n    inds = difference(inds, mcc)\n    \n    # Fill the working grid with the main color in selected cells\n    gi = fill(wg, mc, mcc)\n    \n    # Select colors for other cells\n    ocols = sample(remcols, ncols)\n    # Calculate average number of cells per remaining color\n    k = len(inds) // ncols + 1\n    \n    # For each other color:\n    for ocol in ocols:\n        # Break if no more cells available\n        if len(inds) == 0:\n            break\n        # Determine upper bound for number of cells for this color\n        ub = min(nmc - 1, len(inds))\n        ub = min(ub, k)\n        ub = max(ub, 1)\n        # Randomly select cells for this color\n        locs = sample(inds, unifint(diff_lb, diff_ub, (1, ub)))\n        # Remove these cells from available indices\n        inds = difference(inds, locs)\n        # Fill the grid with this color in selected cells\n        gi = fill(gi, ocol, locs)\n    \n    # Replace any remaining -1 cells with the main color\n    gi = replace(gi, -1, mc)\n    \n    # Convert the input grid to an object\n    o = asobject(gi)\n    # Replace -1 with 0 in the large output grid\n    gob = replace(gob, -1, 0)\n    \n    # Create the output by painting enlarged main color cells onto the large grid\n    # This effectively creates a zoomed-in version of the main color pattern\n    go = paint(gob, mapply(lbind(shift, o), apply(rbind(multiply, (h, w)), ofcolor(gi, mc))))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "c3f564a4": {
    "original": "def generate_c3f564a4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    p = unifint(diff_lb, diff_ub, (2, min(9, min(h//3, w//3))))\n    fixc = choice(cols)\n    remcols = remove(fixc, cols)\n    ccols = list(sample(remcols, p))\n    shuffle(ccols)\n    c = canvas(-1, (h, w))\n    baseobj = {(cc, (0, jj)) for cc, jj in zip(ccols, range(p))}\n    obj = {c for c in baseobj}\n    while rightmost(obj) < 2 * max(w, h):\n        obj = obj | shift(obj, (0, p))\n    if choice((True, False)):\n        obj = mapply(lbind(shift, obj), {(jj, 0) for jj in interval(0, h, 1)})\n    else:\n        obj = mapply(lbind(shift, obj), {(jj, -jj) for jj in interval(0, h, 1)})\n    go = paint(c, obj)\n    gi = tuple(e for e in go)\n    nsq = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 25)))\n    maxtr = 4 * nsq\n    tr = 0\n    succ = 0\n    while succ < nsq and tr < maxtr:\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        ow = unifint(diff_lb, diff_ub, (2, 5))\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        tmpg = fill(gi, fixc, backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})))\n        if len(occurrences(tmpg, baseobj)) > 1 and len([r for r in tmpg if fixc not in r]) > 0 and len([r for r in dmirror(tmpg) if fixc not in r]) > 0:\n            gi = tmpg\n            succ += 1\n        tr += 1\n    if choice((True, False)):\n        gi = rot90(gi)\n        go = rot90(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c3f564a4(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 7 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Generate a random width between 7 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Generate a random period between 2 and 9 (or less based on grid dimensions)\n    p = unifint(diff_lb, diff_ub, (2, min(9, min(h//3, w//3))))\n    \n    # Choose a fixed color randomly\n    fixc = choice(cols)\n    \n    # Remove the fixed color from the color list\n    remcols = remove(fixc, cols)\n    \n    # Randomly sample 'p' colors from the remaining colors\n    ccols = list(sample(remcols, p))\n    \n    # Shuffle the chosen colors\n    shuffle(ccols)\n    \n    # Create an empty canvas filled with -1\n    c = canvas(-1, (h, w))\n    \n    # Create a base object with the chosen colors in a horizontal line\n    baseobj = {(cc, (0, jj)) for cc, jj in zip(ccols, range(p))}\n    \n    # Initialize the object with the base object\n    obj = {c for c in baseobj}\n    \n    # Extend the object horizontally by repeating the pattern\n    while rightmost(obj) < 2 * max(w, h):\n        obj = obj | shift(obj, (0, p))\n    \n    # Randomly choose to either:\n    if choice((True, False)):\n        # Spread the object vertically across the entire height\n        obj = mapply(lbind(shift, obj), {(jj, 0) for jj in interval(0, h, 1)})\n    else:\n        # Create a diagonal pattern\n        obj = mapply(lbind(shift, obj), {(jj, -jj) for jj in interval(0, h, 1)})\n    \n    # Paint the object onto the canvas\n    go = paint(c, obj)\n    \n    # Convert the grid object to a tuple of tuples\n    gi = tuple(e for e in go)\n    \n    # Determine the number of squares to add based on difficulty\n    nsq = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 25)))\n    \n    # Set maximum number of attempts\n    maxtr = 4 * nsq\n    \n    # Initialize counters\n    tr = 0  # Number of attempts\n    succ = 0  # Number of successful additions\n    \n    # Add fixed-color squares to the grid\n    while succ < nsq and tr < maxtr:\n        # Generate random height and width for the square\n        oh = unifint(diff_lb, diff_ub, (2, 5))\n        ow = unifint(diff_lb, diff_ub, (2, 5))\n        \n        # Generate random location for the square\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        \n        # Try to add a fixed-color square\n        tmpg = fill(gi, fixc, backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})))\n        \n        # Check if the addition is valid\n        if len(occurrences(tmpg, baseobj)) > 1 and len([r for r in tmpg if fixc not in r]) > 0 and len([r for r in dmirror(tmpg) if fixc not in r]) > 0:\n            gi = tmpg\n            succ += 1\n        tr += 1\n    \n    # Randomly decide whether to rotate the grids\n    if choice((True, False)):\n        gi = rot90(gi)\n        go = rot90(go)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "c444b776": {
    "original": "def generate_c444b776(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 9))\n    w = unifint(diff_lb, diff_ub, (2, 9))\n    nh = unifint(diff_lb, diff_ub, (1, 3))\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))\n    bgclinc = sample(cols, 2)\n    bgc, linc = bgclinc\n    remcols = difference(cols, bgclinc)\n    fullh = h * nh + (nh - 1)\n    fullw = w * nw + (nw - 1)\n    c = canvas(linc, (fullh, fullw))\n    smallc = canvas(bgc, (h, w))\n    inds = totuple(asindices(smallc))\n    numcol = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numcol)\n    numcels = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    cels = sample(inds, numcels)\n    obj = {(choice(ccols), ij) for ij in cels}\n    smallcpainted = paint(smallc, obj)\n    llocs = set()\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    srcloc = choice(llocs)\n    obj = asobject(smallcpainted)\n    gi = paint(c, shift(obj, srcloc))\n    remlocs = remove(srcloc, llocs)\n    bobj = asobject(smallc)\n    for rl in remlocs:\n        gi = paint(gi, shift(bobj, rl))\n    go = tuple(e for e in gi)\n    for rl in remlocs:\n        go = paint(go, shift(obj, rl))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c444b776(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly select height of small canvas based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 9))\n    # Randomly select width of small canvas based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly select number of rows in the grid based on difficulty\n    nh = unifint(diff_lb, diff_ub, (1, 3))\n    # Randomly select number of columns in the grid based on difficulty\n    # Ensure at least 2 columns if there's only 1 row\n    nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))\n    \n    # Randomly select two colors for background and lines\n    bgclinc = sample(cols, 2)\n    bgc, linc = bgclinc  # Unpack the selected colors\n    \n    # Get the remaining colors not used for background and lines\n    remcols = difference(cols, bgclinc)\n    \n    # Calculate full height and width of the grid, including separating lines\n    fullh = h * nh + (nh - 1)\n    fullw = w * nw + (nw - 1)\n    \n    # Create the full canvas with line color\n    c = canvas(linc, (fullh, fullw))\n    # Create a small canvas with background color\n    smallc = canvas(bgc, (h, w))\n    \n    # Get all indices of the small canvas\n    inds = totuple(asindices(smallc))\n    \n    # Randomly select number of colors to use for the pattern\n    numcol = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly select colors for the pattern\n    ccols = sample(remcols, numcol)\n    \n    # Randomly select number of cells to color in the pattern\n    numcels = unifint(diff_lb, diff_ub, (1, (h * w) // 2))\n    # Randomly select cells to color\n    cels = sample(inds, numcels)\n    \n    # Create the pattern object by assigning random colors to selected cells\n    obj = {(choice(ccols), ij) for ij in cels}\n    \n    # Paint the small canvas with the created pattern\n    smallcpainted = paint(smallc, obj)\n    \n    # Calculate locations for placing small canvases in the full grid\n    llocs = set()\n    for a in range(0, fullh, h+1):\n        for b in range(0, fullw, w + 1):\n            llocs.add((a, b))\n    llocs = tuple(llocs)\n    \n    # Randomly select a location for the source pattern\n    srcloc = choice(llocs)\n    \n    # Convert the painted small canvas to an object\n    obj = asobject(smallcpainted)\n    \n    # Paint the full canvas with the source pattern at the selected location\n    gi = paint(c, shift(obj, srcloc))\n    \n    # Remove the source location from available locations\n    remlocs = remove(srcloc, llocs)\n    \n    # Create a background object from the small canvas\n    bobj = asobject(smallc)\n    \n    # Fill the remaining locations with background color\n    for rl in remlocs:\n        gi = paint(gi, shift(bobj, rl))\n    \n    # Create the output grid by copying the input\n    go = tuple(e for e in gi)\n    \n    # Fill all locations (except source) with the pattern in the output\n    for rl in remlocs:\n        go = paint(go, shift(obj, rl))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "c59eb873": {
    "original": "def generate_c59eb873(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = upscale(gi, 2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c59eb873(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (other than background) based on difficulty\n    # The maximum number of colors is capped at 9 or the total number of cells, whichever is smaller\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each selected color:\n    for col in colsch:\n        # Determine how many cells to fill with this color\n        # The maximum is capped at the remaining available cells divided by the number of colors\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose cells to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled cells from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by upscaling the input grid by a factor of 2\n    go = upscale(gi, 2)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "c8cbb738": {
    "original": "def generate_c8cbb738(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    gh = unifint(diff_lb, diff_ub, (3, 10))\n    gw = unifint(diff_lb, diff_ub, (3, 10))\n    h = unifint(diff_lb, diff_ub, (gh*2, 30))\n    w = unifint(diff_lb, diff_ub, (gw*2, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, ncols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (gh, gw))\n    goinds = asindices(go)\n    ring = box(goinds)\n    crns = corners(ring)\n    remring = ring - crns\n    nrr = len(remring)\n    sc = ccols[0]\n    go = fill(go, sc, crns)\n    loci = randint(0, h - gh)\n    locj = randint(0, w - gw)\n    gi = fill(gi, sc, shift(crns, (loci, locj)))\n    ccols = ccols[1:]\n    issucc = True\n    bL = connect((0, 0), (gh - 1, 0))\n    bR = connect((0, gw - 1), (gh - 1, gw - 1))\n    bT = connect((0, 0), (0, gw - 1))\n    bB = connect((gh - 1, 0), (gh - 1, gw - 1))\n    validpairs = [(bL, bT), (bL, bB), (bR, bT), (bR, bB)]\n    for c in ccols:\n        if len(remring) < 3:\n            break\n        obj = set(sample(totuple(remring), unifint(diff_lb, diff_ub, (3, max(3, min(len(remring), nrr//len(ccols)))))))\n        flag = False\n        for b1, b2 in validpairs:\n            if len(obj & b1) > 0 and len(obj & b2) > 0:\n                flag = True\n                break\n        if flag:\n            oh, ow = shape(obj)\n            locs = ofcolor(gi, bgc)\n            cands = sfilter(locs, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) > 0:\n                objn = normalize(obj)\n                cands2 = sfilter(cands, lambda ij: shift(objn, ij).issubset(locs))\n                if len(cands2) > 0:\n                    loc = choice(totuple(cands2))\n                    gi = fill(gi, c, shift(objn, loc))\n                    go = fill(go, c, obj)\n                    remring -= obj\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c8cbb738(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Determine the height of the output grid, between 3 and 10\n    gh = unifint(diff_lb, diff_ub, (3, 10))\n    \n    # Determine the width of the output grid, between 3 and 10\n    gw = unifint(diff_lb, diff_ub, (3, 10))\n    \n    # Determine the height of the input grid, between twice the output height and 30\n    h = unifint(diff_lb, diff_ub, (gh*2, 30))\n    \n    # Determine the width of the input grid, between twice the output width and 30\n    w = unifint(diff_lb, diff_ub, (gw*2, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (excluding background), between 1 and 9\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select colors to use\n    ccols = sample(remcols, ncols)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (gh, gw))\n    \n    # Get all indices of the output grid\n    goinds = asindices(go)\n    \n    # Create a box (outline) of the output grid\n    ring = box(goinds)\n    \n    # Get the corner indices of the box\n    crns = corners(ring)\n    \n    # Remove the corners from the ring, leaving only the edges\n    remring = ring - crns\n    \n    # Count the number of cells in the remaining ring\n    nrr = len(remring)\n    \n    # Select the first color for the corners\n    sc = ccols[0]\n    \n    # Fill the corners of the output grid with the selected color\n    go = fill(go, sc, crns)\n    \n    # Randomly choose a location to place the corner pattern in the input grid\n    loci = randint(0, h - gh)\n    locj = randint(0, w - gw)\n    \n    # Fill the corners in the input grid at the chosen location\n    gi = fill(gi, sc, shift(crns, (loci, locj)))\n    \n    # Remove the first color from the list of colors to use\n    ccols = ccols[1:]\n    \n    # Flag to track if the generation is successful (unused in this function)\n    issucc = True\n    \n    # Define the left, right, top, and bottom edges of the output grid\n    bL = connect((0, 0), (gh - 1, 0))\n    bR = connect((0, gw - 1), (gh - 1, gw - 1))\n    bT = connect((0, 0), (0, gw - 1))\n    bB = connect((gh - 1, 0), (gh - 1, gw - 1))\n    \n    # Define valid pairs of edges (left-top, left-bottom, right-top, right-bottom)\n    validpairs = [(bL, bT), (bL, bB), (bR, bT), (bR, bB)]\n    \n    # Iterate through the remaining colors\n    for c in ccols:\n        # Break if there are fewer than 3 cells left in the ring\n        if len(remring) < 3:\n            break\n        \n        # Randomly select a number of cells from the remaining ring\n        obj = set(sample(totuple(remring), unifint(diff_lb, diff_ub, (3, max(3, min(len(remring), nrr//len(ccols)))))))\n        \n        # Flag to check if the object touches two adjacent edges\n        flag = False\n        \n        # Check if the object touches two adjacent edges\n        for b1, b2 in validpairs:\n            if len(obj & b1) > 0 and len(obj & b2) > 0:\n                flag = True\n                break\n        \n        # If the object touches two adjacent edges\n        if flag:\n            # Get the shape of the object\n            oh, ow = shape(obj)\n            \n            # Find all background-colored cells in the input grid\n            locs = ofcolor(gi, bgc)\n            \n            # Find all valid locations where the object can be placed in the input grid\n            cands = sfilter(locs, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            \n            # If there are valid locations\n            if len(cands) > 0:\n                # Normalize the object (shift to origin)\n                objn = normalize(obj)\n                \n                # Find locations where the entire object can be placed on background color\n                cands2 = sfilter(cands, lambda ij: shift(objn, ij).issubset(locs))\n                \n                # If there are still valid locations\n                if len(cands2) > 0:\n                    # Choose a random location\n                    loc = choice(totuple(cands2))\n                    \n                    # Place the object in the input grid at the chosen location\n                    gi = fill(gi, c, shift(objn, loc))\n                    \n                    # Place the object in the output grid\n                    go = fill(go, c, obj)\n                    \n                    # Remove the placed object from the remaining ring\n                    remring -= obj\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "c8f0f002": {
    "original": "def generate_c8f0f002(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(7, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(cols, numc)\n    c = canvas(-1, (h, w))\n    inds = totuple(asindices(c))\n    numo = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    orng = sample(inds, numo)\n    rem = difference(inds, orng)\n    gi = fill(c, 7, orng)\n    go = fill(c, 5, orng)\n    for ij in rem:\n        col = choice(ccols)\n        gi = fill(gi, col, {ij})\n        go = fill(go, col, {ij})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c8f0f002(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 7\n    cols = remove(7, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the number of colors to use (1-9) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select 'numc' colors from the available colors\n    ccols = sample(cols, numc)\n    \n    # Create an empty canvas of size (h, w) filled with -1\n    c = canvas(-1, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly determine the number of orange cells (0 to half the grid size)\n    numo = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly select 'numo' indices to be orange\n    orng = sample(inds, numo)\n    \n    # Get the remaining indices (non-orange)\n    rem = difference(inds, orng)\n    \n    # Create input grid: Fill orange cells with 7 (orange)\n    gi = fill(c, 7, orng)\n    \n    # Create output grid: Fill orange cells with 5 (light blue)\n    go = fill(c, 5, orng)\n    \n    # For each remaining (non-orange) cell:\n    for ij in rem:\n        # Randomly choose a color from the selected colors\n        col = choice(ccols)\n        \n        # Fill the cell in the input grid with the chosen color\n        gi = fill(gi, col, {ij})\n        \n        # Fill the corresponding cell in the output grid with the same color\n        go = fill(go, col, {ij})\n    \n    # Return a dictionary with 'input' and 'output' grids\n    return {'input': gi, 'output': go}\n"
  },
  "c909285e": {
    "original": "def generate_c909285e(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    nfronts = unifint(diff_lb, diff_ub, (1, (h + w) // 2))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    boxcol = choice(remcols)\n    remcols = remove(boxcol, remcols)\n    gi = canvas(bgc, (h, w))\n    inds = totuple(asindices(gi))\n    for k in range(nfronts):\n        ff = choice((hfrontier, vfrontier))\n        loc = choice(inds)\n        inds = remove(loc, inds)\n        col = choice(remcols)\n        gi = fill(gi, col, ff(loc))\n    oh = unifint(diff_lb, diff_ub, (3, max(3, (h - 2) // 2)))\n    ow = unifint(diff_lb, diff_ub, (3, max(3, (w - 2) // 2)))\n    loci = randint(1, h - oh - 1)\n    locj = randint(1, w - ow - 1)\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    gi = fill(gi, boxcol, bx)\n    go = subgrid(bx, gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c909285e(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 5 and 30\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid between 5 and 30\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the number of frontiers (lines) to be added\n    # The maximum number of frontiers is half the sum of height and width\n    nfronts = unifint(diff_lb, diff_ub, (1, (h + w) // 2))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the box outline\n    boxcol = choice(remcols)\n    \n    # Remove the box color from the remaining colors\n    remcols = remove(boxcol, remcols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Loop to add frontiers (lines) to the grid\n    for k in range(nfronts):\n        # Randomly choose between horizontal and vertical frontier\n        ff = choice((hfrontier, vfrontier))\n        \n        # Randomly choose a location for the frontier\n        loc = choice(inds)\n        \n        # Remove the chosen location from available indices\n        inds = remove(loc, inds)\n        \n        # Randomly choose a color for the frontier\n        col = choice(remcols)\n        \n        # Add the frontier to the grid with the chosen color\n        gi = fill(gi, col, ff(loc))\n    \n    # Randomly determine the height of the box to be extracted\n    oh = unifint(diff_lb, diff_ub, (3, max(3, (h - 2) // 2)))\n    \n    # Randomly determine the width of the box to be extracted\n    ow = unifint(diff_lb, diff_ub, (3, max(3, (w - 2) // 2)))\n    \n    # Randomly choose the top-left corner i-coordinate for the box\n    loci = randint(1, h - oh - 1)\n    \n    # Randomly choose the top-left corner j-coordinate for the box\n    locj = randint(1, w - ow - 1)\n    \n    # Create the box outline using the top-left and bottom-right corners\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Add the box outline to the grid using the box color\n    gi = fill(gi, boxcol, bx)\n    \n    # Extract the subgrid within the box as the output\n    go = subgrid(bx, gi)\n    \n    # Return a dictionary with the full grid as input and the extracted subgrid as output\n    return {'input': gi, 'output': go}\n"
  },
  "c9e6f938": {
    "original": "def generate_c9e6f938(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (1, 30)\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = hconcat(gi, vmirror(gi))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c9e6f938(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (1, 30)\n    \n    # Create a tuple of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a width between 1 and 15 based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 15))\n    \n    # Randomly select a background color from the color tuple\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the color options\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (0 to 9, or less if grid is smaller)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly select the colors to use from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Create a tuple of all grid indices\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Randomly choose how many cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly select the cells to fill\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by horizontally concatenating the input grid with its vertical mirror\n    go = hconcat(gi, vmirror(gi))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "c9f8e694": {
    "original": "def generate_c9f8e694(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    sqc = choice(remcols)\n    remcols = remove(sqc, remcols)\n    ncols = unifint(diff_lb, diff_ub, (1, min(h, 8)))\n    nsq = unifint(diff_lb, diff_ub, (1, 8))\n    gir = canvas(bgc, (h, w - 1))\n    gil = tuple((choice(remcols),) for j in range(h))\n    inds = asindices(gir)\n    succ = 0\n    fails = 0\n    maxfails = nsq * 5\n    while succ < nsq and fails < maxfails:\n        loci = randint(0, h - 3)\n        locj = randint(0, w - 3)\n        lock = randint(loci+1, min(loci + max(1, 2*h//3), h - 1))\n        locl = randint(locj+1, min(locj + max(1, 2*w//3), w - 1))\n        bd = backdrop(frozenset({(loci, locj), (lock, locl)}))\n        if bd.issubset(inds):\n            gir = fill(gir, sqc, bd)\n            succ += 1\n            indss = inds - bd\n        else:\n            fails += 1\n    locs = ofcolor(gir, sqc)\n    gil = tuple(e if idx in apply(first, locs) else (bgc,) for idx, e in enumerate(gil))\n    fullobj = toobject(locs, hupscale(gil, w))\n    gi = hconcat(gil, gir)\n    giro = paint(gir, fullobj)\n    go = hconcat(gil, giro)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_c9f8e694(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of column values from 1 to 9\n    cols = interval(1, 10, 1)\n    # Randomly choose a height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly choose a width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Set background color to 0 (black)\n    bgc = 0\n    # Remove background color from available colors\n    remcols = remove(bgc, cols)\n    # Randomly choose a color for squares\n    sqc = choice(remcols)\n    # Remove square color from remaining colors\n    remcols = remove(sqc, remcols)\n    # Randomly choose number of colors to use (between 1 and min(h, 8))\n    ncols = unifint(diff_lb, diff_ub, (1, min(h, 8)))\n    # Randomly choose number of squares to generate (between 1 and 8)\n    nsq = unifint(diff_lb, diff_ub, (1, 8))\n    # Create a canvas for the right part of the grid with background color\n    gir = canvas(bgc, (h, w - 1))\n    # Create a tuple of random colors for the left column\n    gil = tuple((choice(remcols),) for j in range(h))\n    # Get all indices of the right grid\n    inds = asindices(gir)\n    # Initialize counter for successful square placements\n    succ = 0\n    # Initialize counter for failed square placements\n    fails = 0\n    # Set maximum number of allowed failures\n    maxfails = nsq * 5\n\n    # Loop to place squares on the grid\n    while succ < nsq and fails < maxfails:\n        # Randomly choose top-left corner i-coordinate\n        loci = randint(0, h - 3)\n        # Randomly choose top-left corner j-coordinate\n        locj = randint(0, w - 3)\n        # Randomly choose bottom-right corner i-coordinate\n        lock = randint(loci+1, min(loci + max(1, 2*h//3), h - 1))\n        # Randomly choose bottom-right corner j-coordinate\n        locl = randint(locj+1, min(locj + max(1, 2*w//3), w - 1))\n        # Create a backdrop (rectangle) based on chosen corners\n        bd = backdrop(frozenset({(loci, locj), (lock, locl)}))\n        # Check if the backdrop fits within the grid\n        if bd.issubset(inds):\n            # Fill the backdrop with the square color\n            gir = fill(gir, sqc, bd)\n            # Increment success counter\n            succ += 1\n            # Remove filled indices from available indices\n            indss = inds - bd\n        else:\n            # Increment fail counter if placement is invalid\n            fails += 1\n\n    # Get locations of all squares in the right grid\n    locs = ofcolor(gir, sqc)\n    # Update left column colors based on square positions\n    gil = tuple(e if idx in apply(first, locs) else (bgc,) for idx, e in enumerate(gil))\n    # Create full object by combining left column info with right grid squares\n    fullobj = toobject(locs, hupscale(gil, w))\n    # Concatenate left column with right grid for input\n    gi = hconcat(gil, gir)\n    # Paint full object onto right grid for output\n    giro = paint(gir, fullobj)\n    # Concatenate left column with painted right grid for output\n    go = hconcat(gil, giro)\n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply chosen rotation to input grid\n    gi = rotf(gi)\n    # Apply chosen rotation to output grid\n    go = rotf(go)\n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "caa06a1f": {
    "original": "def generate_caa06a1f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    vp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    hp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    bgc = choice(cols)\n    numc = unifint(diff_lb, diff_ub, (2, min(8, max(2, hp * vp))))\n    remcols = remove(bgc, cols)\n    ccols = sample(remcols, numc)\n    remcols = difference(remcols, ccols)\n    tric = choice(remcols)\n    obj = {(choice(ccols), ij) for ij in asindices(canvas(-1, (vp, hp)))}\n    go = canvas(bgc, (h, w))\n    gi = canvas(bgc, (h, w))\n    for a in range(-vp, h+1, vp):\n        for b in range(-hp, w+1, hp):\n            go = paint(go, shift(obj, (a, b + 1)))\n    for a in range(-vp, h+1, vp):\n        for b in range(-hp, w+1, hp):\n            gi = paint(gi, shift(obj, (a, b)))\n    ioffs = unifint(diff_lb, diff_ub, (1, h - 2 * vp))\n    joffs = unifint(diff_lb, diff_ub, (1, w - 2 * hp))\n    for a in range(ioffs):\n        gi = fill(gi, tric, connect((a, 0), (a, w - 1)))\n    for b in range(joffs):\n        gi = fill(gi, tric, connect((0, b), (h - 1, b)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_caa06a1f(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Determine the vertical period (2 to half of height - 1)\n    vp = unifint(diff_lb, diff_ub, (2, h//2-1))\n    \n    # Determine the horizontal period (2 to half of width - 1)\n    hp = unifint(diff_lb, diff_ub, (2, w//2-1))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Determine the number of colors to use (2 to 8, or max of hp * vp)\n    numc = unifint(diff_lb, diff_ub, (2, min(8, max(2, hp * vp))))\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly select colors for the pattern\n    ccols = sample(remcols, numc)\n    \n    # Remove the selected colors from the remaining colors\n    remcols = difference(remcols, ccols)\n    \n    # Choose a color for the grid lines\n    tric = choice(remcols)\n    \n    # Create a random object pattern within the period\n    obj = {(choice(ccols), ij) for ij in asindices(canvas(-1, (vp, hp)))}\n    \n    # Initialize the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Initialize the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Paint the object pattern onto the output grid with a slight offset\n    for a in range(-vp, h+1, vp):\n        for b in range(-hp, w+1, hp):\n            go = paint(go, shift(obj, (a, b + 1)))\n    \n    # Paint the object pattern onto the input grid without offset\n    for a in range(-vp, h+1, vp):\n        for b in range(-hp, w+1, hp):\n            gi = paint(gi, shift(obj, (a, b)))\n    \n    # Determine vertical offset for grid lines\n    ioffs = unifint(diff_lb, diff_ub, (1, h - 2 * vp))\n    \n    # Determine horizontal offset for grid lines\n    joffs = unifint(diff_lb, diff_ub, (1, w - 2 * hp))\n    \n    # Draw vertical grid lines on the input grid\n    for a in range(ioffs):\n        gi = fill(gi, tric, connect((a, 0), (a, w - 1)))\n    \n    # Draw horizontal grid lines on the input grid\n    for b in range(joffs):\n        gi = fill(gi, tric, connect((0, b), (h - 1, b)))\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "cbded52d": {
    "original": "def generate_cbded52d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))\n    numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))\n    bgc, linc = sample(cols, 2)\n    remcols = difference(cols, (bgc, linc))\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))\n    ccols = sample(remcols, ncols)\n    fullh = numh * oh + numh - 1\n    fullw = numw * ow + numw - 1\n    gi = canvas(linc, (fullh, fullw))\n    sgi = asindices(canvas(bgc, (oh, ow)))\n    for a in range(numh):\n        for b in range(numw):\n            gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))\n    go = tuple(e for e in gi)\n    for col in ccols:\n        inds = ofcolor(go, bgc)\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        narms = randint(1, 4)\n        armdirs = sample(totuple(dneighbors((0, 0))), narms)\n        succ = 0\n        for armdir in armdirs:\n            x, y = armdir\n            arm = []\n            for k in range(1, max(numh, numw)):\n                nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))\n                if nextloc not in inds:\n                    break\n                arm.append(nextloc)\n            if len(arm) < 2:\n                continue\n            aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))\n            endp = arm[aidx]\n            gi = fill(gi, col, {endp})\n            go = fill(go, col, set(arm[:aidx+1]))\n            succ += 1\n        if succ > 0:\n            gi = fill(gi, col, {loc})\n            go = fill(go, col, {loc})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_cbded52d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of each object (1 to 4)\n    oh = unifint(diff_lb, diff_ub, (1, 4))\n    # Randomly determine the width of each object (1 to 4)\n    ow = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # Determine the number of objects vertically (3 to 31 divided by object height + 1)\n    numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))\n    # Determine the number of objects horizontally (3 to 31 divided by object width + 1)\n    numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))\n    \n    # Choose two random colors for background and lines\n    bgc, linc = sample(cols, 2)\n    # Get the remaining colors\n    remcols = difference(cols, (bgc, linc))\n    \n    # Determine the number of colors to use for objects (1 to min(8, (numh * numh) // 3))\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))\n    # Choose random colors for objects\n    ccols = sample(remcols, ncols)\n    \n    # Calculate the full height and width of the grid\n    fullh = numh * oh + numh - 1\n    fullw = numw * ow + numw - 1\n    \n    # Create the initial input grid with line color\n    gi = canvas(linc, (fullh, fullw))\n    # Create a small grid of background color\n    sgi = asindices(canvas(bgc, (oh, ow)))\n    \n    # Fill the input grid with background colored objects\n    for a in range(numh):\n        for b in range(numw):\n            gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))\n    \n    # Create the output grid as a copy of the input grid\n    go = tuple(e for e in gi)\n    \n    # Add colored objects to both input and output grids\n    for col in ccols:\n        # Find all background colored cells\n        inds = ofcolor(go, bgc)\n        # If no background cells left, stop adding objects\n        if len(inds) == 0:\n            break\n        # Choose a random background cell\n        loc = choice(totuple(inds))\n        # Determine number of arms for the object (1 to 4)\n        narms = randint(1, 4)\n        # Choose random directions for the arms\n        armdirs = sample(totuple(dneighbors((0, 0))), narms)\n        succ = 0\n        # For each arm direction\n        for armdir in armdirs:\n            x, y = armdir\n            arm = []\n            # Extend the arm until it hits a non-background cell\n            for k in range(1, max(numh, numw)):\n                nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))\n                if nextloc not in inds:\n                    break\n                arm.append(nextloc)\n            # If arm is too short, skip it\n            if len(arm) < 2:\n                continue\n            # Choose a random length for the arm\n            aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))\n            endp = arm[aidx]\n            # Color the endpoint in the input grid\n            gi = fill(gi, col, {endp})\n            # Color the entire arm in the output grid\n            go = fill(go, col, set(arm[:aidx+1]))\n            succ += 1\n        # If at least one arm was successful, color the center point\n        if succ > 0:\n            gi = fill(gi, col, {loc})\n            go = fill(go, col, {loc})\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "cce03e0d": {
    "original": "def generate_cce03e0d(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 8))    \n    h = unifint(diff_lb, diff_ub, (2, 5))\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    nred = unifint(diff_lb, diff_ub, (1, h * w - 1))\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, nred)))\n    ncells = unifint(diff_lb, diff_ub, (1, h * w - nred))\n    ccols = sample(cols, ncols)\n    gi = canvas(0, (h, w))\n    inds = asindices(gi)\n    reds = sample(totuple(inds), nred)\n    reminds = difference(inds, reds)\n    gi = fill(gi, 2, reds)\n    rest = sample(totuple(reminds), ncells)\n    rest = {(choice(ccols), ij) for ij in rest}\n    gi = paint(gi, rest)\n    go = canvas(0, (h**2, w**2))\n    locs = apply(rbind(multiply, (h, w)), reds)\n    res = mapply(lbind(shift, asobject(gi)), locs)\n    go = paint(go, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_cce03e0d(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 2 and 8\n    cols = difference(interval(0, 10, 1), (2, 8))    \n    \n    # Randomly determine height of the input grid (2 to 5)\n    h = unifint(diff_lb, diff_ub, (2, 5))\n    # Randomly determine width of the input grid (2 to 5)\n    w = unifint(diff_lb, diff_ub, (2, 5))\n    \n    # Determine number of red cells (color 2) in the input grid\n    nred = unifint(diff_lb, diff_ub, (1, h * w - 1))\n    # Determine number of other colors to use (1 to 8, but not more than nred)\n    ncols = unifint(diff_lb, diff_ub, (1, min(8, nred)))\n    # Determine number of non-red, non-black cells\n    ncells = unifint(diff_lb, diff_ub, (1, h * w - nred))\n    \n    # Randomly select colors to use (excluding red and black)\n    ccols = sample(cols, ncols)\n    \n    # Create an empty input grid filled with black (0)\n    gi = canvas(0, (h, w))\n    # Get all indices of the input grid\n    inds = asindices(gi)\n    # Randomly select positions for red cells\n    reds = sample(totuple(inds), nred)\n    # Get remaining indices (non-red positions)\n    reminds = difference(inds, reds)\n    \n    # Fill the selected positions with red (2)\n    gi = fill(gi, 2, reds)\n    # Randomly select positions for other colored cells\n    rest = sample(totuple(reminds), ncells)\n    # Assign random colors to the selected positions\n    rest = {(choice(ccols), ij) for ij in rest}\n    # Paint the other colored cells onto the grid\n    gi = paint(gi, rest)\n    \n    # Create an empty output grid (h^2 x w^2) filled with black (0)\n    go = canvas(0, (h**2, w**2))\n    # Calculate new positions for red cells in the output grid\n    locs = apply(rbind(multiply, (h, w)), reds)\n    # Create objects representing the input grid at each new red cell position\n    res = mapply(lbind(shift, asobject(gi)), locs)\n    # Paint these objects onto the output grid\n    go = paint(go, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "cdecee7f": {
    "original": "def generate_cdecee7f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    numc = unifint(diff_lb, diff_ub, (1, min(9, w)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numcols)\n    inds = interval(0, w, 1)\n    locs = sample(inds, numc)\n    locs = order(locs, identity)\n    gi = canvas(bgc, (h, w))\n    go = []\n    for j in locs:\n        iloc = randint(0, h - 1)\n        col = choice(ccols)\n        gi = fill(gi, col, {(iloc, j)})\n        go.append(col)\n    go = go + [bgc] * (9 - len(go))\n    go = tuple(go)\n    go = tuple([go[:3], go[3:6][::-1], go[6:]])\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_cdecee7f(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of integers from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Determine the number of colored columns, bounded by width and 9\n    numc = unifint(diff_lb, diff_ub, (1, min(9, w)))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (excluding background)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select colors to use\n    ccols = sample(remcols, numcols)\n    \n    # Create a range of indices for the width of the grid\n    inds = interval(0, w, 1)\n    \n    # Randomly select column indices for colored cells\n    locs = sample(inds, numc)\n    \n    # Sort the selected column indices\n    locs = order(locs, identity)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Initialize an empty list for the output colors\n    go = []\n    \n    # For each selected column:\n    for j in locs:\n        # Choose a random row index\n        iloc = randint(0, h - 1)\n        \n        # Choose a random color from the selected colors\n        col = choice(ccols)\n        \n        # Place the chosen color at the random location in the input grid\n        gi = fill(gi, col, {(iloc, j)})\n        \n        # Add the chosen color to the output list\n        go.append(col)\n    \n    # Pad the output list with background colors to ensure it has 9 elements\n    go = go + [bgc] * (9 - len(go))\n    \n    # Convert the output list to a tuple\n    go = tuple(go)\n    \n    # Reorganize the output tuple:\n    # First 3 elements remain in order\n    # Next 3 elements are reversed\n    # Last 3 elements remain in order\n    go = tuple([go[:3], go[3:6][::-1], go[6:]])\n    \n    # Return a dictionary with the input grid and the reorganized output tuple\n    return {'input': gi, 'output': go}\n"
  },
  "ce22a75a": {
    "original": "def generate_ce22a75a(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(1, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    ndots = unifint(diff_lb, diff_ub, (1, (h * w) // 3))\n    dots = sample(totuple(asindices(c)), ndots)\n    gi = fill(c, fgc, dots)\n    go = fill(c, 1, mapply(neighbors, dots))\n    go = fill(go, 1, dots)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ce22a75a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 1\n    cols = remove(1, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid (between 3 and 30)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid (between 3 and 30)\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Determine the number of dots to place (between 1 and 1/3 of the grid area)\n    ndots = unifint(diff_lb, diff_ub, (1, (h * w) // 3))\n    \n    # Randomly select positions for the dots\n    dots = sample(totuple(asindices(c)), ndots)\n    \n    # Create the input grid by filling the dot positions with the foreground color\n    gi = fill(c, fgc, dots)\n    \n    # Create the output grid:\n    # First, fill the neighbors of all dots with color 1\n    go = fill(c, 1, mapply(neighbors, dots))\n    # Then, fill the original dot positions with color 1\n    go = fill(go, 1, dots)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ce4f8723": {
    "original": "def generate_ce4f8723(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    barcol = choice(remcols)\n    remcols = remove(barcol, remcols)\n    cola = choice(remcols)\n    colb = choice(remove(cola, remcols))\n    canv = canvas(bgc, (h, w))\n    inds = totuple(asindices(canv))\n    gbar = canvas(barcol, (h, 1))\n    mp = (h * w) // 2\n    devrng = (0, mp)\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    deva = sgna * deva\n    devb = sgnb * devb\n    numa = mp + deva\n    numb = mp + devb\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gi = hconcat(hconcat(gia, gbar), gib)\n    go = fill(canv, 3, set(a) | set(b))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ce4f8723(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the separating bar\n    barcol = choice(remcols)\n    \n    # Remove the bar color from the remaining colors\n    remcols = remove(barcol, remcols)\n    \n    # Choose a random color for the first set of cells (A)\n    cola = choice(remcols)\n    \n    # Choose a random color for the second set of cells (B), different from A\n    colb = choice(remove(cola, remcols))\n    \n    # Create a canvas (grid) with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    \n    # Create a vertical bar with the bar color\n    gbar = canvas(barcol, (h, 1))\n    \n    # Calculate the midpoint of the total number of cells\n    mp = (h * w) // 2\n    \n    # Set the range for deviation from the midpoint\n    devrng = (0, mp)\n    \n    # Generate random deviations for A and B based on difficulty\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    \n    # Randomly choose signs for the deviations\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    \n    # Apply signs to the deviations\n    deva = sgna * deva\n    devb = sgnb * devb\n    \n    # Calculate the number of cells for A and B\n    numa = mp + deva\n    numb = mp + devb\n    \n    # Ensure the numbers of cells are within valid range\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    \n    # Randomly sample indices for A and B\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    \n    # Create input grids for A and B with their respective colors\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    \n    # Concatenate A, the separating bar, and B to form the input grid\n    gi = hconcat(hconcat(gia, gbar), gib)\n    \n    # Create the output grid by filling the union of A and B with color 3\n    go = fill(canv, 3, set(a) | set(b))\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ce602527": {
    "original": "def generate_ce602527(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    bgc, c1, c2, c3 = sample(cols, 4)\n    while True:\n        objs = []\n        for k in range(2):\n            oh1 = unifint(diff_lb, diff_ub, (3, h//3-1))\n            ow1 = unifint(diff_lb, diff_ub, (3, w//3-1))\n            cc1 = canvas(bgc, (oh1, ow1))\n            bounds1 = asindices(cc1)\n            numcd1 = unifint(diff_lb, diff_ub, (0, (oh1 * ow1) // 2 - 4))\n            numc1 = choice((numcd1, oh1 * ow1 - numcd1))\n            numc1 = min(max(3, numc1), oh1 * ow1 - 3)\n            obj1 = {choice(totuple(bounds1))}\n            while len(obj1) < numc1 or shape(obj1) != (oh1, ow1):\n                obj1.add(choice(totuple((bounds1 - obj1) & mapply(dneighbors, obj1))))\n            objs.append(normalize(obj1))\n        a, b = objs\n        ag = fill(canvas(0, shape(a)), 1, a)\n        bg = fill(canvas(0, shape(b)), 1, b)\n        maxinh = min(height(a), height(b)) // 2 + 1\n        maxinw = min(width(a), width(b)) // 2 + 1\n        maxshp = (maxinh, maxinw)\n        ag = crop(ag, (0, 0), maxshp)\n        bg = crop(bg, (0, 0), maxshp)\n        if ag != bg:\n            break\n    a, b = objs\n    trgo = choice(objs)\n    trgo2 = ofcolor(upscale(fill(canvas(0, shape(trgo)), 1, trgo), 2), 1)\n    staysinh = unifint(diff_lb, diff_ub, (maxinh * 2, height(trgo) * 2))\n    nout = height(trgo2) - staysinh\n    loci = h - height(trgo2) + nout\n    locj = randint(0, w - maxinw * 2)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, c3, shift(trgo2, (loci, locj)))\n    (lcol, lobj), (rcol, robj) = sample([(c1, a), (c2, b)], 2)\n    cands = ofcolor(gi, bgc) - box(asindices(gi))\n    lca = sfilter(cands, lambda ij: ij[1] < w//3*2)\n    rca = sfilter(cands, lambda ij: ij[1] > w//3)\n    lcands = sfilter(lca, lambda ij: shift(lobj, ij).issubset(lca))\n    rcands = sfilter(rca, lambda ij: shift(robj, ij).issubset(rca))\n    while True:\n        lloc = choice(totuple(lcands))\n        rloc = choice(totuple(lcands))\n        lplcd = shift(lobj, lloc)\n        rplcd = shift(robj, rloc)\n        if lplcd.issubset(cands) and rplcd.issubset(cands) and len(lplcd & rplcd) == 0:\n            break\n    gi = fill(gi, lcol, shift(lobj, lloc))\n    gi = fill(gi, rcol, shift(robj, rloc))\n    go = fill(canvas(bgc, shape(trgo)), c1 if trgo == a else c2, trgo)\n    mfs = (identity, rot90, rot180, rot270, cmirror, dmirror, hmirror, vmirror)\n    mf = choice(mfs)\n    gi, go = mf(gi), mf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ce602527(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 12 and 30\n    h = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Randomly determine the width of the grid between 12 and 30\n    w = unifint(diff_lb, diff_ub, (12, 30))\n    \n    # Randomly select 4 unique colors from the color range\n    bgc, c1, c2, c3 = sample(cols, 4)\n    \n    # Start an infinite loop to generate valid objects\n    while True:\n        objs = []\n        # Generate two objects\n        for k in range(2):\n            # Randomly determine the height of the object (between 3 and 1/3 of grid height)\n            oh1 = unifint(diff_lb, diff_ub, (3, h//3-1))\n            \n            # Randomly determine the width of the object (between 3 and 1/3 of grid width)\n            ow1 = unifint(diff_lb, diff_ub, (3, w//3-1))\n            \n            # Create a canvas of background color with the object's dimensions\n            cc1 = canvas(bgc, (oh1, ow1))\n            \n            # Get all possible indices in the object's canvas\n            bounds1 = asindices(cc1)\n            \n            # Randomly determine the number of cells to color (up to half the object's area)\n            numcd1 = unifint(diff_lb, diff_ub, (0, (oh1 * ow1) // 2 - 4))\n            \n            # Choose between coloring numcd1 cells or the complement\n            numc1 = choice((numcd1, oh1 * ow1 - numcd1))\n            \n            # Ensure at least 3 cells are colored and at least 3 are not\n            numc1 = min(max(3, numc1), oh1 * ow1 - 3)\n            \n            # Start with a random cell in the object\n            obj1 = {choice(totuple(bounds1))}\n            \n            # Grow the object by adding adjacent cells until it reaches the desired size and shape\n            while len(obj1) < numc1 or shape(obj1) != (oh1, ow1):\n                obj1.add(choice(totuple((bounds1 - obj1) & mapply(dneighbors, obj1))))\n            \n            # Normalize the object (move it to the origin) and add it to the list\n            objs.append(normalize(obj1))\n        \n        # Unpack the two generated objects\n        a, b = objs\n        \n        # Create binary representations of both objects\n        ag = fill(canvas(0, shape(a)), 1, a)\n        bg = fill(canvas(0, shape(b)), 1, b)\n        \n        # Determine the maximum possible height for comparison (up to half the smaller object's height)\n        maxinh = min(height(a), height(b)) // 2 + 1\n        \n        # Determine the maximum possible width for comparison (up to half the smaller object's width)\n        maxinw = min(width(a), width(b)) // 2 + 1\n        \n        # Combine max height and width into a tuple\n        maxshp = (maxinh, maxinw)\n        \n        # Crop both binary representations to the maximum shape\n        ag = crop(ag, (0, 0), maxshp)\n        bg = crop(bg, (0, 0), maxshp)\n        \n        # If the cropped representations are different, break the loop\n        if ag != bg:\n            break\n\n    # Unpack the final two objects\n    a, b = objs\n    \n    # Randomly choose one of the objects as the target\n    trgo = choice(objs)\n    \n    # Create a binary representation of the target object, upscaled by 2\n    trgo2 = ofcolor(upscale(fill(canvas(0, shape(trgo)), 1, trgo), 2), 1)\n    \n    # Determine how much of the upscaled object will be visible (at least the original size)\n    staysinh = unifint(diff_lb, diff_ub, (maxinh * 2, height(trgo) * 2))\n    \n    # Calculate how much of the object will be cut off\n    nout = height(trgo2) - staysinh\n    \n    # Determine the vertical position of the upscaled object (partially off the bottom)\n    loci = h - height(trgo2) + nout\n    \n    # Randomly determine the horizontal position of the upscaled object\n    locj = randint(0, w - maxinw * 2)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Place the upscaled target object on the input grid\n    gi = fill(gi, c3, shift(trgo2, (loci, locj)))\n    \n    # Randomly assign colors to the two original objects\n    (lcol, lobj), (rcol, robj) = sample([(c1, a), (c2, b)], 2)\n    \n    # Find all background-colored cells that are not on the border\n    cands = ofcolor(gi, bgc) - box(asindices(gi))\n    \n    # Divide candidates into left and right sections\n    lca = sfilter(cands, lambda ij: ij[1] < w//3*2)\n    rca = sfilter(cands, lambda ij: ij[1] > w//3)\n    \n    # Find valid positions for the left object\n    lcands = sfilter(lca, lambda ij: shift(lobj, ij).issubset(lca))\n    \n    # Find valid positions for the right object\n    rcands = sfilter(rca, lambda ij: shift(robj, ij).issubset(rca))\n    \n    # Keep trying until valid positions are found for both objects\n    while True:\n        # Choose random positions for left and right objects\n        lloc = choice(totuple(lcands))\n        rloc = choice(totuple(lcands))\n        \n        # Calculate the positions of the objects if placed\n        lplcd = shift(lobj, lloc)\n        rplcd = shift(robj, rloc)\n        \n        # If both objects fit and don't overlap, break the loop\n        if lplcd.issubset(cands) and rplcd.issubset(cands) and len(lplcd & rplcd) == 0:\n            break\n    \n    # Place the left object on the input grid\n    gi = fill(gi, lcol, shift(lobj, lloc))\n    \n    # Place the right object on the input grid\n    gi = fill(gi, rcol, shift(robj, rloc))\n    \n    # Create the output grid with just the target object\n    go = fill(canvas(bgc, shape(trgo)), c1 if trgo == a else c2, trgo)\n    \n    # Define a list of possible transformations\n    mfs = (identity, rot90, rot180, rot270, cmirror, dmirror, hmirror, vmirror)\n    \n    # Choose a random transformation\n    mf = choice(mfs)\n    \n    # Apply the chosen transformation to both input and output grids\n    gi, go = mf(gi), mf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ce9e57f2": {
    "original": "def generate_ce9e57f2(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    nbars = unifint(diff_lb, diff_ub, (2, (w - 2) // 2))\n    locopts = interval(1, w - 1, 1)\n    barlocs = []\n    for k in range(nbars):\n        if len(locopts) == 0:\n            break\n        loc = choice(locopts)\n        barlocs.append(loc)\n        locopts = remove(loc, locopts)\n        locopts = remove(loc + 1, locopts)\n        locopts = remove(loc - 1, locopts)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    colss = sample(remcols, numc)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for j in barlocs:\n        barloci = unifint(diff_lb, diff_ub, (1, h - 2))\n        fullbar = connect((0, j), (barloci, j))\n        halfbar = connect((0, j), (barloci // 2 if barloci % 2 == 1 else (barloci - 1) // 2, j))\n        barcol = choice(colss)\n        gi = fill(gi, barcol, fullbar)\n        go = fill(go, barcol, fullbar)\n        go = fill(go, 8, halfbar)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ce9e57f2(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))    \n    \n    # Generate random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate random number of bars between 2 and half the width minus 1\n    nbars = unifint(diff_lb, diff_ub, (2, (w - 2) // 2))\n    \n    # Create a list of possible bar locations (1 to width-1)\n    locopts = interval(1, w - 1, 1)\n    \n    # Initialize an empty list to store bar locations\n    barlocs = []\n    \n    # Loop to choose bar locations\n    for k in range(nbars):\n        # Break if no more location options available\n        if len(locopts) == 0:\n            break\n        \n        # Randomly choose a location for the bar\n        loc = choice(locopts)\n        \n        # Add the chosen location to barlocs\n        barlocs.append(loc)\n        \n        # Remove the chosen location and adjacent locations from options\n        locopts = remove(loc, locopts)\n        locopts = remove(loc + 1, locopts)\n        locopts = remove(loc - 1, locopts)\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (1-8)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample colors from remaining colors\n    colss = sample(remcols, numc)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Loop through each bar location\n    for j in barlocs:\n        # Choose a random height for the bar (1 to height-2)\n        barloci = unifint(diff_lb, diff_ub, (1, h - 2))\n        \n        # Create a full bar from top to chosen height\n        fullbar = connect((0, j), (barloci, j))\n        \n        # Create a half bar (half the height of full bar)\n        halfbar = connect((0, j), (barloci // 2 if barloci % 2 == 1 else (barloci - 1) // 2, j))\n        \n        # Choose a random color for the bar\n        barcol = choice(colss)\n        \n        # Fill the full bar in the input grid\n        gi = fill(gi, barcol, fullbar)\n        \n        # Fill the full bar in the output grid\n        go = fill(go, barcol, fullbar)\n        \n        # Fill the half bar with color 8 (grey) in the output grid\n        go = fill(go, 8, halfbar)\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply rotation to input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to output grid\n    go = rotf(go)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "cf98881b": {
    "original": "def generate_cf98881b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 9))\n    bgc, barcol, cola, colb, colc = sample(cols, 5)\n    canv = canvas(bgc, (h, w))\n    inds = totuple(asindices(canv))\n    gbar = canvas(barcol, (h, 1))\n    mp = (h * w) // 2\n    devrng = (0, mp)\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    devc = unifint(diff_lb, diff_ub, devrng)\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    sgnc = choice((+1, -1))\n    deva = sgna * deva\n    devb = sgnb * devb\n    devc = sgnc * devc\n    numa = mp + deva\n    numb = mp + devb\n    numc = mp + devc\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    numc = max(min(h * w - 1, numc), 1)\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    c = sample(inds, numc)\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gic = fill(canv, colc, c)\n    gi = hconcat(hconcat(hconcat(gia, gbar), hconcat(gib, gbar)), gic)\n    go = fill(gic, colb, b)\n    go = fill(go, cola, a)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_cf98881b(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate the width of each section of the grid between 2 and 9\n    w = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly select 5 unique colors from the color palette\n    bgc, barcol, cola, colb, colc = sample(cols, 5)\n    \n    # Create a canvas (grid) with the background color and dimensions (h, w)\n    canv = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    \n    # Create a vertical bar grid with the bar color\n    gbar = canvas(barcol, (h, 1))\n    \n    # Calculate the midpoint of the total number of cells\n    mp = (h * w) // 2\n    \n    # Set the range for deviations\n    devrng = (0, mp)\n    \n    # Randomly generate deviations for each color within the range\n    deva = unifint(diff_lb, diff_ub, devrng)\n    devb = unifint(diff_lb, diff_ub, devrng)\n    devc = unifint(diff_lb, diff_ub, devrng)\n    \n    # Randomly choose the sign (+1 or -1) for each deviation\n    sgna = choice((+1, -1))\n    sgnb = choice((+1, -1))\n    sgnc = choice((+1, -1))\n    \n    # Apply the signs to the deviations\n    deva = sgna * deva\n    devb = sgnb * devb\n    devc = sgnc * devc\n    \n    # Calculate the number of cells for each color\n    numa = mp + deva\n    numb = mp + devb\n    numc = mp + devc\n    \n    # Ensure the numbers are within valid range (1 to total cells - 1)\n    numa = max(min(h * w - 1, numa), 1)\n    numb = max(min(h * w - 1, numb), 1)\n    numc = max(min(h * w - 1, numc), 1)\n    \n    # Randomly sample indices for each color\n    a = sample(inds, numa)\n    b = sample(inds, numb)\n    c = sample(inds, numc)\n    \n    # Create grids with colored cells for each color\n    gia = fill(canv, cola, a)\n    gib = fill(canv, colb, b)\n    gic = fill(canv, colc, c)\n    \n    # Concatenate the colored grids horizontally with separator bars\n    gi = hconcat(hconcat(hconcat(gia, gbar), hconcat(gib, gbar)), gic)\n    \n    # Create the output grid by filling color b and then color a over color c\n    go = fill(gic, colb, b)\n    go = fill(go, cola, a)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d037b0a7": {
    "original": "def generate_d037b0a7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    nlocs = unifint(diff_lb, diff_ub, (1, w))\n    locs = sample(interval(0, w, 1), nlocs)\n    for j in locs:\n        col = choice(remcols)\n        loci = randint(0, h - 1)\n        loc = (loci, j)\n        gi = fill(gi, col, {loc})\n        go = fill(go, col, connect(loc, (h - 1, j)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d037b0a7(diff_lb: float, diff_ub: float) -> dict:\n    # Define a tuple of integers from 0 to 9 (representing possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly select the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a new tuple of colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly determine the number of columns to modify based on difficulty\n    nlocs = unifint(diff_lb, diff_ub, (1, w))\n    \n    # Randomly select 'nlocs' number of unique column indices\n    locs = sample(interval(0, w, 1), nlocs)\n    \n    # Iterate through the selected column indices\n    for j in locs:\n        # Choose a random color different from the background color\n        col = choice(remcols)\n        \n        # Select a random row index\n        loci = randint(0, h - 1)\n        \n        # Create a tuple representing the location (row, column)\n        loc = (loci, j)\n        \n        # In the input grid, set the color of the cell at 'loc'\n        gi = fill(gi, col, {loc})\n        \n        # In the output grid, create a vertical line from 'loc' to the bottom of the grid\n        go = fill(go, col, connect(loc, (h - 1, j)))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d06dbe63": {
    "original": "def generate_d06dbe63(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    obj1 = mapply(lbind(shift, frozenset({(-1, 0), (-2, 0), (-2, 1), (-2, 2)})), {(-k * 2, 2 * k) for k in range(15)})\n    obj2 = mapply(lbind(shift, frozenset({(1, 0), (2, 0), (2, -1), (2, -2)})), {(2 * k, -k * 2) for k in range(15)})\n    obj = obj1 | obj2\n    objf = lambda ij: shift(obj, ij)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    ndots = unifint(diff_lb, diff_ub, (1, min(h, w)))\n    succ = 0\n    tr = 0\n    maxtr = 4 * ndots\n    bgc, dotc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    fullinds = asindices(gi)\n    while tr < maxtr and succ < ndots:\n        tr += 1\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        objx = objf(loc)\n        if (objx & fullinds).issubset(inds):\n            succ += 1\n            inds = (inds - objx) - {loc}\n            gi = fill(gi, dotc, {loc})\n            go = fill(go, dotc, {loc})\n            go = fill(go, 5, objx)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d06dbe63(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 5\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Define the first part of the object shape (upward-pointing arrow)\n    obj1 = mapply(lbind(shift, frozenset({(-1, 0), (-2, 0), (-2, 1), (-2, 2)})), {(-k * 2, 2 * k) for k in range(15)})\n    \n    # Define the second part of the object shape (downward-pointing arrow)\n    obj2 = mapply(lbind(shift, frozenset({(1, 0), (2, 0), (2, -1), (2, -2)})), {(2 * k, -k * 2) for k in range(15)})\n    \n    # Combine both parts to form the complete object shape\n    obj = obj1 | obj2\n    \n    # Create a function to shift the object to a given position\n    objf = lambda ij: shift(obj, ij)\n    \n    # Randomly determine the height of the grid\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the number of dots to place\n    ndots = unifint(diff_lb, diff_ub, (1, min(h, w)))\n    \n    # Initialize success counter\n    succ = 0\n    \n    # Initialize try counter\n    tr = 0\n    \n    # Set maximum number of tries\n    maxtr = 4 * ndots\n    \n    # Randomly select background color and dot color\n    bgc, dotc = sample(cols, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Keep a copy of all indices\n    fullinds = asindices(gi)\n    \n    # Loop to place dots and their corresponding objects\n    while tr < maxtr and succ < ndots:\n        # Increment try counter\n        tr += 1\n        \n        # If no more valid positions, break the loop\n        if len(inds) == 0:\n            break\n        \n        # Randomly choose a location for the dot\n        loc = choice(totuple(inds))\n        \n        # Create the object at the chosen location\n        objx = objf(loc)\n        \n        # Check if the object fits within the grid and doesn't overlap with existing objects\n        if (objx & fullinds).issubset(inds):\n            # Increment success counter\n            succ += 1\n            \n            # Remove object positions and dot location from available indices\n            inds = (inds - objx) - {loc}\n            \n            # Place dot in input grid\n            gi = fill(gi, dotc, {loc})\n            \n            # Place dot in output grid\n            go = fill(go, dotc, {loc})\n            \n            # Place object in output grid\n            go = fill(go, 5, objx)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d07ae81c": {
    "original": "def generate_d07ae81c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    lnf = lambda ij: shoot(ij, (1, 1)) | shoot(ij, (-1, -1)) | shoot(ij, (-1, 1)) | shoot(ij, (1, -1))\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    c1, c2, c3, c4 = sample(cols, 4)\n    magiccol = 0\n    gi = canvas(0, (h, w))\n    ndivi = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    for k in range(ndivi):\n        objs = objects(gi, T, F, F)\n        objs = sfilter(objs, lambda o: min(shape(o)) > 3 and max(shape(o)) > 4)\n        objs = sfilter(objs, lambda o: height(o) * width(o) == len(o))\n        if len(objs) == 0:\n            break\n        obj = choice(totuple(objs))\n        if choice((True, False)):\n            loci = randint(uppermost(obj)+2, lowermost(obj)-1)\n            newobj = backdrop(frozenset({(loci, leftmost(obj)), lrcorner(obj)}))\n        else:\n            locj = randint(leftmost(obj)+2, rightmost(obj)-1)\n            newobj = backdrop(frozenset({(uppermost(obj), locj), lrcorner(obj)}))\n        magiccol += 1\n        gi = fill(gi, magiccol, newobj)\n    objs = objects(gi, T, F, F)\n    for ii, obj in enumerate(objs):\n        col = c1 if ii == 0 else (c2 if ii == 1 else choice((c1, c2)))\n        gi = fill(gi, col, toindices(obj))\n    ofc1 = ofcolor(gi, c1)\n    ofc2 = ofcolor(gi, c2)\n    mn = min(len(ofc1), len(ofc2))\n    n1 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))\n    n2 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))\n    srcs1 = set()\n    for k in range(n1):\n        cands = totuple((ofc1 - srcs1) - mapply(neighbors, srcs1))\n        if len(cands) == 0:\n            break\n        srcs1.add(choice(cands))\n    srcs2 = set()\n    for k in range(n2):\n        cands = totuple((ofc2 - srcs2) - mapply(neighbors, srcs2))\n        if len(cands) == 0:\n            break\n        srcs2.add(choice(cands))\n    gi = fill(gi, c3, srcs1)\n    gi = fill(gi, c4, srcs2)\n    lns = mapply(lnf, srcs1) | mapply(lnf, srcs2)\n    ofc3 = ofc1 & lns\n    ofc4 = ofc2 & lns\n    go = fill(gi, c3, ofc3)\n    go = fill(go, c4, ofc4)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d07ae81c(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Define a lambda function that creates diagonal lines from a given point\n    lnf = lambda ij: shoot(ij, (1, 1)) | shoot(ij, (-1, -1)) | shoot(ij, (-1, 1)) | shoot(ij, (1, -1))\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select 4 unique colors\n    c1, c2, c3, c4 = sample(cols, 4)\n    \n    # Initialize a counter for generating new colors\n    magiccol = 0\n    \n    # Create an empty canvas (grid) filled with zeros\n    gi = canvas(0, (h, w))\n    \n    # Determine number of divisions to make, between 1 and 10% of total cells\n    ndivi = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    \n    # Loop to create divisions on the grid\n    for k in range(ndivi):\n        # Find all objects (connected components) in the grid\n        objs = objects(gi, T, F, F)\n        \n        # Filter objects to keep only those with minimum dimension > 3 and maximum dimension > 4\n        objs = sfilter(objs, lambda o: min(shape(o)) > 3 and max(shape(o)) > 4)\n        \n        # Further filter to keep only rectangular objects\n        objs = sfilter(objs, lambda o: height(o) * width(o) == len(o))\n        \n        # If no suitable objects remain, end the loop\n        if len(objs) == 0:\n            break\n        \n        # Randomly select one object\n        obj = choice(totuple(objs))\n        \n        # Randomly decide to make a horizontal or vertical division\n        if choice((True, False)):\n            # Make a horizontal division\n            loci = randint(uppermost(obj)+2, lowermost(obj)-1)\n            newobj = backdrop(frozenset({(loci, leftmost(obj)), lrcorner(obj)}))\n        else:\n            # Make a vertical division\n            locj = randint(leftmost(obj)+2, rightmost(obj)-1)\n            newobj = backdrop(frozenset({(uppermost(obj), locj), lrcorner(obj)}))\n        \n        # Increment the color counter\n        magiccol += 1\n        \n        # Fill the new division with the new color\n        gi = fill(gi, magiccol, newobj)\n    \n    # Find all objects in the grid after divisions\n    objs = objects(gi, T, F, F)\n    \n    # Color the objects with c1 and c2\n    for ii, obj in enumerate(objs):\n        col = c1 if ii == 0 else (c2 if ii == 1 else choice((c1, c2)))\n        gi = fill(gi, col, toindices(obj))\n    \n    # Find all cells of color c1 and c2\n    ofc1 = ofcolor(gi, c1)\n    ofc2 = ofcolor(gi, c2)\n    \n    # Determine the minimum number of cells of either color\n    mn = min(len(ofc1), len(ofc2))\n    \n    # Determine number of source points for each color\n    n1 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))\n    n2 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))\n    \n    # Select source points for c1\n    srcs1 = set()\n    for k in range(n1):\n        cands = totuple((ofc1 - srcs1) - mapply(neighbors, srcs1))\n        if len(cands) == 0:\n            break\n        srcs1.add(choice(cands))\n    \n    # Select source points for c2\n    srcs2 = set()\n    for k in range(n2):\n        cands = totuple((ofc2 - srcs2) - mapply(neighbors, srcs2))\n        if len(cands) == 0:\n            break\n        srcs2.add(choice(cands))\n    \n    # Color the source points with c3 and c4\n    gi = fill(gi, c3, srcs1)\n    gi = fill(gi, c4, srcs2)\n    \n    # Generate diagonal lines from all source points\n    lns = mapply(lnf, srcs1) | mapply(lnf, srcs2)\n    \n    # Find intersections of diagonal lines with c1 and c2 areas\n    ofc3 = ofc1 & lns\n    ofc4 = ofc2 & lns\n    \n    # Create the output grid by coloring the intersections\n    go = fill(gi, c3, ofc3)\n    go = fill(go, c4, ofc4)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d0f5fe59": {
    "original": "def generate_d0f5fe59(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 9)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    nfound = 0\n    trials = 0\n    maxtrials = nobjs * 5\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while trials < maxtrials and nfound < nobjs:\n        oh = unifint(diff_lb, diff_ub, (1, 5))\n        ow = unifint(diff_lb, diff_ub, (1, 5))\n        bx = asindices(canvas(-1, (oh, ow)))\n        sp = choice(totuple(bx))\n        shp = {sp}\n        dev = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        ncells = choice((dev, oh * ow - dev))\n        ncells = min(max(1, ncells), oh * ow - 1)\n        for k in range(ncells):\n            ij = choice(totuple((bx - shp) & mapply(dneighbors, shp)))\n            shp.add(ij)\n        shp = normalize(shp)\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        plcd = shift(shp, loc)\n        if plcd.issubset(inds):\n            gi = fill(gi, fgc, plcd)\n            inds = (inds - plcd) - mapply(neighbors, plcd)\n            nfound += 1\n        trials += 1\n    go = canvas(bgc, (nfound, nfound))\n    go = fill(go, fgc, connect((0, 0), (nfound - 1, nfound - 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d0f5fe59(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the input grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Determine the number of objects to place, between 1 and min(30, (h * w) // 9)\n    nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 9)))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Initialize counters for placed objects and placement attempts\n    nfound = 0\n    trials = 0\n    maxtrials = nobjs * 5\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Start placing objects on the grid\n    while trials < maxtrials and nfound < nobjs:\n        # Randomly determine the height of the object between 1 and 5\n        oh = unifint(diff_lb, diff_ub, (1, 5))\n        \n        # Randomly determine the width of the object between 1 and 5\n        ow = unifint(diff_lb, diff_ub, (1, 5))\n        \n        # Create a bounding box for the object\n        bx = asindices(canvas(-1, (oh, ow)))\n        \n        # Choose a random starting point for the object\n        sp = choice(totuple(bx))\n        shp = {sp}\n        \n        # Determine the deviation in object size\n        dev = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))\n        \n        # Determine the number of cells for the object\n        ncells = choice((dev, oh * ow - dev))\n        ncells = min(max(1, ncells), oh * ow - 1)\n        \n        # Generate the shape of the object\n        for k in range(ncells):\n            # Choose a neighboring cell to add to the shape\n            ij = choice(totuple((bx - shp) & mapply(dneighbors, shp)))\n            shp.add(ij)\n        \n        # Normalize the shape (move it to the origin)\n        shp = normalize(shp)\n        \n        # If there are no more available indices, break the loop\n        if len(inds) == 0:\n            break\n        \n        # Choose a random location to place the object\n        loc = choice(totuple(inds))\n        \n        # Shift the object to the chosen location\n        plcd = shift(shp, loc)\n        \n        # If the object fits within the available indices\n        if plcd.issubset(inds):\n            # Place the object on the grid\n            gi = fill(gi, fgc, plcd)\n            \n            # Remove the placed cells and their neighbors from available indices\n            inds = (inds - plcd) - mapply(neighbors, plcd)\n            \n            # Increment the counter of placed objects\n            nfound += 1\n        \n        # Increment the trial counter\n        trials += 1\n    \n    # Create the output grid with dimensions equal to the number of objects placed\n    go = canvas(bgc, (nfound, nfound))\n    \n    # Draw a diagonal line on the output grid\n    go = fill(go, fgc, connect((0, 0), (nfound - 1, nfound - 1)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d10ecb37": {
    "original": "def generate_d10ecb37(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = crop(gi, (0, 0), (2, 2))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d10ecb37(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of color values from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid between 2 and 30\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (besides the background color)\n    # The maximum is either 9 or the total number of cells, whichever is smaller\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly choose the colors to be used\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Determine how many cells will be filled with this color\n        # The maximum is either 1 or the remaining cells divided by the number of colors, whichever is larger\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly choose the cells to be filled with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen cells with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Create the output grid by taking the top-left 2x2 subgrid of the input grid\n    go = crop(gi, (0, 0), (2, 2))\n    \n    # Return a dictionary with the input grid and the output grid\n    return {'input': gi, 'output': go}\n"
  },
  "d13f3404": {
    "original": "def generate_d13f3404(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    vopts = {(ii, 0) for ii in interval(0, h, 1)}\n    hopts = {(0, jj) for jj in interval(1, w, 1)}\n    opts = tuple(vopts | hopts)\n    num = unifint(diff_lb, diff_ub, (1, len(opts)))\n    locs = sample(opts, num)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h*2, w*2))\n    inds = asindices(gi)\n    for loc in locs:\n        ln = tuple(shoot(loc, (1, 1)) & inds)\n        locc = choice(ln)\n        col = choice(remcols)\n        gi = fill(gi, col, {locc})\n        go = fill(go, col, shoot(locc, (1, 1)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d13f3404(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the input grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Randomly determine the width of the input grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Create a set of tuples representing all possible vertical positions on the left edge\n    vopts = {(ii, 0) for ii in interval(0, h, 1)}\n    \n    # Create a set of tuples representing all possible horizontal positions on the top edge (excluding top-left corner)\n    hopts = {(0, jj) for jj in interval(1, w, 1)}\n    \n    # Combine vertical and horizontal options into a tuple of all possible starting positions\n    opts = tuple(vopts | hopts)\n    \n    # Randomly determine the number of lines to draw based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, len(opts)))\n    \n    # Randomly select 'num' starting positions from the available options\n    locs = sample(opts, num)\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid (twice the size of input) filled with the background color\n    go = canvas(bgc, (h*2, w*2))\n    \n    # Get all valid indices of the input grid\n    inds = asindices(gi)\n    \n    # Iterate through each selected starting position\n    for loc in locs:\n        # Create a diagonal line from the starting position, bounded by the grid size\n        ln = tuple(shoot(loc, (1, 1)) & inds)\n        \n        # Randomly choose a position on this diagonal line\n        locc = choice(ln)\n        \n        # Randomly choose a color (different from background) for this line\n        col = choice(remcols)\n        \n        # Place a colored pixel at the chosen position in the input grid\n        gi = fill(gi, col, {locc})\n        \n        # Draw a diagonal line of the same color in the output grid, starting from the corresponding position\n        go = fill(go, col, shoot(locc, (1, 1)))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d22278a0": {
    "original": "def generate_d22278a0(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    crns = corners(inds)\n    ncorns = unifint(diff_lb, diff_ub, (1, 4))\n    crns = sample(totuple(crns), ncorns)\n    ccols = sample(remcols, ncorns)\n    for col, crn in zip(ccols, crns):\n        gi = fill(gi, col, {crn})\n        go = fill(go, col, {crn})\n        rings = {crn}\n        for k in range(1, max(h, w) // 2 + 2, 1):\n            rings = rings | outbox(outbox(rings))\n        if len(crns) > 1:\n            ff = lambda ij: manhattan({ij}, {crn}) < min(apply(rbind(manhattan, {ij}), apply(initset, remove(crn, crns))))\n        else:\n            ff = lambda ij: True\n        locs = sfilter(inds, ff) & rings\n        go = fill(go, col, locs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d22278a0(diff_lb: float, diff_ub: float) -> dict:\n    # Generate a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Get all indices of the grid\n    inds = asindices(gi)\n    # Get the corner indices of the grid\n    crns = corners(inds)\n    # Randomly determine the number of corners to use (1 to 4)\n    ncorns = unifint(diff_lb, diff_ub, (1, 4))\n    # Randomly select 'ncorns' number of corners\n    crns = sample(totuple(crns), ncorns)\n    # Randomly select 'ncorns' number of colors (different from background)\n    ccols = sample(remcols, ncorns)\n    # Iterate through the selected colors and corners\n    for col, crn in zip(ccols, crns):\n        # Fill the corner cell with the selected color in the input grid\n        gi = fill(gi, col, {crn})\n        # Fill the corner cell with the selected color in the output grid\n        go = fill(go, col, {crn})\n        # Initialize the set of cells to be colored (starting with the corner)\n        rings = {crn}\n        # Expand the rings outward from the corner\n        for k in range(1, max(h, w) // 2 + 2, 1):\n            # Add the next outer ring of cells\n            rings = rings | outbox(outbox(rings))\n        # If there's more than one corner being used\n        if len(crns) > 1:\n            # Define a function to check if a cell is closer to this corner than others\n            ff = lambda ij: manhattan({ij}, {crn}) < min(apply(rbind(manhattan, {ij}), apply(initset, remove(crn, crns))))\n        else:\n            # If only one corner, include all cells\n            ff = lambda ij: True\n        # Filter cells that are within the rings and satisfy the distance condition\n        locs = sfilter(inds, ff) & rings\n        # Fill the selected cells with the current color in the output grid\n        go = fill(go, col, locs)\n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d23f8c26": {
    "original": "def generate_d23f8c26(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (2, 30))\n    wh = unifint(diff_lb, diff_ub, (1, 14))\n    w = 2 * wh + 1\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    numn = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    remcols = sample(remcols, numcols)\n    inds = totuple(asindices(gi))\n    locs = sample(inds, numn)\n    for ij in locs:\n        col = choice(remcols)\n        gi = fill(gi, col, {ij})\n        a, b = ij\n        if b == w // 2:\n            go = fill(go, col, {ij})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d23f8c26(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)    \n    \n    # Randomly generate the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly generate half the width (minus the middle column) between 1 and 14\n    wh = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Calculate the full width (always odd due to the middle column)\n    w = 2 * wh + 1\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a tuple of remaining colors (all colors except the background color)\n    remcols = remove(bgc, cols)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Randomly generate the number of non-background cells (between 1 and half the grid size minus 1)\n    numn = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    \n    # Randomly choose how many different colors to use (between 1 and 9)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample the colors to be used\n    remcols = sample(remcols, numcols)\n    \n    # Get all possible cell indices in the grid\n    inds = totuple(asindices(gi))\n    \n    # Randomly choose locations for non-background cells\n    locs = sample(inds, numn)\n    \n    # Iterate through the chosen locations\n    for ij in locs:\n        # Choose a random color for this cell\n        col = choice(remcols)\n        \n        # Fill the cell in the input grid with the chosen color\n        gi = fill(gi, col, {ij})\n        \n        # Unpack the cell coordinates\n        a, b = ij\n        \n        # If the cell is in the middle column\n        if b == w // 2:\n            # Fill the corresponding cell in the output grid with the same color\n            go = fill(go, col, {ij})\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d2abd087": {
    "original": "def generate_d2abd087(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc = choice(difference(cols, (1, 2)))\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    maxtrials = 4 * nobjs\n    tr = 0\n    succ = 0\n    while succ < nobjs and tr <= maxtrials:\n        if len(inds) == 0:\n            break\n        opts = asindices(canvas(-1, (5, 5)))\n        sp = choice(totuple(opts))\n        opts = remove(sp, opts)\n        lb = unifint(diff_lb, diff_ub, (1, 5))\n        lopts = interval(lb, 6, 1)\n        ubi = unifint(diff_lb, diff_ub, (1, 5))\n        ub = 12 - ubi\n        uopts = interval(7, ub + 1, 1)\n        if choice((True, False)):\n            numcells = 6\n        else:\n            numcells = choice(lopts + uopts)\n        obj = {sp}\n        for k in range(numcells - 1):\n            obj.add(choice(totuple((opts - obj) & mapply(dneighbors, obj))))\n        obj = normalize(obj)\n        loc = choice(totuple(inds))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds):\n            gi = fill(gi, choice(remcols), plcd)\n            go = fill(go, 1 + (len(obj) == 6), plcd)\n            succ += 1\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d2abd087(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 8 and 30\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly determine the width of the grid between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Choose a background color that is not 1 or 2\n    bgc = choice(difference(cols, (1, 2)))\n    \n    # Create a list of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Determine the number of objects to place (between 1 and 10% of grid size)\n    nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * nobjs\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placements counter\n    succ = 0\n    \n    # Start placing objects\n    while succ < nobjs and tr <= maxtrials:\n        # Break if no more available indices\n        if len(inds) == 0:\n            break\n        \n        # Create a 5x5 grid of options for object shape\n        opts = asindices(canvas(-1, (5, 5)))\n        \n        # Choose a starting point for the object\n        sp = choice(totuple(opts))\n        \n        # Remove the starting point from options\n        opts = remove(sp, opts)\n        \n        # Determine lower bound for object size (between 1 and 5)\n        lb = unifint(diff_lb, diff_ub, (1, 5))\n        \n        # Create range of options for small objects\n        lopts = interval(lb, 6, 1)\n        \n        # Determine upper bound for large objects\n        ubi = unifint(diff_lb, diff_ub, (1, 5))\n        ub = 12 - ubi\n        \n        # Create range of options for large objects\n        uopts = interval(7, ub + 1, 1)\n        \n        # Decide if object will have exactly 6 cells or a random size\n        if choice((True, False)):\n            numcells = 6\n        else:\n            numcells = choice(lopts + uopts)\n        \n        # Initialize object with starting point\n        obj = {sp}\n        \n        # Grow the object to desired size\n        for k in range(numcells - 1):\n            obj.add(choice(totuple((opts - obj) & mapply(dneighbors, obj))))\n        \n        # Normalize object position\n        obj = normalize(obj)\n        \n        # Choose a random location on the grid\n        loc = choice(totuple(inds))\n        \n        # Shift object to chosen location\n        plcd = shift(obj, loc)\n        \n        # Check if object fits on the grid\n        if plcd.issubset(inds):\n            # Place object on input grid with a random color\n            gi = fill(gi, choice(remcols), plcd)\n            \n            # Place object on output grid: 2 if size is 6, else 1\n            go = fill(go, 1 + (len(obj) == 6), plcd)\n            \n            # Increment successful placements counter\n            succ += 1\n            \n            # Remove placed object and its neighbors from available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d364b489": {
    "original": "def generate_d364b489(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 6, 7, 8))    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    inds = totuple(asindices(gi))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 5))\n    res = set()\n    for j in range(num):\n        if len(inds) == 0:\n            break\n        r = choice(inds)\n        inds = remove(r, inds)\n        inds = difference(inds, neighbors(r))\n        inds = difference(inds, totuple(shift(apply(rbind(multiply, TWO), dneighbors(ORIGIN)), r)))\n        res.add(r)\n    gi = fill(gi, fgc, res)\n    go = fill(gi, 7, shift(res, LEFT))\n    go = fill(go, 6, shift(res, RIGHT))\n    go = fill(go, 8, shift(res, DOWN))\n    go = fill(go, 2, shift(res, UP))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d364b489(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of color values excluding 2, 6, 7, and 8\n    cols = difference(interval(0, 10, 1), (2, 6, 7, 8))    \n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select two colors from the available colors\n    bgc, fgc = sample(cols, 2)\n    \n    # Create a canvas (input grid) with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Determine the number of foreground cells (1 to 20% of total cells)\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 5))\n    \n    # Initialize an empty set to store selected cell positions\n    res = set()\n    \n    # Loop to select foreground cell positions\n    for j in range(num):\n        # Break if no more valid positions are available\n        if len(inds) == 0:\n            break\n        \n        # Choose a random position from available indices\n        r = choice(inds)\n        \n        # Remove the chosen position from available indices\n        inds = remove(r, inds)\n        \n        # Remove neighboring cells from available indices\n        inds = difference(inds, neighbors(r))\n        \n        # Remove cells at a distance of 2 in cardinal directions\n        inds = difference(inds, totuple(shift(apply(rbind(multiply, TWO), dneighbors(ORIGIN)), r)))\n        \n        # Add the chosen position to the result set\n        res.add(r)\n    \n    # Fill the selected positions with the foreground color in the input grid\n    gi = fill(gi, fgc, res)\n    \n    # Create the output grid by filling shifted positions:\n    # Fill left-shifted positions with color 7\n    go = fill(gi, 7, shift(res, LEFT))\n    # Fill right-shifted positions with color 6\n    go = fill(go, 6, shift(res, RIGHT))\n    # Fill down-shifted positions with color 8\n    go = fill(go, 8, shift(res, DOWN))\n    # Fill up-shifted positions with color 2\n    go = fill(go, 2, shift(res, UP))\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d406998b": {
    "original": "def generate_d406998b(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    bgc, dotc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    itv = interval(0, h, 1)\n    for j in range(w):\n        nilocs = unifint(diff_lb, diff_ub, (1, h // 2 - 1 if h % 2 == 0 else h // 2))\n        ilocs = sample(itv, nilocs)\n        locs = {(ii, j) for ii in ilocs}\n        gi = fill(gi, dotc, locs)\n        go = fill(go, dotc if (j - w) % 2 == 0 else 3, locs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d406998b(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range 0-9 and store the result in 'cols'\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly select two colors from 'cols': one for background and one for dots\n    bgc, dotc = sample(cols, 2)\n    \n    # Create an input grid 'gi' filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create an output grid 'go' filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Create a range of integers from 0 to h-1\n    itv = interval(0, h, 1)\n    \n    # Iterate through each column of the grid\n    for j in range(w):\n        # Determine the number of dots to place in this column (between 1 and half the height)\n        nilocs = unifint(diff_lb, diff_ub, (1, h // 2 - 1 if h % 2 == 0 else h // 2))\n        \n        # Randomly select 'nilocs' number of row indices from 'itv'\n        ilocs = sample(itv, nilocs)\n        \n        # Create a set of (row, column) coordinates for the dots\n        locs = {(ii, j) for ii in ilocs}\n        \n        # Place dots of color 'dotc' in the input grid at the selected locations\n        gi = fill(gi, dotc, locs)\n        \n        # Place dots in the output grid:\n        # - Use 'dotc' for even-indexed columns (counting from right)\n        # - Use color 3 for odd-indexed columns (counting from right)\n        go = fill(go, dotc if (j - w) % 2 == 0 else 3, locs)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d43fd935": {
    "original": "def generate_d43fd935(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    boxh = unifint(diff_lb, diff_ub, (2, h // 2))\n    boxw = unifint(diff_lb, diff_ub, (2, w // 2))\n    loci = randint(0, h - boxh)\n    locj = randint(0, w - boxw)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ccol = choice(remcols)\n    remcols = remove(ccol, remcols)\n    ndcols = unifint(diff_lb, diff_ub, (1, 8))\n    dcols = sample(remcols, ndcols)\n    bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, ccol, bd)\n    reminds = totuple(asindices(gi) - bd)\n    noiseb = max(1, len(reminds) // 4)\n    nnoise = unifint(diff_lb, diff_ub, (0, noiseb))\n    noise = sample(reminds, nnoise)\n    truenoise = sfilter(noise, lambda ij: (ij[0] < loci or ij[0] > loci + boxh - 1) and (ij[1] < locj or ij[1] > locj + boxw - 1))\n    rem = difference(noise, truenoise)\n    top = sfilter(rem, lambda ij: ij[0] < loci)\n    bottom = sfilter(rem, lambda ij: ij[0] > loci + boxh - 1)\n    left = sfilter(rem, lambda ij: ij[1] < locj)\n    right = sfilter(rem, lambda ij: ij[1] > locj + boxw - 1)\n    truenoiseobj = {(choice(dcols), ij) for ij in truenoise}\n    gi = paint(gi, truenoiseobj)\n    go = tuple(e for e in gi)\n    for jj in apply(last, top):\n        col = choice(dcols)\n        mf = matcher(last, jj)\n        subs = sfilter(top, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((valmin(subs, first), jj), (loci - 1, jj)))\n    for jj in apply(last, bottom):\n        col = choice(dcols)\n        mf = matcher(last, jj)\n        subs = sfilter(bottom, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((valmax(subs, first), jj), (loci + boxh, jj)))\n    for ii in apply(first, left):\n        col = choice(dcols)\n        mf = matcher(first, ii)\n        subs = sfilter(left, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((ii, valmin(subs, last)), (ii, locj - 1)))\n    for ii in apply(first, right):\n        col = choice(dcols)\n        mf = matcher(first, ii)\n        subs = sfilter(right, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((ii, valmax(subs, last)), (ii, locj + boxw)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d43fd935(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))    # Generate a random height between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))    # Generate a random width between 10 and 30 based on difficulty\n    boxh = unifint(diff_lb, diff_ub, (2, h // 2))    # Generate a random box height between 2 and half the grid height\n    boxw = unifint(diff_lb, diff_ub, (2, w // 2))    # Generate a random box width between 2 and half the grid width\n    loci = randint(0, h - boxh)    # Randomly select the row index for the top-left corner of the box\n    locj = randint(0, w - boxw)    # Randomly select the column index for the top-left corner of the box\n    bgc = choice(cols)    # Randomly select a background color\n    remcols = remove(bgc, cols)    # Remove the background color from the available colors\n    ccol = choice(remcols)    # Randomly select a color for the central box\n    remcols = remove(ccol, remcols)    # Remove the central box color from the available colors\n    ndcols = unifint(diff_lb, diff_ub, (1, 8))    # Determine the number of colors for decorations based on difficulty\n    dcols = sample(remcols, ndcols)    # Randomly select colors for decorations\n    bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))    # Create a set of indices for the central box\n    gi = canvas(bgc, (h, w))    # Create the initial grid filled with the background color\n    gi = fill(gi, ccol, bd)    # Fill the central box with its designated color\n    reminds = totuple(asindices(gi) - bd)    # Get the remaining indices outside the central box\n    noiseb = max(1, len(reminds) // 4)    # Calculate the maximum number of noise pixels\n    nnoise = unifint(diff_lb, diff_ub, (0, noiseb))    # Determine the actual number of noise pixels based on difficulty\n    noise = sample(reminds, nnoise)    # Randomly select indices for noise pixels\n    truenoise = sfilter(noise, lambda ij: (ij[0] < loci or ij[0] > loci + boxh - 1) and (ij[1] < locj or ij[1] > locj + boxw - 1))    # Filter noise pixels outside the box and its projections\n    rem = difference(noise, truenoise)    # Get the remaining noise pixels (those inside the box projections)\n    top = sfilter(rem, lambda ij: ij[0] < loci)    # Filter noise pixels above the box\n    bottom = sfilter(rem, lambda ij: ij[0] > loci + boxh - 1)    # Filter noise pixels below the box\n    left = sfilter(rem, lambda ij: ij[1] < locj)    # Filter noise pixels to the left of the box\n    right = sfilter(rem, lambda ij: ij[1] > locj + boxw - 1)    # Filter noise pixels to the right of the box\n    truenoiseobj = {(choice(dcols), ij) for ij in truenoise}    # Assign random colors to the true noise pixels\n    gi = paint(gi, truenoiseobj)    # Paint the true noise pixels on the input grid\n    go = tuple(e for e in gi)    # Create a copy of the input grid for the output\n\n    # Process noise pixels above the box\n    for jj in apply(last, top):\n        col = choice(dcols)    # Choose a random color for this column\n        mf = matcher(last, jj)    # Create a matcher function for this column\n        subs = sfilter(top, mf)    # Find all noise pixels in this column\n        gi = fill(gi, col, subs)    # Color the noise pixels in the input grid\n        go = fill(go, col, connect((valmin(subs, first), jj), (loci - 1, jj)))    # Draw a line from the topmost noise pixel to the box in the output grid\n\n    # Process noise pixels below the box (similar to above)\n    for jj in apply(last, bottom):\n        col = choice(dcols)\n        mf = matcher(last, jj)\n        subs = sfilter(bottom, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((valmax(subs, first), jj), (loci + boxh, jj)))\n\n    # Process noise pixels to the left of the box\n    for ii in apply(first, left):\n        col = choice(dcols)    # Choose a random color for this row\n        mf = matcher(first, ii)    # Create a matcher function for this row\n        subs = sfilter(left, mf)    # Find all noise pixels in this row\n        gi = fill(gi, col, subs)    # Color the noise pixels in the input grid\n        go = fill(go, col, connect((ii, valmin(subs, last)), (ii, locj - 1)))    # Draw a line from the leftmost noise pixel to the box in the output grid\n\n    # Process noise pixels to the right of the box (similar to left)\n    for ii in apply(first, right):\n        col = choice(dcols)\n        mf = matcher(first, ii)\n        subs = sfilter(right, mf)\n        gi = fill(gi, col, subs)\n        go = fill(go, col, connect((ii, valmax(subs, last)), (ii, locj + boxw)))\n\n    return {'input': gi, 'output': go}    # Return the generated input and output grids\n"
  },
  "d4469b4b": {
    "original": "def generate_d4469b4b(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    canv = canvas(5, (3, 3))\n    A = fill(canv, 0, {(1, 0), (2, 0), (1, 2), (2, 2)})\n    B = fill(canv, 0, corners(asindices(canv)))\n    C = fill(canv, 0, {(0, 0), (0, 1), (1, 0), (1, 1)})\n    colabc = ((2, A), (1, B), (3, C))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    col, go = choice(colabc)\n    gi = canvas(col, (h, w))\n    inds = asindices(gi)\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    ccols = sample(cols, numc)\n    numcells = unifint(diff_lb, diff_ub, (0, h * w - 1))\n    locs = sample(totuple(inds), numcells)\n    otherobj = {(choice(ccols), ij) for ij in locs}\n    gi = paint(gi, otherobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d4469b4b(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1, 2, and 3\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    \n    # Create a 3x3 canvas filled with color 5\n    canv = canvas(5, (3, 3))\n    \n    # Create pattern A: 3x3 grid with 0s in corners except top-left and bottom-right\n    A = fill(canv, 0, {(1, 0), (2, 0), (1, 2), (2, 2)})\n    \n    # Create pattern B: 3x3 grid with 0s in all four corners\n    B = fill(canv, 0, corners(asindices(canv)))\n    \n    # Create pattern C: 3x3 grid with 0s in top-left 2x2 square\n    C = fill(canv, 0, {(0, 0), (0, 1), (1, 0), (1, 1)})\n    \n    # Create a tuple of tuples, each containing a color and a pattern\n    colabc = ((2, A), (1, B), (3, C))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly choose a color and pattern from colabc\n    col, go = choice(colabc)\n    \n    # Create an input grid of size h x w filled with the chosen color\n    gi = canvas(col, (h, w))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Choose a random number of colors to use (1 to 7) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, 7))\n    \n    # Randomly sample colors from cols\n    ccols = sample(cols, numc)\n    \n    # Choose a random number of cells to color (0 to h*w-1) based on difficulty\n    numcells = unifint(diff_lb, diff_ub, (0, h * w - 1))\n    \n    # Randomly sample locations to color\n    locs = sample(totuple(inds), numcells)\n    \n    # Create a set of (color, location) pairs for the other objects\n    otherobj = {(choice(ccols), ij) for ij in locs}\n    \n    # Paint the other objects onto the input grid\n    gi = paint(gi, otherobj)\n    \n    # Return a dictionary with the input grid and the chosen output pattern\n    return {'input': gi, 'output': go}\n"
  },
  "d4a91cb9": {
    "original": "def generate_d4a91cb9(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (2, 4, 8))    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    gloci = unifint(diff_lb, diff_ub, (1, h - 1))\n    glocj = unifint(diff_lb, diff_ub, (1, w - 1))\n    gloc = (gloci, glocj)\n    bgc = choice(cols)\n    g = canvas(bgc, (h, w))\n    g = fill(g, 8, {gloc})\n    g = rot180(g)\n    glocinv = center(ofcolor(g, 8))\n    glocinvi, glocinvj = glocinv\n    rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))\n    rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))\n    rlocinv = (rloci, rlocj)\n    g = fill(g, 2, {rlocinv})\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(g)\n    a, b = center(ofcolor(gi, 2))\n    c, d = center(ofcolor(gi, 8))\n    go = fill(gi, 4, connect((a, b), (a, d)))\n    go = fill(go, 4, connect((a, d), (c, d)))\n    go = fill(go, 2, {(a, b)})\n    go = fill(go, 8, {(c, d)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d4a91cb9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 2, 4, and 8\n    cols = difference(interval(0, 10, 1), (2, 4, 8))    \n    \n    # Generate random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate random row index for green dot, ensuring it's not on the bottom row\n    gloci = unifint(diff_lb, diff_ub, (1, h - 1))\n    # Generate random column index for green dot, ensuring it's not on the right edge\n    glocj = unifint(diff_lb, diff_ub, (1, w - 1))\n    # Combine row and column indices for green dot location\n    gloc = (gloci, glocj)\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a canvas filled with the background color\n    g = canvas(bgc, (h, w))\n    \n    # Place a green dot (color 8) at the chosen location\n    g = fill(g, 8, {gloc})\n    \n    # Rotate the grid 180 degrees, effectively moving the green dot to the opposite corner\n    g = rot180(g)\n    \n    # Find the new location of the green dot after rotation\n    glocinv = center(ofcolor(g, 8))\n    glocinvi, glocinvj = glocinv\n    \n    # Generate random row index for red dot, ensuring it's below the green dot\n    rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))\n    # Generate random column index for red dot, ensuring it's to the right of the green dot\n    rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))\n    # Combine row and column indices for red dot location\n    rlocinv = (rloci, rlocj)\n    \n    # Place a red dot (color 2) at the chosen location\n    g = fill(g, 2, {rlocinv})\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    # Apply the chosen rotation to the grid\n    gi = rotf(g)\n    \n    # Find the center of the red dot in the rotated grid\n    a, b = center(ofcolor(gi, 2))\n    # Find the center of the green dot in the rotated grid\n    c, d = center(ofcolor(gi, 8))\n    \n    # Draw a blue line (color 4) from the red dot to the green dot's column\n    go = fill(gi, 4, connect((a, b), (a, d)))\n    # Draw a blue line from the previous endpoint to the green dot\n    go = fill(go, 4, connect((a, d), (c, d)))\n    \n    # Place the red dot (color 2) at its original location\n    go = fill(go, 2, {(a, b)})\n    # Place the green dot (color 8) at its original location\n    go = fill(go, 8, {(c, d)})\n    \n    # Return a dictionary with the input grid and the output grid\n    return {'input': gi, 'output': go}\n"
  },
  "d4f3cd78": {
    "original": "def generate_d4f3cd78(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    ih = unifint(diff_lb, diff_ub, (3, h//3*2))\n    iw = unifint(diff_lb, diff_ub, (3, w//3*2))\n    loci = randint(1, h - ih - 1)\n    locj = randint(1, w - iw - 1)\n    crns = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})\n    fullcrns = corners(crns)\n    bx = box(crns)\n    opts = bx - fullcrns\n    bgc, fgc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    nholes = unifint(diff_lb, diff_ub, (1, len(opts)))\n    holes = sample(totuple(opts), nholes)\n    gi = fill(c, fgc, bx - set(holes))\n    bib = backdrop(inbox(bx))\n    go = fill(gi, 8, bib)\n    A, B = ulcorner(bib)\n    C, D = lrcorner(bib)\n    f1 = lambda idx: 1 if idx > C else (-1 if idx < A else 0)\n    f2 = lambda idx: 1 if idx > D else (-1 if idx < B else 0)\n    f = lambda d: shoot(d, (f1(d[0]), f2(d[1])))\n    res = mapply(f, set(holes))\n    go = fill(go, 8, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d4f3cd78(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 8 from the set of colors 0-9\n    cols = remove(8, interval(0, 10, 1))    \n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random inner height between 3 and 2/3 of the total height\n    ih = unifint(diff_lb, diff_ub, (3, h//3*2))\n    # Generate random inner width between 3 and 2/3 of the total width\n    iw = unifint(diff_lb, diff_ub, (3, w//3*2))\n    \n    # Generate random vertical position for the inner rectangle\n    loci = randint(1, h - ih - 1)\n    # Generate random horizontal position for the inner rectangle\n    locj = randint(1, w - iw - 1)\n    \n    # Create a set of two corner coordinates for the inner rectangle\n    crns = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})\n    # Get all four corners of the rectangle\n    fullcrns = corners(crns)\n    # Get the outline of the rectangle\n    bx = box(crns)\n    # Get all points on the outline except the corners\n    opts = bx - fullcrns\n    \n    # Randomly select two colors: one for background and one for foreground\n    bgc, fgc = sample(cols, 2)\n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Determine number of holes in the rectangle outline\n    nholes = unifint(diff_lb, diff_ub, (1, len(opts)))\n    # Randomly select positions for the holes\n    holes = sample(totuple(opts), nholes)\n    \n    # Fill the rectangle outline with the foreground color, leaving holes\n    gi = fill(c, fgc, bx - set(holes))\n    \n    # Get the area inside the rectangle\n    bib = backdrop(inbox(bx))\n    # Fill the inside of the rectangle with color 8 (creating the output grid)\n    go = fill(gi, 8, bib)\n    \n    # Get the top-left and bottom-right corners of the inner area\n    A, B = ulcorner(bib)\n    C, D = lrcorner(bib)\n    \n    # Define functions to determine the direction of the line from each hole\n    f1 = lambda idx: 1 if idx > C else (-1 if idx < A else 0)\n    f2 = lambda idx: 1 if idx > D else (-1 if idx < B else 0)\n    # Create a function to draw a line from a hole to the edge of the grid\n    f = lambda d: shoot(d, (f1(d[0]), f2(d[1])))\n    \n    # Draw lines from all holes to the edge of the grid\n    res = mapply(f, set(holes))\n    # Fill these lines with color 8 in the output grid\n    go = fill(go, 8, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d511f180": {
    "original": "def generate_d511f180(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (5, 8))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(cols, numc)\n    c = canvas(-1, (h, w))\n    inds = totuple(asindices(c))\n    numbg = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    bginds = sample(inds, numbg)\n    idx = randint(0, numbg)\n    blues = bginds[:idx]\n    greys = bginds[idx:]\n    rem = difference(inds, bginds)\n    gi = fill(c, 8, blues)\n    gi = fill(gi, 5, greys)\n    go = fill(c, 5, blues)\n    go = fill(go, 8, greys)\n    for ij in rem:\n        col = choice(ccols)\n        gi = fill(gi, col, {ij})\n        go = fill(go, col, {ij})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d511f180(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of color values, excluding 5 and 8\n    cols = difference(interval(0, 10, 1), (5, 8))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the number of colors to use (excluding background colors)\n    numc = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select 'numc' colors from the 'cols' set\n    ccols = sample(cols, numc)\n    \n    # Create an empty canvas filled with -1 (representing empty cells)\n    c = canvas(-1, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly determine the number of background cells (up to half the grid)\n    numbg = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly select 'numbg' indices for background cells\n    bginds = sample(inds, numbg)\n    \n    # Randomly split background indices into two groups (for blue and grey)\n    idx = randint(0, numbg)\n    blues = bginds[:idx]  # Indices for blue cells\n    greys = bginds[idx:]  # Indices for grey cells\n    \n    # Get the remaining indices (non-background cells)\n    rem = difference(inds, bginds)\n    \n    # Create input grid: fill blue cells with 8, grey cells with 5\n    gi = fill(c, 8, blues)\n    gi = fill(gi, 5, greys)\n    \n    # Create output grid: swap colors (blue becomes 5, grey becomes 8)\n    go = fill(c, 5, blues)\n    go = fill(go, 8, greys)\n    \n    # Fill remaining cells with random colors from ccols\n    for ij in rem:\n        col = choice(ccols)\n        gi = fill(gi, col, {ij})  # Fill cell in input grid\n        go = fill(go, col, {ij})  # Fill same cell in output grid with same color\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d5d6de2d": {
    "original": "def generate_d5d6de2d(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 16))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(1, 7)\n        ow = randint(1, 7)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        col = choice(remcols)\n        if bd.issubset(indss):\n            gi = fill(gi, col, box(bd))\n            if oh > 2 and ow > 2:\n                go = fill(go, 3, backdrop(inbox(bd)))\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d5d6de2d(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range 0-9, creating a list of available colors\n    cols = remove(3, interval(0, 10, 1))    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random background color from available colors\n    bgc = choice(cols)\n    # Remove the chosen background color from available colors\n    remcols = remove(bgc, cols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Generate a random number of objects to place (1-16) based on difficulty\n    num = unifint(diff_lb, diff_ub, (1, 16))\n    # Get all possible indices in the input grid\n    indss = asindices(gi)\n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    # Initialize trial counter\n    tr = 0\n    # Initialize successful placement counter\n    succ = 0\n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we run out of colors or available spaces\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        # Generate random object height (1-7)\n        oh = randint(1, 7)\n        # Generate random object width (1-7)\n        ow = randint(1, 7)\n        # Find valid placement locations for the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        # If no valid locations, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        # Choose a random location for the object\n        loci, locj = choice(subs)\n        # Create the object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get the backdrop (full rectangle) of the object\n        bd = backdrop(obj)\n        # Choose a random color for the object\n        col = choice(remcols)\n        # If the object fits within available space\n        if bd.issubset(indss):\n            # Fill the object's outline on the input grid\n            gi = fill(gi, col, box(bd))\n            # If object is large enough, fill its inner area on output grid\n            if oh > 2 and ow > 2:\n                go = fill(go, 3, backdrop(inbox(bd)))\n            # Increment successful placement counter\n            succ += 1\n            # Remove used space from available indices\n            indss = (indss - bd) - outbox(bd)\n        # Increment trial counter\n        tr += 1\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d631b094": {
    "original": "def generate_d631b094(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    nc = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 2 - 1)))\n    c = canvas(bgc, (h, w))\n    cands = totuple(asindices(c))\n    cels = sample(cands, nc)\n    gi = fill(c, fgc, cels)\n    go = canvas(fgc, (1, nc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d631b094(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Set background color to 0 (black)\n    bgc = 0\n    \n    # Create a new tuple of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Generate a random number of cells to fill, between 1 and half the grid size or 30, whichever is smaller\n    nc = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 2 - 1)))\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Generate a tuple of all possible cell coordinates in the grid\n    cands = totuple(asindices(c))\n    \n    # Randomly select 'nc' number of cells from the candidates\n    cels = sample(cands, nc)\n    \n    # Fill the selected cells with the foreground color to create the input grid\n    gi = fill(c, fgc, cels)\n    \n    # Create the output grid: a 1xnc grid filled with the foreground color\n    # This represents a condensed version of the filled cells from the input\n    go = canvas(fgc, (1, nc))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d687bc17": {
    "original": "def generate_d687bc17(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, c1, c2, c3, c4 = sample(cols, 5)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, c1, connect((0, 0), (0, w - 1)))\n    gi = fill(gi, c2, connect((0, 0), (h - 1, 0)))\n    gi = fill(gi, c3, connect((h - 1, w - 1), (0, w - 1)))\n    gi = fill(gi, c4, connect((h - 1, w - 1), (h - 1, 0)))\n    inds = asindices(gi)\n    gi = fill(gi, bgc, corners(inds))\n    go = tuple(e for e in gi)\n    cands = backdrop(inbox(inbox(inds)))\n    ndots = unifint(diff_lb, diff_ub, (1, min(len(cands), h + h + w + w)))\n    dots = sample(totuple(cands), ndots)\n    dots = {(choice((c1, c2, c3, c4)), ij) for ij in dots}\n    n1 = toindices(sfilter(dots, lambda cij: cij[0] == c1))\n    n1coverage = apply(last, n1)\n    if len(n1coverage) == w - 4 and w > 5:\n        n1coverage = remove(choice(totuple(n1coverage)), n1coverage)\n    for jj in n1coverage:\n        loci = choice([ij[0] for ij in sfilter(n1, lambda ij: ij[1] == jj)])\n        gi = fill(gi, c1, {(loci, jj)})\n        go = fill(go, c1, {(1, jj)})\n    n2 = toindices(sfilter(dots, lambda cij: cij[0] == c2))\n    n2coverage = apply(first, n2)\n    if len(n2coverage) == h - 4 and h > 5:\n        n2coverage = remove(choice(totuple(n2coverage)), n2coverage)\n    for ii in n2coverage:\n        locj = choice([ij[1] for ij in sfilter(n2, lambda ij: ij[0] == ii)])\n        gi = fill(gi, c2, {(ii, locj)})\n        go = fill(go, c2, {(ii, 1)})\n    n3 = toindices(sfilter(dots, lambda cij: cij[0] == c4))\n    n3coverage = apply(last, n3)\n    if len(n3coverage) == w - 4 and w > 5:\n        n3coverage = remove(choice(totuple(n3coverage)), n3coverage)\n    for jj in n3coverage:\n        loci = choice([ij[0] for ij in sfilter(n3, lambda ij: ij[1] == jj)])\n        gi = fill(gi, c4, {(loci, jj)})\n        go = fill(go, c4, {(h - 2, jj)})\n    n4 = toindices(sfilter(dots, lambda cij: cij[0] == c3))\n    n4coverage = apply(first, n4)\n    if len(n4coverage) == h - 4 and h > 5:\n        n4coverage = remove(choice(totuple(n4coverage)), n4coverage)\n    for ii in n4coverage:\n        locj = choice([ij[1] for ij in sfilter(n4, lambda ij: ij[0] == ii)])\n        gi = fill(gi, c3, {(ii, locj)})\n        go = fill(go, c3, {(ii, w - 2)})\n    noisecands = ofcolor(gi, bgc)\n    noisecols = difference(cols, (bgc, c1, c2, c3, c4))\n    nnoise = unifint(diff_lb, diff_ub, (0, len(noisecands)))\n    ub = ((h * w) - 2 * h - 2 * (w - 2)) // 2 - ndots - 1\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, ub)))\n    noise = sample(totuple(noisecands), nnoise)\n    noiseobj = {(choice(noisecols), ij) for ij in noise}\n    gi = paint(gi, noiseobj)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d687bc17(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    # Randomly choose a height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly choose a width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly select 5 unique colors from the color range\n    bgc, c1, c2, c3, c4 = sample(cols, 5)\n    # Create a canvas filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Draw a line of color c1 along the top edge of the canvas\n    gi = fill(gi, c1, connect((0, 0), (0, w - 1)))\n    # Draw a line of color c2 along the left edge of the canvas\n    gi = fill(gi, c2, connect((0, 0), (h - 1, 0)))\n    # Draw a line of color c3 along the bottom edge of the canvas\n    gi = fill(gi, c3, connect((h - 1, w - 1), (0, w - 1)))\n    # Draw a line of color c4 along the right edge of the canvas\n    gi = fill(gi, c4, connect((h - 1, w - 1), (h - 1, 0)))\n    # Get all indices of the canvas\n    inds = asindices(gi)\n    # Set the corners of the canvas back to the background color\n    gi = fill(gi, bgc, corners(inds))\n    # Create a copy of the input grid for the output\n    go = tuple(e for e in gi)\n    # Define the area for placing dots (inside the frame)\n    cands = backdrop(inbox(inbox(inds)))\n    # Choose a random number of dots to place based on difficulty\n    ndots = unifint(diff_lb, diff_ub, (1, min(len(cands), h + h + w + w)))\n    # Randomly select positions for the dots\n    dots = sample(totuple(cands), ndots)\n    # Assign random colors (c1, c2, c3, c4) to the dots\n    dots = {(choice((c1, c2, c3, c4)), ij) for ij in dots}\n    # Filter dots with color c1\n    n1 = toindices(sfilter(dots, lambda cij: cij[0] == c1))\n    # Get the unique y-coordinates of c1 dots\n    n1coverage = apply(last, n1)\n    # If all possible y-coordinates are covered and width > 5, remove one randomly\n    if len(n1coverage) == w - 4 and w > 5:\n        n1coverage = remove(choice(totuple(n1coverage)), n1coverage)\n    # For each y-coordinate, choose a random x-coordinate and place a c1 dot\n    for jj in n1coverage:\n        loci = choice([ij[0] for ij in sfilter(n1, lambda ij: ij[1] == jj)])\n        gi = fill(gi, c1, {(loci, jj)})\n        # In the output, move all c1 dots to the top edge (row 1)\n        go = fill(go, c1, {(1, jj)})\n    # Repeat the process for c2 dots (left edge)\n    n2 = toindices(sfilter(dots, lambda cij: cij[0] == c2))\n    n2coverage = apply(first, n2)\n    if len(n2coverage) == h - 4 and h > 5:\n        n2coverage = remove(choice(totuple(n2coverage)), n2coverage)\n    for ii in n2coverage:\n        locj = choice([ij[1] for ij in sfilter(n2, lambda ij: ij[0] == ii)])\n        gi = fill(gi, c2, {(ii, locj)})\n        go = fill(go, c2, {(ii, 1)})\n    # Repeat the process for c4 dots (bottom edge)\n    n3 = toindices(sfilter(dots, lambda cij: cij[0] == c4))\n    n3coverage = apply(last, n3)\n    if len(n3coverage) == w - 4 and w > 5:\n        n3coverage = remove(choice(totuple(n3coverage)), n3coverage)\n    for jj in n3coverage:\n        loci = choice([ij[0] for ij in sfilter(n3, lambda ij: ij[1] == jj)])\n        gi = fill(gi, c4, {(loci, jj)})\n        go = fill(go, c4, {(h - 2, jj)})\n    # Repeat the process for c3 dots (right edge)\n    n4 = toindices(sfilter(dots, lambda cij: cij[0] == c3))\n    n4coverage = apply(first, n4)\n    if len(n4coverage) == h - 4 and h > 5:\n        n4coverage = remove(choice(totuple(n4coverage)), n4coverage)\n    for ii in n4coverage:\n        locj = choice([ij[1] for ij in sfilter(n4, lambda ij: ij[0] == ii)])\n        gi = fill(gi, c3, {(ii, locj)})\n        go = fill(go, c3, {(ii, w - 2)})\n    # Find all background color cells for potential noise\n    noisecands = ofcolor(gi, bgc)\n    # Select colors for noise (excluding bgc, c1, c2, c3, c4)\n    noisecols = difference(cols, (bgc, c1, c2, c3, c4))\n    # Choose a random number of noise dots based on difficulty and available space\n    nnoise = unifint(diff_lb, diff_ub, (0, len(noisecands)))\n    ub = ((h * w) - 2 * h - 2 * (w - 2)) // 2 - ndots - 1\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, ub)))\n    # Randomly select positions for noise dots\n    noise = sample(totuple(noisecands), nnoise)\n    # Assign random colors to noise dots\n    noiseobj = {(choice(noisecols), ij) for ij in noise}\n    # Add noise dots to the input grid\n    gi = paint(gi, noiseobj)\n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d6ad076f": {
    "original": "def generate_d6ad076f(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    inh = unifint(diff_lb, diff_ub, (3, h))\n    inw = unifint(diff_lb, diff_ub, (3, w))\n    bgc, c1, c2 = sample(cols, 3)\n    itv = interval(0, inh, 1)\n    loci2i = unifint(diff_lb, diff_ub, (2, inh - 1))\n    loci2 = itv[loci2i]\n    itv = itv[:loci2i-1][::-1]\n    loci1i = unifint(diff_lb, diff_ub, (0, len(itv) - 1))\n    loci1 = itv[loci1i]\n    cp = randint(1, inw - 2)\n    ajs = randint(0, cp - 1)\n    aje = randint(cp + 1, inw - 1)\n    bjs = randint(0, cp - 1)\n    bje = randint(cp + 1, inw - 1)\n    obja = backdrop(frozenset({(0, ajs), (loci1, aje)}))\n    objb = backdrop(frozenset({(loci2, bjs), (inh - 1, bje)}))\n    c = canvas(bgc, (inh, inw))\n    c = fill(c, c1, obja)\n    c = fill(c, c2, objb)\n    obj = asobject(c)\n    loci = randint(0, h - inh)\n    locj = randint(0, w - inw)\n    loc = (loci, locj)\n    obj = shift(obj, loc)\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, obj)\n    midobj = backdrop(frozenset({(loci1 + 1, max(ajs, bjs) + 1), (loci2 - 1, min(aje, bje) - 1)}))\n    go = fill(gi, 8, shift(midobj, loc))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d6ad076f(diff_lb: float, diff_ub: float) -> dict:\n    # Select 3 random colors (excluding 8) from the range 0-9\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Generate random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    # Generate random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate random inner height between 3 and h\n    inh = unifint(diff_lb, diff_ub, (3, h))\n    # Generate random inner width between 3 and w\n    inw = unifint(diff_lb, diff_ub, (3, w))\n    \n    # Randomly select background color, and two other colors\n    bgc, c1, c2 = sample(cols, 3)\n    \n    # Create a range from 0 to inner height\n    itv = interval(0, inh, 1)\n    # Select a random index for the second location, between 2 and inner height - 1\n    loci2i = unifint(diff_lb, diff_ub, (2, inh - 1))\n    # Get the actual second location value\n    loci2 = itv[loci2i]\n    \n    # Reverse and trim the interval for the first location selection\n    itv = itv[:loci2i-1][::-1]\n    # Select a random index for the first location\n    loci1i = unifint(diff_lb, diff_ub, (0, len(itv) - 1))\n    # Get the actual first location value\n    loci1 = itv[loci1i]\n    \n    # Select a random column position\n    cp = randint(1, inw - 2)\n    # Generate random start and end positions for object A\n    ajs = randint(0, cp - 1)\n    aje = randint(cp + 1, inw - 1)\n    # Generate random start and end positions for object B\n    bjs = randint(0, cp - 1)\n    bje = randint(cp + 1, inw - 1)\n    \n    # Create the bounding box for object A\n    obja = backdrop(frozenset({(0, ajs), (loci1, aje)}))\n    # Create the bounding box for object B\n    objb = backdrop(frozenset({(loci2, bjs), (inh - 1, bje)}))\n    \n    # Create a canvas with the background color\n    c = canvas(bgc, (inh, inw))\n    # Fill object A with color c1\n    c = fill(c, c1, obja)\n    # Fill object B with color c2\n    c = fill(c, c2, objb)\n    \n    # Convert the canvas to an object\n    obj = asobject(c)\n    \n    # Generate random location for placing the object in the full grid\n    loci = randint(0, h - inh)\n    locj = randint(0, w - inw)\n    loc = (loci, locj)\n    \n    # Shift the object to its new location\n    obj = shift(obj, loc)\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    # Paint the shifted object onto the input grid\n    gi = paint(gi, obj)\n    \n    # Create the middle object (to be filled with color 8 in output)\n    midobj = backdrop(frozenset({(loci1 + 1, max(ajs, bjs) + 1), (loci2 - 1, min(aje, bje) - 1)}))\n    # Create the output grid by filling the middle object with color 8\n    go = fill(gi, 8, shift(midobj, loc))\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d89b689b": {
    "original": "def generate_d89b689b(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, sqc, a, b, c, d = sample(cols, 6)\n    loci = randint(1, h - 3)\n    locj = randint(1, w - 3)\n    canv = canvas(bgc, (h, w))\n    go = fill(canv, a, {(loci, locj)})\n    go = fill(go, b, {(loci, locj+1)})\n    go = fill(go, c, {(loci+1, locj)})\n    go = fill(go, d, {(loci+1, locj+1)})\n    inds = totuple(asindices(canv))\n    aopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] < locj)\n    bopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] > locj + 1)\n    copts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] < locj)\n    dopts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] > locj + 1)\n    aopts = order(aopts, lambda ij: manhattan({ij}, {(loci, locj)}))\n    bopts = order(bopts, lambda ij: manhattan({ij}, {(loci, locj + 1)}))\n    copts = order(copts, lambda ij: manhattan({ij}, {(loci + 1, locj)}))\n    dopts = order(dopts, lambda ij: manhattan({ij}, {(loci + 1, locj + 1)}))\n    aidx = unifint(diff_lb, diff_ub, (0, len(aopts) - 1))\n    bidx = unifint(diff_lb, diff_ub, (0, len(bopts) - 1))\n    cidx = unifint(diff_lb, diff_ub, (0, len(copts) - 1))\n    didx = unifint(diff_lb, diff_ub, (0, len(dopts) - 1))\n    loca = aopts[aidx]\n    locb = bopts[bidx]\n    locc = copts[cidx]\n    locd = dopts[didx]\n    gi = fill(canv, sqc, backdrop({(loci, locj), (loci + 1, locj + 1)}))\n    gi = fill(gi, a, {loca})\n    gi = fill(gi, b, {locb})\n    gi = fill(gi, c, {locc})\n    gi = fill(gi, d, {locd})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d89b689b(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 5 from the range 0-9, creating a list of available colors\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Generate random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select 6 colors from the available colors\n    bgc, sqc, a, b, c, d = sample(cols, 6)\n    \n    # Choose random row index for the 2x2 square, at least 1 row from top and 2 from bottom\n    loci = randint(1, h - 3)\n    # Choose random column index for the 2x2 square, at least 1 column from left and 2 from right\n    locj = randint(1, w - 3)\n    \n    # Create a canvas filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Place color 'a' in the top-left cell of the 2x2 square\n    go = fill(canv, a, {(loci, locj)})\n    # Place color 'b' in the top-right cell of the 2x2 square\n    go = fill(go, b, {(loci, locj+1)})\n    # Place color 'c' in the bottom-left cell of the 2x2 square\n    go = fill(go, c, {(loci+1, locj)})\n    # Place color 'd' in the bottom-right cell of the 2x2 square\n    go = fill(go, d, {(loci+1, locj+1)})\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(canv))\n    \n    # Filter indices for potential locations of color 'a' (top-left quadrant)\n    aopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] < locj)\n    # Filter indices for potential locations of color 'b' (top-right quadrant)\n    bopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] > locj + 1)\n    # Filter indices for potential locations of color 'c' (bottom-left quadrant)\n    copts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] < locj)\n    # Filter indices for potential locations of color 'd' (bottom-right quadrant)\n    dopts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] > locj + 1)\n    \n    # Sort potential 'a' locations by Manhattan distance from its position in the 2x2 square\n    aopts = order(aopts, lambda ij: manhattan({ij}, {(loci, locj)}))\n    # Sort potential 'b' locations by Manhattan distance from its position in the 2x2 square\n    bopts = order(bopts, lambda ij: manhattan({ij}, {(loci, locj + 1)}))\n    # Sort potential 'c' locations by Manhattan distance from its position in the 2x2 square\n    copts = order(copts, lambda ij: manhattan({ij}, {(loci + 1, locj)}))\n    # Sort potential 'd' locations by Manhattan distance from its position in the 2x2 square\n    dopts = order(dopts, lambda ij: manhattan({ij}, {(loci + 1, locj + 1)}))\n    \n    # Choose index for 'a' location based on difficulty\n    aidx = unifint(diff_lb, diff_ub, (0, len(aopts) - 1))\n    # Choose index for 'b' location based on difficulty\n    bidx = unifint(diff_lb, diff_ub, (0, len(bopts) - 1))\n    # Choose index for 'c' location based on difficulty\n    cidx = unifint(diff_lb, diff_ub, (0, len(copts) - 1))\n    # Choose index for 'd' location based on difficulty\n    didx = unifint(diff_lb, diff_ub, (0, len(dopts) - 1))\n    \n    # Get final location for 'a'\n    loca = aopts[aidx]\n    # Get final location for 'b'\n    locb = bopts[bidx]\n    # Get final location for 'c'\n    locc = copts[cidx]\n    # Get final location for 'd'\n    locd = dopts[didx]\n    \n    # Create input grid: fill 2x2 square area with 'sqc' color\n    gi = fill(canv, sqc, backdrop({(loci, locj), (loci + 1, locj + 1)}))\n    # Place color 'a' in its chosen location on the input grid\n    gi = fill(gi, a, {loca})\n    # Place color 'b' in its chosen location on the input grid\n    gi = fill(gi, b, {locb})\n    # Place color 'c' in its chosen location on the input grid\n    gi = fill(gi, c, {locc})\n    # Place color 'd' in its chosen location on the input grid\n    gi = fill(gi, d, {locd})\n    \n    # Return dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "d8c310e9": {
    "original": "def generate_d8c310e9(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    p = unifint(diff_lb, diff_ub, (2, (w - 1) // 3))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numc)\n    obj = set()\n    for j in range(p):\n        numcells = unifint(diff_lb, diff_ub, (1, h - 1))\n        for ii in range(h - 1, h - numcells - 1, -1):\n            loc = (ii, j)\n            col = choice(ccols)\n            cell = (col, loc)\n            obj.add(cell)\n    gi = canvas(bgc, (h, w))\n    minobj = obj | shift(obj, (0, p))\n    addonw = randint(0, p)\n    addon = sfilter(obj, lambda cij: cij[1][1] < addonw)\n    fullobj = minobj | addon\n    leftshift = randint(0, addonw)\n    fullobj = shift(fullobj, (0, -leftshift))\n    gi = paint(gi, fullobj)\n    go = tuple(e for e in gi)\n    for j in range(w//(2*p)+2):\n        go = paint(go, shift(fullobj, (0, j * 2 * p)))\n    mfs = (identity, rot90, rot180, rot270)\n    fn = choice(mfs)\n    gi = fn(gi)\n    go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d8c310e9(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the period of the pattern between 2 and (w-1)/3\n    p = unifint(diff_lb, diff_ub, (2, (w - 1) // 3))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly determine the number of colors to use (1 to 9)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly sample colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Initialize an empty set to store the object cells\n    obj = set()\n    \n    # Loop to create the initial object pattern\n    for j in range(p):\n        # Randomly determine the number of cells in this column\n        numcells = unifint(diff_lb, diff_ub, (1, h - 1))\n        \n        # Fill cells from bottom to top\n        for ii in range(h - 1, h - numcells - 1, -1):\n            loc = (ii, j)\n            # Randomly choose a color for this cell\n            col = choice(ccols)\n            cell = (col, loc)\n            # Add the cell to the object\n            obj.add(cell)\n    \n    # Create the initial grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the minimum object by combining the original and shifted pattern\n    minobj = obj | shift(obj, (0, p))\n    \n    # Randomly determine additional width to the left\n    addonw = randint(0, p)\n    \n    # Add some cells to the left based on addonw\n    addon = sfilter(obj, lambda cij: cij[1][1] < addonw)\n    \n    # Combine all parts to create the full object\n    fullobj = minobj | addon\n    \n    # Randomly shift the entire object to the left\n    leftshift = randint(0, addonw)\n    fullobj = shift(fullobj, (0, -leftshift))\n    \n    # Paint the full object onto the input grid\n    gi = paint(gi, fullobj)\n    \n    # Create the output grid, initially as a copy of the input\n    go = tuple(e for e in gi)\n    \n    # Repeat the pattern across the output grid\n    for j in range(w//(2*p)+2):\n        go = paint(go, shift(fullobj, (0, j * 2 * p)))\n    \n    # List of possible grid transformations\n    mfs = (identity, rot90, rot180, rot270)\n    \n    # Randomly choose a transformation\n    fn = choice(mfs)\n    \n    # Apply the chosen transformation to both input and output grids\n    gi = fn(gi)\n    go = fn(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d90796e8": {
    "original": "def generate_d90796e8(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (8, 2, 3))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc, noisec = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    nocc = unifint(diff_lb, diff_ub, (1, (h * w) // 3))\n    inds = asindices(gi)\n    locs = sample(totuple(inds), nocc)\n    obj = frozenset({(choice((noisec, 2, 3)), ij) for ij in locs})\n    gi = paint(gi, obj)\n    fixloc = choice(totuple(inds))\n    fixloc2 = choice(totuple(dneighbors(fixloc) & inds))\n    gi = fill(gi, 2, {fixloc})\n    gi = fill(gi, 3, {fixloc2})\n    go = tuple(e for e in gi)\n    reds = ofcolor(gi, 2)\n    greens = ofcolor(gi, 3)\n    tocover = set()\n    tolblue = set()\n    for r in reds:\n        inters = dneighbors(r) & greens\n        if len(inters) > 0:\n            tocover.add(r)\n            tolblue = tolblue | inters\n    go = fill(go, bgc, tocover)\n    go = fill(go, 8, tolblue)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d90796e8(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 8, 2, and 3\n    cols = difference(interval(0, 10, 1), (8, 2, 3))\n    \n    # Generate random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select two colors: one for background and one for noise\n    bgc, noisec = sample(cols, 2)\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine number of noise cells (up to 1/3 of total cells)\n    nocc = unifint(diff_lb, diff_ub, (1, (h * w) // 3))\n    \n    # Get all possible cell indices in the grid\n    inds = asindices(gi)\n    \n    # Randomly select locations for noise cells\n    locs = sample(totuple(inds), nocc)\n    \n    # Create noise object with random colors (noise color, 2, or 3)\n    obj = frozenset({(choice((noisec, 2, 3)), ij) for ij in locs})\n    \n    # Paint the noise object onto the grid\n    gi = paint(gi, obj)\n    \n    # Choose a random location for a red cell (color 2)\n    fixloc = choice(totuple(inds))\n    \n    # Choose a random adjacent location for a green cell (color 3)\n    fixloc2 = choice(totuple(dneighbors(fixloc) & inds))\n    \n    # Place a red cell (color 2) at the chosen location\n    gi = fill(gi, 2, {fixloc})\n    \n    # Place a green cell (color 3) adjacent to the red cell\n    gi = fill(gi, 3, {fixloc2})\n    \n    # Create a copy of the input grid for output\n    go = tuple(e for e in gi)\n    \n    # Find all red cells in the input grid\n    reds = ofcolor(gi, 2)\n    \n    # Find all green cells in the input grid\n    greens = ofcolor(gi, 3)\n    \n    # Initialize sets for cells to be covered and turned blue\n    tocover = set()\n    tolblue = set()\n    \n    # Iterate through red cells\n    for r in reds:\n        # Find green cells adjacent to the current red cell\n        inters = dneighbors(r) & greens\n        # If there are adjacent green cells\n        if len(inters) > 0:\n            # Mark the red cell to be covered (removed)\n            tocover.add(r)\n            # Mark the adjacent green cells to be turned blue\n            tolblue = tolblue | inters\n    \n    # Remove marked red cells by replacing them with background color\n    go = fill(go, bgc, tocover)\n    \n    # Turn marked green cells blue\n    go = fill(go, 8, tolblue)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d9f24cd1": {
    "original": "def generate_d9f24cd1(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    dotc = choice(remcols)\n    locopts = interval(1, w - 1, 1)\n    maxnloc = (w - 2) // 2\n    nlins = unifint(diff_lb, diff_ub, (1, maxnloc))\n    locs = []\n    for k in range(nlins):\n        if len(locopts) == 0:\n            break\n        loc = choice(locopts)\n        locopts = remove(loc, locopts)\n        locopts = remove(loc - 1, locopts)\n        locopts = remove(loc + 1, locopts)\n        locs.append(loc)\n    ndots = unifint(diff_lb, diff_ub, (1, maxnloc))\n    locopts = interval(1, w - 1, 1)\n    dotlocs = []\n    for k in range(ndots):\n        if len(locopts) == 0:\n            break\n        loc = choice(locopts)\n        locopts = remove(loc, locopts)\n        locopts = remove(loc - 1, locopts)\n        locopts = remove(loc + 1, locopts)\n        dotlocs.append(loc)\n    gi = canvas(bgc, (h, w))\n    for l in locs:\n        gi = fill(gi, linc, {(h - 1, l)})\n    dotlocs2 = []\n    for l in dotlocs:\n        jj = randint(1, h - 2)\n        gi = fill(gi, dotc, {(jj, l)})\n        dotlocs2.append(jj)\n    go = tuple(e for e in gi)\n    for linloc in locs:\n        if linloc in dotlocs:\n            jj = dotlocs2[dotlocs.index(linloc)]\n            go = fill(go, linc, connect((h - 1, linloc), (jj + 1, linloc)))\n            go = fill(go, linc, connect((jj + 1, linloc + 1), (0, linloc + 1)))\n        else:\n            go = fill(go, linc, connect((h - 1, linloc), (0, linloc)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d9f24cd1(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (possible color values)\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the lines\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random color for the dots\n    dotc = choice(remcols)\n    \n    # Create a tuple of possible locations for lines and dots (1 to width-1)\n    locopts = interval(1, w - 1, 1)\n    \n    # Calculate the maximum number of lines/dots (half the width minus 1)\n    maxnloc = (w - 2) // 2\n    \n    # Generate a random number of lines based on difficulty\n    nlins = unifint(diff_lb, diff_ub, (1, maxnloc))\n    \n    # Initialize an empty list to store line locations\n    locs = []\n    \n    # Generate random locations for lines\n    for k in range(nlins):\n        # Break if no more location options available\n        if len(locopts) == 0:\n            break\n        # Choose a random location for the line\n        loc = choice(locopts)\n        # Remove the chosen location and adjacent locations from options\n        locopts = remove(loc, locopts)\n        locopts = remove(loc - 1, locopts)\n        locopts = remove(loc + 1, locopts)\n        # Add the chosen location to the list of line locations\n        locs.append(loc)\n    \n    # Generate a random number of dots based on difficulty\n    ndots = unifint(diff_lb, diff_ub, (1, maxnloc))\n    \n    # Reset location options for dots\n    locopts = interval(1, w - 1, 1)\n    \n    # Initialize an empty list to store dot locations\n    dotlocs = []\n    \n    # Generate random locations for dots\n    for k in range(ndots):\n        # Break if no more location options available\n        if len(locopts) == 0:\n            break\n        # Choose a random location for the dot\n        loc = choice(locopts)\n        # Remove the chosen location and adjacent locations from options\n        locopts = remove(loc, locopts)\n        locopts = remove(loc - 1, locopts)\n        locopts = remove(loc + 1, locopts)\n        # Add the chosen location to the list of dot locations\n        dotlocs.append(loc)\n    \n    # Create the input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Add lines to the bottom row of the input grid\n    for l in locs:\n        gi = fill(gi, linc, {(h - 1, l)})\n    \n    # Initialize an empty list to store vertical positions of dots\n    dotlocs2 = []\n    \n    # Add dots to the input grid at random heights\n    for l in dotlocs:\n        # Generate a random vertical position for the dot\n        jj = randint(1, h - 2)\n        # Add the dot to the input grid\n        gi = fill(gi, dotc, {(jj, l)})\n        # Store the vertical position of the dot\n        dotlocs2.append(jj)\n    \n    # Create the output grid as a copy of the input grid\n    go = tuple(e for e in gi)\n    \n    # Process each line location\n    for linloc in locs:\n        # If there's a dot at this line location\n        if linloc in dotlocs:\n            # Get the vertical position of the dot\n            jj = dotlocs2[dotlocs.index(linloc)]\n            # Draw a line from the bottom to the dot\n            go = fill(go, linc, connect((h - 1, linloc), (jj + 1, linloc)))\n            # Draw a line from above the dot to the top, shifted right\n            go = fill(go, linc, connect((jj + 1, linloc + 1), (0, linloc + 1)))\n        else:\n            # If no dot, draw a straight line from bottom to top\n            go = fill(go, linc, connect((h - 1, linloc), (0, linloc)))\n    \n    # Choose a random rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "d9fac9be": {
    "original": "def generate_d9fac9be(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    bgc, noisec, ringc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    nnoise1 = unifint(diff_lb, diff_ub, (1, (h * w) // 3 - 1))\n    nnoise2 = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 3 - 9)))\n    inds = asindices(gi)\n    noise1 = sample(totuple(inds), nnoise1)\n    noise2 = sample(difference(totuple(inds), noise1), nnoise2)\n    gi = fill(gi, noisec, noise1)\n    gi = fill(gi, ringc, noise2)\n    rng = neighbors((1, 1))\n    fp1 = recolor(noisec, rng)\n    fp2 = recolor(ringc, rng)\n    fp1occ = occurrences(gi, fp1)\n    fp2occ = occurrences(gi, fp2)\n    for occ1 in fp1occ:\n        loc = choice(totuple(shift(rng, occ1)))\n        gi = fill(gi, choice((bgc, ringc)), {loc})\n    for occ2 in fp2occ:\n        loc = choice(totuple(shift(rng, occ2)))\n        gi = fill(gi, choice((bgc, noisec)), {loc})\n    loci = randint(0, h - 3)\n    locj = randint(0, w - 3)\n    ringp = shift(rng, (loci, locj))\n    gi = fill(gi, ringc, ringp)\n    gi = fill(gi, noisec, {(loci + 1, locj + 1)})\n    go = canvas(noisec, (1, 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_d9fac9be(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Randomly select 3 distinct colors for background, noise, and ring\n    bgc, noisec, ringc = sample(cols, 3)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the number of noise1 cells (between 1 and 1/3 of total cells)\n    nnoise1 = unifint(diff_lb, diff_ub, (1, (h * w) // 3 - 1))\n    \n    # Determine the number of noise2 cells (between 1 and 1/3 of total cells, minus 9)\n    nnoise2 = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 3 - 9)))\n    \n    # Get all possible grid indices\n    inds = asindices(gi)\n    \n    # Randomly select positions for noise1\n    noise1 = sample(totuple(inds), nnoise1)\n    \n    # Randomly select positions for noise2, ensuring no overlap with noise1\n    noise2 = sample(difference(totuple(inds), noise1), nnoise2)\n    \n    # Fill the grid with noise1 color at noise1 positions\n    gi = fill(gi, noisec, noise1)\n    \n    # Fill the grid with ring color at noise2 positions\n    gi = fill(gi, ringc, noise2)\n    \n    # Define the ring shape (3x3 square without center)\n    rng = neighbors((1, 1))\n    \n    # Create fingerprints for noise and ring colors\n    fp1 = recolor(noisec, rng)\n    fp2 = recolor(ringc, rng)\n    \n    # Find occurrences of noise fingerprint in the grid\n    fp1occ = occurrences(gi, fp1)\n    \n    # Find occurrences of ring fingerprint in the grid\n    fp2occ = occurrences(gi, fp2)\n    \n    # For each noise fingerprint occurrence:\n    for occ1 in fp1occ:\n        # Choose a random position within the fingerprint\n        loc = choice(totuple(shift(rng, occ1)))\n        # Randomly fill that position with either background or ring color\n        gi = fill(gi, choice((bgc, ringc)), {loc})\n    \n    # For each ring fingerprint occurrence:\n    for occ2 in fp2occ:\n        # Choose a random position within the fingerprint\n        loc = choice(totuple(shift(rng, occ2)))\n        # Randomly fill that position with either background or noise color\n        gi = fill(gi, choice((bgc, noisec)), {loc})\n    \n    # Choose a random position for the final ring (at least 3 cells from edges)\n    loci = randint(0, h - 3)\n    locj = randint(0, w - 3)\n    \n    # Create the final ring at the chosen position\n    ringp = shift(rng, (loci, locj))\n    gi = fill(gi, ringc, ringp)\n    \n    # Fill the center of the final ring with noise color\n    gi = fill(gi, noisec, {(loci + 1, locj + 1)})\n    \n    # Create the output: a 1x1 grid with the noise color\n    go = canvas(noisec, (1, 1))\n    \n    # Return the input grid and output grid as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "dae9d2b5": {
    "original": "def generate_dae9d2b5(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(6, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    if len(set(aset) & set(bset)) == 0:\n        bset = bset[:-1] + [choice(aset)]\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(A, B)\n    res = set(aset) | set(bset)\n    go = fill(c, 6, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_dae9d2b5(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 6\n    cols = remove(6, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the first shape (A)\n    acol = choice(remcols)\n    \n    # Remove the first shape's color from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a random color for the second shape (B)\n    bcol = choice(remcols)\n    \n    # Create a canvas with the background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Generate a random number of deviations for shape A\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Generate a random number of deviations for shape B\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose either the deviation or its complement for shape A's size\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose either the deviation or its complement for shape B's size\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure shape A's size is between 1 and h*w-1\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure shape B's size is between 1 and h*w-1\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly sample indices for shape A\n    aset = sample(inds, numa)\n    \n    # Randomly sample indices for shape B\n    bset = sample(inds, numb)\n    \n    # If shapes A and B don't overlap, make them overlap by one cell\n    if len(set(aset) & set(bset)) == 0:\n        # Replace the last element of B with a random element from A\n        bset = bset[:-1] + [choice(aset)]\n    \n    # Fill the canvas with shape A's color at the chosen indices\n    A = fill(c, acol, aset)\n    \n    # Fill the canvas with shape B's color at the chosen indices\n    B = fill(c, bcol, bset)\n    \n    # Concatenate A and B horizontally to create the input grid\n    gi = hconcat(A, B)\n    \n    # Combine the indices of both shapes\n    res = set(aset) | set(bset)\n    \n    # Fill the output canvas with color 6 at the combined indices\n    go = fill(c, 6, res)\n    \n    # Randomly decide whether to mirror the input and output diagonally\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "db3e9e38": {
    "original": "def generate_db3e9e38(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    barth = unifint(diff_lb, diff_ub, (1, max(1, w // 5)))\n    loci = unifint(diff_lb, diff_ub, (1, h - 2))\n    locj = randint(1, w - barth - 1)\n    bar = backdrop(frozenset({(loci, locj), (0, locj + barth - 1)}))\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, fgc, bar)\n    go = canvas(bgc, (h, w))\n    for k in range(16):\n        rsh = multiply(2 * k, (-1, barth))\n        go = fill(go, fgc, shift(bar, rsh))\n        lsh = multiply(2 * k, (-1, -barth))\n        go = fill(go, fgc, shift(bar, lsh))\n        rsh = multiply(2 * k + 1, (-1, barth))\n        go = fill(go, 8, shift(bar, rsh))\n        lsh = multiply(2 * k + 1, (-1, -barth))\n        go = fill(go, 8, shift(bar, lsh))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_db3e9e38(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid between 3 and 30\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly determine the width of the grid between 3 and 30\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a new list of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    \n    # Determine the thickness of the bar, between 1 and 1/5 of the width\n    barth = unifint(diff_lb, diff_ub, (1, max(1, w // 5)))\n    \n    # Randomly choose the vertical position of the bar, excluding top and bottom rows\n    loci = unifint(diff_lb, diff_ub, (1, h - 2))\n    \n    # Randomly choose the horizontal starting position of the bar\n    locj = randint(1, w - barth - 1)\n    \n    # Create a set of coordinates representing the bar\n    bar = backdrop(frozenset({(loci, locj), (0, locj + barth - 1)}))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Draw the initial bar on the input grid with the foreground color\n    gi = fill(gi, fgc, bar)\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Loop 16 times to create a pattern of bars in the output grid\n    for k in range(16):\n        # Draw right-shifted bars with foreground color (even iterations)\n        rsh = multiply(2 * k, (-1, barth))\n        go = fill(go, fgc, shift(bar, rsh))\n        \n        # Draw left-shifted bars with foreground color (even iterations)\n        lsh = multiply(2 * k, (-1, -barth))\n        go = fill(go, fgc, shift(bar, lsh))\n        \n        # Draw right-shifted bars with color 8 (odd iterations)\n        rsh = multiply(2 * k + 1, (-1, barth))\n        go = fill(go, 8, shift(bar, rsh))\n        \n        # Draw left-shifted bars with color 8 (odd iterations)\n        lsh = multiply(2 * k + 1, (-1, -barth))\n        go = fill(go, 8, shift(bar, lsh))\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "db93a21d": {
    "original": "def generate_db93a21d(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 3))\n    h = unifint(diff_lb, diff_ub, (12, 31))\n    w = unifint(diff_lb, diff_ub, (12, 32))\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    bgc, fgc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    while succ < num and tr <= maxtrials:\n        if len(indss) == 0:\n            break\n        oh = randint(1, h // 4)\n        ow = oh\n        fullh = 4 * oh\n        fullw = 4 * ow\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - fullh and ij[1] < w - fullw))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        bigobj = backdrop(frozenset({(loci, locj), (loci + fullh - 1, locj + fullw - 1)}))\n        smallobj = backdrop(frozenset({(loci+oh, locj+ow), (loci + fullh - 1 - oh, locj + fullw - 1 - ow)}))\n        if bigobj.issubset(indss | ofcolor(go, 3)):\n            gi = fill(gi, fgc, smallobj)\n            go = fill(go, 3, bigobj)\n            go = fill(go, fgc, smallobj)\n            strp = mapply(rbind(shoot, (1, 0)), connect(lrcorner(smallobj), llcorner(smallobj)))\n            go = fill(go, 1, ofcolor(go, bgc) & strp)\n            succ += 1\n            indss = indss - bigobj\n        tr += 1\n    gi = gi[1:]\n    go = go[1:]\n    gi = tuple(r[1:-1] for r in gi)\n    go = tuple(r[1:-1] for r in go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_db93a21d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1 and 3\n    cols = difference(interval(0, 10, 1), (1, 3))\n    \n    # Generate random height between 12 and 31 based on difficulty\n    h = unifint(diff_lb, diff_ub, (12, 31))\n    \n    # Generate random width between 12 and 32 based on difficulty\n    w = unifint(diff_lb, diff_ub, (12, 32))\n    \n    # Calculate number of objects to place, between 1 and (h*w)//25\n    num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Randomly choose background and foreground colors\n    bgc, fgc = sample(cols, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid\n    indss = asindices(gi)\n    \n    # Set maximum number of placement attempts\n    maxtrials = 4 * num\n    \n    # Initialize trial counter\n    tr = 0\n    \n    # Initialize successful placement counter\n    succ = 0\n    \n    # Main loop for placing objects\n    while succ < num and tr <= maxtrials:\n        # Break if no more available indices\n        if len(indss) == 0:\n            break\n        \n        # Randomly determine object height (1/4 of total height)\n        oh = randint(1, h // 4)\n        \n        # Set object width equal to height (square shape)\n        ow = oh\n        \n        # Calculate full height of the object (4 times object height)\n        fullh = 4 * oh\n        \n        # Calculate full width of the object (4 times object width)\n        fullw = 4 * ow\n        \n        # Find valid starting positions for placing the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - fullh and ij[1] < w - fullw))\n        \n        # If no valid positions, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        \n        # Choose a random starting position\n        loci, locj = choice(subs)\n        \n        # Create the larger bounding box for the object\n        bigobj = backdrop(frozenset({(loci, locj), (loci + fullh - 1, locj + fullw - 1)}))\n        \n        # Create the smaller inner box for the object\n        smallobj = backdrop(frozenset({(loci+oh, locj+ow), (loci + fullh - 1 - oh, locj + fullw - 1 - ow)}))\n        \n        # Check if the object can be placed without overlapping\n        if bigobj.issubset(indss | ofcolor(go, 3)):\n            # Fill the small object in the input grid with foreground color\n            gi = fill(gi, fgc, smallobj)\n            \n            # Fill the big object in the output grid with color 3 (frame)\n            go = fill(go, 3, bigobj)\n            \n            # Fill the small object in the output grid with foreground color\n            go = fill(go, fgc, smallobj)\n            \n            # Create a stripe on the right side of the small object\n            strp = mapply(rbind(shoot, (1, 0)), connect(lrcorner(smallobj), llcorner(smallobj)))\n            \n            # Fill the stripe with color 1 where it overlaps with background color\n            go = fill(go, 1, ofcolor(go, bgc) & strp)\n            \n            # Increment successful placement counter\n            succ += 1\n            \n            # Remove used indices from available indices\n            indss = indss - bigobj\n        \n        # Increment trial counter\n        tr += 1\n    \n    # Remove the top row from input grid\n    gi = gi[1:]\n    \n    # Remove the top row from output grid\n    go = go[1:]\n    \n    # Remove the leftmost and rightmost columns from input grid\n    gi = tuple(r[1:-1] for r in gi)\n    \n    # Remove the leftmost and rightmost columns from output grid\n    go = tuple(r[1:-1] for r in go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "dbc1a6ce": {
    "original": "def generate_dbc1a6ce(diff_lb: float, diff_ub: float) -> dict:\n    dim_bounds = (3, 30)\n    colopts = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    bgc = choice(colopts)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    card_bounds = (0, max(1, (h * w) // 4))\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    s = sample(inds, num)\n    fgcol = choice(remove(bgc, colopts))\n    gi = fill(c, fgcol, s)\n    resh = frozenset()\n    for x, r in enumerate(gi):\n        if r.count(fgcol) > 1:\n            resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))\n    go = fill(c, 8, resh)\n    resv = frozenset()\n    for x, r in enumerate(dmirror(gi)):\n        if r.count(fgcol) > 1:\n            resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))\n    go = dmirror(fill(dmirror(go), 8, resv))\n    go = fill(go, fgcol, s)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_dbc1a6ce(diff_lb: float, diff_ub: float) -> dict:\n    # Define bounds for grid dimensions\n    dim_bounds = (3, 30)\n    # Create a list of color options, excluding 8\n    colopts = remove(8, interval(0, 10, 1))\n    # Randomly choose height within bounds based on difficulty\n    h = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose width within bounds based on difficulty\n    w = unifint(diff_lb, diff_ub, dim_bounds)\n    # Randomly choose background color\n    bgc = choice(colopts)\n    # Create a canvas (grid) with chosen dimensions and background color\n    c = canvas(bgc, (h, w))\n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    # Define bounds for number of foreground cells\n    card_bounds = (0, max(1, (h * w) // 4))\n    # Randomly choose number of foreground cells based on difficulty\n    num = unifint(diff_lb, diff_ub, card_bounds)\n    # Randomly sample indices for foreground cells\n    s = sample(inds, num)\n    # Choose foreground color different from background\n    fgcol = choice(remove(bgc, colopts))\n    # Create input grid by filling sampled indices with foreground color\n    gi = fill(c, fgcol, s)\n    \n    # Initialize set for horizontal connections\n    resh = frozenset()\n    # Iterate over rows of input grid\n    for x, r in enumerate(gi):\n        # If row has more than one foreground cell\n        if r.count(fgcol) > 1:\n            # Add horizontal connection between first and last foreground cell in row\n            resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))\n    \n    # Create output grid by filling horizontal connections with color 8\n    go = fill(c, 8, resh)\n    \n    # Initialize set for vertical connections\n    resv = frozenset()\n    # Iterate over columns of input grid (using diagonal mirror)\n    for x, r in enumerate(dmirror(gi)):\n        # If column has more than one foreground cell\n        if r.count(fgcol) > 1:\n            # Add vertical connection between first and last foreground cell in column\n            resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))\n    \n    # Add vertical connections to output grid (using diagonal mirror twice)\n    go = dmirror(fill(dmirror(go), 8, resv))\n    # Add original foreground cells to output grid\n    go = fill(go, fgcol, s)\n    \n    # Return input and output grids as dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "dc0a314f": {
    "original": "def generate_dc0a314f(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    gi = paint(gi, tr)\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    go = subgrid(bd, gi)\n    gi = fill(gi, 3, bd)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_dc0a314f(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height (and width) of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h  # Set width equal to height, creating a square grid\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas (grid) filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Determine the number of cells to color based on difficulty\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Create a set of all possible grid indices\n    bx = asindices(canv)\n    \n    # Initialize the object with a single colored cell at a random location\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Iteratively add colored cells adjacent to existing ones\n    for kk in range(nc - 1):\n        # Find all neighbors of the current object\n        dns = mapply(neighbors, toindices(obj))\n        \n        # Choose a random available cell from the neighbors\n        ch = choice(totuple(bx & dns))\n        \n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        \n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Paint the object onto the canvas\n    gi = paint(canv, obj)\n    \n    # Create a triangular shape by filtering the diagonal mirror of the grid\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    \n    # Paint the triangular shape onto the grid\n    gi = paint(gi, tr)\n    \n    # Mirror the grid horizontally and vertically to create a symmetric pattern\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    \n    # Determine the location and size of a subgrid to extract\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    \n    # Create a backdrop for the subgrid\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    \n    # Extract the subgrid\n    go = subgrid(bd, gi)\n    \n    # Fill the original grid with color 3 where the subgrid was extracted\n    gi = fill(gi, 3, bd)\n    \n    # Randomly rotate both the input and output grids\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "dc1df850": {
    "original": "def generate_dc1df850(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    c = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))\n    nreddev = unifint(diff_lb, diff_ub, (0, nc // 2))\n    nred = choice((nreddev, nc - nreddev))\n    nred = min(max(0, nred), nc)\n    inds = totuple(asindices(c))\n    occ = sample(inds, nc)\n    reds = sample(occ, nred)\n    others = difference(occ, reds)\n    c = fill(c, 2, reds)\n    obj = frozenset({(choice(remcols), ij) for ij in others})\n    c = paint(c, obj)\n    gi = tuple(r for r in c)\n    go = underfill(c, 1, mapply(neighbors, frozenset(reds)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_dc1df850(diff_lb: float, diff_ub: float) -> dict:\n    # Create a set of colors excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    \n    # Randomly determine the height of the grid between 4 and 30\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid between 4 and 30\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Determine the number of cells to be colored (up to half the grid)\n    nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))\n    \n    # Determine the number of red deviations (up to half of colored cells)\n    nreddev = unifint(diff_lb, diff_ub, (0, nc // 2))\n    \n    # Choose between nreddev and (nc - nreddev) for the number of red cells\n    nred = choice((nreddev, nc - nreddev))\n    \n    # Ensure nred is between 0 and nc\n    nred = min(max(0, nred), nc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly select nc indices to be colored\n    occ = sample(inds, nc)\n    \n    # Randomly select nred indices to be colored red\n    reds = sample(occ, nred)\n    \n    # Get the remaining indices to be colored with other colors\n    others = difference(occ, reds)\n    \n    # Fill the selected red indices with color 2 (red)\n    c = fill(c, 2, reds)\n    \n    # Create an object with randomly chosen colors for the other indices\n    obj = frozenset({(choice(remcols), ij) for ij in others})\n    \n    # Paint the other colored cells onto the canvas\n    c = paint(c, obj)\n    \n    # Convert the canvas to a tuple of tuples (input grid)\n    gi = tuple(r for r in c)\n    \n    # Create the output grid by filling neighbors of red cells with color 1\n    go = underfill(c, 1, mapply(neighbors, frozenset(reds)))\n    \n    # Return a dictionary with input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "dc433765": {
    "original": "def generate_dc433765(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, src = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    if choice((True, False)):\n        opts = {(ii, 0) for ii in range(h - 2)} | {(0, jj) for jj in range(1, w - 2, 1)}\n        opts = tuple([inds & shoot(src, (1, 1)) for src in opts])\n        opts = order(opts, size)\n        k = len(opts)\n        opt = unifint(diff_lb, diff_ub, (0, k - 1))\n        ln = order(opts[opt], first)\n        epi = unifint(diff_lb, diff_ub, (2, len(ln) - 1))\n        ep = ln[epi]\n        ln = ln[:epi-1][::-1]\n        spi = unifint(diff_lb, diff_ub, (0, len(ln) - 1))\n        sp = ln[spi]\n        gi = fill(gi, src, {sp})\n        gi = fill(gi, 4, {ep})\n        go = fill(go, src, {add(sp, (1, 1))})\n        go = fill(go, 4, {ep})\n    else:\n        loci = randint(0, h - 1)\n        objw = unifint(diff_lb, diff_ub, (3, w))\n        locj1 = randint(0, w - objw)\n        locj2 = locj1 + objw - 1\n        sp = (loci, locj1)\n        ep = (loci, locj2)\n        gi = fill(gi, src, {sp})\n        gi = fill(gi, 4, {ep})\n        go = fill(go, src, {add(sp, (0, 1))})\n        go = fill(go, 4, {ep})\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_dc433765(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    \n    # Generate random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    # Generate random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select two colors: one for background and one for the source\n    bgc, src = sample(cols, 2)\n    \n    # Create input grid filled with background color\n    gi = canvas(bgc, (h, w))\n    # Create output grid filled with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly choose between two different patterns\n    if choice((True, False)):\n        # Create a set of potential starting points along the left and top edges\n        opts = {(ii, 0) for ii in range(h - 2)} | {(0, jj) for jj in range(1, w - 2, 1)}\n        # Create diagonal lines from each starting point\n        opts = tuple([inds & shoot(src, (1, 1)) for src in opts])\n        # Sort the lines by their length\n        opts = order(opts, size)\n        \n        # Get the number of lines\n        k = len(opts)\n        # Randomly select a line based on difficulty\n        opt = unifint(diff_lb, diff_ub, (0, k - 1))\n        # Sort the selected line by its first coordinate\n        ln = order(opts[opt], first)\n        \n        # Randomly select an end point on the line\n        epi = unifint(diff_lb, diff_ub, (2, len(ln) - 1))\n        ep = ln[epi]\n        # Reverse the line up to the end point\n        ln = ln[:epi-1][::-1]\n        \n        # Randomly select a start point on the reversed line\n        spi = unifint(diff_lb, diff_ub, (0, len(ln) - 1))\n        sp = ln[spi]\n        \n        # Place the source color at the start point on the input grid\n        gi = fill(gi, src, {sp})\n        # Place color 4 at the end point on the input grid\n        gi = fill(gi, 4, {ep})\n        \n        # Place the source color one step diagonally from the start on the output grid\n        go = fill(go, src, {add(sp, (1, 1))})\n        # Place color 4 at the end point on the output grid\n        go = fill(go, 4, {ep})\n    else:\n        # Randomly select a row\n        loci = randint(0, h - 1)\n        # Generate a random width for the object based on difficulty\n        objw = unifint(diff_lb, diff_ub, (3, w))\n        # Randomly select a starting column\n        locj1 = randint(0, w - objw)\n        # Calculate the ending column\n        locj2 = locj1 + objw - 1\n        \n        # Set start and end points\n        sp = (loci, locj1)\n        ep = (loci, locj2)\n        \n        # Place the source color at the start point on the input grid\n        gi = fill(gi, src, {sp})\n        # Place color 4 at the end point on the input grid\n        gi = fill(gi, 4, {ep})\n        \n        # Place the source color one step to the right from the start on the output grid\n        go = fill(go, src, {add(sp, (0, 1))})\n        # Place color 4 at the end point on the output grid\n        go = fill(go, 4, {ep})\n    \n    # Define a list of possible transformations\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    # Randomly choose to apply either 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply the randomly selected transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ddf7fa4f": {
    "original": "def generate_ddf7fa4f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    nocc = unifint(diff_lb, diff_ub, (1, min(w // 3, (h * w) // 36)))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    succ = 0\n    tr = 0\n    maxtr = 10 * nocc\n    inds = asindices(gi)\n    inds = sfilter(inds, lambda ij: ij[0] > 1)\n    while succ < nocc and tr < maxtr:\n        tr += 1\n        oh = randint(2, 7)\n        ow = randint(2, 7)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        hastobein = {cidx for cidx, col in enumerate(gi[0]) if col == bgc}\n        cantbein = {cidx for cidx, col in enumerate(gi[0]) if col != bgc}\n        jopts = [j for j in range(w) if \\\n            len(set(interval(j, j + ow, 1)) & hastobein) > 0 and len(set(interval(j, j + ow, 1)) & cantbein) == 0\n        ]\n        cands = sfilter(cands, lambda ij: ij[1] in jopts)\n        if len(cands) == 0:\n            continue\n        loci, locj = choice(totuple(cands))\n        locat = choice(sfilter(interval(locj, locj + ow, 1), lambda jj: jj in hastobein))\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        if sq.issubset(inds):\n            succ += 1\n            inds = (inds - sq) - mapply(dneighbors, sq)\n            col = choice(remcols)\n            gr = choice(remove(col, remcols))\n            gi = fill(gi, col, {(0, locat)})\n            go = fill(go, col, {(0, locat)})\n            gi = fill(gi, gr, sq)\n            go = fill(go, col, sq)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ddf7fa4f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random height between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))  # Generate a random width between 10 and 30\n    nocc = unifint(diff_lb, diff_ub, (1, min(w // 3, (h * w) // 36)))  # Calculate number of objects to place\n    bgc = choice(cols)  # Choose a random background color\n    remcols = remove(bgc, cols)  # Remove the background color from the list of available colors\n    gi = canvas(bgc, (h, w))  # Create input grid filled with background color\n    go = canvas(bgc, (h, w))  # Create output grid filled with background color\n    succ = 0  # Initialize successful placements counter\n    tr = 0  # Initialize attempts counter\n    maxtr = 10 * nocc  # Set maximum number of attempts\n    inds = asindices(gi)  # Get all indices of the grid\n    inds = sfilter(inds, lambda ij: ij[0] > 1)  # Filter out first two rows of the grid\n\n    while succ < nocc and tr < maxtr:  # Loop until all objects are placed or max attempts reached\n        tr += 1  # Increment attempt counter\n        oh = randint(2, 7)  # Generate random object height between 2 and 7\n        ow = randint(2, 7)  # Generate random object width between 2 and 7\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)  # Filter valid placement locations\n        hastobein = {cidx for cidx, col in enumerate(gi[0]) if col == bgc}  # Indices where object must touch in top row\n        cantbein = {cidx for cidx, col in enumerate(gi[0]) if col != bgc}  # Indices where object can't touch in top row\n        jopts = [j for j in range(w) if \\\n            len(set(interval(j, j + ow, 1)) & hastobein) > 0 and len(set(interval(j, j + ow, 1)) & cantbein) == 0\n        ]  # Calculate valid horizontal placements\n        cands = sfilter(cands, lambda ij: ij[1] in jopts)  # Further filter placement candidates\n        if len(cands) == 0:  # If no valid placements, continue to next attempt\n            continue\n        loci, locj = choice(totuple(cands))  # Choose random placement location\n        locat = choice(sfilter(interval(locj, locj + ow, 1), lambda jj: jj in hastobein))  # Choose touch point in top row\n        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))  # Create object area\n        if sq.issubset(inds):  # If object area is valid\n            succ += 1  # Increment successful placements\n            inds = (inds - sq) - mapply(dneighbors, sq)  # Remove placed area and its neighbors from available indices\n            col = choice(remcols)  # Choose random color for object\n            gr = choice(remove(col, remcols))  # Choose different color for input grid object\n            gi = fill(gi, col, {(0, locat)})  # Place color indicator in top row of input grid\n            go = fill(go, col, {(0, locat)})  # Place color indicator in top row of output grid\n            gi = fill(gi, gr, sq)  # Fill object area with different color in input grid\n            go = fill(go, col, sq)  # Fill object area with chosen color in output grid\n\n    rotf = choice((identity, rot90, rot180, rot270))  # Choose random rotation function\n    gi = rotf(gi)  # Apply rotation to input grid\n    go = rotf(go)  # Apply same rotation to output grid\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "de1cd16c": {
    "original": "def generate_de1cd16c(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    noisec = choice(cols)\n    remcols = remove(noisec, cols)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    ccols = sample(remcols, ncols)\n    starterc = ccols[0]\n    ccols = ccols[1:]\n    gi = canvas(starterc, (h, w))\n    for k in range(ncols - 1):\n        objs = objects(gi, T, F, F)\n        objs = sfilter(objs, lambda o: height(o) > 5 or width(o) > 5)\n        if len(objs) == 0:\n            break\n        objs = totuple(objs)\n        obj = choice(objs)\n        if height(obj) > 5 and width(obj) > 5:\n            ax = choice((0, 1))\n        elif height(obj) > 5:\n            ax = 0\n        elif width(obj) > 5:\n            ax = 1\n        if ax == 0:\n            loci = randint(uppermost(obj)+3, lowermost(obj)-2)\n            newobj = sfilter(toindices(obj), lambda ij: ij[0] >= loci)\n        elif ax == 1:\n            locj = randint(leftmost(obj)+3, rightmost(obj)-2)\n            newobj = sfilter(toindices(obj), lambda ij: ij[1] >= locj)\n        gi = fill(gi, ccols[k], newobj)\n    objs = order(objects(gi, T, F, F), size)\n    allowances = [max(1, ((height(o) - 2) * (width(o) - 2)) // 2) for o in objs]\n    meann = max(1, int(sum(allowances) / len(allowances)))\n    chosens = [randint(0, min(meann, allowed)) for allowed in allowances]\n    while max(chosens) == 0:\n        chosens = [randint(0, min(meann, allowed)) for allowed in allowances]\n    mx = max(chosens)\n    fixinds = [idx for idx, cnt in enumerate(chosens) if cnt == mx]\n    gogoind = fixinds[0]\n    gogocol = color(objs[gogoind])\n    fixinds = fixinds[1:]\n    for idx in fixinds:\n        chosens[idx] -= 1\n    for obj, cnt in zip(objs, chosens):\n        locs = sample(totuple(backdrop(inbox(toindices(obj)))), cnt)\n        gi = fill(gi, noisec, locs)\n    go = canvas(gogocol, (1, 1))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_de1cd16c(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 6 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Generate a random width between 6 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Choose a random color for noise\n    noisec = choice(cols)\n    \n    # Remove the noise color from the list of available colors\n    remcols = remove(noisec, cols)\n    \n    # Choose a random number of colors to use (between 2 and 9)\n    ncols = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Sample colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Set the starter color as the first color in the list\n    starterc = ccols[0]\n    \n    # Remove the starter color from the list of colors to use\n    ccols = ccols[1:]\n    \n    # Create an initial grid filled with the starter color\n    gi = canvas(starterc, (h, w))\n    \n    # Loop to create nested color regions\n    for k in range(ncols - 1):\n        # Find all objects in the grid (connected regions of the same color)\n        objs = objects(gi, T, F, F)\n        \n        # Filter objects to keep only those larger than 5x5\n        objs = sfilter(objs, lambda o: height(o) > 5 or width(o) > 5)\n        \n        # If no large objects remain, break the loop\n        if len(objs) == 0:\n            break\n        \n        # Convert the set of objects to a tuple\n        objs = totuple(objs)\n        \n        # Choose a random object from the list\n        obj = choice(objs)\n        \n        # Determine whether to split horizontally or vertically\n        if height(obj) > 5 and width(obj) > 5:\n            ax = choice((0, 1))  # Randomly choose horizontal or vertical split\n        elif height(obj) > 5:\n            ax = 0  # Split horizontally\n        elif width(obj) > 5:\n            ax = 1  # Split vertically\n        \n        # Perform the split\n        if ax == 0:\n            # Choose a random row for horizontal split\n            loci = randint(uppermost(obj)+3, lowermost(obj)-2)\n            # Keep only the lower part of the object\n            newobj = sfilter(toindices(obj), lambda ij: ij[0] >= loci)\n        elif ax == 1:\n            # Choose a random column for vertical split\n            locj = randint(leftmost(obj)+3, rightmost(obj)-2)\n            # Keep only the right part of the object\n            newobj = sfilter(toindices(obj), lambda ij: ij[1] >= locj)\n        \n        # Fill the new object with the next color\n        gi = fill(gi, ccols[k], newobj)\n    \n    # Sort objects by size\n    objs = order(objects(gi, T, F, F), size)\n    \n    # Calculate allowances for noise in each object\n    allowances = [max(1, ((height(o) - 2) * (width(o) - 2)) // 2) for o in objs]\n    \n    # Calculate the mean allowance\n    meann = max(1, int(sum(allowances) / len(allowances)))\n    \n    # Choose random number of noise pixels for each object\n    chosens = [randint(0, min(meann, allowed)) for allowed in allowances]\n    \n    # Ensure at least one object has noise\n    while max(chosens) == 0:\n        chosens = [randint(0, min(meann, allowed)) for allowed in allowances]\n    \n    # Find the maximum number of noise pixels\n    mx = max(chosens)\n    \n    # Find objects with the maximum number of noise pixels\n    fixinds = [idx for idx, cnt in enumerate(chosens) if cnt == mx]\n    \n    # Choose the first object as the \"goal\" object\n    gogoind = fixinds[0]\n    \n    # Get the color of the goal object\n    gogocol = color(objs[gogoind])\n    \n    # Remove the goal object from the list of objects to add noise to\n    fixinds = fixinds[1:]\n    \n    # Reduce noise count for other objects with max noise\n    for idx in fixinds:\n        chosens[idx] -= 1\n    \n    # Add noise to objects\n    for obj, cnt in zip(objs, chosens):\n        # Choose random locations within the object for noise\n        locs = sample(totuple(backdrop(inbox(toindices(obj)))), cnt)\n        # Add noise pixels to the grid\n        gi = fill(gi, noisec, locs)\n    \n    # Create a 1x1 grid with the goal color\n    go = canvas(gogocol, (1, 1))\n    \n    # Return the input grid and the goal grid\n    return {'input': gi, 'output': go}\n"
  },
  "ded97339": {
    "original": "def generate_ded97339(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc, linc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    ndots = unifint(diff_lb, diff_ub, (2, (h * w) // 9))\n    inds = asindices(gi)\n    dots = set()\n    if choice((True, False)):\n        idxi = randint(0, h - 1)\n        locj1 = randint(0, w - 3)\n        locj2 = randint(locj1 + 2, w - 1)\n        dots.add((idxi, locj1))\n        dots.add((idxi, locj2))\n    else:\n        idxj = randint(0, w - 1)\n        loci1 = randint(0, h - 3)\n        loci2 = randint(loci1 + 2, h - 1)\n        dots.add((loci1, idxj))\n        dots.add((loci2, idxj))\n    for k in range(ndots - 2):\n        if len(inds) == 0:\n            break\n        loc = choice(totuple(inds))\n        dots.add(loc)\n        inds = (inds - {loc}) - neighbors(loc)\n    gi = fill(gi, linc, dots)\n    go = tuple(e for e in gi)\n    for ii, r in enumerate(gi):\n        if r.count(linc) > 1:\n            a = r.index(linc)\n            b = w - r[::-1].index(linc) - 1\n            go = fill(go, linc, connect((ii, a), (ii, b)))\n    go = dmirror(go)\n    gi = dmirror(gi)\n    for ii, r in enumerate(gi):\n        if r.count(linc) > 1:\n            a = r.index(linc)\n            b = h - r[::-1].index(linc) - 1\n            go = fill(go, linc, connect((ii, a), (ii, b)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ded97339(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Randomly select two different colors: one for background and one for lines\n    bgc, linc = sample(cols, 2)\n    \n    # Create an initial input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the number of dots to place, based on difficulty and grid size\n    ndots = unifint(diff_lb, diff_ub, (2, (h * w) // 9))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Initialize an empty set to store dot locations\n    dots = set()\n    \n    # Randomly decide whether to place initial dots horizontally or vertically\n    if choice((True, False)):\n        # Place dots horizontally\n        idxi = randint(0, h - 1)  # Choose a random row\n        locj1 = randint(0, w - 3)  # Choose first column\n        locj2 = randint(locj1 + 2, w - 1)  # Choose second column, ensuring space between dots\n        dots.add((idxi, locj1))  # Add first dot\n        dots.add((idxi, locj2))  # Add second dot\n    else:\n        # Place dots vertically\n        idxj = randint(0, w - 1)  # Choose a random column\n        loci1 = randint(0, h - 3)  # Choose first row\n        loci2 = randint(loci1 + 2, h - 1)  # Choose second row, ensuring space between dots\n        dots.add((loci1, idxj))  # Add first dot\n        dots.add((loci2, idxj))  # Add second dot\n    \n    # Add remaining dots randomly\n    for k in range(ndots - 2):\n        if len(inds) == 0:\n            break  # Stop if no more valid positions\n        loc = choice(totuple(inds))  # Choose a random location\n        dots.add(loc)  # Add the dot\n        # Remove the chosen location and its neighbors from available positions\n        inds = (inds - {loc}) - neighbors(loc)\n    \n    # Place the dots on the input grid\n    gi = fill(gi, linc, dots)\n    \n    # Initialize the output grid as a copy of the input grid\n    go = tuple(e for e in gi)\n    \n    # Connect horizontal dots\n    for ii, r in enumerate(gi):\n        if r.count(linc) > 1:  # If there's more than one dot in the row\n            a = r.index(linc)  # Find the leftmost dot\n            b = w - r[::-1].index(linc) - 1  # Find the rightmost dot\n            # Draw a line connecting these dots in the output grid\n            go = fill(go, linc, connect((ii, a), (ii, b)))\n    \n    # Mirror both grids diagonally to handle vertical connections\n    go = dmirror(go)\n    gi = dmirror(gi)\n    \n    # Connect vertical dots (now horizontal in mirrored grids)\n    for ii, r in enumerate(gi):\n        if r.count(linc) > 1:  # If there's more than one dot in the column\n            a = r.index(linc)  # Find the topmost dot\n            b = h - r[::-1].index(linc) - 1  # Find the bottommost dot\n            # Draw a line connecting these dots in the mirrored output grid\n            go = fill(go, linc, connect((ii, a), (ii, b)))\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e179c5f4": {
    "original": "def generate_e179c5f4(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    h = unifint(diff_lb, diff_ub, (w+1, 30))\n    bgc, linc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    sp = (h - 1, 0)\n    gi = fill(c, linc, {sp})\n    go = tuple(e for e in gi)\n    changing = True\n    direc = 1\n    while True:\n        sp = add(sp, (-1, direc))\n        if sp[1] == w - 1 or sp[1] == 0:\n            direc *= -1\n        go2 = fill(go, linc, {sp})\n        if go2 == go:\n            break\n        go = go2\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    gix = tuple(e for e in gi)\n    gox = tuple(e for e in go)\n    numlins = unifint(diff_lb, diff_ub, (1, 4))\n    if numlins > 1:\n        gi = fill(gi, linc, ofcolor(hmirror(gix), linc))\n        go = fill(go, linc, ofcolor(hmirror(gox), linc))\n    if numlins > 2:\n        gi = fill(gi, linc, ofcolor(vmirror(gix), linc))\n        go = fill(go, linc, ofcolor(vmirror(gox), linc))\n    if numlins > 3:\n        gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))\n        go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))\n    go = replace(go, bgc, 8)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e179c5f4(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Randomly select width between 2 and 10 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Randomly select height between w+1 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (w+1, 30))\n    \n    # Randomly select two colors for background and line\n    bgc, linc = sample(cols, 2)\n    \n    # Create a canvas with background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Set starting point at bottom-left corner\n    sp = (h - 1, 0)\n    \n    # Create input grid by filling starting point with line color\n    gi = fill(c, linc, {sp})\n    \n    # Convert input grid to tuple (immutable) for output grid\n    go = tuple(e for e in gi)\n    \n    # Initialize direction and change flag\n    changing = True\n    direc = 1\n    \n    # Main loop to create zigzag pattern\n    while True:\n        # Move starting point up and in current direction\n        sp = add(sp, (-1, direc))\n        \n        # If reached right or left edge, reverse direction\n        if sp[1] == w - 1 or sp[1] == 0:\n            direc *= -1\n        \n        # Fill new point with line color in output grid\n        go2 = fill(go, linc, {sp})\n        \n        # If no change occurred, break the loop\n        if go2 == go:\n            break\n        \n        # Update output grid\n        go = go2\n    \n    # List of possible mirroring and rotation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Randomly choose to apply 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply random transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Convert grids to tuples for further operations\n    gix = tuple(e for e in gi)\n    gox = tuple(e for e in go)\n    \n    # Randomly choose number of lines (1 to 4) based on difficulty\n    numlins = unifint(diff_lb, diff_ub, (1, 4))\n    \n    # If more than 1 line, add horizontal mirror of the line\n    if numlins > 1:\n        gi = fill(gi, linc, ofcolor(hmirror(gix), linc))\n        go = fill(go, linc, ofcolor(hmirror(gox), linc))\n    \n    # If more than 2 lines, add vertical mirror of the line\n    if numlins > 2:\n        gi = fill(gi, linc, ofcolor(vmirror(gix), linc))\n        go = fill(go, linc, ofcolor(vmirror(gox), linc))\n    \n    # If 4 lines, add diagonal mirror of the line\n    if numlins > 3:\n        gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))\n        go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))\n    \n    # Replace background color with 8 in output grid\n    go = replace(go, bgc, 8)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e21d9049": {
    "original": "def generate_e21d9049(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    ph = unifint(diff_lb, diff_ub, (2, 9))\n    pw = unifint(diff_lb, diff_ub, (2, 9))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    hbar = frozenset({(choice(remcols), (k, 0)) for k in range(ph)})\n    wbar = frozenset({(choice(remcols), (0, k)) for k in range(pw)})\n    locih = randint(0, h - ph)\n    locjh = randint(0, w - 1)\n    loch = (locih, locjh)\n    locjw = randint(0, w - pw)\n    lociw = randint(0, h - 1)\n    locw = (lociw, locjw)\n    canv = canvas(bgc, (h, w))\n    hbar = shift(hbar, loch)\n    wbar = shift(wbar, locw)\n    cp = (lociw, locjh)\n    col = choice(remcols)\n    hbard = extract(hbar, lambda cij: abs(cij[1][0] - lociw) % ph == 0)[1]\n    hbar = sfilter(hbar, lambda cij: abs(cij[1][0] - lociw) % ph != 0) | {(col, hbard)}\n    wbard = extract(wbar, lambda cij: abs(cij[1][1] - locjh) % pw == 0)[1]\n    wbar = sfilter(wbar, lambda cij: abs(cij[1][1] - locjh) % pw != 0) | {(col, wbard)}\n    gi = paint(canv, hbar | wbar)\n    go = paint(canv, hbar | wbar)\n    for k in range(h//ph + 1):\n        go = paint(go, shift(hbar, (k*ph, 0)))\n        go = paint(go, shift(hbar, (-k*ph, 0)))\n    for k in range(w//pw + 1):\n        go = paint(go, shift(wbar, (0, k*pw)))\n        go = paint(go, shift(wbar, (0, -k*pw)))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e21d9049(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random height for the pattern between 2 and 9 based on difficulty\n    ph = unifint(diff_lb, diff_ub, (2, 9))\n    # Generate a random width for the pattern between 2 and 9 based on difficulty\n    pw = unifint(diff_lb, diff_ub, (2, 9))\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    # Create a new tuple of colors without the background color\n    remcols = remove(bgc, cols)\n    \n    # Create a horizontal bar of random color with height ph\n    hbar = frozenset({(choice(remcols), (k, 0)) for k in range(ph)})\n    # Create a vertical bar of random color with width pw\n    wbar = frozenset({(choice(remcols), (0, k)) for k in range(pw)})\n    \n    # Generate a random vertical position for the horizontal bar\n    locih = randint(0, h - ph)\n    # Generate a random horizontal position for the horizontal bar\n    locjh = randint(0, w - 1)\n    # Combine the positions into a tuple\n    loch = (locih, locjh)\n    \n    # Generate a random horizontal position for the vertical bar\n    locjw = randint(0, w - pw)\n    # Generate a random vertical position for the vertical bar\n    lociw = randint(0, h - 1)\n    # Combine the positions into a tuple\n    locw = (lociw, locjw)\n    \n    # Create a canvas (grid) with the background color and specified dimensions\n    canv = canvas(bgc, (h, w))\n    \n    # Shift the horizontal bar to its random position\n    hbar = shift(hbar, loch)\n    # Shift the vertical bar to its random position\n    wbar = shift(wbar, locw)\n    \n    # Define the intersection point of the two bars\n    cp = (lociw, locjh)\n    \n    # Choose a random color for the intersection point\n    col = choice(remcols)\n    \n    # Extract the cell from hbar that intersects with the vertical bar\n    hbard = extract(hbar, lambda cij: abs(cij[1][0] - lociw) % ph == 0)[1]\n    # Remove the intersection cell from hbar and add it back with the new color\n    hbar = sfilter(hbar, lambda cij: abs(cij[1][0] - lociw) % ph != 0) | {(col, hbard)}\n    \n    # Extract the cell from wbar that intersects with the horizontal bar\n    wbard = extract(wbar, lambda cij: abs(cij[1][1] - locjh) % pw == 0)[1]\n    # Remove the intersection cell from wbar and add it back with the new color\n    wbar = sfilter(wbar, lambda cij: abs(cij[1][1] - locjh) % pw != 0) | {(col, wbard)}\n    \n    # Paint the input grid with the horizontal and vertical bars\n    gi = paint(canv, hbar | wbar)\n    \n    # Initialize the output grid with the same bars as the input\n    go = paint(canv, hbar | wbar)\n    \n    # Repeat the horizontal bar pattern vertically\n    for k in range(h//ph + 1):\n        # Paint additional horizontal bars above the original\n        go = paint(go, shift(hbar, (k*ph, 0)))\n        # Paint additional horizontal bars below the original\n        go = paint(go, shift(hbar, (-k*ph, 0)))\n    \n    # Repeat the vertical bar pattern horizontally\n    for k in range(w//pw + 1):\n        # Paint additional vertical bars to the right of the original\n        go = paint(go, shift(wbar, (0, k*pw)))\n        # Paint additional vertical bars to the left of the original\n        go = paint(go, shift(wbar, (0, -k*pw)))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "e26a3af2": {
    "original": "def generate_e26a3af2(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    nr = unifint(diff_lb, diff_ub, (1, 10))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    scols = sample(cols, nr)\n    sgs = [canvas(col, (2, w)) for col in scols]\n    numexp = unifint(diff_lb, diff_ub, (0, 30 - nr))\n    for k in range(numexp):\n        idx = randint(0, nr - 1)\n        sgs[idx] = sgs[idx] + sgs[idx][-1:]\n    sgs2 = []\n    for idx, col in enumerate(scols):\n        sg = sgs[idx]\n        a, b = shape(sg)\n        ub = (a * b) // 2 - 1\n        nnoise = unifint(diff_lb, diff_ub, (0, ub))\n        inds = totuple(asindices(sg))\n        noise = sample(inds, nnoise)\n        oc = remove(col, cols)\n        noise = frozenset({(choice(oc), ij) for ij in noise})\n        sg2 = paint(sg, noise)\n        for idxx in [0, -1]:\n            while sum([e == col for e in sg2[idxx]]) < w // 2:\n                locs = [j for j, e in enumerate(sg2[idxx]) if e != col]\n                ch = choice(locs)\n                if idxx == 0:\n                    sg2 = (sg2[0][:ch] + (col,) + sg2[0][ch+1:],) + sg2[1:]\n                else:\n                    sg2 = sg2[:-1] + (sg2[-1][:ch] + (col,) + sg2[-1][ch+1:],)\n        sgs2.append(sg2)\n    gi = tuple(row for sg in sgs2 for row in sg)\n    go = tuple(row for sg in sgs for row in sg)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e26a3af2(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the number of rows (1 to 10) based on difficulty\n    nr = unifint(diff_lb, diff_ub, (1, 10))\n    \n    # Randomly choose the width of the grid (4 to 30) based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly sample 'nr' colors from the available colors\n    scols = sample(cols, nr)\n    \n    # Create a list of grids, each 2 rows high and 'w' columns wide, filled with a single color\n    sgs = [canvas(col, (2, w)) for col in scols]\n    \n    # Randomly choose number of rows to expand (0 to 30-nr) based on difficulty\n    numexp = unifint(diff_lb, diff_ub, (0, 30 - nr))\n    \n    # Randomly expand some grids by duplicating their last row\n    for k in range(numexp):\n        idx = randint(0, nr - 1)  # Choose a random grid\n        sgs[idx] = sgs[idx] + sgs[idx][-1:]  # Append the last row to the chosen grid\n    \n    sgs2 = []\n    for idx, col in enumerate(scols):\n        sg = sgs[idx]\n        a, b = shape(sg)  # Get the dimensions of the current grid\n        \n        # Calculate upper bound for noise (half the grid size minus 1)\n        ub = (a * b) // 2 - 1\n        \n        # Randomly choose number of noise pixels based on difficulty\n        nnoise = unifint(diff_lb, diff_ub, (0, ub))\n        \n        # Get all indices of the grid\n        inds = totuple(asindices(sg))\n        \n        # Randomly sample indices for noise\n        noise = sample(inds, nnoise)\n        \n        # Choose colors different from the current color for noise\n        oc = remove(col, cols)\n        \n        # Create noise by assigning random colors to chosen indices\n        noise = frozenset({(choice(oc), ij) for ij in noise})\n        \n        # Apply noise to the grid\n        sg2 = paint(sg, noise)\n        \n        # Ensure at least half of the first and last rows are the original color\n        for idxx in [0, -1]:  # For first and last row\n            while sum([e == col for e in sg2[idxx]]) < w // 2:\n                # Find indices where color is different\n                locs = [j for j, e in enumerate(sg2[idxx]) if e != col]\n                ch = choice(locs)  # Choose a random index to change\n                \n                # Change the color at the chosen index\n                if idxx == 0:  # For the first row\n                    sg2 = (sg2[0][:ch] + (col,) + sg2[0][ch+1:],) + sg2[1:]\n                else:  # For the last row\n                    sg2 = sg2[:-1] + (sg2[-1][:ch] + (col,) + sg2[-1][ch+1:],)\n        \n        sgs2.append(sg2)  # Add the modified grid to the list\n    \n    # Combine all grids into a single input grid\n    gi = tuple(row for sg in sgs2 for row in sg)\n    \n    # Combine all original grids into a single output grid\n    go = tuple(row for sg in sgs for row in sg)\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        gi = dmirror(gi)  # Mirror input grid\n        go = dmirror(go)  # Mirror output grid\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e3497940": {
    "original": "def generate_e3497940(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    bgc, barc = sample(cols, 2)\n    remcols = remove(barc, remove(bgc, cols))\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, ncols)\n    nlinesocc = unifint(diff_lb, diff_ub, (1, h))\n    lopts = interval(0, h, 1)\n    linesocc = sample(lopts, nlinesocc)\n    rs = canvas(bgc, (h, w))\n    ls = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    for idx in linesocc:\n        j = unifint(diff_lb, diff_ub, (1, w - 1))\n        obj = [(choice(ccols), (idx, jj)) for jj in range(j)]\n        go = paint(go, obj)\n        slen = randint(1, j)\n        obj2 = obj[:slen]\n        if choice((True, False)):\n            obj, obj2 = obj2, obj\n        rs = paint(rs, obj)\n        ls = paint(ls, obj2)\n    gi = hconcat(hconcat(vmirror(ls), canvas(barc, (h, 1))), rs)\n    go = vmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e3497940(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly choose the height of the grid between 4 and 30\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose the width of the grid between 3 and 14\n    w = unifint(diff_lb, diff_ub, (3, 14))\n    \n    # Randomly select two different colors: one for background and one for the separator bar\n    bgc, barc = sample(cols, 2)\n    \n    # Create a set of remaining colors, excluding the background and separator colors\n    remcols = remove(barc, remove(bgc, cols))\n    \n    # Randomly choose the number of colors to be used in the pattern (between 1 and 8)\n    ncols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select the colors to be used in the pattern\n    ccols = sample(remcols, ncols)\n    \n    # Randomly choose the number of lines that will contain the pattern (between 1 and h)\n    nlinesocc = unifint(diff_lb, diff_ub, (1, h))\n    \n    # Create a tuple of possible line indices\n    lopts = interval(0, h, 1)\n    \n    # Randomly select which lines will contain the pattern\n    linesocc = sample(lopts, nlinesocc)\n    \n    # Create three empty grids filled with the background color\n    rs = canvas(bgc, (h, w))  # Right side of the input\n    ls = canvas(bgc, (h, w))  # Left side of the input\n    go = canvas(bgc, (h, w))  # Output grid\n    \n    # For each line that should contain a pattern:\n    for idx in linesocc:\n        # Randomly choose the length of the pattern (between 1 and w-1)\n        j = unifint(diff_lb, diff_ub, (1, w - 1))\n        \n        # Create a full pattern object with randomly chosen colors\n        obj = [(choice(ccols), (idx, jj)) for jj in range(j)]\n        \n        # Paint the full pattern on the output grid\n        go = paint(go, obj)\n        \n        # Randomly choose a split point for the pattern\n        slen = randint(1, j)\n        \n        # Split the pattern into two parts\n        obj2 = obj[:slen]\n        \n        # Randomly decide which part goes to the left and right side of the input\n        if choice((True, False)):\n            obj, obj2 = obj2, obj\n        \n        # Paint the patterns on the right and left side of the input\n        rs = paint(rs, obj)\n        ls = paint(ls, obj2)\n    \n    # Construct the input grid: mirror the left side, add separator bar, then add right side\n    gi = hconcat(hconcat(vmirror(ls), canvas(barc, (h, 1))), rs)\n    \n    # Mirror the output grid vertically\n    go = vmirror(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e40b9e2f": {
    "original": "def generate_e40b9e2f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  \n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    d = unifint(diff_lb, diff_ub, (4, min(h, w) - 2))\n    loci = randint(0, h - d)\n    locj = randint(0, w - d)\n    loc = (loci, locj)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numcols)\n    subg = canvas(bgc, (d, d))\n    inds = asindices(subg)\n    if d % 2 == 0:\n        q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] < d//2)\n        cp = {(d//2-1, d//2-1), (d//2, d//2-1), (d//2-1, d//2), (d//2, d//2)}\n    else:\n        q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] <= d//2)\n        cp = {(d//2, d//2)} | ineighbors((d//2, d//2))\n    nrings = unifint(diff_lb, diff_ub, (1, max(1, (d-2)//2)))\n    rings = set()\n    for k in range(nrings):\n        ring = box({(k, k), (d-k-1, d-k-1)})\n        rings = rings | ring\n    qin = q - rings\n    qout = rings & q\n    ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))\n    tailobjcells = sample(totuple(q), ntailobjcells)\n    tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}\n    tailobj = {(choice(ccols), ij) for ij in tailobjcells}\n    while hmirror(tailobj) == tailobj and vmirror(tailobj) == tailobj:\n        ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))\n        tailobjcells = sample(totuple(q), ntailobjcells)\n        tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}\n        tailobj = {(choice(ccols), ij) for ij in tailobjcells}\n    for k in range(4):\n        subg = paint(subg, tailobj)\n        subg = rot90(subg)\n    fxobj = recolor(choice(ccols), cp)\n    subg = paint(subg, fxobj)\n    subgi = subg\n    subgo = tuple(e for e in subgi)\n    subgi = fill(subgi, bgc, rings)\n    nsplits = unifint(diff_lb, diff_ub, (1, 4))\n    splits = [set() for k in range(nsplits)]\n    for idx, cel in enumerate(tailobj):\n        splits[idx%nsplits].add(cel)\n    for jj in range(4):\n        if jj < len(splits):\n            subgi = paint(subgi, splits[jj])\n        subgi = rot90(subgi)\n    subgi = paint(subgi, fxobj)\n    rotf = choice((identity, rot90, rot180, rot270))\n    subgi = rotf(subgi)\n    subgo = rotf(subgo)\n    gi = paint(canvas(bgc, (h, w)), shift(asobject(subgi), loc))\n    go = paint(canvas(bgc, (h, w)), shift(asobject(subgo), loc))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e40b9e2f(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (6, 30))  # Generate a random height between 6 and 30\n    w = unifint(diff_lb, diff_ub, (6, 30))  # Generate a random width between 6 and 30\n    d = unifint(diff_lb, diff_ub, (4, min(h, w) - 2))  # Generate a random size for the inner square, at least 4 and at most 2 less than the smaller dimension\n    loci = randint(0, h - d)  # Generate a random vertical position for the inner square\n    locj = randint(0, w - d)  # Generate a random horizontal position for the inner square\n    loc = (loci, locj)  # Combine the positions into a tuple\n    bgc = choice(cols)  # Choose a random background color\n    remcols = remove(bgc, cols)  # Remove the background color from the list of available colors\n    numcols = unifint(diff_lb, diff_ub, (1, 9))  # Choose a random number of colors to use (1 to 9)\n    ccols = sample(remcols, numcols)  # Randomly select colors from the remaining colors\n    subg = canvas(bgc, (d, d))  # Create a square grid of size d x d with the background color\n    inds = asindices(subg)  # Get all indices of the subgrid\n    if d % 2 == 0:  # If the subgrid size is even\n        q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] < d//2)  # Get the top-left quarter of the subgrid\n        cp = {(d//2-1, d//2-1), (d//2, d//2-1), (d//2-1, d//2), (d//2, d//2)}  # Define the center points\n    else:  # If the subgrid size is odd\n        q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] <= d//2)  # Get the top-left quarter (plus middle column) of the subgrid\n        cp = {(d//2, d//2)} | ineighbors((d//2, d//2))  # Define the center point and its diagonal neighbors\n    nrings = unifint(diff_lb, diff_ub, (1, max(1, (d-2)//2)))  # Choose a random number of rings to create\n    rings = set()  # Initialize an empty set for ring indices\n    for k in range(nrings):\n        ring = box({(k, k), (d-k-1, d-k-1)})  # Create a ring of indices\n        rings = rings | ring  # Add the ring to the set of rings\n    qin = q - rings  # Get the indices in the quarter that are not part of any ring\n    qout = rings & q  # Get the indices in the quarter that are part of a ring\n    ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))  # Choose a random number of cells for the tail object\n    tailobjcells = sample(totuple(q), ntailobjcells)  # Randomly select cells for the tail object\n    tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}  # Ensure at least one cell is inside and outside the rings\n    tailobj = {(choice(ccols), ij) for ij in tailobjcells}  # Create the tail object with random colors\n    while hmirror(tailobj) == tailobj and vmirror(tailobj) == tailobj:  # If the tail object is symmetrical both horizontally and vertically\n        ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))  # Choose a new random number of cells\n        tailobjcells = sample(totuple(q), ntailobjcells)  # Randomly select new cells\n        tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}  # Ensure at least one cell is inside and outside the rings\n        tailobj = {(choice(ccols), ij) for ij in tailobjcells}  # Create a new tail object with random colors\n    for k in range(4):\n        subg = paint(subg, tailobj)  # Paint the tail object onto the subgrid\n        subg = rot90(subg)  # Rotate the subgrid 90 degrees\n    fxobj = recolor(choice(ccols), cp)  # Create a fixed object at the center with a random color\n    subg = paint(subg, fxobj)  # Paint the fixed object onto the subgrid\n    subgi = subg  # Create a copy of the subgrid for the input\n    subgo = tuple(e for e in subgi)  # Create a copy of the subgrid for the output\n    subgi = fill(subgi, bgc, rings)  # Fill the rings with the background color in the input subgrid\n    nsplits = unifint(diff_lb, diff_ub, (1, 4))  # Choose a random number of splits (1 to 4)\n    splits = [set() for k in range(nsplits)]  # Create empty sets for each split\n    for idx, cel in enumerate(tailobj):\n        splits[idx%nsplits].add(cel)  # Distribute the tail object cells among the splits\n    for jj in range(4):\n        if jj < len(splits):\n            subgi = paint(subgi, splits[jj])  # Paint each split onto the input subgrid\n        subgi = rot90(subgi)  # Rotate the input subgrid 90 degrees\n    subgi = paint(subgi, fxobj)  # Paint the fixed object onto the input subgrid\n    rotf = choice((identity, rot90, rot180, rot270))  # Choose a random rotation function\n    subgi = rotf(subgi)  # Apply the rotation to the input subgrid\n    subgo = rotf(subgo)  # Apply the same rotation to the output subgrid\n    gi = paint(canvas(bgc, (h, w)), shift(asobject(subgi), loc))  # Create the final input grid by painting the rotated input subgrid onto a background\n    go = paint(canvas(bgc, (h, w)), shift(asobject(subgo), loc))  # Create the final output grid by painting the rotated output subgrid onto a background\n    return {'input': gi, 'output': go}  # Return the input and output grids as a dictionary\n"
  },
  "e48d4e1a": {
    "original": "def generate_e48d4e1a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    loci = randint(1, h - 2)\n    locj = randint(1, w - 2)\n    inds = asindices(canvas(-1, (loci, locj)))\n    maxn = min(min(h - loci - 1, w - locj - 1), len(inds))\n    nn = unifint(diff_lb, diff_ub, (1, maxn))\n    ss = sample(totuple(inds), nn)\n    bgc, fgc, dotc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    gi = fill(gi, fgc, hfrontier((loci, 0)) | vfrontier((0, locj)))\n    gi = fill(gi, dotc, ss)\n    go = fill(go, fgc, hfrontier((loci + nn, 0)) | vfrontier((0, locj + nn)))\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e48d4e1a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random row index for the starting point, excluding edges\n    loci = randint(1, h - 2)\n    \n    # Choose a random column index for the starting point, excluding edges\n    locj = randint(1, w - 2)\n    \n    # Create a set of all indices in a subgrid from (0,0) to (loci, locj)\n    inds = asindices(canvas(-1, (loci, locj)))\n    \n    # Calculate the maximum number of dots that can be placed\n    maxn = min(min(h - loci - 1, w - locj - 1), len(inds))\n    \n    # Choose a random number of dots to place based on difficulty\n    nn = unifint(diff_lb, diff_ub, (1, maxn))\n    \n    # Randomly select nn indices from inds to place dots\n    ss = sample(totuple(inds), nn)\n    \n    # Randomly choose three different colors for background, foreground, and dots\n    bgc, fgc, dotc = sample(cols, 3)\n    \n    # Create the input grid with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Add horizontal and vertical lines to the input grid\n    gi = fill(gi, fgc, hfrontier((loci, 0)) | vfrontier((0, locj)))\n    \n    # Place the dots on the input grid\n    gi = fill(gi, dotc, ss)\n    \n    # Add horizontal and vertical lines to the output grid, shifted by nn\n    go = fill(go, fgc, hfrontier((loci + nn, 0)) | vfrontier((0, locj + nn)))\n    \n    # Randomly choose a rotation function (including no rotation)\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to the input grid\n    gi = rotf(gi)\n    \n    # Apply the same rotation to the output grid\n    go = rotf(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "e5062a87": {
    "original": "def generate_e5062a87(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    eligcol, objc = sample(cols, 2)\n    gi = canvas(eligcol, (h, w))\n    inds = asindices(gi)\n    sp = choice(totuple(inds))\n    obj = {sp}\n    ncells = unifint(diff_lb, diff_ub, (3, 9))\n    for k in range(ncells - 1):\n        obj.add(choice(totuple((inds - obj) & mapply(neighbors, obj))))\n    obj = normalize(obj)\n    nnoise = unifint(diff_lb, diff_ub, (int(0.2*h*w), int(0.5*h*w)))\n    locs = sample(totuple(inds), nnoise)\n    gi = fill(gi, 0, locs)\n    noccs = unifint(diff_lb, diff_ub, (2, max(2, (h * w) // (len(obj) * 3))))\n    oh, ow = shape(obj)\n    for k in range(noccs):\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        loc = (loci, locj)\n        gi = fill(gi, objc if k == noccs - 1 else 0, shift(obj, loc))\n    occs = occurrences(gi, recolor(0, obj))\n    res = mapply(lbind(shift, obj), occs)\n    go = fill(gi, objc, res)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e5062a87(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 1 to 9 (possible color values)\n    cols = interval(1, 10, 1)\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select two colors: one for the background, one for the object\n    eligcol, objc = sample(cols, 2)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(eligcol, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Choose a random starting point for the object\n    sp = choice(totuple(inds))\n    \n    # Initialize the object with the starting point\n    obj = {sp}\n    \n    # Determine a random number of cells for the object (3 to 9)\n    ncells = unifint(diff_lb, diff_ub, (3, 9))\n    \n    # Grow the object by adding adjacent cells\n    for k in range(ncells - 1):\n        # Add a random neighboring cell to the object\n        obj.add(choice(totuple((inds - obj) & mapply(neighbors, obj))))\n    \n    # Move the object to the origin (normalize its position)\n    obj = normalize(obj)\n    \n    # Determine the number of noise cells (20% to 50% of grid area)\n    nnoise = unifint(diff_lb, diff_ub, (int(0.2*h*w), int(0.5*h*w)))\n    \n    # Select random locations for noise\n    locs = sample(totuple(inds), nnoise)\n    \n    # Add noise to the grid (set selected cells to color 0)\n    gi = fill(gi, 0, locs)\n    \n    # Determine number of object occurrences (2 to max possible fit)\n    noccs = unifint(diff_lb, diff_ub, (2, max(2, (h * w) // (len(obj) * 3))))\n    \n    # Get the shape of the object\n    oh, ow = shape(obj)\n    \n    # Place object occurrences on the grid\n    for k in range(noccs):\n        # Choose a random location for the object\n        loci = randint(0, h - oh)\n        locj = randint(0, w - ow)\n        loc = (loci, locj)\n        \n        # Place the object: last occurrence in objc color, others in color 0\n        gi = fill(gi, objc if k == noccs - 1 else 0, shift(obj, loc))\n    \n    # Find all occurrences of the object in the grid\n    occs = occurrences(gi, recolor(0, obj))\n    \n    # Shift all occurrences to their actual positions\n    res = mapply(lbind(shift, obj), occs)\n    \n    # Create the output grid by filling all object occurrences with objc color\n    go = fill(gi, objc, res)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e509e548": {
    "original": "def generate_e509e548(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 6))\n    getL = lambda h, w: connect((0, 0), (h - 1, 0)) | connect((0, 0), (0, w - 1))\n    getU = lambda h, w: connect((0, 0), (0, w - 1)) | connect((0, 0), (randint(1, h - 1), 0)) | connect((0, w - 1), (randint(1, h - 1), w - 1))\n    getH = lambda h, w: connect((0, 0), (0, w - 1)) | shift(connect((0, 0), (h - 1, 0)) | connect((h - 1, 0), (h - 1, randint(1, w - 1))), (0, randint(1, w - 2)))\n    minshp_getter_pairs = ((2, 2, getL), (2, 3, getU), (3, 3, getH))\n    colmapper = {getL: 1, getU: 6, getH: 2}\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, 6))\n    ccols = sample(remcols, ncols)\n    nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        minh, minw, getter = choice(minshp_getter_pairs)\n        oh = randint(minh, 6)\n        ow = randint(minw, 6)\n        obj = getter(oh, ow)\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror)\n        nmfs = choice((1, 2))\n        for fn in sample(mfs, nmfs):\n            obj = fn(obj)\n            obj = normalize(obj)\n        oh, ow = shape(obj)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        plcd = shift(obj, loc)\n        if plcd.issubset(inds):\n            succ += 1\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            col = choice(ccols)\n            gi = fill(gi, col, plcd)\n            go = fill(go, colmapper[getter], plcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e509e548(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1, 2, and 6\n    cols = difference(interval(0, 10, 1), (1, 2, 6))\n    \n    # Define lambda functions for creating different shapes:\n    # L-shape\n    getL = lambda h, w: connect((0, 0), (h - 1, 0)) | connect((0, 0), (0, w - 1))\n    # U-shape\n    getU = lambda h, w: connect((0, 0), (0, w - 1)) | connect((0, 0), (randint(1, h - 1), 0)) | connect((0, w - 1), (randint(1, h - 1), w - 1))\n    # H-shape\n    getH = lambda h, w: connect((0, 0), (0, w - 1)) | shift(connect((0, 0), (h - 1, 0)) | connect((h - 1, 0), (h - 1, randint(1, w - 1))), (0, randint(1, w - 2)))\n    \n    # Define minimum shape dimensions and their corresponding getter functions\n    minshp_getter_pairs = ((2, 2, getL), (2, 3, getU), (3, 3, getH))\n    \n    # Define color mapping for each shape type\n    colmapper = {getL: 1, getU: 6, getH: 2}\n    \n    # Generate random height and width for the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use\n    ncols = unifint(diff_lb, diff_ub, (1, 6))\n    \n    # Sample colors to use for objects\n    ccols = sample(remcols, ncols)\n    \n    # Determine the number of objects to place based on difficulty\n    nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))\n    \n    # Initialize counters for successful placements and attempts\n    succ = 0\n    tr = 0\n    maxtr = 5 * nobjs\n    \n    # Create input and output grids with background color\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Main loop for placing objects\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        # Choose a random shape type and minimum dimensions\n        minh, minw, getter = choice(minshp_getter_pairs)\n        \n        # Generate random dimensions for the object\n        oh = randint(minh, 6)\n        ow = randint(minw, 6)\n        \n        # Create the object using the chosen getter function\n        obj = getter(oh, ow)\n        \n        # Define possible mirror transformations\n        mfs = (identity, dmirror, cmirror, vmirror, hmirror)\n        \n        # Choose number of transformations to apply\n        nmfs = choice((1, 2))\n        \n        # Apply random transformations to the object\n        for fn in sample(mfs, nmfs):\n            obj = fn(obj)\n            obj = normalize(obj)\n        \n        # Get the final dimensions of the transformed object\n        oh, ow = shape(obj)\n        \n        # Find valid placement locations for the object\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random valid location\n        loc = choice(totuple(cands))\n        \n        # Shift the object to the chosen location\n        plcd = shift(obj, loc)\n        \n        # Check if the placed object fits within the grid\n        if plcd.issubset(inds):\n            succ += 1\n            # Remove placed object and its neighbors from available indices\n            inds = (inds - plcd) - mapply(dneighbors, plcd)\n            \n            # Choose a random color for the object\n            col = choice(ccols)\n            \n            # Place the object on the input grid with the chosen color\n            gi = fill(gi, col, plcd)\n            \n            # Place the object on the output grid with the shape-specific color\n            go = fill(go, colmapper[getter], plcd)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "e50d258f": {
    "original": "def generate_e50d258f(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    padcol = choice(remcols)\n    remcols = remove(padcol, remcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    num = unifint(diff_lb, diff_ub, (1, 10))\n    indss = asindices(gi)\n    maxtrials = 4 * num\n    tr = 0\n    succ = 0\n    bound = None\n    go = None\n    while succ < num and tr <= maxtrials:\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        oh = randint(3, 8)\n        ow = randint(3, 8)\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        if len(subs) == 0:\n            tr += 1\n            continue\n        loci, locj = choice(subs)\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        bd = backdrop(obj)\n        if bd.issubset(indss):\n            numcc = unifint(diff_lb, diff_ub, (1, 7))\n            ccols = sample(remcols, numcc)\n            if succ == 0:\n                numred = unifint(diff_lb, diff_ub, (1, oh * ow))\n                bound = numred\n            else:\n                numred = unifint(diff_lb, diff_ub, (0, min(oh * ow, bound - 1)))\n            cc = canvas(choice(ccols), (oh, ow))\n            cci = asindices(cc)\n            subs = sample(totuple(cci), numred)\n            obj1 = {(choice(ccols), ij) for ij in cci - set(subs)}\n            obj2 = {(2, ij) for ij in subs}\n            obj = obj1 | obj2\n            gi = paint(gi, shift(obj, (loci, locj)))\n            if go is None:\n                go = paint(cc, obj)\n            succ += 1\n            indss = (indss - bd) - outbox(bd)\n        tr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e50d258f(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 2 from the range 0-9, creating a list of available colors\n    cols = remove(2, interval(0, 10, 1))    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    # Choose a random background color from available colors\n    bgc = choice(cols)\n    # Remove the background color from the list of remaining colors\n    remcols = remove(bgc, cols)\n    # Choose a random padding color from the remaining colors\n    padcol = choice(remcols)\n    # Remove the padding color from the list of remaining colors\n    remcols = remove(padcol, remcols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color (initially same as input)\n    go = canvas(bgc, (h, w))\n    # Generate a random number of objects to place, between 1 and 10\n    num = unifint(diff_lb, diff_ub, (1, 10))\n    # Get all possible indices in the grid\n    indss = asindices(gi)\n    # Set maximum number of attempts to place objects\n    maxtrials = 4 * num\n    tr = 0  # Initialize trial counter\n    succ = 0  # Initialize success counter\n    bound = None  # Initialize bound for number of red cells\n    go = None  # Initialize output grid\n    \n    # Loop to place objects on the grid\n    while succ < num and tr <= maxtrials:\n        # Break if we've used all colors or all grid spaces\n        if len(remcols) == 0 or len(indss) == 0:\n            break\n        # Generate random height and width for the object\n        oh = randint(3, 8)\n        ow = randint(3, 8)\n        # Find all possible locations to place the object\n        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))\n        # If no valid locations, increment trial counter and continue\n        if len(subs) == 0:\n            tr += 1\n            continue\n        # Choose a random location for the object\n        loci, locj = choice(subs)\n        # Create the object as a set of its corner coordinates\n        obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})\n        # Get the backdrop (area) of the object\n        bd = backdrop(obj)\n        # Check if the object fits within the available grid space\n        if bd.issubset(indss):\n            # Choose a random number of colors for the object\n            numcc = unifint(diff_lb, diff_ub, (1, 7))\n            # Sample colors for the object\n            ccols = sample(remcols, numcc)\n            # For the first object, set a bound for the number of red cells\n            if succ == 0:\n                numred = unifint(diff_lb, diff_ub, (1, oh * ow))\n                bound = numred\n            else:\n                # For subsequent objects, ensure decreasing number of red cells\n                numred = unifint(diff_lb, diff_ub, (0, min(oh * ow, bound - 1)))\n            # Create a canvas for the object with a random color\n            cc = canvas(choice(ccols), (oh, ow))\n            # Get all indices of the object's canvas\n            cci = asindices(cc)\n            # Randomly select indices for red cells\n            subs = sample(totuple(cci), numred)\n            # Create the object with chosen colors and red cells\n            obj1 = {(choice(ccols), ij) for ij in cci - set(subs)}\n            obj2 = {(2, ij) for ij in subs}\n            obj = obj1 | obj2\n            # Paint the object onto the input grid\n            gi = paint(gi, shift(obj, (loci, locj)))\n            # If it's the first object, set it as the output\n            if go is None:\n                go = paint(cc, obj)\n            succ += 1  # Increment success counter\n            # Remove used grid spaces and their surroundings from available indices\n            indss = (indss - bd) - outbox(bd)\n        tr += 1  # Increment trial counter\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "e6721834": {
    "original": "def generate_e6721834(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 15))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    bgc1, bgc2, sqc = sample(cols, 3)\n    remcols = difference(cols, (bgc1, bgc2, sqc))\n    gi1 = canvas(bgc1, (h, w))\n    gi2 = canvas(bgc2, (h, w))\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    tr = 0\n    succ = 0\n    maxtr = 5 * noccs\n    gi1inds = asindices(gi1)\n    gi2inds = asindices(gi2)\n    go = canvas(bgc2, (h, w))\n    seen = []\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        oh = randint(2, min(6, h//2))\n        ow = randint(2, min(6, w//2))\n        cands = sfilter(gi1inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        bounds = shift(asindices(canvas(-1, (oh, ow))), loc)\n        ncells = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n        obj = set(sample(totuple(bounds), ncells))\n        objc = choice(remcols)\n        objn = normalize(obj)\n        if (objn, objc) in seen:\n            continue\n        seen.append(((objn, objc)))\n        if bounds.issubset(gi1inds):\n            succ += 1\n            gi1inds = (gi1inds - bounds) - mapply(neighbors, bounds)\n            gi1 = fill(gi1, sqc, bounds)\n            gi1 = fill(gi1, objc, obj)\n            cands2 = sfilter(gi2inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands2) == 0:\n                continue\n            loc2 = choice(totuple(cands2))\n            bounds2 = shift(shift(bounds, invert(loc)), loc2)\n            obj2 = shift(shift(obj, invert(loc)), loc2)\n            if bounds2.issubset(gi2inds):\n                gi2inds = (gi2inds - bounds2) - mapply(neighbors, bounds2)\n                gi2 = fill(gi2, objc, obj2)\n                go = fill(go, sqc, bounds2)\n                go = fill(go, objc, obj2)\n    gi = vconcat(gi1, gi2)\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e6721834(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 6 and 15 based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 15))\n    \n    # Generate random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Randomly select 3 colors: two for backgrounds and one for squares\n    bgc1, bgc2, sqc = sample(cols, 3)\n    \n    # Create a set of remaining colors not used for backgrounds or squares\n    remcols = difference(cols, (bgc1, bgc2, sqc))\n    \n    # Create two canvases with different background colors\n    gi1 = canvas(bgc1, (h, w))\n    gi2 = canvas(bgc2, (h, w))\n    \n    # Determine number of objects to place based on difficulty (1 to 1/16th of total cells)\n    noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))\n    \n    # Initialize counters for attempts and successful placements\n    tr = 0\n    succ = 0\n    maxtr = 5 * noccs\n    \n    # Get all indices for both canvases\n    gi1inds = asindices(gi1)\n    gi2inds = asindices(gi2)\n    \n    # Create output canvas with second background color\n    go = canvas(bgc2, (h, w))\n    \n    # Initialize list to track seen objects\n    seen = []\n    \n    # Main loop for placing objects\n    while tr < maxtr and succ < noccs:\n        tr += 1\n        \n        # Randomly determine object height and width\n        oh = randint(2, min(6, h//2))\n        ow = randint(2, min(6, w//2))\n        \n        # Find valid locations for object placement in first canvas\n        cands = sfilter(gi1inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid locations, skip this iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random location for the object\n        loc = choice(totuple(cands))\n        \n        # Create bounding box for the object\n        bounds = shift(asindices(canvas(-1, (oh, ow))), loc)\n        \n        # Randomly determine number of cells to fill in object\n        ncells = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))\n        \n        # Randomly select cells to fill within the object\n        obj = set(sample(totuple(bounds), ncells))\n        \n        # Choose a random color for the object\n        objc = choice(remcols)\n        \n        # Normalize the object (move to origin)\n        objn = normalize(obj)\n        \n        # If this object has been seen before, skip it\n        if (objn, objc) in seen:\n            continue\n        \n        # Add object to seen list\n        seen.append(((objn, objc)))\n        \n        # If object fits in first canvas\n        if bounds.issubset(gi1inds):\n            succ += 1\n            \n            # Remove object area and its neighbors from available indices\n            gi1inds = (gi1inds - bounds) - mapply(neighbors, bounds)\n            \n            # Fill object area with square color in first canvas\n            gi1 = fill(gi1, sqc, bounds)\n            \n            # Fill object cells with object color in first canvas\n            gi1 = fill(gi1, objc, obj)\n            \n            # Find valid locations for object placement in second canvas\n            cands2 = sfilter(gi2inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            \n            # If no valid locations in second canvas, skip\n            if len(cands2) == 0:\n                continue\n            \n            # Choose a random location for the object in second canvas\n            loc2 = choice(totuple(cands2))\n            \n            # Calculate new bounds and object position in second canvas\n            bounds2 = shift(shift(bounds, invert(loc)), loc2)\n            obj2 = shift(shift(obj, invert(loc)), loc2)\n            \n            # If object fits in second canvas\n            if bounds2.issubset(gi2inds):\n                # Remove object area from available indices in second canvas\n                gi2inds = (gi2inds - bounds2) - mapply(neighbors, bounds2)\n                \n                # Fill object cells with object color in second canvas\n                gi2 = fill(gi2, objc, obj2)\n                \n                # Fill object area with square color in output canvas\n                go = fill(go, sqc, bounds2)\n                \n                # Fill object cells with object color in output canvas\n                go = fill(go, objc, obj2)\n    \n    # Concatenate first and second canvas vertically\n    gi = vconcat(gi1, gi2)\n    \n    # Define possible transformation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Choose to apply 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply random transformations to input and output\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e76a88a6": {
    "original": "def generate_e76a88a6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    objh = unifint(diff_lb, diff_ub, (2, 5))\n    objw = unifint(diff_lb, diff_ub, (2, 5))\n    bounds = asindices(canvas(0, (objh, objw)))\n    shp = {choice(totuple(bounds))}\n    nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))\n    for j in range(nc):\n        ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))\n        shp.add(ij)\n    shp = normalize(shp)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    dmyc = choice(remcols)\n    remcols = remove(dmyc, remcols)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    shpp = shift(shp, (loci, locj))\n    numco = unifint(diff_lb, diff_ub, (2, 8))\n    colll = sample(remcols, numco)\n    shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    while numcolors(shppc) == 1:\n        shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    shppcn = normalize(shppc)\n    gi = canvas(bgc, (h, w))\n    gi = paint(gi, shppc)\n    go = tuple(e for e in gi)\n    ub = ((h * w) / (oh * ow)) // 2\n    ub = max(1, ub)\n    numlocs = unifint(diff_lb, diff_ub, (1, ub))\n    cnt = 0\n    fails = 0\n    maxfails = 5 * numlocs\n    idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)\n    idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n    while cnt < numlocs and fails < maxfails:\n        if len(idns) == 0:\n            break\n        loc = choice(totuple(idns))\n        plcd = shift(shppcn, loc)\n        plcdi = toindices(plcd)\n        if plcdi.issubset(idns):\n            go = paint(go, plcd)\n            gi = fill(gi, dmyc, plcdi)\n            cnt += 1\n            idns = (idns - plcdi) - mapply(dneighbors, plcdi)\n        else:\n            fails += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e76a88a6(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a tuple of integers from 0 to 9\n    h = unifint(diff_lb, diff_ub, (8, 30))  # Generate a random height between 8 and 30\n    w = unifint(diff_lb, diff_ub, (8, 30))  # Generate a random width between 8 and 30\n    objh = unifint(diff_lb, diff_ub, (2, 5))  # Generate a random object height between 2 and 5\n    objw = unifint(diff_lb, diff_ub, (2, 5))  # Generate a random object width between 2 and 5\n    bounds = asindices(canvas(0, (objh, objw)))  # Create a set of all possible indices for the object\n    shp = {choice(totuple(bounds))}  # Start the shape with a random cell\n    nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))  # Determine number of cells to add to the shape\n    for j in range(nc):\n        # Add neighboring cells to the shape until we reach the desired number\n        ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))\n        shp.add(ij)\n    shp = normalize(shp)  # Move the shape to the origin\n    bgc = choice(cols)  # Choose a background color\n    remcols = remove(bgc, cols)  # Remove the background color from available colors\n    dmyc = choice(remcols)  # Choose a dummy color\n    remcols = remove(dmyc, remcols)  # Remove the dummy color from available colors\n    oh, ow = shape(shp)  # Get the dimensions of the shape\n    loci = randint(0, h - oh)  # Choose a random vertical position for the shape\n    locj = randint(0, w - ow)  # Choose a random horizontal position for the shape\n    shpp = shift(shp, (loci, locj))  # Move the shape to its position on the grid\n    numco = unifint(diff_lb, diff_ub, (2, 8))  # Determine number of colors to use for the shape\n    colll = sample(remcols, numco)  # Select colors for the shape\n    shppc = frozenset({(choice(colll), ij) for ij in shpp})  # Assign random colors to the shape cells\n    while numcolors(shppc) == 1:\n        # Ensure the shape has more than one color\n        shppc = frozenset({(choice(colll), ij) for ij in shpp})\n    shppcn = normalize(shppc)  # Normalize the colored shape\n    gi = canvas(bgc, (h, w))  # Create the input grid with background color\n    gi = paint(gi, shppc)  # Paint the colored shape onto the input grid\n    go = tuple(e for e in gi)  # Create the output grid as a copy of the input grid\n    ub = ((h * w) / (oh * ow)) // 2  # Calculate upper bound for number of additional shapes\n    ub = max(1, ub)  # Ensure at least one additional shape\n    numlocs = unifint(diff_lb, diff_ub, (1, ub))  # Determine number of additional shapes to add\n    cnt = 0  # Counter for successfully placed shapes\n    fails = 0  # Counter for failed placement attempts\n    maxfails = 5 * numlocs  # Maximum number of failed attempts allowed\n    idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)  # Find valid placement locations\n    idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)  # Ensure shapes fit within grid\n    while cnt < numlocs and fails < maxfails:\n        if len(idns) == 0:\n            break  # Stop if no valid positions left\n        loc = choice(totuple(idns))  # Choose a random position for new shape\n        plcd = shift(shppcn, loc)  # Move the normalized shape to the chosen position\n        plcdi = toindices(plcd)  # Get indices of the placed shape\n        if plcdi.issubset(idns):\n            # If the shape fits, add it to the output grid and update the input grid\n            go = paint(go, plcd)  # Add the shape to the output grid\n            gi = fill(gi, dmyc, plcdi)  # Mark the shape's position with dummy color in input grid\n            cnt += 1  # Increment successful placement counter\n            idns = (idns - plcdi) - mapply(dneighbors, plcdi)  # Update valid placement locations\n        else:\n            fails += 1  # Increment failed attempt counter\n    return {'input': gi, 'output': go}  # Return the generated input and output grids\n"
  },
  "e8593010": {
    "original": "def generate_e8593010(diff_lb: float, diff_ub: float) -> dict:\n    a = frozenset({frozenset({ORIGIN})})\n    b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})\n    c = frozenset({\n        frozenset({ORIGIN, DOWN, UNITY}),\n        frozenset({ORIGIN, DOWN, RIGHT}),\n        frozenset({UNITY, DOWN, RIGHT}),\n        frozenset({UNITY, ORIGIN, RIGHT}),\n        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),\n        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)\n    })\n    a, b, c = totuple(a), totuple(b), totuple(c)\n    prs = [(a, 3), (b, 2), (c, 1)]\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    reminds = asindices(gi)\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 2))\n    maxtr = 10\n    for k in range(nobjs):\n        ntr = 0\n        objs, col = choice(prs)\n        obj = choice(objs)\n        while ntr < maxtr:\n            if len(reminds) == 0:\n                break\n            loc = choice(totuple(reminds))\n            olcd = shift(obj, loc)\n            if olcd.issubset(reminds):\n                gi = fill(gi, fgc, olcd)\n                go = fill(go, col, olcd)\n                reminds = (reminds - olcd) - mapply(dneighbors, olcd)\n                break\n            ntr += 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e8593010(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set containing a single point at the origin\n    a = frozenset({frozenset({ORIGIN})})\n    # Define a set containing two shapes: a horizontal line of 2 points and a vertical line of 2 points\n    b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})\n    # Define a set containing various 3-point shapes: L-shapes, corners, and lines\n    c = frozenset({\n        frozenset({ORIGIN, DOWN, UNITY}),  # L-shape\n        frozenset({ORIGIN, DOWN, RIGHT}),  # L-shape\n        frozenset({UNITY, DOWN, RIGHT}),   # L-shape\n        frozenset({UNITY, ORIGIN, RIGHT}), # Corner\n        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),  # Vertical line\n        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)  # Horizontal line\n    })\n    # Convert the sets of shapes to tuples for easier handling\n    a, b, c = totuple(a), totuple(b), totuple(c)\n    # Create a list of shape tuples with their corresponding output color\n    prs = [(a, 3), (b, 2), (c, 1)]\n    # Create a set of colors excluding 1, 2, and 3 (which are used for output)\n    cols = difference(interval(0, 10, 1), (1, 2, 3))\n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    # Randomly choose a background color\n    bgc = choice(cols)\n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    # Choose a foreground color from the remaining colors\n    fgc = choice(remcols)\n    # Create an input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    # Create an output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    # Create a set of all indices in the grid\n    reminds = asindices(gi)\n    # Determine the number of objects to place based on difficulty and grid size\n    nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 2))\n    # Set maximum number of attempts to place each object\n    maxtr = 10\n    # Loop to place each object\n    for k in range(nobjs):\n        # Initialize attempt counter\n        ntr = 0\n        # Randomly choose an object type and its corresponding output color\n        objs, col = choice(prs)\n        # Randomly choose a specific shape from the chosen object type\n        obj = choice(objs)\n        # Try to place the object, with a maximum number of attempts\n        while ntr < maxtr:\n            # Break if no more available positions\n            if len(reminds) == 0:\n                break\n            # Choose a random location from available positions\n            loc = choice(totuple(reminds))\n            # Shift the object to the chosen location\n            olcd = shift(obj, loc)\n            # Check if the shifted object fits within available positions\n            if olcd.issubset(reminds):\n                # Place the object in the input grid with the foreground color\n                gi = fill(gi, fgc, olcd)\n                # Place the object in the output grid with its corresponding color\n                go = fill(go, col, olcd)\n                # Remove the object's positions and its neighbors from available positions\n                reminds = (reminds - olcd) - mapply(dneighbors, olcd)\n                break\n            # Increment attempt counter\n            ntr += 1\n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e8dc4411": {
    "original": "def generate_e8dc4411(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  \n    h = unifint(diff_lb, diff_ub, (9, 30))\n    w = unifint(diff_lb, diff_ub, (9, 30))\n    d = unifint(diff_lb, diff_ub, (3, min(h, w)//2-1))\n    bgc, objc, remc = sample(cols, 3)\n    c = canvas(bgc, (d, d))\n    inds = sfilter(asindices(c), lambda ij: ij[0]>=d//2 and ij[1]>=d//2)\n    ncd = unifint(diff_lb, diff_ub, (1, len(inds)//2))\n    nc = choice((ncd, len(inds)-ncd))\n    nc = min(max(2, nc), len(inds) - 1)\n    cells = sample(totuple(inds), nc)\n    cells = set(cells) | {choice(((d//2, d//2), (d//2, d//2-1)))}\n    cells = cells | {(jj, ii) for ii, jj in cells}\n    for k in range(4):\n        c = fill(c, objc, cells)\n        c = rot90(c)\n    while palette(toobject(box(asindices(c)), c)) == frozenset({bgc}) and height(c) > 3:\n        c = trim(c)\n    obj = ofcolor(c, objc)\n    od = height(obj)\n    loci = randint(1, h - 2*od)\n    locj = randint(1, w - 2*od)\n    obj = shift(obj, (loci, locj))\n    bd = backdrop(obj)\n    p = 0\n    while len(shift(obj, (p, p)) & bd) > 0:\n        p += 1\n    obj2 = shift(obj, (p, p))\n    nbhs = mapply(neighbors, obj)\n    while len(obj2 & nbhs) == 0:\n        nbhs = mapply(neighbors, nbhs)\n    indic = obj2 & nbhs\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, objc, obj)\n    gi = fill(gi, remc, indic)\n    go = tuple(e for e in gi)\n    for k in range(30):\n        newg = fill(go, remc, shift(obj, (p*(k+1), p*(k+1))))\n        if newg == go:\n            break\n        go = newg\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e8dc4411(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (9, 30))  # Generate a random height between 9 and 30\n    w = unifint(diff_lb, diff_ub, (9, 30))  # Generate a random width between 9 and 30\n    d = unifint(diff_lb, diff_ub, (3, min(h, w)//2-1))  # Generate a random size for the initial shape\n    bgc, objc, remc = sample(cols, 3)  # Choose 3 random colors for background, object, and remainder\n    c = canvas(bgc, (d, d))  # Create a square canvas with background color\n    inds = sfilter(asindices(c), lambda ij: ij[0]>=d//2 and ij[1]>=d//2)  # Get indices in the lower right quadrant\n    ncd = unifint(diff_lb, diff_ub, (1, len(inds)//2))  # Generate a random number for cell count\n    nc = choice((ncd, len(inds)-ncd))  # Choose between the generated number and its complement\n    nc = min(max(2, nc), len(inds) - 1)  # Ensure at least 2 cells and not all cells are chosen\n    cells = sample(totuple(inds), nc)  # Randomly select cells from the lower right quadrant\n    cells = set(cells) | {choice(((d//2, d//2), (d//2, d//2-1)))}  # Add a cell at or near the center\n    cells = cells | {(jj, ii) for ii, jj in cells}  # Mirror the cells diagonally\n    for k in range(4):\n        c = fill(c, objc, cells)  # Fill the selected cells with the object color\n        c = rot90(c)  # Rotate the canvas 90 degrees\n    while palette(toobject(box(asindices(c)), c)) == frozenset({bgc}) and height(c) > 3:\n        c = trim(c)  # Trim the canvas until the border contains non-background colors or minimum size reached\n    obj = ofcolor(c, objc)  # Get all cells with the object color\n    od = height(obj)  # Get the height of the object\n    loci = randint(1, h - 2*od)  # Choose a random vertical position for the object\n    locj = randint(1, w - 2*od)  # Choose a random horizontal position for the object\n    obj = shift(obj, (loci, locj))  # Move the object to the chosen position\n    bd = backdrop(obj)  # Get the bounding box of the object\n    p = 0\n    while len(shift(obj, (p, p)) & bd) > 0:\n        p += 1  # Find the minimum shift to move object out of its bounding box\n    obj2 = shift(obj, (p, p))  # Create a shifted copy of the object\n    nbhs = mapply(neighbors, obj)  # Get all neighbors of the object cells\n    while len(obj2 & nbhs) == 0:\n        nbhs = mapply(neighbors, nbhs)  # Expand neighborhood until it intersects with shifted object\n    indic = obj2 & nbhs  # Get the intersection of shifted object and expanded neighborhood\n    gi = canvas(bgc, (h, w))  # Create the input grid with background color\n    gi = fill(gi, objc, obj)  # Add the object to the input grid\n    gi = fill(gi, remc, indic)  # Add the intersection cells to the input grid\n    go = tuple(e for e in gi)  # Create a copy of the input grid for output\n    for k in range(30):\n        newg = fill(go, remc, shift(obj, (p*(k+1), p*(k+1))))  # Shift and fill object repeatedly\n        if newg == go:\n            break  # Stop if no changes were made\n        go = newg  # Update output grid\n    rotf = choice((identity, rot90, rot180, rot270))  # Choose a random rotation function\n    gi = rotf(gi)  # Apply rotation to input grid\n    go = rotf(go)  # Apply same rotation to output grid\n    return {'input': gi, 'output': go}  # Return the input and output grids as a dictionary\n"
  },
  "e9614598": {
    "original": "def generate_e9614598(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))    \n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    r = randint(0, h - 1)\n    sizh = unifint(diff_lb, diff_ub, (2, w//2))\n    siz = 2 * sizh + 1\n    siz = min(max(5, siz), w)\n    locj = randint(0, w - siz)\n    bgc, dotc = sample(cols, 2)\n    c = canvas(bgc, (h, w))\n    A = (r, locj)\n    B = (r, locj+siz-1)\n    gi = fill(c, dotc, {A, B})\n    locc = (r, locj + siz // 2)\n    go = fill(gi, 3, {locc})\n    go = fill(go, 3, dneighbors(locc))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e9614598(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range 0-9, creating a list of available colors\n    cols = remove(3, interval(0, 10, 1))    \n    \n    # Generate a random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate a random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Choose a random row index\n    r = randint(0, h - 1)\n    \n    # Calculate half of the size of the pattern, ensuring it's within bounds\n    sizh = unifint(diff_lb, diff_ub, (2, w//2))\n    \n    # Calculate the full size of the pattern (always odd)\n    siz = 2 * sizh + 1\n    \n    # Ensure the pattern size is between 5 and the grid width\n    siz = min(max(5, siz), w)\n    \n    # Choose a random starting column for the pattern\n    locj = randint(0, w - siz)\n    \n    # Select two different colors: one for background and one for dots\n    bgc, dotc = sample(cols, 2)\n    \n    # Create a blank canvas with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Define the leftmost point of the pattern\n    A = (r, locj)\n    \n    # Define the rightmost point of the pattern\n    B = (r, locj+siz-1)\n    \n    # Place dots at the leftmost and rightmost points of the pattern\n    gi = fill(c, dotc, {A, B})\n    \n    # Calculate the center point of the pattern\n    locc = (r, locj + siz // 2)\n    \n    # Place a green (color 3) dot at the center of the pattern\n    go = fill(gi, 3, {locc})\n    \n    # Place green dots around the center dot (creating a plus sign)\n    go = fill(go, 3, dneighbors(locc))\n    \n    # Randomly decide whether to diagonally mirror the input and output\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e98196ab": {
    "original": "def generate_e98196ab(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (3, 14))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    topc = choice(remcols)\n    remcols = remove(topc, remcols)\n    botc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    nocc = unifint(diff_lb, diff_ub, (2, (h * w) // 2))\n    subs = sample(inds, nocc)\n    numa = randint(1, nocc - 1)\n    A = sample(subs, numa)\n    B = difference(subs, A)\n    topg = fill(c, topc, A)\n    botg = fill(c, botc, B)\n    go = fill(topg, botc, B)\n    br = canvas(linc, (1, w))\n    gi = vconcat(vconcat(topg, br), botg)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e98196ab(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9 (inclusive)\n    cols = interval(0, 10, 1)    \n    \n    # Generate a random height between 3 and 14 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 14))\n    \n    # Generate a random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Remove the background color from the available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random color for the dividing line\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random color for the top section\n    topc = choice(remcols)\n    \n    # Remove the top color from the remaining colors\n    remcols = remove(topc, remcols)\n    \n    # Choose a random color for the bottom section\n    botc = choice(remcols)\n    \n    # Create a canvas (grid) with the background color and specified dimensions\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Generate a random number of cells to color, between 2 and half the total cells\n    nocc = unifint(diff_lb, diff_ub, (2, (h * w) // 2))\n    \n    # Randomly select indices to be colored\n    subs = sample(inds, nocc)\n    \n    # Generate a random number for how many cells will be in the top section\n    numa = randint(1, nocc - 1)\n    \n    # Randomly select indices for the top section\n    A = sample(subs, numa)\n    \n    # The remaining indices will be for the bottom section\n    B = difference(subs, A)\n    \n    # Color the top section on the canvas\n    topg = fill(c, topc, A)\n    \n    # Color the bottom section on the canvas\n    botg = fill(c, botc, B)\n    \n    # Create the output grid by coloring both sections on the same canvas\n    go = fill(topg, botc, B)\n    \n    # Create a horizontal line with the line color\n    br = canvas(linc, (1, w))\n    \n    # Combine top section, line, and bottom section vertically\n    gi = vconcat(vconcat(topg, br), botg)\n    \n    # 50% chance to diagonally mirror both input and output\n    if choice((True, False)):\n        # Diagonally mirror the input grid\n        gi = dmirror(gi)\n        # Diagonally mirror the output grid\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "e9afcf9a": {
    "original": "def generate_e9afcf9a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)    \n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    numc = unifint(diff_lb, diff_ub, (1, min(10, h)))\n    colss = sample(cols, numc)\n    rr = tuple(choice(colss) for k in range(h))\n    rr2 = rr[::-1]\n    gi = []\n    go = []\n    for k in range(w):\n        gi.append(rr)\n        if k % 2 == 0:\n            go.append(rr)\n        else:\n            go.append(rr2)\n    gi = dmirror(tuple(gi))\n    go = dmirror(tuple(go))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_e9afcf9a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)    \n    \n    # Randomly choose the height of the grid between 2 and 30\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly choose the width of the grid between 4 and 30\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly choose the number of colors to use, between 1 and min(10, h)\n    numc = unifint(diff_lb, diff_ub, (1, min(10, h)))\n    \n    # Randomly sample 'numc' colors from the color range\n    colss = sample(cols, numc)\n    \n    # Create a tuple of randomly chosen colors, of length 'h'\n    # This represents a vertical stripe pattern\n    rr = tuple(choice(colss) for k in range(h))\n    \n    # Create the reverse of the stripe pattern\n    rr2 = rr[::-1]\n    \n    # Initialize lists for input and output grids\n    gi = []\n    go = []\n    \n    # Generate the input and output grids\n    for k in range(w):\n        # Add the original stripe pattern to the input grid\n        gi.append(rr)\n        \n        # For the output grid:\n        if k % 2 == 0:\n            # Add the original stripe pattern for even columns\n            go.append(rr)\n        else:\n            # Add the reversed stripe pattern for odd columns\n            go.append(rr2)\n    \n    # Mirror the input grid diagonally\n    # This transforms vertical stripes into horizontal stripes\n    gi = dmirror(tuple(gi))\n    \n    # Mirror the output grid diagonally\n    # This transforms the alternating vertical stripes into alternating horizontal stripes\n    go = dmirror(tuple(go))\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ea32f347": {
    "original": "def generate_ea32f347(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2, 4))\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    a = unifint(diff_lb, diff_ub, (3, 30))\n    b = unifint(diff_lb, diff_ub, (2, a))\n    c = unifint(diff_lb, diff_ub, (1, b))\n    if c - a == 2:\n        if a > 1:\n            a -= 1\n        elif c < min(h, w):\n            c += 1\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    for col, l in zip((1, 4, 2), (a, b, c)):\n        ln1 = connect((0, 0), (0, l - 1))\n        ln2 = connect((0, 0), (l - 1, 0))\n        tmpg = fill(gi, -1, asindices(gi) - inds)\n        occs1 = occurrences(tmpg, recolor(bgc, ln1))\n        occs2 = occurrences(tmpg, recolor(bgc, ln2))\n        pool = []\n        if len(occs1) > 0:\n            pool.append((ln1, occs1))\n        if len(occs2) > 0:\n            pool.append((ln2, occs2))\n        ln, occs = choice(pool)\n        loc = choice(totuple(occs))\n        plcd = shift(ln, loc)\n        gi = fill(gi, choice(remcols), plcd)\n        go = fill(go, col, plcd)\n        inds = (inds - plcd) - mapply(dneighbors, plcd)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ea32f347(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors, excluding 1, 2, and 4\n    cols = difference(interval(0, 10, 1), (1, 2, 4))\n    \n    # Generate random height between 5 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random width between 5 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (5, 30))\n    \n    # Generate random length 'a' between 3 and 30 based on difficulty\n    a = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate random length 'b' between 2 and 'a' based on difficulty\n    b = unifint(diff_lb, diff_ub, (2, a))\n    \n    # Generate random length 'c' between 1 and 'b' based on difficulty\n    c = unifint(diff_lb, diff_ub, (1, b))\n    \n    # Ensure the difference between 'c' and 'a' is not 2\n    if c - a == 2:\n        # If 'a' is greater than 1, decrease it by 1\n        if a > 1:\n            a -= 1\n        # Otherwise, if 'c' is less than the minimum of height and width, increase it by 1\n        elif c < min(h, w):\n            c += 1\n    \n    # Choose a random background color from the color set\n    bgc = choice(cols)\n    \n    # Remove the chosen background color from the color set\n    remcols = remove(bgc, cols)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid with background color\n    go = canvas(bgc, (h, w))\n    \n    # Get all indices of the input grid\n    inds = asindices(gi)\n    \n    # Iterate over colors (1, 4, 2) and lengths (a, b, c)\n    for col, l in zip((1, 4, 2), (a, b, c)):\n        # Create a vertical line of length 'l'\n        ln1 = connect((0, 0), (0, l - 1))\n        \n        # Create a horizontal line of length 'l'\n        ln2 = connect((0, 0), (l - 1, 0))\n        \n        # Create a temporary grid with -1 outside the valid indices\n        tmpg = fill(gi, -1, asindices(gi) - inds)\n        \n        # Find occurrences of vertical line in the temporary grid\n        occs1 = occurrences(tmpg, recolor(bgc, ln1))\n        \n        # Find occurrences of horizontal line in the temporary grid\n        occs2 = occurrences(tmpg, recolor(bgc, ln2))\n        \n        # Initialize pool of possible lines and their occurrences\n        pool = []\n        \n        # If vertical line has occurrences, add it to the pool\n        if len(occs1) > 0:\n            pool.append((ln1, occs1))\n        \n        # If horizontal line has occurrences, add it to the pool\n        if len(occs2) > 0:\n            pool.append((ln2, occs2))\n        \n        # Choose a random line and its occurrences from the pool\n        ln, occs = choice(pool)\n        \n        # Choose a random location from the occurrences\n        loc = choice(totuple(occs))\n        \n        # Shift the chosen line to the chosen location\n        plcd = shift(ln, loc)\n        \n        # Fill the input grid with a random color at the placed line\n        gi = fill(gi, choice(remcols), plcd)\n        \n        # Fill the output grid with the current color at the placed line\n        go = fill(go, col, plcd)\n        \n        # Update available indices by removing placed line and its neighbors\n        inds = (inds - plcd) - mapply(dneighbors, plcd)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ea786f4a": {
    "original": "def generate_ea786f4a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    mp = (h, w)\n    h = 2 * h + 1\n    w = 2 * w + 1\n    linc = choice(cols)\n    remcols = remove(linc, cols)\n    gi = canvas(linc, (h, w))\n    inds = remove(mp, asindices(gi))\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, ncols)\n    obj = {(choice(ccols), ij) for ij in inds}\n    gi = paint(gi, obj)\n    ln1 = shoot(mp, (-1, -1))\n    ln2 = shoot(mp, (1, 1))\n    ln3 = shoot(mp, (-1, 1))\n    ln4 = shoot(mp, (1, -1))\n    go = fill(gi, linc, ln1 | ln2 | ln3 | ln4)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ea786f4a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine half of the height (rounded down) based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Randomly determine half of the width (rounded down) based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 14))\n    \n    # Set the midpoint of the grid\n    mp = (h, w)\n    \n    # Calculate full height (always odd)\n    h = 2 * h + 1\n    \n    # Calculate full width (always odd)\n    w = 2 * w + 1\n    \n    # Randomly choose a color for the lines\n    linc = choice(cols)\n    \n    # Remove the line color from the available colors\n    remcols = remove(linc, cols)\n    \n    # Create initial grid filled with the line color\n    gi = canvas(linc, (h, w))\n    \n    # Get all indices except the midpoint\n    inds = remove(mp, asindices(gi))\n    \n    # Randomly determine number of colors to use (1-9)\n    ncols = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly choose colors from remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Create object with random colors at all indices except midpoint\n    obj = {(choice(ccols), ij) for ij in inds}\n    \n    # Paint the random colored object onto the initial grid\n    gi = paint(gi, obj)\n    \n    # Create diagonal line from midpoint to top-left\n    ln1 = shoot(mp, (-1, -1))\n    \n    # Create diagonal line from midpoint to bottom-right\n    ln2 = shoot(mp, (1, 1))\n    \n    # Create diagonal line from midpoint to top-right\n    ln3 = shoot(mp, (-1, 1))\n    \n    # Create diagonal line from midpoint to bottom-left\n    ln4 = shoot(mp, (1, -1))\n    \n    # Fill all diagonal lines with the line color to create an X\n    go = fill(gi, linc, ln1 | ln2 | ln3 | ln4)\n    \n    # Return input (random colored grid) and output (grid with X overlay)\n    return {'input': gi, 'output': go}\n"
  },
  "eb281b96": {
    "original": "def generate_eb281b96(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 8))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(remcols, numc)\n    c = canvas(bgc, (h, w))\n    inds = asindices(c)\n    ncells = unifint(diff_lb, diff_ub, (1, h * w))\n    locs = sample(totuple(inds), ncells)\n    obj = {(choice(ccols), ij) for ij in locs}\n    gi = paint(c, obj)\n    go = vconcat(gi, hmirror(gi[:-1]))\n    go = vconcat(go, hmirror(go[:-1]))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_eb281b96(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose a height between 3 and 8 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 8))\n    \n    # Randomly choose a width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Create a list of colors excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (1 to 9) based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, 9))\n    \n    # Randomly select 'numc' colors from the remaining colors\n    ccols = sample(remcols, numc)\n    \n    # Create a canvas of size h x w filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all possible indices of the canvas\n    inds = asindices(c)\n    \n    # Randomly choose the number of cells to color (1 to h*w) based on difficulty\n    ncells = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Randomly select 'ncells' locations from all possible indices\n    locs = sample(totuple(inds), ncells)\n    \n    # Create an object by assigning random colors to the selected locations\n    obj = {(choice(ccols), ij) for ij in locs}\n    \n    # Paint the object onto the canvas to create the input grid\n    gi = paint(c, obj)\n    \n    # Create the first part of the output by concatenating the input with its horizontal mirror (excluding the last row)\n    go = vconcat(gi, hmirror(gi[:-1]))\n    \n    # Complete the output by concatenating the previous result with its horizontal mirror (excluding the last row)\n    # This creates a symmetrical pattern that's mirrored both vertically and horizontally\n    go = vconcat(go, hmirror(go[:-1]))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "eb5a1d5d": {
    "original": "def generate_eb5a1d5d(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    d = unifint(diff_lb, diff_ub, (2, 10))\n    go = canvas(-1, (d*2-1, d*2-1))\n    colss = sample(cols, d)\n    for j, cc in enumerate(colss):\n        go = fill(go, cc, box(frozenset({(j, j), (2*d - 2 - j, 2*d - 2 - j)})))\n    nvenl = unifint(diff_lb, diff_ub, (0, 30 - d))\n    nhenl = unifint(diff_lb, diff_ub, (0, 30 - d))\n    enl = [nvenl, nhenl]\n    gi = tuple(e for e in go)\n    while (enl[0] > 0 or enl[1] > 0) and max(shape(gi)) < 30:\n        opts = []\n        if enl[0] > 0:\n            opts.append((identity, 0))\n        if enl[1] > 0:\n            opts.append((dmirror, 1))\n        mirrf, ch = choice(opts)\n        gi = mirrf(gi)\n        idx = randint(0, len(gi) - 1)\n        gi = gi[:idx+1] + gi[idx:]\n        gi = mirrf(gi)\n        enl[ch] -= 1\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_eb5a1d5d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a range of integers from 0 to 9 (possible colors)\n    cols = interval(0, 10, 1)\n    \n    # Generate a random integer between 2 and 10 based on difficulty\n    d = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Create a square canvas of size (2d-1) x (2d-1) filled with -1 (empty)\n    go = canvas(-1, (d*2-1, d*2-1))\n    \n    # Randomly select 'd' colors from the available colors\n    colss = sample(cols, d)\n    \n    # Fill the diagonal boxes of the canvas with selected colors\n    for j, cc in enumerate(colss):\n        # Fill a box at (j,j) and its symmetric position with color cc\n        go = fill(go, cc, box(frozenset({(j, j), (2*d - 2 - j, 2*d - 2 - j)})))\n    \n    # Generate random integers for vertical and horizontal enlargements\n    nvenl = unifint(diff_lb, diff_ub, (0, 30 - d))\n    nhenl = unifint(diff_lb, diff_ub, (0, 30 - d))\n    enl = [nvenl, nhenl]\n    \n    # Convert the output grid to a tuple of tuples\n    gi = tuple(e for e in go)\n    \n    # Enlarge the grid randomly while keeping its size under 30x30\n    while (enl[0] > 0 or enl[1] > 0) and max(shape(gi)) < 30:\n        opts = []\n        # If vertical enlargement is possible, add it as an option\n        if enl[0] > 0:\n            opts.append((identity, 0))\n        # If horizontal enlargement is possible, add it as an option\n        if enl[1] > 0:\n            opts.append((dmirror, 1))\n        \n        # Randomly choose between vertical and horizontal enlargement\n        mirrf, ch = choice(opts)\n        \n        # Apply the chosen transformation (identity or diagonal mirror)\n        gi = mirrf(gi)\n        \n        # Choose a random index to duplicate a row/column\n        idx = randint(0, len(gi) - 1)\n        \n        # Duplicate the row/column at the chosen index\n        gi = gi[:idx+1] + gi[idx:]\n        \n        # Revert the transformation\n        gi = mirrf(gi)\n        \n        # Decrease the count for the chosen enlargement direction\n        enl[ch] -= 1\n    \n    # Return a dictionary with the input (enlarged grid) and output (original grid)\n    return {'input': gi, 'output': go}\n"
  },
  "ec883f72": {
    "original": "def generate_ec883f72(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    ohi = unifint(diff_lb, diff_ub, (0, h - 6))\n    owi = unifint(diff_lb, diff_ub, (0, w - 6))\n    oh = h - 5 - ohi\n    ow = w - 5 - owi\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    bgc, sqc, linc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    gi = fill(gi, sqc, obj)\n    obob = outbox(outbox(obj))\n    gi = fill(gi, linc, obob)\n    ln1 = shoot(lrcorner(obob), (1, 1))\n    ln2 = shoot(ulcorner(obob), (-1, -1))\n    ln3 = shoot(llcorner(obob), (1, -1))\n    ln4 = shoot(urcorner(obob), (-1, 1))\n    lns = (ln1 | ln2 | ln3 | ln4) & ofcolor(gi, bgc)\n    go = fill(gi, sqc, lns)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ec883f72(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (6, 30))\n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (6, 30))\n    \n    # Determine offset for inner object (height)\n    ohi = unifint(diff_lb, diff_ub, (0, h - 6))\n    # Determine offset for inner object (width)\n    owi = unifint(diff_lb, diff_ub, (0, w - 6))\n    \n    # Calculate height of inner object\n    oh = h - 5 - ohi\n    # Calculate width of inner object\n    ow = w - 5 - owi\n    \n    # Randomly choose top-left corner position for inner object\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Randomly select three distinct colors for background, square, and lines\n    bgc, sqc, linc = sample(cols, 3)\n    \n    # Create initial grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Define the inner object as a rectangle\n    obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    # Fill the inner object with the square color\n    gi = fill(gi, sqc, obj)\n    \n    # Create an outer box around the inner object\n    obob = outbox(outbox(obj))\n    # Draw the outer box with the line color\n    gi = fill(gi, linc, obob)\n    \n    # Define four diagonal lines from the corners of the outer box\n    ln1 = shoot(lrcorner(obob), (1, 1))   # Lower-right to top-right\n    ln2 = shoot(ulcorner(obob), (-1, -1)) # Upper-left to bottom-left\n    ln3 = shoot(llcorner(obob), (1, -1))  # Lower-left to top-left\n    ln4 = shoot(urcorner(obob), (-1, 1))  # Upper-right to bottom-right\n    \n    # Combine all diagonal lines and keep only the parts on the background\n    lns = (ln1 | ln2 | ln3 | ln4) & ofcolor(gi, bgc)\n    \n    # Fill the diagonal lines with the square color to create the output\n    go = fill(gi, sqc, lns)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ecdecbb3": {
    "original": "def generate_ecdecbb3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, dotc, linc = sample(cols, 3)\n    gi = canvas(bgc, (h, w))\n    nl = unifint(diff_lb, diff_ub, (1, h//4))\n    inds = interval(0, h, 1)\n    locs = []\n    for k in range(nl):\n        if len(inds) == 0:\n            break\n        idx = choice(inds)\n        locs.append(idx)\n        inds = remove(idx, inds)\n        inds = remove(idx - 1, inds)\n        inds = remove(idx + 1, inds)\n        inds = remove(idx - 2, inds)\n        inds = remove(idx + 2, inds)\n    locs = sorted(locs)\n    for ii in locs:\n        gi = fill(gi, linc, hfrontier((ii, 0)))\n    iopts = difference(difference(difference(interval(0, h, 1), locs), apply(increment, locs)), apply(decrement, locs))\n    jopts = interval(0, w, 1)\n    ndots = unifint(diff_lb, diff_ub, (1, min(len(iopts), w // 2)))\n    dlocs = []\n    for k in range(ndots):\n        if len(iopts) == 0 or len(jopts) == 0:\n            break\n        loci = choice(iopts)\n        locj = choice(jopts)\n        dlocs.append((loci, locj))\n        jopts = remove(locj, jopts)\n        jopts = remove(locj+1, jopts)\n        jopts = remove(locj-1, jopts)\n    go = gi\n    for d in dlocs:\n        loci, locj = d\n        if loci < min(locs):\n            go = fill(go, dotc, connect(d, (min(locs), locj)))\n            go = fill(go, linc, neighbors((min(locs), locj)))\n        elif loci > max(locs):\n            go = fill(go, dotc, connect(d, (max(locs), locj)))\n            go = fill(go, linc, neighbors((max(locs), locj)))\n        else:\n            sp = [e for e in locs if e < loci][-1]\n            ep = [e for e in locs if e > loci][0]\n            go = fill(go, dotc, connect((sp, locj), (ep, locj)))\n            go = fill(go, linc, neighbors((sp, locj)))\n            go = fill(go, linc, neighbors((ep, locj)))\n        gi = fill(gi, dotc, {d})\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ecdecbb3(diff_lb: float, diff_ub: float) -> dict:\n    # Generate a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select three unique colors for background, dots, and lines\n    bgc, dotc, linc = sample(cols, 3)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the number of horizontal lines to be added (1 to 1/4 of height)\n    nl = unifint(diff_lb, diff_ub, (1, h//4))\n    \n    # Create a list of all possible row indices\n    inds = interval(0, h, 1)\n    \n    # Initialize an empty list to store the selected line positions\n    locs = []\n    \n    # Loop to select positions for horizontal lines\n    for k in range(nl):\n        # Break if no more valid positions are available\n        if len(inds) == 0:\n            break\n        \n        # Randomly choose a row index for the line\n        idx = choice(inds)\n        \n        # Add the chosen index to the list of line positions\n        locs.append(idx)\n        \n        # Remove the chosen index and nearby indices to ensure spacing between lines\n        inds = remove(idx, inds)\n        inds = remove(idx - 1, inds)\n        inds = remove(idx + 1, inds)\n        inds = remove(idx - 2, inds)\n        inds = remove(idx + 2, inds)\n    \n    # Sort the line positions in ascending order\n    locs = sorted(locs)\n    \n    # Draw horizontal lines on the input grid\n    for ii in locs:\n        gi = fill(gi, linc, hfrontier((ii, 0)))\n    \n    # Determine valid positions for dots (not on or adjacent to lines)\n    iopts = difference(difference(difference(interval(0, h, 1), locs), apply(increment, locs)), apply(decrement, locs))\n    jopts = interval(0, w, 1)\n    \n    # Determine the number of dots to add\n    ndots = unifint(diff_lb, diff_ub, (1, min(len(iopts), w // 2)))\n    \n    # Initialize an empty list to store dot positions\n    dlocs = []\n    \n    # Loop to select positions for dots\n    for k in range(ndots):\n        # Break if no more valid positions are available\n        if len(iopts) == 0 or len(jopts) == 0:\n            break\n        \n        # Randomly choose a row and column for the dot\n        loci = choice(iopts)\n        locj = choice(jopts)\n        \n        # Add the chosen position to the list of dot positions\n        dlocs.append((loci, locj))\n        \n        # Remove the chosen column and adjacent columns to ensure spacing between dots\n        jopts = remove(locj, jopts)\n        jopts = remove(locj+1, jopts)\n        jopts = remove(locj-1, jopts)\n    \n    # Create the output grid, initially the same as the input grid\n    go = gi\n    \n    # Process each dot to create connections in the output grid\n    for d in dlocs:\n        loci, locj = d\n        if loci < min(locs):\n            # If dot is above all lines, connect it to the topmost line\n            go = fill(go, dotc, connect(d, (min(locs), locj)))\n            go = fill(go, linc, neighbors((min(locs), locj)))\n        elif loci > max(locs):\n            # If dot is below all lines, connect it to the bottommost line\n            go = fill(go, dotc, connect(d, (max(locs), locj)))\n            go = fill(go, linc, neighbors((max(locs), locj)))\n        else:\n            # If dot is between lines, connect it to the nearest lines above and below\n            sp = [e for e in locs if e < loci][-1]\n            ep = [e for e in locs if e > loci][0]\n            go = fill(go, dotc, connect((sp, locj), (ep, locj)))\n            go = fill(go, linc, neighbors((sp, locj)))\n            go = fill(go, linc, neighbors((ep, locj)))\n        \n        # Add the dot to the input grid\n        gi = fill(gi, dotc, {d})\n    \n    # Randomly decide whether to diagonally mirror both input and output grids\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ed36ccf7": {
    "original": "def generate_ed36ccf7(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    bgc = choice(cols)\n    gi = canvas(bgc, (h, w))\n    remcols = remove(bgc, cols)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    colsch = sample(remcols, numc)\n    inds = totuple(asindices(gi))\n    for col in colsch:\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        chos = sample(inds, num)\n        gi = fill(gi, col, chos)\n        inds = difference(inds, chos)\n    go = rot270(gi)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ed36ccf7(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly generate the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly generate the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (1, 30))\n    \n    # Randomly choose a background color from the color range\n    bgc = choice(cols)\n    \n    # Create a canvas (grid) with the chosen background color and dimensions\n    gi = canvas(bgc, (h, w))\n    \n    # Remove the background color from the color range to get remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (excluding background)\n    numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))\n    \n    # Randomly sample colors from the remaining colors\n    colsch = sample(remcols, numc)\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # For each chosen color:\n    for col in colsch:\n        # Randomly choose the number of cells to fill with this color\n        num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))\n        \n        # Randomly sample indices to fill with this color\n        chos = sample(inds, num)\n        \n        # Fill the chosen indices with the current color\n        gi = fill(gi, col, chos)\n        \n        # Remove the filled indices from the available indices\n        inds = difference(inds, chos)\n    \n    # Rotate the input grid 270 degrees (counterclockwise) to create the output\n    go = rot270(gi)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ef135b50": {
    "original": "def generate_ef135b50(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(9, interval(0, 10, 1))\n    while True:\n        h = unifint(diff_lb, diff_ub, (8, 30))\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        bgc = choice(cols)\n        remcols = remove(bgc, cols)\n        numc = unifint(diff_lb, diff_ub, (1, 8))\n        ccols = sample(remcols, numc)\n        gi = canvas(bgc, (h, w))\n        nsq = unifint(diff_lb, diff_ub, (2, (h * w) // 30))\n        succ = 0\n        tr = 0\n        maxtr = 5 * nsq\n        inds = asindices(gi)\n        pats = set()\n        while tr < maxtr and succ < nsq:\n            tr += 1\n            oh = randint(1, (h//3*2))\n            ow = randint(1, (w//3*2))\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) == 0:\n                continue\n            loc = choice(totuple(cands))\n            loci, locj = loc\n            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n            if bd.issubset(inds):\n                succ += 1\n                inds = (inds - bd) - mapply(neighbors, bd)\n                gi = fill(gi, choice(ccols), bd)\n                pats.add(bd)\n        res = set()\n        ofc = ofcolor(gi, bgc)\n        for pat1 in pats:\n            for pat2 in remove(pat1, pats):\n                if hmatching(pat1, pat2):\n                    um = max(uppermost(pat1), uppermost(pat2))\n                    bm = min(lowermost(pat1), lowermost(pat2))\n                    lm = min(rightmost(pat1), rightmost(pat2)) + 1\n                    rm = max(leftmost(pat1), leftmost(pat2)) - 1\n                    res = res | backdrop(frozenset({(um, lm), (bm, rm)}))\n        res = (res & ofc) - box(asindices(gi))\n        go = fill(gi, 9, res)\n        if go != gi:\n            break\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ef135b50(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-8) excluding 9\n    cols = remove(9, interval(0, 10, 1))\n    while True:\n        # Generate random height between 8 and 30 based on difficulty\n        h = unifint(diff_lb, diff_ub, (8, 30))\n        # Generate random width between 8 and 30 based on difficulty\n        w = unifint(diff_lb, diff_ub, (8, 30))\n        # Choose a random background color\n        bgc = choice(cols)\n        # Create a list of remaining colors excluding the background color\n        remcols = remove(bgc, cols)\n        # Choose a random number of colors to use (1-8) based on difficulty\n        numc = unifint(diff_lb, diff_ub, (1, 8))\n        # Randomly sample colors from the remaining colors\n        ccols = sample(remcols, numc)\n        # Create an initial grid filled with the background color\n        gi = canvas(bgc, (h, w))\n        # Calculate the number of squares to place based on difficulty and grid size\n        nsq = unifint(diff_lb, diff_ub, (2, (h * w) // 30))\n        succ = 0  # Counter for successfully placed squares\n        tr = 0    # Counter for placement attempts\n        maxtr = 5 * nsq  # Maximum number of placement attempts\n        # Get all indices of the grid\n        inds = asindices(gi)\n        pats = set()  # Set to store placed patterns\n        while tr < maxtr and succ < nsq:\n            tr += 1\n            # Generate random height for a new square (1 to 2/3 of grid height)\n            oh = randint(1, (h//3*2))\n            # Generate random width for a new square (1 to 2/3 of grid width)\n            ow = randint(1, (w//3*2))\n            # Filter valid placement locations for the new square\n            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n            if len(cands) == 0:\n                continue  # Skip if no valid placement locations\n            # Choose a random location for the new square\n            loc = choice(totuple(cands))\n            loci, locj = loc\n            # Create a backdrop for the new square\n            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n            if bd.issubset(inds):\n                succ += 1\n                # Remove the placed square and its neighbors from available indices\n                inds = (inds - bd) - mapply(neighbors, bd)\n                # Fill the new square with a randomly chosen color\n                gi = fill(gi, choice(ccols), bd)\n                pats.add(bd)  # Add the new pattern to the set\n        res = set()  # Set to store result indices\n        # Get indices of background color\n        ofc = ofcolor(gi, bgc)\n        # Find areas between horizontally matching patterns\n        for pat1 in pats:\n            for pat2 in remove(pat1, pats):\n                if hmatching(pat1, pat2):\n                    # Calculate the bounding box between the two patterns\n                    um = max(uppermost(pat1), uppermost(pat2))\n                    bm = min(lowermost(pat1), lowermost(pat2))\n                    lm = min(rightmost(pat1), rightmost(pat2)) + 1\n                    rm = max(leftmost(pat1), leftmost(pat2)) - 1\n                    # Add the area between patterns to the result set\n                    res = res | backdrop(frozenset({(um, lm), (bm, rm)}))\n        # Keep only background cells within the result set, excluding the grid border\n        res = (res & ofc) - box(asindices(gi))\n        # Create the output grid by filling the result area with color 9\n        go = fill(gi, 9, res)\n        if go != gi:\n            break  # Exit the loop if changes were made\n    return {'input': gi, 'output': go}\n"
  },
  "f15e1fac": {
    "original": "def generate_f15e1fac(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    nsps = unifint(diff_lb, diff_ub, (1, (w-1) // 2))\n    ngps = unifint(diff_lb, diff_ub, (1, (h-1) // 2))\n    spsj = sorted(sample(interval(1, w - 1, 1), nsps))\n    gpsi = sorted(sample(interval(1, h - 1, 1), ngps))\n    ofs = 0\n    bgc, linc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    gi = fill(gi, linc, {(0, jj) for jj in spsj})\n    gi = fill(gi, 2, {(ii, 0) for ii in gpsi})\n    go = tuple(e for e in gi)\n    for a, b in zip([0] + gpsi, [x - 1 for x in gpsi] + [h - 1]):\n        for jj in spsj:\n            go = fill(go, linc, connect((a, jj + ofs), (b, jj + ofs)))\n        ofs += 1\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    nmfs = choice((1, 2))\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f15e1fac(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 2 from the range 0-9, creating a list of available colors\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Determine number of starting points (1 to half of width-1)\n    nsps = unifint(diff_lb, diff_ub, (1, (w-1) // 2))\n    \n    # Determine number of growing points (1 to half of height-1)\n    ngps = unifint(diff_lb, diff_ub, (1, (h-1) // 2))\n    \n    # Randomly select and sort column indices for starting points\n    spsj = sorted(sample(interval(1, w - 1, 1), nsps))\n    \n    # Randomly select and sort row indices for growing points\n    gpsi = sorted(sample(interval(1, h - 1, 1), ngps))\n    \n    # Initialize offset for diagonal lines\n    ofs = 0\n    \n    # Randomly select background color and line color\n    bgc, linc = sample(cols, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Add vertical lines at starting points in the first row\n    gi = fill(gi, linc, {(0, jj) for jj in spsj})\n    \n    # Add horizontal line with color 2 in the first column at growing points\n    gi = fill(gi, 2, {(ii, 0) for ii in gpsi})\n    \n    # Initialize output grid as a copy of input grid\n    go = tuple(e for e in gi)\n    \n    # Iterate through growing points to create diagonal lines\n    for a, b in zip([0] + gpsi, [x - 1 for x in gpsi] + [h - 1]):\n        for jj in spsj:\n            # Draw diagonal line in output grid\n            go = fill(go, linc, connect((a, jj + ofs), (b, jj + ofs)))\n        # Increase offset for next set of diagonal lines\n        ofs += 1\n    \n    # List of possible mirror/rotation functions\n    mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)\n    \n    # Randomly choose to apply 1 or 2 transformations\n    nmfs = choice((1, 2))\n    \n    # Apply randomly selected transformations to both input and output grids\n    for fn in sample(mfs, nmfs):\n        gi = fn(gi)\n        go = fn(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f1cefba8": {
    "original": "def generate_f1cefba8(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    ih = unifint(diff_lb, diff_ub, (6, h - 1))\n    iw = unifint(diff_lb, diff_ub, (6, w - 1))\n    loci = randint(0, h - ih)\n    locj = randint(0, w - iw)\n    bgc, ringc, inc = sample(cols, 3)\n    obj = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})\n    ring1 = box(obj)\n    ring2 = inbox(obj)\n    bd = backdrop(obj)\n    c = canvas(bgc, (h, w))\n    c = fill(c, inc, bd)\n    c = fill(c, ringc, ring1 | ring2)\n    cands = totuple(ring2 - corners(ring2))\n    numc = unifint(diff_lb, diff_ub, (1, len(cands) // 2))\n    locs = sample(cands, numc)\n    gi = fill(c, inc, locs)\n    lm = lowermost(ring2)\n    hori = sfilter(locs, lambda ij: ij[0] > loci + 1 and ij[0] < lm)\n    verti = difference(locs, hori)\n    hlines = mapply(hfrontier, hori)\n    vlines = mapply(vfrontier, verti)\n    fulllocs = set(hlines) | set(vlines)\n    topaintinc = fulllocs & ofcolor(c, bgc)\n    topaintringc = fulllocs & ofcolor(c, inc)\n    go = fill(c, inc, topaintinc)\n    go = fill(go, ringc, topaintringc)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f1cefba8(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 7 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Generate random width between 7 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Generate random inner height between 6 and h-1 based on difficulty\n    ih = unifint(diff_lb, diff_ub, (6, h - 1))\n    \n    # Generate random inner width between 6 and w-1 based on difficulty\n    iw = unifint(diff_lb, diff_ub, (6, w - 1))\n    \n    # Generate random vertical position for the inner rectangle\n    loci = randint(0, h - ih)\n    \n    # Generate random horizontal position for the inner rectangle\n    locj = randint(0, w - iw)\n    \n    # Randomly select 3 unique colors for background, ring, and inner area\n    bgc, ringc, inc = sample(cols, 3)\n    \n    # Create a set with two corners of the inner rectangle\n    obj = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})\n    \n    # Create the outer ring of the rectangle\n    ring1 = box(obj)\n    \n    # Create the inner ring of the rectangle\n    ring2 = inbox(obj)\n    \n    # Create the backdrop (all cells within the rectangle)\n    bd = backdrop(obj)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Fill the backdrop with the inner color\n    c = fill(c, inc, bd)\n    \n    # Fill both rings with the ring color\n    c = fill(c, ringc, ring1 | ring2)\n    \n    # Get all cells of the inner ring except corners\n    cands = totuple(ring2 - corners(ring2))\n    \n    # Determine number of cells to be filled based on difficulty\n    numc = unifint(diff_lb, diff_ub, (1, len(cands) // 2))\n    \n    # Randomly select cells to be filled\n    locs = sample(cands, numc)\n    \n    # Fill selected cells with inner color to create the input grid\n    gi = fill(c, inc, locs)\n    \n    # Find the lowermost row of the inner ring\n    lm = lowermost(ring2)\n    \n    # Separate horizontal and vertical filled cells\n    hori = sfilter(locs, lambda ij: ij[0] > loci + 1 and ij[0] < lm)\n    verti = difference(locs, hori)\n    \n    # Create horizontal lines from horizontal cells\n    hlines = mapply(hfrontier, hori)\n    \n    # Create vertical lines from vertical cells\n    vlines = mapply(vfrontier, verti)\n    \n    # Combine all cells from horizontal and vertical lines\n    fulllocs = set(hlines) | set(vlines)\n    \n    # Find cells to be painted with inner color (currently background color)\n    topaintinc = fulllocs & ofcolor(c, bgc)\n    \n    # Find cells to be painted with ring color (currently inner color)\n    topaintringc = fulllocs & ofcolor(c, inc)\n    \n    # Create output grid by filling cells with inner color\n    go = fill(c, inc, topaintinc)\n    \n    # Complete output grid by filling cells with ring color\n    go = fill(go, ringc, topaintringc)\n    \n    # Return input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f25fbde4": {
    "original": "def generate_f25fbde4(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    ncd = unifint(diff_lb, diff_ub, (1, max(1, (min(15, h-1) * min(15, w-1)) // 2)))\n    nc = choice((ncd, (h-1) * (w-1) - ncd))\n    nc = min(max(1, ncd), (h-1) * (w-1) - 1)\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    fgc = choice(remcols)\n    c = canvas(bgc, (h, w))\n    bounds = asindices(canvas(-1, (min(15, h - 1), min(15, w - 1))))\n    ch = choice(totuple(bounds))\n    shp = {ch}\n    bounds = remove(ch, bounds)\n    for j in range(nc):\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    shp = normalize(shp)\n    oh, ow = shape(shp)\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    plcd = shift(shp, loc)\n    gi = fill(c, fgc, plcd)\n    go = compress(gi)\n    go = upscale(go, 2)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f25fbde4(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Determine the number of cells for the shape, bounded by grid size and difficulty\n    ncd = unifint(diff_lb, diff_ub, (1, max(1, (min(15, h-1) * min(15, w-1)) // 2)))\n    \n    # Choose between ncd and its complement for final cell count\n    nc = choice((ncd, (h-1) * (w-1) - ncd))\n    \n    # Ensure nc is within valid bounds\n    nc = min(max(1, ncd), (h-1) * (w-1) - 1)\n    \n    # Randomly select a background color\n    bgc = choice(cols)\n    \n    # Remove the background color from available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a foreground color different from the background\n    fgc = choice(remcols)\n    \n    # Create a canvas filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Generate a set of possible coordinates for the shape\n    bounds = asindices(canvas(-1, (min(15, h - 1), min(15, w - 1))))\n    \n    # Choose a starting cell for the shape\n    ch = choice(totuple(bounds))\n    \n    # Initialize the shape with the chosen cell\n    shp = {ch}\n    \n    # Remove the chosen cell from available bounds\n    bounds = remove(ch, bounds)\n    \n    # Grow the shape by adding adjacent cells\n    for j in range(nc):\n        # Add a neighboring cell that's within bounds and not already in the shape\n        shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))\n    \n    # Normalize the shape to start from (0,0)\n    shp = normalize(shp)\n    \n    # Get the dimensions of the shape\n    oh, ow = shape(shp)\n    \n    # Choose a random location to place the shape\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    loc = (loci, locj)\n    \n    # Shift the shape to its final location\n    plcd = shift(shp, loc)\n    \n    # Fill the shape on the canvas with the foreground color\n    gi = fill(c, fgc, plcd)\n    \n    # Remove any single-color rows or columns (compress the grid)\n    go = compress(gi)\n    \n    # Double the size of the output grid\n    go = upscale(go, 2)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f25ffba3": {
    "original": "def generate_f25ffba3(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    h = h * 2 + 1\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 2))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    while uppermost(obj) > h // 2 - 1 or lowermost(obj) < h // 2 + 1:\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gix = paint(canv, obj)\n    gix = apply(rbind(order, matcher(identity, bgc)), gix)\n    gi = hconcat(gix, canv)\n    go = hconcat(gix, vmirror(gix))\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    if choice((True, False)):\n        gi = hmirror(gi)\n        go = hmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f25ffba3(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 1 to 9 (possible color values)\n    cols = interval(1, 10, 1)\n    \n    # Generate a random odd height between 3 and 29\n    h = unifint(diff_lb, diff_ub, (1, 14))\n    h = h * 2 + 1\n    \n    # Generate a random width between 3 and 15\n    w = unifint(diff_lb, diff_ub, (3, 15))\n    \n    # Choose a random background color\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random number of colors to use (between 1 and 8)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly sample colors from the remaining colors\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas with the chosen background color and dimensions\n    canv = canvas(bgc, (h, w))\n    \n    # Choose a random number of cells to color (between 2 and h*w-2)\n    nc = unifint(diff_lb, diff_ub, (2, h * w - 2))\n    \n    # Get all indices of the canvas\n    bx = asindices(canv)\n    \n    # Start the object with a single randomly colored cell\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Add more cells to the object, ensuring they're connected\n    for kk in range(nc - 1):\n        # Get neighboring cells of the current object\n        dns = mapply(neighbors, toindices(obj))\n        # Choose a random neighbor that's still available\n        ch = choice(totuple(bx & dns))\n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Ensure the object spans the middle row of the grid\n    while uppermost(obj) > h // 2 - 1 or lowermost(obj) < h // 2 + 1:\n        # Get neighboring cells of the current object\n        dns = mapply(neighbors, toindices(obj))\n        # Choose a random neighbor that's still available\n        ch = choice(totuple(bx & dns))\n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Paint the object onto the canvas\n    gix = paint(canv, obj)\n    \n    # Sort each row of the grid, putting background color cells last\n    gix = apply(rbind(order, matcher(identity, bgc)), gix)\n    \n    # Create the input grid by concatenating the sorted grid with the original canvas\n    gi = hconcat(gix, canv)\n    \n    # Create the output grid by concatenating the sorted grid with its vertical mirror\n    go = hconcat(gix, vmirror(gix))\n    \n    # Randomly flip the input and output vertically (50% chance)\n    if choice((True, False)):\n        gi = vmirror(gi)\n        go = vmirror(go)\n    \n    # Randomly flip the input and output horizontally (50% chance)\n    if choice((True, False)):\n        gi = hmirror(gi)\n        go = hmirror(go)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "f2829549": {
    "original": "def generate_f2829549(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    linc = choice(remcols)\n    remcols = remove(linc, remcols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    bar = canvas(linc, (h, 1))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(hconcat(A, bar), B)\n    res = (set(inds) - set(aset)) & (set(inds) - set(bset))\n    go = fill(c, 3, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f2829549(diff_lb: float, diff_ub: float) -> dict:\n    # Remove color 3 from the range of colors 0 to 9\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Generate a random height between 2 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Generate a random width between 2 and 14 based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a random background color from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a random line color from the remaining colors\n    linc = choice(remcols)\n    \n    # Remove the line color from the remaining colors\n    remcols = remove(linc, remcols)\n    \n    # Choose a random color for set A from the remaining colors\n    acol = choice(remcols)\n    \n    # Remove color A from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a random color for set B from the remaining colors\n    bcol = choice(remcols)\n    \n    # Create a canvas with the background color and dimensions h x w\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the canvas as a tuple\n    inds = totuple(asindices(c))\n    \n    # Create a vertical bar with the line color and height h\n    bar = canvas(linc, (h, 1))\n    \n    # Generate a random number of deviations for set A based on difficulty\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Generate a random number of deviations for set B based on difficulty\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose the size of set A, either the number of deviations or its complement\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose the size of set B, either the number of deviations or its complement\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure numa is between 1 and h*w-1\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure numb is between 1 and h*w-1\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly sample numa indices for set A\n    aset = sample(inds, numa)\n    \n    # Randomly sample numb indices for set B\n    bset = sample(inds, numb)\n    \n    # Fill the canvas with color A at the indices in aset\n    A = fill(c, acol, aset)\n    \n    # Fill the canvas with color B at the indices in bset\n    B = fill(c, bcol, bset)\n    \n    # Concatenate A, the vertical bar, and B horizontally to create the input grid\n    gi = hconcat(hconcat(A, bar), B)\n    \n    # Find the indices that are in neither set A nor set B\n    res = (set(inds) - set(aset)) & (set(inds) - set(bset))\n    \n    # Fill the canvas with color 3 at the indices in res to create the output grid\n    go = fill(c, 3, res)\n    \n    # Randomly decide whether to mirror the input and output grids diagonally\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary with the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "f35d900a": {
    "original": "def generate_f35d900a(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    bgc, c1, c2 = sample(cols, 3)\n    oh = unifint(diff_lb, diff_ub, (4, h))\n    ow = unifint(diff_lb, diff_ub, (4, w))\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    gi = fill(gi, c1, {ulcorner(bx), lrcorner(bx)})\n    gi = fill(gi, c2, {urcorner(bx), llcorner(bx)})\n    go = fill(go, c1, {ulcorner(bx), lrcorner(bx)})\n    go = fill(go, c2, {urcorner(bx), llcorner(bx)})\n    go = fill(go, c1, neighbors(urcorner(bx)) | neighbors(llcorner(bx)))\n    go = fill(go, c2, neighbors(ulcorner(bx)) | neighbors(lrcorner(bx)))\n    crns = corners(bx)\n    for c in crns:\n        cobj = {c}\n        remcorns = remove(c, crns)\n        belongto = sfilter(bx, lambda ij: manhattan(cobj, {ij}) <= valmin(remcorns, lambda cc: manhattan({ij}, {cc})))\n        valids = sfilter(belongto, lambda ij: manhattan(cobj, {ij}) > 1 and manhattan(cobj, {ij}) % 2 == 0)\n        go = fill(go, 5, valids)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f35d900a(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 5\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Generate a random height between 4 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Randomly select three colors: background, color1, and color2\n    bgc, c1, c2 = sample(cols, 3)\n    \n    # Generate a random height for the inner box, between 4 and h\n    oh = unifint(diff_lb, diff_ub, (4, h))\n    \n    # Generate a random width for the inner box, between 4 and w\n    ow = unifint(diff_lb, diff_ub, (4, w))\n    \n    # Generate random top-left corner coordinates for the inner box\n    loci = randint(0, h - oh)\n    locj = randint(0, w - ow)\n    \n    # Create the outline of the inner box\n    bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Fill the upper-left and lower-right corners of the box with color1 in the input grid\n    gi = fill(gi, c1, {ulcorner(bx), lrcorner(bx)})\n    \n    # Fill the upper-right and lower-left corners of the box with color2 in the input grid\n    gi = fill(gi, c2, {urcorner(bx), llcorner(bx)})\n    \n    # Fill the upper-left and lower-right corners of the box with color1 in the output grid\n    go = fill(go, c1, {ulcorner(bx), lrcorner(bx)})\n    \n    # Fill the upper-right and lower-left corners of the box with color2 in the output grid\n    go = fill(go, c2, {urcorner(bx), llcorner(bx)})\n    \n    # Fill the neighbors of upper-right and lower-left corners with color1 in the output grid\n    go = fill(go, c1, neighbors(urcorner(bx)) | neighbors(llcorner(bx)))\n    \n    # Fill the neighbors of upper-left and lower-right corners with color2 in the output grid\n    go = fill(go, c2, neighbors(ulcorner(bx)) | neighbors(lrcorner(bx)))\n    \n    # Get the corner coordinates of the box\n    crns = corners(bx)\n    \n    # For each corner of the box:\n    for c in crns:\n        # Create a set with the current corner\n        cobj = {c}\n        \n        # Get the other corners\n        remcorns = remove(c, crns)\n        \n        # Find cells belonging to this corner (closer to this corner than to any other)\n        belongto = sfilter(bx, lambda ij: manhattan(cobj, {ij}) <= valmin(remcorns, lambda cc: manhattan({ij}, {cc})))\n        \n        # Filter valid cells (manhattan distance > 1 and even)\n        valids = sfilter(belongto, lambda ij: manhattan(cobj, {ij}) > 1 and manhattan(cobj, {ij}) % 2 == 0)\n        \n        # Fill the valid cells with color 5 in the output grid\n        go = fill(go, 5, valids)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f5b8619d": {
    "original": "def generate_f5b8619d(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(8, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    ncells = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    locs = sample(totuple(inds), ncells)\n    blockcol = randint(0, w - 1)\n    locs = sfilter(locs, lambda ij: ij[1] != blockcol)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    ccols = sample(remcols, numcols)\n    obj = frozenset({(choice(ccols), ij) for ij in locs})\n    gi = paint(gi, obj)\n    go = fill(gi, 8, mapply(vfrontier, set(locs)) & (inds - set(locs)))\n    go = hconcat(go, go)\n    go = vconcat(go, go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f5b8619d(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 8\n    cols = remove(8, interval(0, 10, 1))\n    \n    # Randomly determine height of the grid (2-15)\n    h = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly determine width of the grid (2-15)\n    w = unifint(diff_lb, diff_ub, (2, 15))\n    \n    # Randomly determine number of cells to be colored (1 to half of total cells)\n    ncells = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors (excluding background color)\n    remcols = remove(bgc, cols)\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Randomly select 'ncells' number of locations from the grid\n    locs = sample(totuple(inds), ncells)\n    \n    # Randomly choose a column to block (will not be colored)\n    blockcol = randint(0, w - 1)\n    \n    # Remove locations in the blocked column from the selected locations\n    locs = sfilter(locs, lambda ij: ij[1] != blockcol)\n    \n    # Randomly determine the number of colors to use (1-8)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    \n    # Randomly select colors to use\n    ccols = sample(remcols, numcols)\n    \n    # Create an object with randomly colored cells at the selected locations\n    obj = frozenset({(choice(ccols), ij) for ij in locs})\n    \n    # Paint the object onto the input grid\n    gi = paint(gi, obj)\n    \n    # Create the output grid:\n    # Fill vertical frontiers of colored cells with color 8, excluding original colored cells\n    go = fill(gi, 8, mapply(vfrontier, set(locs)) & (inds - set(locs)))\n    \n    # Double the width of the output grid\n    go = hconcat(go, go)\n    \n    # Double the height of the output grid\n    go = vconcat(go, go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f76d97a5": {
    "original": "def generate_f76d97a5(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(0, remove(5, interval(0, 10, 1)))\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    col = choice(cols)\n    gi = canvas(5, (h, w))\n    go = canvas(col, (h, w))\n    numdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    num = choice((numdev, h * w - numdev))\n    num = min(max(1, num), h * w)\n    inds = totuple(asindices(gi))\n    locs = sample(inds, num)\n    gi = fill(gi, col, locs)\n    go = fill(go, 0, locs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f76d97a5(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of colors (1,2,3,4,6,7,8,9) by removing 0 and 5 from the range 0-9\n    cols = remove(0, remove(5, interval(0, 10, 1)))\n    \n    # Generate a random height between 4 and 30 based on the difficulty bounds\n    h = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate a random width between 4 and 30 based on the difficulty bounds\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Choose a random color from the available colors (excluding 0 and 5)\n    col = choice(cols)\n    \n    # Create an input grid filled with color 5 (light gray) of size h x w\n    gi = canvas(5, (h, w))\n    \n    # Create an output grid filled with the chosen color of size h x w\n    go = canvas(col, (h, w))\n    \n    # Calculate a random number of deviations based on difficulty (0 to half of total cells)\n    numdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose either the number of deviations or its complement\n    num = choice((numdev, h * w - numdev))\n    \n    # Ensure num is between 1 and the total number of cells\n    num = min(max(1, num), h * w)\n    \n    # Get all possible cell indices in the grid as a tuple\n    inds = totuple(asindices(gi))\n    \n    # Randomly select 'num' locations from all possible indices\n    locs = sample(inds, num)\n    \n    # In the input grid, fill the selected locations with the chosen color\n    # This creates a pattern of colored cells on the light gray background\n    gi = fill(gi, col, locs)\n    \n    # In the output grid, fill the same locations with color 0 (black)\n    # This inverts the pattern, turning colored cells to black and vice versa\n    go = fill(go, 0, locs)\n    \n    # Return a dictionary with the input and output grids\n    # The puzzle is to figure out the color inversion rule\n    return {'input': gi, 'output': go}\n"
  },
  "f8a8fe49": {
    "original": "def generate_f8a8fe49(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    fullh = unifint(diff_lb, diff_ub, (10, h))\n    fullw = unifint(diff_lb, diff_ub, (3, w))\n    bgc, objc, boxc = sample(cols, 3)\n    bcanv = canvas(bgc, (h, w))\n    loci = randint(0, h - fullh)\n    locj = randint(0, w - fullw)\n    loc = (loci, locj)\n    canvi = canvas(bgc, (fullh, fullw))\n    canvo = canvas(bgc, (fullh, fullw))\n    objh = (fullh // 2 - 3) // 2\n    br = connect((objh + 1, 0), (objh + 1, fullw - 1))\n    br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}\n    cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))\n    for k in range(2):\n        canvi = fill(canvi, boxc, br)\n        canvo = fill(canvo, boxc, br)\n        ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))\n        ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))\n        ncells = min(max(1, ncells), objh * (fullw - 2))\n        cells = frozenset(sample(totuple(cands), ncells))\n        cells = insert(choice(totuple(sfilter(cands, lambda ij: ij[0] == lowermost(cands)))), cells)\n        canvi = fill(canvi, objc, cells)\n        canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))\n        canvi = hmirror(canvi)\n        canvo = hmirror(canvo)\n    gi = paint(bcanv, shift(asobject(canvi), loc))\n    go = paint(bcanv, shift(asobject(canvo), loc))\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    go, gi = gi, go\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f8a8fe49(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate random width between 4 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (4, 30))\n    \n    # Generate random full height between 10 and h based on difficulty\n    fullh = unifint(diff_lb, diff_ub, (10, h))\n    \n    # Generate random full width between 3 and w based on difficulty\n    fullw = unifint(diff_lb, diff_ub, (3, w))\n    \n    # Randomly select 3 distinct colors for background, object, and box\n    bgc, objc, boxc = sample(cols, 3)\n    \n    # Create a background canvas with the selected background color\n    bcanv = canvas(bgc, (h, w))\n    \n    # Generate random vertical position for the inner canvas\n    loci = randint(0, h - fullh)\n    \n    # Generate random horizontal position for the inner canvas\n    locj = randint(0, w - fullw)\n    \n    # Combine vertical and horizontal positions into a tuple\n    loc = (loci, locj)\n    \n    # Create an input canvas with the background color\n    canvi = canvas(bgc, (fullh, fullw))\n    \n    # Create an output canvas with the background color\n    canvo = canvas(bgc, (fullh, fullw))\n    \n    # Calculate the height of the object area\n    objh = (fullh // 2 - 3) // 2\n    \n    # Create a horizontal line (box bottom) with endpoints\n    br = connect((objh + 1, 0), (objh + 1, fullw - 1))\n    \n    # Add two points to make the box bottom thicker\n    br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}\n    \n    # Define candidate positions for object cells\n    cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))\n    \n    # Loop twice to create mirrored patterns\n    for k in range(2):\n        # Draw the box bottom on the input canvas\n        canvi = fill(canvi, boxc, br)\n        \n        # Draw the box bottom on the output canvas\n        canvo = fill(canvo, boxc, br)\n        \n        # Generate random number of cells based on difficulty\n        ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))\n        \n        # Choose between ncellsd and its complement\n        ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))\n        \n        # Ensure at least one cell and not more than available space\n        ncells = min(max(1, ncells), objh * (fullw - 2))\n        \n        # Randomly select cells from candidates\n        cells = frozenset(sample(totuple(cands), ncells))\n        \n        # Ensure at least one cell at the bottom\n        cells = insert(choice(totuple(sfilter(cands, lambda ij: ij[0] == lowermost(cands)))), cells)\n        \n        # Fill selected cells with object color on input canvas\n        canvi = fill(canvi, objc, cells)\n        \n        # Fill mirrored cells with object color on output canvas\n        canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))\n        \n        # Mirror the input canvas horizontally\n        canvi = hmirror(canvi)\n        \n        # Mirror the output canvas horizontally\n        canvo = hmirror(canvo)\n    \n    # Paint the input canvas onto the background\n    gi = paint(bcanv, shift(asobject(canvi), loc))\n    \n    # Paint the output canvas onto the background\n    go = paint(bcanv, shift(asobject(canvo), loc))\n    \n    # Randomly decide whether to mirror diagonally\n    if choice((True, False)):\n        # Mirror input diagonally\n        gi = dmirror(gi)\n        # Mirror output diagonally\n        go = dmirror(go)\n    \n    # Swap input and output\n    go, gi = gi, go\n    \n    # Return the generated input-output pair\n    return {'input': gi, 'output': go}\n"
  },
  "f8b3ba0a": {
    "original": "def generate_f8b3ba0a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (1, 5))\n    w = unifint(diff_lb, diff_ub, (1, 5))\n    nh = unifint(diff_lb, diff_ub, (3, 29 // (h + 1)))\n    nw = unifint(diff_lb, diff_ub, (3, 29 // (w + 1)))\n    fullh = (h + 1) * nh + 1\n    fullw = (w + 1) * nw + 1\n    fullbgc, bgc = sample(cols, 2)\n    remcols = remove(fullbgc, remove(bgc, cols))\n    shp = shift(asindices(canvas(-1, (h, w))), (1, 1))\n    gi = canvas(fullbgc, (fullh, fullw))\n    locs = set()\n    for a in range(nh):\n        for b in range(nw):\n            loc = (a * (h + 1), b * (w + 1))\n            locs.add(loc)\n            gi = fill(gi, bgc, shift(shp, loc))\n    numc = unifint(diff_lb, diff_ub, (1, (nh * nw) // 2 - 1))\n    stack = []\n    nn = numc + 1\n    ncols = 0\n    while nn > 1 and numc > 0 and len(remcols) > 0:\n        nn3 = int(0.5 * (8 * numc + 1) ** 0.5 - 1)\n        nn = min(max(1, nn3), nn - 1)\n        col = choice(remcols)\n        remcols = remove(col, remcols)\n        numc -= nn\n        stack.append((col, nn))\n    go = dmirror((tuple(c for c, nn in stack),))\n    for col, nn in stack:\n        slocs = sample(totuple(locs), nn)\n        gi = fill(gi, col, mapply(lbind(shift, shp), slocs))\n        locs = locs - set(slocs)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f8b3ba0a(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)  # Create a range of colors from 0 to 9\n    h = unifint(diff_lb, diff_ub, (1, 5))  # Randomly choose height of each small rectangle\n    w = unifint(diff_lb, diff_ub, (1, 5))  # Randomly choose width of each small rectangle\n    nh = unifint(diff_lb, diff_ub, (3, 29 // (h + 1)))  # Choose number of rectangles vertically\n    nw = unifint(diff_lb, diff_ub, (3, 29 // (w + 1)))  # Choose number of rectangles horizontally\n    fullh = (h + 1) * nh + 1  # Calculate full height of the grid\n    fullw = (w + 1) * nw + 1  # Calculate full width of the grid\n    fullbgc, bgc = sample(cols, 2)  # Choose two colors: one for full background, one for rectangle backgrounds\n    remcols = remove(fullbgc, remove(bgc, cols))  # Remove chosen colors from available colors\n    shp = shift(asindices(canvas(-1, (h, w))), (1, 1))  # Create shape of small rectangle\n    gi = canvas(fullbgc, (fullh, fullw))  # Create input grid with full background color\n    locs = set()  # Initialize set to store locations of rectangles\n    for a in range(nh):\n        for b in range(nw):\n            loc = (a * (h + 1), b * (w + 1))  # Calculate location for each rectangle\n            locs.add(loc)  # Add location to set\n            gi = fill(gi, bgc, shift(shp, loc))  # Fill rectangle with background color\n    numc = unifint(diff_lb, diff_ub, (1, (nh * nw) // 2 - 1))  # Choose number of colored rectangles\n    stack = []  # Initialize stack to store colors and their frequencies\n    nn = numc + 1  # Initialize nn for the loop\n    ncols = 0  # Initialize number of colors (unused in this function)\n    while nn > 1 and numc > 0 and len(remcols) > 0:\n        nn3 = int(0.5 * (8 * numc + 1) ** 0.5 - 1)  # Calculate new nn value\n        nn = min(max(1, nn3), nn - 1)  # Adjust nn within bounds\n        col = choice(remcols)  # Choose a color from remaining colors\n        remcols = remove(col, remcols)  # Remove chosen color from remaining colors\n        numc -= nn  # Decrease number of colored rectangles left to assign\n        stack.append((col, nn))  # Add color and its frequency to stack\n    go = dmirror((tuple(c for c, nn in stack),))  # Create output grid by mirroring colors diagonally\n    for col, nn in stack:\n        slocs = sample(totuple(locs), nn)  # Choose random locations for this color\n        gi = fill(gi, col, mapply(lbind(shift, shp), slocs))  # Fill chosen locations with this color\n        locs = locs - set(slocs)  # Remove used locations\n    return {'input': gi, 'output': go}  # Return input and output grids\n"
  },
  "f8c80d96": {
    "original": "def generate_f8c80d96(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(5, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    ow = randint(1, 3 if h > 10 else 2)\n    oh = randint(1, 3 if w > 10 else 2)\n    loci = randint(-oh+1, h-1)\n    locj = randint(-ow+1, w-1)\n    obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    bgc, linc = sample(cols, 2)\n    gi = canvas(bgc, (h, w))\n    go = canvas(5, (h, w))\n    ln1 = outbox(obj)\n    ulci, ulcj = decrement(ulcorner(obj))\n    lrci, lrcj = increment(lrcorner(obj))\n    hoffs = randint(2, 4 if h > 12 else 3)\n    woffs = randint(2, 4 if w > 12 else 3)\n    lns = []\n    for k in range(max(h, w) // min(hoffs, woffs) + 1):\n        lnx = box(frozenset({(ulci - hoffs * k, ulcj - woffs * k), (lrci + hoffs * k, lrcj + woffs * k)}))\n        lns.append(lnx)\n    inds = asindices(gi)\n    lns = sfilter(lns, lambda ln: len(ln & inds) > 0)\n    nlns = len(lns)\n    nmissing = unifint(diff_lb, diff_ub, (0, nlns - 2))\n    npresent = nlns - nmissing\n    for k in range(npresent):\n        gi = fill(gi, linc, lns[k])\n    for ln in lns:\n        go = fill(go, linc, ln)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f8c80d96(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 5\n    cols = remove(5, interval(0, 10, 1))\n    \n    # Generate random height between 8 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Generate random width between 8 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (8, 30))\n    \n    # Set object width (1-3 if h>10, else 1-2)\n    ow = randint(1, 3 if h > 10 else 2)\n    \n    # Set object height (1-3 if w>10, else 1-2)\n    oh = randint(1, 3 if w > 10 else 2)\n    \n    # Generate random row index for object placement\n    loci = randint(-oh+1, h-1)\n    \n    # Generate random column index for object placement\n    locj = randint(-ow+1, w-1)\n    \n    # Create a rectangular object using the generated dimensions and location\n    obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n    \n    # Randomly select two colors: one for background, one for lines\n    bgc, linc = sample(cols, 2)\n    \n    # Create input grid with background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create output grid filled with color 5\n    go = canvas(5, (h, w))\n    \n    # Generate the outer box of the object\n    ln1 = outbox(obj)\n    \n    # Calculate upper-left corner coordinates, decremented\n    ulci, ulcj = decrement(ulcorner(obj))\n    \n    # Calculate lower-right corner coordinates, incremented\n    lrci, lrcj = increment(lrcorner(obj))\n    \n    # Set vertical offset for concentric boxes (2-4 if h>12, else 2-3)\n    hoffs = randint(2, 4 if h > 12 else 3)\n    \n    # Set horizontal offset for concentric boxes (2-4 if w>12, else 2-3)\n    woffs = randint(2, 4 if w > 12 else 3)\n    \n    # Initialize list to store concentric boxes\n    lns = []\n    \n    # Generate concentric boxes\n    for k in range(max(h, w) // min(hoffs, woffs) + 1):\n        # Create a box expanding outwards from the object\n        lnx = box(frozenset({(ulci - hoffs * k, ulcj - woffs * k), (lrci + hoffs * k, lrcj + woffs * k)}))\n        lns.append(lnx)\n    \n    # Get all valid indices of the input grid\n    inds = asindices(gi)\n    \n    # Filter out boxes that don't intersect with the grid\n    lns = sfilter(lns, lambda ln: len(ln & inds) > 0)\n    \n    # Count the number of concentric boxes\n    nlns = len(lns)\n    \n    # Determine number of missing boxes based on difficulty\n    nmissing = unifint(diff_lb, diff_ub, (0, nlns - 2))\n    \n    # Calculate number of boxes to be drawn in the input\n    npresent = nlns - nmissing\n    \n    # Draw the visible concentric boxes on the input grid\n    for k in range(npresent):\n        gi = fill(gi, linc, lns[k])\n    \n    # Draw all concentric boxes on the output grid\n    for ln in lns:\n        go = fill(go, linc, ln)\n    \n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "f8ff0b80": {
    "original": "def generate_f8ff0b80(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 25)))\n    gi = canvas(bgc, (h, w))\n    numcells = unifint(diff_lb, diff_ub, (nobjs+1, 36))\n    base = asindices(canvas(-1, (6, 6)))\n    maxtr = 10\n    inds = asindices(gi)\n    go = []\n    for k in range(nobjs):\n        if len(inds) == 0 or numcells < 2:\n            break\n        numcells = unifint(diff_lb, diff_ub, (nobjs - k, numcells - 1))\n        if numcells == 0:\n            break\n        sp = choice(totuple(base))\n        shp = {sp}\n        reminds = remove(sp, base)\n        for kk in range(numcells - 1):\n            shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n        shp = normalize(shp)\n        validloc = False\n        rems = sfilter(inds, lambda ij: ij[0] <= h - height(shp) and ij[1] <= w - width(shp))\n        if len(rems) == 0:\n            break\n        loc = choice(totuple(rems))\n        tr = 0\n        while not validloc and tr < maxtr:\n            loc = choice(totuple(inds))\n            validloc = shift(shp, loc).issubset(inds)\n            tr += 1\n        if validloc:\n            plcd = shift(shp, loc)\n            col = choice(remcols)\n            go.append(col)\n            inds = (inds - plcd) - mapply(neighbors, plcd)\n            gi = fill(gi, col, plcd)\n    go = dmirror((tuple(go),))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f8ff0b80(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Generate a random height between 10 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Generate a random width between 10 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Choose a random color for the background\n    bgc = choice(cols)\n    \n    # Create a tuple of remaining colors (excluding the background color)\n    remcols = remove(bgc, cols)\n    \n    # Calculate the number of objects to place, between 1 and min(30, (h*w)//25)\n    nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 25)))\n    \n    # Create the initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Determine the total number of cells to be colored (objects)\n    numcells = unifint(diff_lb, diff_ub, (nobjs+1, 36))\n    \n    # Create a 6x6 base grid of indices\n    base = asindices(canvas(-1, (6, 6)))\n    \n    # Set maximum number of tries for placing an object\n    maxtr = 10\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Initialize an empty list to store the colors of placed objects\n    go = []\n    \n    # Loop to place each object\n    for k in range(nobjs):\n        # Break if no more space or cells to place\n        if len(inds) == 0 or numcells < 2:\n            break\n        \n        # Recalculate number of cells for this object\n        numcells = unifint(diff_lb, diff_ub, (nobjs - k, numcells - 1))\n        \n        # Break if no more cells to place\n        if numcells == 0:\n            break\n        \n        # Choose a random starting point for the shape\n        sp = choice(totuple(base))\n        \n        # Initialize the shape with the starting point\n        shp = {sp}\n        \n        # Remove the starting point from available base indices\n        reminds = remove(sp, base)\n        \n        # Grow the shape by adding adjacent cells\n        for kk in range(numcells - 1):\n            shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))\n        \n        # Normalize the shape (move it to origin)\n        shp = normalize(shp)\n        \n        # Initialize flag for valid location\n        validloc = False\n        \n        # Filter valid locations where the shape can be placed\n        rems = sfilter(inds, lambda ij: ij[0] <= h - height(shp) and ij[1] <= w - width(shp))\n        \n        # Break if no valid locations\n        if len(rems) == 0:\n            break\n        \n        # Choose a random location to place the shape\n        loc = choice(totuple(rems))\n        \n        # Try to find a valid location for the shape\n        tr = 0\n        while not validloc and tr < maxtr:\n            loc = choice(totuple(inds))\n            validloc = shift(shp, loc).issubset(inds)\n            tr += 1\n        \n        # If a valid location is found, place the object\n        if validloc:\n            # Shift the shape to its final location\n            plcd = shift(shp, loc)\n            \n            # Choose a random color for the object\n            col = choice(remcols)\n            \n            # Add the color to the output list\n            go.append(col)\n            \n            # Remove placed cells and their neighbors from available indices\n            inds = (inds - plcd) - mapply(neighbors, plcd)\n            \n            # Fill the grid with the chosen color at the placed location\n            gi = fill(gi, col, plcd)\n    \n    # Mirror the output colors diagonally to create a 2D grid\n    go = dmirror((tuple(go),))\n    \n    # Return the input grid and the output color grid as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "f9012d9b": {
    "original": "def generate_f9012d9b(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)    \n    hp = unifint(diff_lb, diff_ub, (2, 10))\n    wp = unifint(diff_lb, diff_ub, (2, 10))\n    srco = canvas(0, (hp, wp))\n    inds = asindices(srco)\n    nc = unifint(diff_lb, diff_ub, (1, 9))\n    ccols = sample(cols, nc)\n    obj = {(choice(ccols), ij) for ij in inds}\n    srco = paint(srco, obj)\n    gi = paint(srco, obj)\n    numhp = unifint(diff_lb, diff_ub, (3, 30 // hp))\n    numwp = unifint(diff_lb, diff_ub, (3, 30 // wp))\n    for k in range(numhp - 1):\n        gi = vconcat(gi, srco)\n    srco = tuple(e for e in gi)\n    for k in range(numwp - 1):\n        gi = hconcat(gi, srco)\n    hcropfac = randint(0, hp)\n    for k in range(hcropfac):\n        gi = gi[:-1]\n    gi = dmirror(gi)\n    wcropfac = randint(0, wp)\n    for k in range(wcropfac):\n        gi = gi[:-1]\n    gi = dmirror(gi)\n    h, w = shape(gi)\n    sgh = unifint(diff_lb, diff_ub, (1, h - hp - 1))\n    sgw = unifint(diff_lb, diff_ub, (1, w - wp - 1))\n    loci = randint(0, h - sgh)\n    locj = randint(0, w - sgw)\n    loc = (loci, locj)\n    shp = (sgh, sgw)\n    obj = {loc, decrement(add(loc, shp))}\n    obj = backdrop(obj)\n    go = subgrid(obj, gi)\n    gi = fill(gi, 0, obj)\n    mf = choice((\n        identity, rot90, rot180, rot270,\n        dmirror, vmirror, hmirror, cmirror\n    ))\n    gi = mf(gi)\n    go = mf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_f9012d9b(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of column values from 1 to 9\n    cols = interval(1, 10, 1)    \n    \n    # Randomly determine the height of the pattern based on difficulty\n    hp = unifint(diff_lb, diff_ub, (2, 10))\n    # Randomly determine the width of the pattern based on difficulty\n    wp = unifint(diff_lb, diff_ub, (2, 10))\n    \n    # Create a blank canvas (all zeros) with the determined pattern size\n    srco = canvas(0, (hp, wp))\n    # Get all indices of the canvas\n    inds = asindices(srco)\n    \n    # Randomly choose the number of colors to use based on difficulty\n    nc = unifint(diff_lb, diff_ub, (1, 9))\n    # Randomly sample colors from the available range\n    ccols = sample(cols, nc)\n    \n    # Create an object by assigning random colors to all indices\n    obj = {(choice(ccols), ij) for ij in inds}\n    # Paint the source canvas with the created object\n    srco = paint(srco, obj)\n    # Initialize the input grid with the painted source canvas\n    gi = paint(srco, obj)\n    \n    # Determine number of vertical repetitions based on difficulty\n    numhp = unifint(diff_lb, diff_ub, (3, 30 // hp))\n    # Determine number of horizontal repetitions based on difficulty\n    numwp = unifint(diff_lb, diff_ub, (3, 30 // wp))\n    \n    # Vertically concatenate the pattern multiple times\n    for k in range(numhp - 1):\n        gi = vconcat(gi, srco)\n    \n    # Store the vertically repeated pattern\n    srco = tuple(e for e in gi)\n    \n    # Horizontally concatenate the pattern multiple times\n    for k in range(numwp - 1):\n        gi = hconcat(gi, srco)\n    \n    # Randomly determine vertical cropping factor\n    hcropfac = randint(0, hp)\n    # Crop the grid vertically\n    for k in range(hcropfac):\n        gi = gi[:-1]\n    \n    # Mirror the grid diagonally\n    gi = dmirror(gi)\n    \n    # Randomly determine horizontal cropping factor\n    wcropfac = randint(0, wp)\n    # Crop the grid horizontally\n    for k in range(wcropfac):\n        gi = gi[:-1]\n    \n    # Mirror the grid diagonally again\n    gi = dmirror(gi)\n    \n    # Get the shape of the final input grid\n    h, w = shape(gi)\n    \n    # Determine the height of the subgrid to extract based on difficulty\n    sgh = unifint(diff_lb, diff_ub, (1, h - hp - 1))\n    # Determine the width of the subgrid to extract based on difficulty\n    sgw = unifint(diff_lb, diff_ub, (1, w - wp - 1))\n    \n    # Randomly choose the starting row for subgrid extraction\n    loci = randint(0, h - sgh)\n    # Randomly choose the starting column for subgrid extraction\n    locj = randint(0, w - sgw)\n    # Combine row and column to form the starting location\n    loc = (loci, locj)\n    # Combine subgrid height and width\n    shp = (sgh, sgw)\n    \n    # Create an object representing the subgrid area\n    obj = {loc, decrement(add(loc, shp))}\n    # Expand the object to include all cells in the subgrid\n    obj = backdrop(obj)\n    \n    # Extract the subgrid from the input grid (this will be the output)\n    go = subgrid(obj, gi)\n    # Remove the subgrid from the input grid by filling it with zeros\n    gi = fill(gi, 0, obj)\n    \n    # Randomly choose a transformation function\n    mf = choice((\n        identity, rot90, rot180, rot270,\n        dmirror, vmirror, hmirror, cmirror\n    ))\n    \n    # Apply the chosen transformation to the input grid\n    gi = mf(gi)\n    # Apply the same transformation to the output grid\n    go = mf(go)\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "fafffa47": {
    "original": "def generate_fafffa47(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(2, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    acol = choice(remcols)\n    remcols = remove(acol, remcols)\n    bcol = choice(remcols)\n    c = canvas(bgc, (h, w))\n    inds = totuple(asindices(c))\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    numa = choice((numadev, h * w - numadev))\n    numb = choice((numadev, h * w - numbdev))\n    numa = min(max(1, numa), h * w - 1)\n    numb = min(max(1, numb), h * w - 1)\n    aset = sample(inds, numa)\n    bset = sample(inds, numb)\n    A = fill(c, acol, aset)\n    B = fill(c, bcol, bset)\n    gi = hconcat(A, B)\n    res = set(inds) - (set(aset) | set(bset))\n    go = fill(c, 2, res)\n    if choice((True, False)):\n        gi = dmirror(gi)\n        go = dmirror(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_fafffa47(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 2\n    cols = remove(2, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (2, 30))\n    \n    # Randomly determine the width of the grid based on difficulty\n    w = unifint(diff_lb, diff_ub, (2, 14))\n    \n    # Choose a background color randomly from the available colors\n    bgc = choice(cols)\n    \n    # Remove the background color from the list of remaining colors\n    remcols = remove(bgc, cols)\n    \n    # Choose a color for the first shape (A) randomly\n    acol = choice(remcols)\n    \n    # Remove the first shape's color from the remaining colors\n    remcols = remove(acol, remcols)\n    \n    # Choose a color for the second shape (B) randomly\n    bcol = choice(remcols)\n    \n    # Create a canvas (grid) filled with the background color\n    c = canvas(bgc, (h, w))\n    \n    # Get all indices of the grid as a tuple\n    inds = totuple(asindices(c))\n    \n    # Randomly determine the number of deviations for shape A based on difficulty\n    numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Randomly determine the number of deviations for shape B based on difficulty\n    numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))\n    \n    # Choose either the number of deviations or its complement for shape A\n    numa = choice((numadev, h * w - numadev))\n    \n    # Choose either the number of deviations or its complement for shape B\n    numb = choice((numadev, h * w - numbdev))\n    \n    # Ensure numa is within valid range (at least 1, at most grid size - 1)\n    numa = min(max(1, numa), h * w - 1)\n    \n    # Ensure numb is within valid range (at least 1, at most grid size - 1)\n    numb = min(max(1, numb), h * w - 1)\n    \n    # Randomly sample indices for shape A\n    aset = sample(inds, numa)\n    \n    # Randomly sample indices for shape B\n    bset = sample(inds, numb)\n    \n    # Fill the canvas with color A at the sampled indices for A\n    A = fill(c, acol, aset)\n    \n    # Fill the canvas with color B at the sampled indices for B\n    B = fill(c, bcol, bset)\n    \n    # Concatenate grids A and B horizontally to create the input grid\n    gi = hconcat(A, B)\n    \n    # Calculate the remaining indices (not part of A or B)\n    res = set(inds) - (set(aset) | set(bset))\n    \n    # Fill the remaining indices with color 2 to create the output grid\n    go = fill(c, 2, res)\n    \n    # Randomly decide whether to mirror the grids diagonally\n    if choice((True, False)):\n        # Mirror the input grid diagonally\n        gi = dmirror(gi)\n        # Mirror the output grid diagonally\n        go = dmirror(go)\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "fcb5c309": {
    "original": "def generate_fcb5c309(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    bgc, dotc, sqc = sample(cols, 3)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    gi = canvas(bgc, (h, w))\n    inds = asindices(gi)\n    maxtr = 4 * numsq\n    tr = 0\n    succ = 0\n    numcells = None\n    take = False\n    while tr < maxtr and succ < numsq:\n        oh = randint(3, 7)\n        ow = randint(3, 7)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            break\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        sq = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        bd = backdrop(sq)\n        if bd.issubset(inds):\n            gi = fill(gi, sqc, sq)\n            ib = backdrop(inbox(sq))\n            if numcells is None:\n                numcells = unifint(diff_lb, diff_ub, (1, len(ib)))\n                cells = sample(totuple(ib), numcells)\n                take = True\n            else:\n                nc = unifint(diff_lb, diff_ub, (0, min(max(0, numcells - 1), len(ib))))\n                cells = sample(totuple(ib), nc)\n            gi = fill(gi, dotc, cells)\n            if take:\n                go = replace(subgrid(sq, gi), sqc, dotc)\n                take = False\n            inds = (inds - bd) - outbox(bd)\n            succ += 1\n        tr += 1\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, len(inds) // 2 - 1)))\n    noise = sample(totuple(inds), nnoise)\n    gi = fill(gi, dotc, noise)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_fcb5c309(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly determine the height of the grid between 10 and 30\n    h = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly determine the width of the grid between 10 and 30\n    w = unifint(diff_lb, diff_ub, (10, 30))\n    \n    # Randomly select 3 colors: background, dot, and square colors\n    bgc, dotc, sqc = sample(cols, 3)\n    \n    # Determine the number of squares to be drawn (between 1 and 1/25th of the grid area)\n    numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))\n    \n    # Create an initial grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Get all possible indices in the grid\n    inds = asindices(gi)\n    \n    # Set maximum number of attempts to 4 times the number of squares\n    maxtr = 4 * numsq\n    \n    # Initialize counters\n    tr = 0  # Number of attempts\n    succ = 0  # Number of successful square placements\n    \n    numcells = None  # Will store the number of dots to place in each square\n    take = False  # Flag to determine when to capture the output grid\n    \n    # Main loop to place squares and dots\n    while tr < maxtr and succ < numsq:\n        # Randomly determine square height (3 to 7)\n        oh = randint(3, 7)\n        \n        # Randomly determine square width (3 to 7)\n        ow = randint(3, 7)\n        \n        # Find valid positions to place the square\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, break the loop\n        if len(cands) == 0:\n            break\n        \n        # Choose a random position for the square\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Create the square outline\n        sq = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))\n        \n        # Get all cells within the square\n        bd = backdrop(sq)\n        \n        # If the square fits within the grid\n        if bd.issubset(inds):\n            # Draw the square on the grid\n            gi = fill(gi, sqc, sq)\n            \n            # Get the inner area of the square\n            ib = backdrop(inbox(sq))\n            \n            # If it's the first square, determine the number of dots to place\n            if numcells is None:\n                numcells = unifint(diff_lb, diff_ub, (1, len(ib)))\n                cells = sample(totuple(ib), numcells)\n                take = True  # Flag to capture this square as the output\n            else:\n                # For subsequent squares, vary the number of dots\n                nc = unifint(diff_lb, diff_ub, (0, min(max(0, numcells - 1), len(ib))))\n                cells = sample(totuple(ib), nc)\n            \n            # Place dots in the square\n            gi = fill(gi, dotc, cells)\n            \n            # If this is the square to capture, create the output grid\n            if take:\n                go = replace(subgrid(sq, gi), sqc, dotc)\n                take = False\n            \n            # Remove used cells from available indices\n            inds = (inds - bd) - outbox(bd)\n            succ += 1\n        tr += 1\n    \n    # Add random noise dots to the input grid\n    nnoise = unifint(diff_lb, diff_ub, (0, max(0, len(inds) // 2 - 1)))\n    noise = sample(totuple(inds), nnoise)\n    gi = fill(gi, dotc, noise)\n    \n    # Return the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "fcc82909": {
    "original": "def generate_fcc82909(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(3, interval(0, 10, 1))\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    nobjs = unifint(diff_lb, diff_ub, (1, w // 3))\n    opts = interval(0, w, 1)\n    tr = 0\n    maxtr = 4 * nobjs\n    succ = 0\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    gi = canvas(bgc, (h, w))\n    go = canvas(bgc, (h, w))\n    while succ < nobjs and tr < maxtr:\n        tr += 1\n        sopts = sfilter(opts, lambda j: set(interval(j, j + 2, 1)).issubset(opts))\n        if len(sopts) == 0:\n            break\n        numc = unifint(diff_lb, diff_ub, (1, 4))\n        jstart = choice(sopts)\n        opts = remove(jstart, opts)\n        opts = remove(jstart+1, opts)\n        options = interval(0, h - 2 - numc + 1, 1)\n        if len(options) == 0:\n            break\n        iloc = choice(options)\n        ccols = sample(remcols, numc)\n        bd = backdrop(frozenset({(iloc, jstart), (iloc + 1, jstart + 1)}))\n        bd = list(bd)\n        shuffle(bd)\n        obj = {(c, ij) for c, ij in zip(ccols, bd[:numc])} | {(choice(ccols), ij) for ij in bd[numc:]}\n        if not mapply(dneighbors, toindices(obj)).issubset(ofcolor(gi, bgc)):\n            continue\n        gi = paint(gi, obj)\n        go = paint(go, obj)\n        for k in range(numc):\n            go = fill(go, 3, {(iloc+k+2, jstart), (iloc+k+2, jstart+1)})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_fcc82909(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of colors (0-9) excluding 3\n    cols = remove(3, interval(0, 10, 1))\n    \n    # Randomly determine the height of the grid between 7 and 30\n    h = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the width of the grid between 7 and 30\n    w = unifint(diff_lb, diff_ub, (7, 30))\n    \n    # Randomly determine the number of objects to place, between 1 and 1/3 of the width\n    nobjs = unifint(diff_lb, diff_ub, (1, w // 3))\n    \n    # Create a list of possible horizontal positions for objects\n    opts = interval(0, w, 1)\n    \n    # Initialize the number of attempts to place objects\n    tr = 0\n    \n    # Set the maximum number of attempts to 4 times the number of objects\n    maxtr = 4 * nobjs\n    \n    # Initialize the count of successfully placed objects\n    succ = 0\n    \n    # Randomly choose a background color from the available colors\n    bgc = choice(cols)\n    \n    # Create a list of remaining colors, excluding the background color\n    remcols = remove(bgc, cols)\n    \n    # Create the input grid filled with the background color\n    gi = canvas(bgc, (h, w))\n    \n    # Create the output grid filled with the background color\n    go = canvas(bgc, (h, w))\n    \n    # Loop to place objects on the grid\n    while succ < nobjs and tr < maxtr:\n        # Increment the attempt counter\n        tr += 1\n        \n        # Filter horizontal positions where there's space for a 2-wide object\n        sopts = sfilter(opts, lambda j: set(interval(j, j + 2, 1)).issubset(opts))\n        \n        # If no valid positions remain, break the loop\n        if len(sopts) == 0:\n            break\n        \n        # Randomly choose the number of colors for the object (1 to 4)\n        numc = unifint(diff_lb, diff_ub, (1, 4))\n        \n        # Randomly choose the starting horizontal position for the object\n        jstart = choice(sopts)\n        \n        # Remove the chosen position and the next one from available options\n        opts = remove(jstart, opts)\n        opts = remove(jstart+1, opts)\n        \n        # Create a list of possible vertical positions for the object\n        options = interval(0, h - 2 - numc + 1, 1)\n        \n        # If no valid vertical positions remain, break the loop\n        if len(options) == 0:\n            break\n        \n        # Randomly choose the vertical position for the object\n        iloc = choice(options)\n        \n        # Randomly sample colors for the object from the remaining colors\n        ccols = sample(remcols, numc)\n        \n        # Create a backdrop for the object (2x2 area)\n        bd = backdrop(frozenset({(iloc, jstart), (iloc + 1, jstart + 1)}))\n        \n        # Convert backdrop to a list and shuffle it\n        bd = list(bd)\n        shuffle(bd)\n        \n        # Create the object by assigning colors to positions\n        obj = {(c, ij) for c, ij in zip(ccols, bd[:numc])} | {(choice(ccols), ij) for ij in bd[numc:]}\n        \n        # Check if the object can be placed without touching other objects\n        if not mapply(dneighbors, toindices(obj)).issubset(ofcolor(gi, bgc)):\n            continue\n        \n        # Paint the object on the input grid\n        gi = paint(gi, obj)\n        \n        # Paint the object on the output grid\n        go = paint(go, obj)\n        \n        # Add the \"3\" color below the object in the output grid\n        for k in range(numc):\n            go = fill(go, 3, {(iloc+k+2, jstart), (iloc+k+2, jstart+1)})\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "feca6190": {
    "original": "def generate_feca6190(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(0, 10, 1)\n    w = unifint(diff_lb, diff_ub, (2, 6))\n    bgc = 0\n    remcols = remove(bgc, cols)\n    ncols = unifint(diff_lb, diff_ub, (1, min(w, 5)))\n    ccols = sample(remcols, ncols)\n    cands = interval(0, w, 1)\n    locs = sample(cands, ncols)\n    gi = canvas(bgc, (1, w))\n    go = canvas(bgc, (w*ncols, w*ncols))\n    for col, j in zip(ccols, locs):\n        gi = fill(gi, col, {(0, j)})\n        go = fill(go, col, shoot((w*ncols-1, j), UP_RIGHT))\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_feca6190(diff_lb: float, diff_ub: float) -> dict:\n    # Create a tuple of integers from 0 to 9\n    cols = interval(0, 10, 1)\n    \n    # Randomly choose the width of the input grid (between 2 and 6)\n    w = unifint(diff_lb, diff_ub, (2, 6))\n    \n    # Set the background color to 0 (black)\n    bgc = 0\n    \n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Randomly choose the number of colors to use (between 1 and min(w, 5))\n    ncols = unifint(diff_lb, diff_ub, (1, min(w, 5)))\n    \n    # Randomly select 'ncols' colors from the remaining colors\n    ccols = sample(remcols, ncols)\n    \n    # Create a list of possible column indices for the input grid\n    cands = interval(0, w, 1)\n    \n    # Randomly select 'ncols' column indices for color placement\n    locs = sample(cands, ncols)\n    \n    # Create the input grid: a 1xw grid filled with the background color\n    gi = canvas(bgc, (1, w))\n    \n    # Create the output grid: a (w*ncols)x(w*ncols) grid filled with the background color\n    go = canvas(bgc, (w*ncols, w*ncols))\n    \n    # For each selected color and its corresponding column in the input:\n    for col, j in zip(ccols, locs):\n        # Place the color in the input grid at the selected column\n        gi = fill(gi, col, {(0, j)})\n        \n        # In the output grid, create a diagonal line of the color\n        # starting from the bottom row at column j, going up and right\n        go = fill(go, col, shoot((w*ncols-1, j), UP_RIGHT))\n    \n    # Return a dictionary containing the input and output grids\n    return {'input': gi, 'output': go}\n"
  },
  "ff28f65a": {
    "original": "def generate_ff28f65a(diff_lb: float, diff_ub: float) -> dict:\n    cols = difference(interval(0, 10, 1), (1, 2))\n    mpr = {1: (0, 0), 2: (0, 2), 3: (1, 1), 4: (2, 0), 5: (2, 2)}\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    bgc = choice(cols)\n    nred = randint(1, 5)\n    gi = canvas(bgc, (h, w))\n    succ = 0\n    tr = 0\n    maxtr = 5 * nred\n    inds = asindices(gi)\n    while tr < maxtr and succ < nred:\n        tr += 1\n        oh = randint(1, h//2+1)\n        ow = randint(1, w//2+1)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))\n        if bd.issubset(inds):\n            succ += 1\n            inds = (inds - bd) - mapply(dneighbors, bd)\n            gi = fill(gi, 2, bd)\n    nblue = succ\n    namt = unifint(diff_lb, diff_ub, (0, nred * 2))\n    succ = 0\n    tr = 0\n    maxtr = 5 * namt\n    remcols = remove(bgc, cols)\n    tr += 1\n    while tr < maxtr and succ < namt:\n        tr += 1\n        oh = randint(1, h//2+1)\n        ow = randint(1, w//2+1)\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        if len(cands) == 0:\n            continue\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))\n        if bd.issubset(inds):\n            succ += 1\n            inds = (inds - bd) - mapply(dneighbors, bd)\n            gi = fill(gi, choice(remcols), bd)\n    go = canvas(bgc, (3, 3))\n    for k in range(nblue):\n        go = fill(go, 1, {mpr[k+1]})\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ff28f65a(diff_lb: float, diff_ub: float) -> dict:\n    # Define a set of colors excluding 1 and 2\n    cols = difference(interval(0, 10, 1), (1, 2))\n    \n    # Define a mapping for positioning blue squares in the output\n    mpr = {1: (0, 0), 2: (0, 2), 3: (1, 1), 4: (2, 0), 5: (2, 2)}\n    \n    # Generate random height between 3 and 30 based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Generate random width between 3 and 30 based on difficulty\n    w = unifint(diff_lb, diff_ub, (3, 30))\n    \n    # Choose a random background color from the defined set\n    bgc = choice(cols)\n    \n    # Randomly decide the number of red rectangles (1 to 5)\n    nred = randint(1, 5)\n    \n    # Create an initial grid with the chosen background color\n    gi = canvas(bgc, (h, w))\n    \n    # Initialize counters for successful placements and tries\n    succ = 0\n    tr = 0\n    maxtr = 5 * nred\n    \n    # Get all indices of the grid\n    inds = asindices(gi)\n    \n    # Loop to place red rectangles\n    while tr < maxtr and succ < nred:\n        tr += 1\n        \n        # Choose random height and width for the rectangle\n        oh = randint(1, h//2+1)\n        ow = randint(1, w//2+1)\n        \n        # Find valid positions for the rectangle\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, continue to next iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random position for the rectangle\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Calculate the area of the rectangle\n        bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))\n        \n        # If the rectangle fits in the grid\n        if bd.issubset(inds):\n            succ += 1\n            # Remove the rectangle area and its neighbors from available indices\n            inds = (inds - bd) - mapply(dneighbors, bd)\n            # Fill the rectangle area with color 2 (red)\n            gi = fill(gi, 2, bd)\n    \n    # Set the number of blue rectangles equal to the number of red ones\n    nblue = succ\n    \n    # Randomly decide the number of additional rectangles\n    namt = unifint(diff_lb, diff_ub, (0, nred * 2))\n    \n    # Reset counters for additional rectangle placement\n    succ = 0\n    tr = 0\n    maxtr = 5 * namt\n    \n    # Get remaining colors (excluding background and red)\n    remcols = remove(bgc, cols)\n    \n    tr += 1\n    \n    # Loop to place additional rectangles\n    while tr < maxtr and succ < namt:\n        tr += 1\n        \n        # Choose random height and width for the rectangle\n        oh = randint(1, h//2+1)\n        ow = randint(1, w//2+1)\n        \n        # Find valid positions for the rectangle\n        cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)\n        \n        # If no valid positions, continue to next iteration\n        if len(cands) == 0:\n            continue\n        \n        # Choose a random position for the rectangle\n        loc = choice(totuple(cands))\n        loci, locj = loc\n        \n        # Calculate the area of the rectangle\n        bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))\n        \n        # If the rectangle fits in the grid\n        if bd.issubset(inds):\n            succ += 1\n            # Remove the rectangle area and its neighbors from available indices\n            inds = (inds - bd) - mapply(dneighbors, bd)\n            # Fill the rectangle area with a random color\n            gi = fill(gi, choice(remcols), bd)\n    \n    # Create a 3x3 output grid with the background color\n    go = canvas(bgc, (3, 3))\n    \n    # Place blue squares in the output grid based on the number of red rectangles\n    for k in range(nblue):\n        go = fill(go, 1, {mpr[k+1]})\n    \n    # Return the input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "ff805c23": {
    "original": "def generate_ff805c23(diff_lb: float, diff_ub: float) -> dict:\n    cols = interval(1, 10, 1)\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    w = h\n    bgc = choice(cols)\n    remcols = remove(bgc, cols)\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    remcols = sample(remcols, numcols)\n    canv = canvas(bgc, (h, w))\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    bx = asindices(canv)\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    for kk in range(nc - 1):\n        dns = mapply(neighbors, toindices(obj))\n        ch = choice(totuple(bx & dns))\n        obj.add((choice(remcols), ch))\n        bx = bx - {ch}\n    gi = paint(canv, obj)\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    gi = paint(gi, tr)\n    gi = hconcat(gi, vmirror(gi))\n    gi = vconcat(gi, hmirror(gi))\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    go = subgrid(bd, gi)\n    gi = fill(gi, 0, bd)\n    rotf = choice((identity, rot90, rot180, rot270))\n    gi = rotf(gi)\n    go = rotf(go)\n    return {'input': gi, 'output': go}\n\n",
    "annotated": "def generate_ff805c23(diff_lb: float, diff_ub: float) -> dict:\n    # Define a range of colors from 1 to 9\n    cols = interval(1, 10, 1)\n    \n    # Randomly determine the height of the grid based on difficulty\n    h = unifint(diff_lb, diff_ub, (3, 15))\n    # Set width equal to height, creating a square grid\n    w = h\n    \n    # Randomly choose a background color\n    bgc = choice(cols)\n    # Remove the background color from the list of available colors\n    remcols = remove(bgc, cols)\n    \n    # Determine the number of colors to use (excluding background) based on difficulty\n    numcols = unifint(diff_lb, diff_ub, (1, 8))\n    # Randomly select colors to use\n    remcols = sample(remcols, numcols)\n    \n    # Create a canvas (grid) filled with the background color\n    canv = canvas(bgc, (h, w))\n    \n    # Determine the number of cells to color based on difficulty\n    nc = unifint(diff_lb, diff_ub, (1, h * w))\n    \n    # Get all indices of the canvas\n    bx = asindices(canv)\n    \n    # Start creating an object by coloring one random cell\n    obj = {(choice(remcols), choice(totuple(bx)))}\n    \n    # Color additional cells, growing the object\n    for kk in range(nc - 1):\n        # Find all neighbors of the current object\n        dns = mapply(neighbors, toindices(obj))\n        # Choose a random cell from the intersection of available cells and neighbors\n        ch = choice(totuple(bx & dns))\n        # Add the chosen cell to the object with a random color\n        obj.add((choice(remcols), ch))\n        # Remove the chosen cell from available cells\n        bx = bx - {ch}\n    \n    # Paint the object onto the canvas\n    gi = paint(canv, obj)\n    \n    # Create a triangular shape by filtering the diagonal mirror of the grid\n    tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])\n    # Paint the triangular shape onto the grid\n    gi = paint(gi, tr)\n    \n    # Mirror the grid horizontally and concatenate\n    gi = hconcat(gi, vmirror(gi))\n    # Mirror the resulting grid vertically and concatenate\n    gi = vconcat(gi, hmirror(gi))\n    \n    # Determine the location for extracting a subgrid (output)\n    locidev = unifint(diff_lb, diff_ub, (1, 2*h))\n    locjdev = unifint(diff_lb, diff_ub, (1, w))\n    loci = 2*h - locidev\n    locj = w - locjdev\n    loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))\n    locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))\n    \n    # Create a backdrop for the subgrid\n    bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))\n    \n    # Extract the subgrid (output)\n    go = subgrid(bd, gi)\n    \n    # Fill the extracted area in the input grid with background color (0)\n    gi = fill(gi, 0, bd)\n    \n    # Randomly choose a rotation function\n    rotf = choice((identity, rot90, rot180, rot270))\n    \n    # Apply the chosen rotation to both input and output grids\n    gi = rotf(gi)\n    go = rotf(go)\n    \n    # Return the generated input and output grids as a dictionary\n    return {'input': gi, 'output': go}\n"
  },
  "e73095fd": {
    "original": "def generate_e73095fd(diff_lb: float, diff_ub: float) -> dict:\n    cols = remove(4, interval(0, 10, 1))\n    while True:\n        h = unifint(diff_lb, diff_ub, (10, 32))\n        w = unifint(diff_lb, diff_ub, (10, 32))\n        bgc, fgc = sample(cols, 2)\n        gi = canvas(bgc, (h, w))\n        nsplits = unifint(diff_lb, diff_ub, (2, min(h, w) // 3))\n        for k in range(nsplits):\n            objs = objects(gi, T, F, F)\n            objs = colorfilter(objs, bgc)\n            objs = apply(toindices, objs)\n            hobjs = sfilter(objs, lambda o: height(o) > 6)\n            wobjs = sfilter(objs, lambda o: width(o) > 6)\n            if len(hobjs) == 0 and len(wobjs) == 0:\n                break\n            cgroups = [(g, ax) for g, ax in zip([hobjs, wobjs], [0, 1]) if len(g) > 0]\n            g, ax = choice(cgroups)\n            obj = choice(totuple(g))\n            ulci, ulcj = ulcorner(obj)\n            oh, ow = shape(obj)\n            if ax == 0:\n                iloc = randint(ulci + 3, ulci+oh-3)\n                bar = sfilter(obj, lambda ij: ij[0] == iloc)\n            else:\n                jloc = randint(ulcj + 3, ulcj+ow-3)\n                bar = sfilter(obj, lambda ij: ij[1] == jloc)\n            gi = fill(gi, fgc, bar)\n        copts = sfilter(\n            ofcolor(gi, fgc),\n            lambda ij: len(sfilter(toobject(dneighbors(ij), gi), lambda cij: cij[0] == fgc)) > 2\n        )\n        copts = sfilter(copts, lambda ij: len(sfilter(toobject(outbox(outbox({ij})), gi), lambda cij: cij[0] == fgc)) in {3, 4})\n        if len(copts) == 0:\n            continue\n        noccs = unifint(diff_lb, diff_ub, (1, len(copts)))\n        noccs = unifint(diff_lb, diff_ub, (noccs, len(copts)))\n        occs = sample(totuple(copts), noccs)\n        go = tuple(e for e in gi)\n        forb = set()\n        for occ in occs:\n            ulci, ulcj = decrement(occ)\n            lrci, lrcj = increment(occ)\n            if len(sfilter(toobject(box({(ulci, ulcj), (lrci, lrcj)}), gi), lambda cij: cij[0] == fgc)) in {3, 4}:\n                boptions = []\n                for ulcioffs in [-2, -1, 0]:\n                    for ulcjoffs in [-2, -1, 0]:\n                        for lrcioffs in [0, 1, 2]:\n                            for lrcjoffs in [0, 1, 2]:\n                                bx = box({(ulci+ulcioffs, ulcj+ulcjoffs), (lrci+lrcioffs, lrcj+lrcjoffs)})\n                                bxobj = toobject(bx, gi)\n                                if len(sfilter(toobject(bxobj, gi), lambda cij: cij[0] == fgc)) in {3, 4} and len(sfilter(toobject(outbox(bxobj), gi), lambda cij: cij[0] == fgc)) in {3, 4}:\n                                    boptions.append(bx)\n                boptions = sfilter(boptions, lambda bx: len(backdrop(bx) & forb) == 0)\n                if len(boptions) > 0:\n                    bx = choice(boptions)\n                    bd = backdrop(bx)\n                    gi = fill(gi, bgc, bd)\n                    gi = fill(gi, fgc, bx)\n                    go = fill(go, 4, bd)\n                    go = fill(go, fgc, bx)\n                    forb |= bd\n        gi = trim(gi)\n        go = trim(go)\n        if 4 in palette(go):\n            break\n    return {'input': gi, 'output': go}\n",
    "annotated": "def generate_e73095fd(diff_lb: float, diff_ub: float) -> dict:\n    # Create a list of color options, excluding 4\n    cols = remove(4, interval(0, 10, 1))\n    while True:\n        # Randomly generate height and width based on difficulty\n        h = unifint(diff_lb, diff_ub, (10, 32))\n        w = unifint(diff_lb, diff_ub, (10, 32))\n        # Randomly select background and foreground colors\n        bgc, fgc = sample(cols, 2)\n        # Create initial grid with background color\n        gi = canvas(bgc, (h, w))\n        # Determine number of splits based on difficulty\n        nsplits = unifint(diff_lb, diff_ub, (2, min(h, w) // 3))\n        for k in range(nsplits):\n            # Identify all objects in the grid\n            objs = objects(gi, T, F, F)\n            # Filter objects with background color\n            objs = colorfilter(objs, bgc)\n            # Convert objects to indices\n            objs = apply(toindices, objs)\n            # Filter objects with height > 6\n            hobjs = sfilter(objs, lambda o: height(o) > 6)\n            # Filter objects with width > 6\n            wobjs = sfilter(objs, lambda o: width(o) > 6)\n            # If no suitable objects found, break the loop\n            if len(hobjs) == 0 and len(wobjs) == 0:\n                break\n            # Group objects by orientation (horizontal or vertical)\n            cgroups = [(g, ax) for g, ax in zip([hobjs, wobjs], [0, 1]) if len(g) > 0]\n            # Randomly choose a group and axis\n            g, ax = choice(cgroups)\n            # Randomly select an object from the chosen group\n            obj = choice(totuple(g))\n            # Get upper-left corner of the object\n            ulci, ulcj = ulcorner(obj)\n            # Get object dimensions\n            oh, ow = shape(obj)\n            if ax == 0:\n                # For vertical split, choose a random row within the object\n                iloc = randint(ulci + 3, ulci+oh-3)\n                # Create a horizontal bar\n                bar = sfilter(obj, lambda ij: ij[0] == iloc)\n            else:\n                # For horizontal split, choose a random column within the object\n                jloc = randint(ulcj + 3, ulcj+ow-3)\n                # Create a vertical bar\n                bar = sfilter(obj, lambda ij: ij[1] == jloc)\n            # Fill the bar with foreground color, creating a split\n            gi = fill(gi, fgc, bar)\n        # Find potential corner positions for boxes\n        copts = sfilter(\n            ofcolor(gi, fgc),\n            lambda ij: len(sfilter(toobject(dneighbors(ij), gi), lambda cij: cij[0] == fgc)) > 2\n        )\n        # Further filter corner options based on surrounding foreground cells\n        copts = sfilter(copts, lambda ij: len(sfilter(toobject(outbox(outbox({ij})), gi), lambda cij: cij[0] == fgc)) in {3, 4})\n        # If no suitable corners found, restart the process\n        if len(copts) == 0:\n            continue\n        # Determine number of occurrences based on difficulty\n        noccs = unifint(diff_lb, diff_ub, (1, len(copts)))\n        noccs = unifint(diff_lb, diff_ub, (noccs, len(copts)))\n        # Randomly select corner positions\n        occs = sample(totuple(copts), noccs)\n        # Create a copy of the input grid for output\n        go = tuple(e for e in gi)\n        # Set of forbidden positions for box placement\n        forb = set()\n        for occ in occs:\n            # Define potential box corners\n            ulci, ulcj = decrement(occ)\n            lrci, lrcj = increment(occ)\n            # Check if the potential box has 3 or 4 foreground cells\n            if len(sfilter(toobject(box({(ulci, ulcj), (lrci, lrcj)}), gi), lambda cij: cij[0] == fgc)) in {3, 4}:\n                boptions = []\n                # Generate all possible box configurations\n                for ulcioffs in [-2, -1, 0]:\n                    for ulcjoffs in [-2, -1, 0]:\n                        for lrcioffs in [0, 1, 2]:\n                            for lrcjoffs in [0, 1, 2]:\n                                bx = box({(ulci+ulcioffs, ulcj+ulcjoffs), (lrci+lrcioffs, lrcj+lrcjoffs)})\n                                bxobj = toobject(bx, gi)\n                                # Check if box and its surroundings meet criteria\n                                if len(sfilter(toobject(bxobj, gi), lambda cij: cij[0] == fgc)) in {3, 4} and len(sfilter(toobject(outbox(bxobj), gi), lambda cij: cij[0] == fgc)) in {3, 4}:\n                                    boptions.append(bx)\n                # Filter out boxes overlapping with forbidden areas\n                boptions = sfilter(boptions, lambda bx: len(backdrop(bx) & forb) == 0)\n                if len(boptions) > 0:\n                    # Randomly choose a box configuration\n                    bx = choice(boptions)\n                    # Get the area covered by the box\n                    bd = backdrop(bx)\n                    # Clear the box area in the input grid\n                    gi = fill(gi, bgc, bd)\n                    # Draw the box outline in the input grid\n                    gi = fill(gi, fgc, bx)\n                    # Fill the box area with color 4 in the output grid\n                    go = fill(go, 4, bd)\n                    # Draw the box outline in the output grid\n                    go = fill(go, fgc, bx)\n                    # Add box area to forbidden set\n                    forb |= bd\n        # Remove border from both input and output grids\n        gi = trim(gi)\n        go = trim(go)\n        # If color 4 is present in the output, end the generation process\n        if 4 in palette(go):\n            break\n    # Return the generated input and output grids\n    return {'input': gi, 'output': go}\n"
  }
}